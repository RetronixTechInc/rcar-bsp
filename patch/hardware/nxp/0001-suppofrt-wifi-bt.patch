From f5bf30bdb1a308e486325474aa5c75a250f414a5 Mon Sep 17 00:00:00 2001
From: TomWang <townwang@retronix.com.tw>
Date: Tue, 29 Aug 2023 09:28:46 +0800
Subject: [PATCH] suppofrt wifi/bt

---
 88x9098/Android.mk                            |   17 +
 88x9098/bt/Android.mk                         |   19 +
 88x9098/bt/libbt/APACHE_LICENSE-2.0.txt       |  202 +
 88x9098/bt/libbt/Android.mk                   |   79 +
 88x9098/bt/libbt/bt_vendor_nxp.c              | 1078 ++++
 88x9098/bt/libbt/bt_vendor_nxp.h              |   90 +
 88x9098/bt/libbt/conf/bt_vendor_8887.conf     |    9 +
 88x9098/bt/libbt/conf/bt_vendor_8987.conf     |    9 +
 88x9098/bt/libbt/conf/bt_vendor_8997.conf     |    9 +
 88x9098/bt/libbt/conf/bt_vendor_9098.conf     |    8 +
 88x9098/bt/libbt/conf/nxp/evk_8mn/Android.mk  |   11 +
 .../bt/libbt/conf/nxp/evk_8mn/bt_vendor.conf  |    9 +
 88x9098/bt/libbt/conf/nxp/evk_8mp/Android.mk  |   11 +
 .../bt/libbt/conf/nxp/evk_8mp/bt_vendor.conf  |    9 +
 88x9098/bt/libbt/conf/nxp/evk_8mq/Android.mk  |   10 +
 .../bt/libbt/conf/nxp/evk_8mq/bt_vendor.conf  |    9 +
 88x9098/bt/libbt/conf/nxp/mek_8q/Android.mk   |   11 +
 .../bt/libbt/conf/nxp/mek_8q/bt_vendor.conf   |    9 +
 .../bt/libbt/conf/renesas/salvator/Android.mk |   10 +
 .../conf/renesas/salvator/bt_vendor.conf      |    6 +
 88x9098/bt/libbt/fw_loader_io.c               |  345 ++
 88x9098/bt/libbt/fw_loader_io.h               |   50 +
 88x9098/bt/libbt/fw_loader_uart.c             | 1443 ++++++
 88x9098/bt/libbt/fw_loader_uart.h             |   46 +
 88x9098/bt/libbt/fw_loader_uart_v2.c          | 1144 ++++
 88x9098/bt/libbt/fw_loader_uart_v2.h          |   39 +
 88x9098/bt/libbt/hardware_nxp.c               |  537 ++
 88x9098/bt/libbt/readme                       |   65 +
 88x9098/bt/libbt/tags                         |  348 ++
 88x9098/bt/muart_src/.config                  |    2 +
 88x9098/bt/muart_src/Makefile                 |  342 ++
 88x9098/bt/muart_src/README                   |  126 +
 88x9098/bt/muart_src/bt_drv.h                 |  297 ++
 88x9098/bt/muart_src/gpl-2.0.txt              |  339 ++
 88x9098/bt/muart_src/hci_bcsp.c               |  873 ++++
 88x9098/bt/muart_src/hci_h4.c                 |  594 +++
 88x9098/bt/muart_src/hci_ldisc.c              |  930 ++++
 88x9098/bt/muart_src/hci_ll.c                 |  591 +++
 88x9098/bt/muart_src/hci_ps.c                 | 1404 +++++
 88x9098/bt/muart_src/hci_uart.h               |  162 +
 88x9098/bt/muart_src/hci_wrapper.c            |  434 ++
 88x9098/bt/muart_src/hci_wrapper.h            |  157 +
 .../include/amp/bluetooth/bluetooth.h         |  189 +
 .../bt/muart_src/include/amp/bluetooth/hci.h  | 1186 +++++
 .../include/amp/bluetooth/hci_core.h          |  718 +++
 88x9098/bt/muart_src/include/bluetooth.h      |  187 +
 88x9098/bt/muart_src/include/hci.h            |  969 ++++
 88x9098/bt/muart_src/include/hci_core.h       |  710 +++
 88x9098/bt/muart_src/mbt_char.c               |  699 +++
 88x9098/bt/muart_src/mbt_char.h               |   64 +
 88x9098/wlan/Android.mk                       |   17 +
 88x9098/wlan/hal/Android.mk                   |   17 +
 .../wlan/hal/wifi_hal/APACHE_LICENSE-2.0.txt  |  202 +
 88x9098/wlan/hal/wifi_hal/Android.mk          |   64 +
 88x9098/wlan/hal/wifi_hal/README              |    1 +
 88x9098/wlan/hal/wifi_hal/common.cpp          |  285 +
 88x9098/wlan/hal/wifi_hal/common.h            |  348 ++
 88x9098/wlan/hal/wifi_hal/cpp_bindings.cpp    |  743 +++
 88x9098/wlan/hal/wifi_hal/cpp_bindings.h      |  372 ++
 88x9098/wlan/hal/wifi_hal/gscan.cpp           | 1852 +++++++
 .../wlan/hal/wifi_hal/link_layer_stats.cpp    |  366 ++
 88x9098/wlan/hal/wifi_hal/nan_nxp.h           |  178 +
 88x9098/wlan/hal/wifi_hal/nl80211_copy.h      | 4588 +++++++++++++++++
 88x9098/wlan/hal/wifi_hal/pkt_stats.h         |   57 +
 88x9098/wlan/hal/wifi_hal/roam.cpp            |  220 +
 88x9098/wlan/hal/wifi_hal/rtt.cpp             |  692 +++
 88x9098/wlan/hal/wifi_hal/wifi_hal.cpp        | 1498 ++++++
 88x9098/wlan/hal/wifi_hal/wifi_logger.cpp     | 1437 ++++++
 88x9098/wlan/hal/wifi_hal/wifi_nan.cpp        | 1708 ++++++
 88x9098/wlan/hal/wifi_hal/wifi_offload.cpp    |  193 +
 .../wlan/hal/wlan_lib/APACHE_LICENSE-2.0.txt  |  202 +
 88x9098/wlan/hal/wlan_lib/Android.mk          |   73 +
 88x9098/wlan/hal/wlan_lib/MODULE_LICENSE_BSD  |    0
 88x9098/wlan/hal/wlan_lib/NOTICE              |   44 +
 .../wlan/hal/wlan_lib/driver_cmd_nl80211.c    |  415 ++
 88x9098/wlan/hal/wlan_lib/driver_cmd_wext.c   |  462 ++
 88x9098/wlan/hal/wlan_lib/driver_cmd_wext.h   |   44 +
 77 files changed, 32683 insertions(+)
 create mode 100644 88x9098/Android.mk
 create mode 100644 88x9098/bt/Android.mk
 create mode 100755 88x9098/bt/libbt/APACHE_LICENSE-2.0.txt
 create mode 100755 88x9098/bt/libbt/Android.mk
 create mode 100755 88x9098/bt/libbt/bt_vendor_nxp.c
 create mode 100755 88x9098/bt/libbt/bt_vendor_nxp.h
 create mode 100755 88x9098/bt/libbt/conf/bt_vendor_8887.conf
 create mode 100755 88x9098/bt/libbt/conf/bt_vendor_8987.conf
 create mode 100755 88x9098/bt/libbt/conf/bt_vendor_8997.conf
 create mode 100755 88x9098/bt/libbt/conf/bt_vendor_9098.conf
 create mode 100755 88x9098/bt/libbt/conf/nxp/evk_8mn/Android.mk
 create mode 100755 88x9098/bt/libbt/conf/nxp/evk_8mn/bt_vendor.conf
 create mode 100755 88x9098/bt/libbt/conf/nxp/evk_8mp/Android.mk
 create mode 100755 88x9098/bt/libbt/conf/nxp/evk_8mp/bt_vendor.conf
 create mode 100755 88x9098/bt/libbt/conf/nxp/evk_8mq/Android.mk
 create mode 100755 88x9098/bt/libbt/conf/nxp/evk_8mq/bt_vendor.conf
 create mode 100755 88x9098/bt/libbt/conf/nxp/mek_8q/Android.mk
 create mode 100755 88x9098/bt/libbt/conf/nxp/mek_8q/bt_vendor.conf
 create mode 100755 88x9098/bt/libbt/conf/renesas/salvator/Android.mk
 create mode 100755 88x9098/bt/libbt/conf/renesas/salvator/bt_vendor.conf
 create mode 100755 88x9098/bt/libbt/fw_loader_io.c
 create mode 100755 88x9098/bt/libbt/fw_loader_io.h
 create mode 100755 88x9098/bt/libbt/fw_loader_uart.c
 create mode 100755 88x9098/bt/libbt/fw_loader_uart.h
 create mode 100755 88x9098/bt/libbt/fw_loader_uart_v2.c
 create mode 100755 88x9098/bt/libbt/fw_loader_uart_v2.h
 create mode 100755 88x9098/bt/libbt/hardware_nxp.c
 create mode 100755 88x9098/bt/libbt/readme
 create mode 100755 88x9098/bt/libbt/tags
 create mode 100644 88x9098/bt/muart_src/.config
 create mode 100644 88x9098/bt/muart_src/Makefile
 create mode 100644 88x9098/bt/muart_src/README
 create mode 100644 88x9098/bt/muart_src/bt_drv.h
 create mode 100644 88x9098/bt/muart_src/gpl-2.0.txt
 create mode 100644 88x9098/bt/muart_src/hci_bcsp.c
 create mode 100644 88x9098/bt/muart_src/hci_h4.c
 create mode 100644 88x9098/bt/muart_src/hci_ldisc.c
 create mode 100644 88x9098/bt/muart_src/hci_ll.c
 create mode 100644 88x9098/bt/muart_src/hci_ps.c
 create mode 100644 88x9098/bt/muart_src/hci_uart.h
 create mode 100644 88x9098/bt/muart_src/hci_wrapper.c
 create mode 100644 88x9098/bt/muart_src/hci_wrapper.h
 create mode 100644 88x9098/bt/muart_src/include/amp/bluetooth/bluetooth.h
 create mode 100644 88x9098/bt/muart_src/include/amp/bluetooth/hci.h
 create mode 100644 88x9098/bt/muart_src/include/amp/bluetooth/hci_core.h
 create mode 100644 88x9098/bt/muart_src/include/bluetooth.h
 create mode 100644 88x9098/bt/muart_src/include/hci.h
 create mode 100644 88x9098/bt/muart_src/include/hci_core.h
 create mode 100644 88x9098/bt/muart_src/mbt_char.c
 create mode 100644 88x9098/bt/muart_src/mbt_char.h
 create mode 100644 88x9098/wlan/Android.mk
 create mode 100644 88x9098/wlan/hal/Android.mk
 create mode 100644 88x9098/wlan/hal/wifi_hal/APACHE_LICENSE-2.0.txt
 create mode 100644 88x9098/wlan/hal/wifi_hal/Android.mk
 create mode 100644 88x9098/wlan/hal/wifi_hal/README
 create mode 100644 88x9098/wlan/hal/wifi_hal/common.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/common.h
 create mode 100644 88x9098/wlan/hal/wifi_hal/cpp_bindings.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/cpp_bindings.h
 create mode 100644 88x9098/wlan/hal/wifi_hal/gscan.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/link_layer_stats.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/nan_nxp.h
 create mode 100644 88x9098/wlan/hal/wifi_hal/nl80211_copy.h
 create mode 100644 88x9098/wlan/hal/wifi_hal/pkt_stats.h
 create mode 100644 88x9098/wlan/hal/wifi_hal/roam.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/rtt.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/wifi_hal.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/wifi_logger.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/wifi_nan.cpp
 create mode 100644 88x9098/wlan/hal/wifi_hal/wifi_offload.cpp
 create mode 100644 88x9098/wlan/hal/wlan_lib/APACHE_LICENSE-2.0.txt
 create mode 100644 88x9098/wlan/hal/wlan_lib/Android.mk
 create mode 100644 88x9098/wlan/hal/wlan_lib/MODULE_LICENSE_BSD
 create mode 100644 88x9098/wlan/hal/wlan_lib/NOTICE
 create mode 100644 88x9098/wlan/hal/wlan_lib/driver_cmd_nl80211.c
 create mode 100644 88x9098/wlan/hal/wlan_lib/driver_cmd_wext.c
 create mode 100644 88x9098/wlan/hal/wlan_lib/driver_cmd_wext.h

diff --git a/88x9098/Android.mk b/88x9098/Android.mk
new file mode 100644
index 0000000..e453ea1
--- /dev/null
+++ b/88x9098/Android.mk
@@ -0,0 +1,17 @@
+# Copyright 2018-2020 NXP
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/88x9098/bt/Android.mk b/88x9098/bt/Android.mk
new file mode 100644
index 0000000..eb04833
--- /dev/null
+++ b/88x9098/bt/Android.mk
@@ -0,0 +1,19 @@
+#
+# Copyright (C) 2019 GlobalLogic
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+ifeq ($(BOARD_WIFI_VENDOR),nxp)
+include $(call all-makefiles-under,$(call my-dir))
+endif
diff --git a/88x9098/bt/libbt/APACHE_LICENSE-2.0.txt b/88x9098/bt/libbt/APACHE_LICENSE-2.0.txt
new file mode 100755
index 0000000..75b5248
--- /dev/null
+++ b/88x9098/bt/libbt/APACHE_LICENSE-2.0.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/88x9098/bt/libbt/Android.mk b/88x9098/bt/libbt/Android.mk
new file mode 100755
index 0000000..25993dc
--- /dev/null
+++ b/88x9098/bt/libbt/Android.mk
@@ -0,0 +1,79 @@
+#
+# Copyright 2012 The Android Open Source Project
+# Portions copyright 2012-2013, 2015, 2018-2021 NXP
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at:
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+ifneq ($(BOARD_HAVE_BLUETOOTH_NXP),)
+
+LOCAL_PATH := $(call my-dir)
+
+BOARD_UART_DOWNLOAD_FW := true
+# v2 is for 8887-FP101, and v3 is for other chips.
+BOARD_UART_FW_LOADER_VERSION = v3
+
+# libbt-vendor.so
+include $(CLEAR_VARS)
+BDROID_DIR := $(TOP_DIR)system/bt
+
+LOCAL_C_INCLUDES += \
+    $(BDROID_DIR)/hci/include \
+
+LOCAL_SRC_FILES := \
+    bt_vendor_nxp.c \
+    fw_loader_io.c \
+    hardware_nxp.c
+
+ifneq ($(BOARD_UART_DOWNLOAD_FW), false)
+LOCAL_CFLAGS += -DUART_DOWNLOAD_FW
+#LOCAL_CFLAGS += -DDEBUG_PRINT
+ifneq ($(BOARD_UART_FW_LOADER_VERSION), v2)
+LOCAL_SRC_FILES += \
+    fw_loader_uart.c
+else
+LOCAL_CFLAGS += -DFW_LOADER_V2
+LOCAL_SRC_FILES += \
+    fw_loader_uart_v2.c
+endif
+endif
+
+LOCAL_SHARED_LIBRARIES := \
+    libcutils \
+    liblog \
+    libprotobuf-cpp-lite \
+    libbase \
+    libchrome
+LOCAL_MODULE := libbt-vendor
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_OWNER := nxp
+LOCAL_MULTILIB := both
+LOCAL_PROPRIETARY_MODULE := true
+
+include $(BUILD_SHARED_LIBRARY)
+ifeq ($(TARGET_PRODUCT), salvator)
+    include $(LOCAL_PATH)/conf/renesas/salvator/Android.mk
+endif
+ifeq ($(TARGET_PRODUCT), evk_8mp)
+    include $(LOCAL_PATH)/conf/nxp/evk_8mp/Android.mk
+endif
+ifeq ($(TARGET_PRODUCT), evk_8mq)
+    include $(LOCAL_PATH)/conf/nxp/evk_8mq/Android.mk
+endif
+ifeq ($(TARGET_PRODUCT), evk_8mn)
+    include $(LOCAL_PATH)/conf/nxp/evk_8mn/Android.mk
+endif
+ifeq ($(TARGET_PRODUCT),$(filter $(TARGET_PRODUCT),mek_8q mek_8q_car mek_8q_car2))
+    include $(LOCAL_PATH)/conf/nxp/mek_8q/Android.mk
+endif
+endif # BOARD_HAVE_BLUETOOTH_NXP
diff --git a/88x9098/bt/libbt/bt_vendor_nxp.c b/88x9098/bt/libbt/bt_vendor_nxp.c
new file mode 100755
index 0000000..143e22c
--- /dev/null
+++ b/88x9098/bt/libbt/bt_vendor_nxp.c
@@ -0,0 +1,1078 @@
+/******************************************************************************
+ *  Copyright 2012 The Android Open Source Project
+ *  Portions copyright (C) 2009-2012 Broadcom Corporation
+ *  Portions copyright 2012-2013, 2015, 2018-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Filename:      bt_vendor_nxp.c
+ *
+ *  Description:   NXP vendor specific library implementation
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt-vnd-nxp"
+
+#include <ctype.h>
+#include <errno.h>
+#include <errno.h>
+#include <grp.h>
+#include <pthread.h>
+#include <pwd.h>
+#include <sched.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <log/log.h>
+#include <cutils/properties.h>
+#include "bt_vendor_nxp.h"
+
+#ifdef FW_LOADER_V2
+#include "fw_loader_uart_v2.h"
+#else
+#include "fw_loader_uart.h"
+#endif
+
+/******************************************************************************
+ **
+ ** Constants and Macro's
+ **
+ ******************************************************************************/
+/*[NK] @NXP - Driver FIX
+  ioctl command to release the read thread before driver close */
+#define MBTCHAR_IOCTL_RELEASE _IO('M', 1)
+
+#define PROP_BLUETOOTH_OPENED "bluetooth.nxp.uart_configured"
+#define PROP_BLUETOOTH_FW_DOWNLOADED "bluetooth.nxp.fw_downloaded"
+#define PROP_BLUETOOTH_DELAY "bluetooth.nxp.fw_downloaded_delay"
+
+/*
+ * Defines for wait for Bluetooth firmware ready Specify durations
+ * between polls and max wait time
+ */
+#define POLL_DRIVER_DURATION_US (100000)
+#define POLL_DRIVER_MAX_TIME_MS (20000)
+
+#define CONF_COMMENT '#'
+#define CONF_DELIMITERS " =\n\r\t"
+#define CONF_VALUES_DELIMITERS "=\n\r\t"
+#define CONF_MAX_LINE_LEN 255
+#define UNUSED(x) (void)(x)
+#define BD_ADDR_LEN 6
+
+/******************************************************************************
+**  Variables
+******************************************************************************/
+int mchar_fd = 0;
+struct termios ti;
+static uint8_t adapterState;
+unsigned char* bdaddr = NULL;
+const bt_vendor_callbacks_t* vnd_cb = NULL;
+/* for NXP USB/SD interface */
+static char mbt_port[512] = "/dev/mbtchar0";
+/* for NXP Uart interface */
+static char mchar_port[512] = "/dev/ttyUSB0";
+static int is_uart_port = 0;
+static int uart_break_before_open = 0;
+static int32_t baudrate_fw_init = 115200;
+static int32_t baudrate_bt = 3000000;
+int write_bdaddrss = 0;
+
+uint8_t write_bd_address[WRITE_BD_ADDRESS_SIZE] = {
+    0xFE, /* Parameter ID */
+    0x06, /* bd_addr length */
+    0x00, /* 6th byte of bd_addr */
+    0x00, /* 5th */
+    0x00, /* 4th */
+    0x00, /* 3rd */
+    0x00, /* 2nd */
+    0x00  /* 1st */
+};
+
+#ifdef UART_DOWNLOAD_FW
+int uart_break_before_change_baudrate = 0;
+static int enable_download_fw = 0;
+static int uart_break_after_dl_helper = 0;
+static int uart_sleep_after_dl = 700;
+static int download_helper = 0;
+static int32_t baudrate_dl_helper = 115200;
+static int32_t baudrate_dl_image = 3000000;
+static char pFileName_helper[512] = "/vendor/firmware/helper_uart_3000000.bin";
+static char pFileName_image[512] = "/vendor/firmware/uart8997_bt_v4.bin";
+static int32_t iSecondBaudrate = 0;
+#endif
+
+static pthread_mutex_t dev_file_lock = PTHREAD_MUTEX_INITIALIZER;
+
+/*****************************************************************************
+**
+**   HELPER FUNCTIONS
+**
+*****************************************************************************/
+typedef int(conf_action_t)(char* p_conf_name, char* p_conf_value, int param);
+
+typedef struct {
+  const char* conf_entry;
+  conf_action_t* p_action;
+  int param;
+} conf_entry_t;
+
+static int set_mchar_port(char* p_conf_name, char* p_conf_value, int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  strcpy(mchar_port, p_conf_value);
+  is_uart_port = 1;
+  return 0;
+}
+
+static int set_mbt_port(char* p_conf_name, char* p_conf_value, int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  strcpy(mbt_port, p_conf_value);
+  is_uart_port = 0;
+  return 0;
+}
+
+static int set_is_uart_port(char* p_conf_name, char* p_conf_value, int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  is_uart_port = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_uart_break_before_open(char* p_conf_name, char* p_conf_value,
+                                      int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  uart_break_before_open = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_baudrate_bt(char* p_conf_name, char* p_conf_value, int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  baudrate_bt = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_baudrate_fw_init(char* p_conf_name, char* p_conf_value,
+                                int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  baudrate_fw_init = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_bd_address_buf(char* p_conf_name, char* p_conf_value,
+                              int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  int i = 0;
+  int j = 7;
+  int len = 0;
+  if (p_conf_value == NULL) return 0;
+  len = strlen(p_conf_value);
+  if (len != 17) return 0;
+  for (i = 0; i < len; i++) {
+    if (((i + 1) % 3) == 0 && p_conf_value[i] != ':') return 0;
+    if (((i + 1) % 3) != 0 && !isxdigit(p_conf_value[i])) return 0;
+    char tmp = p_conf_value[i];
+    if (isupper(p_conf_value[i])) {
+      p_conf_value[i] = p_conf_value[i] - 'A' + 10;
+    } else if (islower(p_conf_value[i])) {
+      p_conf_value[i] = p_conf_value[i] - 'a' + 10;
+    } else if (isdigit(p_conf_value[i])) {
+      p_conf_value[i] = p_conf_value[i] - '0';
+    } else if (p_conf_value[i] == ':')
+      p_conf_value[i] = tmp;
+    else
+      return 0;
+  }
+  for (i = 0; i < 17; i++) {
+    write_bd_address[j--] = (p_conf_value[i] << 4) | p_conf_value[i + 1];
+    i = i + 2;
+  }
+  write_bdaddrss = 1;
+  return 0;
+}
+
+#ifdef UART_DOWNLOAD_FW
+static int set_enable_download_fw(char* p_conf_name, char* p_conf_value,
+                                  int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  enable_download_fw = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_uart_break_before_change_baudrate(char* p_conf_name,
+                                                 char* p_conf_value,
+                                                 int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  uart_break_before_change_baudrate = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_uart_break_after_dl_helper(char* p_conf_name, char* p_conf_value,
+                                          int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  uart_break_after_dl_helper = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_pFileName_image(char* p_conf_name, char* p_conf_value,
+                               int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  strcpy(pFileName_image, p_conf_value);
+  return 0;
+}
+
+static int set_pFileName_helper(char* p_conf_name, char* p_conf_value,
+                                int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  strcpy(pFileName_helper, p_conf_value);
+  download_helper = 1;
+  return 0;
+}
+
+static int set_baudrate_dl_helper(char* p_conf_name, char* p_conf_value,
+                                  int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  baudrate_dl_helper = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_baudrate_dl_image(char* p_conf_name, char* p_conf_value,
+                                 int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  baudrate_dl_image = atoi(p_conf_value);
+  return 0;
+}
+
+static int set_iSecondBaudrate(char* p_conf_name, char* p_conf_value,
+                               int param) {
+  UNUSED(p_conf_name);
+  UNUSED(param);
+  iSecondBaudrate = atoi(p_conf_value);
+  return 0;
+}
+
+#endif
+
+/*
+ * Current supported entries and corresponding action functions
+ */
+
+static const conf_entry_t conf_table[] = {
+    {"mchar_port", set_mchar_port, 0},
+    {"mbt_port", set_mbt_port, 0},
+    {"is_uart_port", set_is_uart_port, 0},
+    {"uart_break_before_open", set_uart_break_before_open, 0},
+    {"baudrate_bt", set_baudrate_bt, 0},
+    {"baudrate_fw_init", set_baudrate_fw_init, 0},
+    {"bd_address", set_bd_address_buf, 0},
+#ifdef UART_DOWNLOAD_FW
+    {"enable_download_fw", set_enable_download_fw, 0},
+    {"uart_break_before_change_baudrate", set_uart_break_before_change_baudrate,
+     0},
+    {"uart_break_after_dl_helper", set_uart_break_after_dl_helper, 0},
+    {"pFileName_image", set_pFileName_image, 0},
+    {"pFileName_helper", set_pFileName_helper, 0},
+    {"baudrate_dl_helper", set_baudrate_dl_helper, 0},
+    {"baudrate_dl_image", set_baudrate_dl_image, 0},
+    {"iSecondBaudrate", set_iSecondBaudrate, 0},
+#endif
+    {(const char*)NULL, NULL, 0}};
+
+/*******************************************************************************
+**
+** Function        vnd_load_conf
+**
+** Description     Read conf file from mentioned p_path at run time and read
+**                 one by one entry and call the corresponding config function
+**
+** Returns         None
+**
+*******************************************************************************/
+static void vnd_load_conf(const char* p_path) {
+  FILE* p_file;
+  char* p_name;
+  char* p_value;
+  conf_entry_t* p_entry;
+  char line[CONF_MAX_LINE_LEN + 1]; /* add 1 for \0 char */
+
+  ALOGI("Attempt to load conf from %s", p_path);
+
+  if ((p_file = fopen(p_path, "r")) != NULL) {
+    /* read line by line */
+    while (fgets(line, CONF_MAX_LINE_LEN + 1, p_file) != NULL) {
+      if (line[0] == CONF_COMMENT) continue;
+
+      p_name = strtok(line, CONF_DELIMITERS);
+
+      if (NULL == p_name) {
+        continue;
+      }
+
+      p_value = strtok(NULL, CONF_DELIMITERS);
+
+      if (NULL == p_value) {
+        ALOGW("vnd_load_conf: missing value for name: %s", p_name);
+        continue;
+      }
+
+      p_entry = (conf_entry_t*)conf_table;
+
+      while (p_entry->conf_entry != NULL) {
+        if (strcmp(p_entry->conf_entry, (const char*)p_name) == 0) {
+          p_entry->p_action(p_name, p_value, p_entry->param);
+          break;
+        }
+
+        p_entry++;
+      }
+    }
+
+    fclose(p_file);
+  } else {
+    ALOGI("vnd_load_conf file >%s< not found", p_path);
+  }
+}
+
+static int set_speed(int fd, struct termios* ti, int speed) {
+  if (cfsetospeed(ti, speed) < 0) {
+    VNDDBG("Set O speed failed!\n");
+    return -1;
+  }
+
+  if (cfsetispeed(ti, speed) < 0) {
+    VNDDBG("Set I speed failed!\n");
+    return -1;
+  }
+
+  if (tcsetattr(fd, TCSANOW, ti) < 0) {
+    VNDDBG("Set Attr speed failed!\n");
+    return -1;
+  }
+
+  return 0;
+}
+
+/******************************************************************************
+ **
+ ** Function:        read_hci_event
+ **
+ ** Description:     Reads the parameter of event received from controller.
+ **
+ ** Return Value:    offset of parameter
+ **
+ *
+ *****************************************************************************/
+
+static int read_hci_event(int fd, unsigned char* buf, int size) {
+  int remain, r;
+  int count = 0;
+  int k = 0;
+
+  if (size <= 0) return -1;
+
+  /* The first byte identifies the packet type. For HCI event packets, it
+   * should be 0x04, so we read until we get to the 0x04. */
+  VNDDBG("start read hci event 0x4\n");
+  while (k < 20) {
+    r = read(fd, buf, 1);
+    if (r <= 0) {
+      VNDDBG("read hci event 0x04 failed, retry\n");
+      k++;
+      usleep(50 * 1000);
+      continue;
+    }
+    if (buf[0] == 0x04) break;
+  }
+  if (k >= 20) {
+    VNDDBG("read hci event 0x04 failed, return error. k = %d\n", k);
+    return -1;
+  }
+  count++;
+
+  /* The next two bytes are the event code and parameter total length. */
+  VNDDBG("start read hci event code and len\n");
+  while (count < 3) {
+    r = read(fd, buf + count, 3 - count);
+    if (r <= 0) {
+      VNDDBG("read hci event code and len failed\n");
+      return -1;
+    }
+    count += r;
+  }
+
+  /* Now we read the parameters. */
+  VNDDBG("start read hci event para\n");
+  if (buf[2] < (size - 3))
+    remain = buf[2];
+  else
+    remain = size - 3;
+
+  while ((count - 3) < remain) {
+    r = read(fd, buf + count, remain - (count - 3));
+    if (r <= 0) {
+      VNDDBG("read hci event para failed\n");
+      return -1;
+    }
+    count += r;
+  }
+
+  VNDDBG("over read count = %d\n", count);
+  return count;
+}
+
+static int set_prop_int32(char* name, int value) {
+  char init_value[PROPERTY_VALUE_MAX];
+  int ret;
+
+  sprintf(init_value, "%d", value);
+  ret = property_set(name, init_value);
+  if (ret < 0) {
+    ALOGE("set_prop_int32 failed: %d", ret);
+  }
+  return ret;
+}
+
+static int get_prop_int32(char* name) {
+  int ret;
+
+  ret = property_get_int32(name, -1);
+  VNDDBG("get_prop_int32: %d", ret);
+  if (ret < 0) {
+    return 0;
+  }
+  return ret;
+}
+
+/******************************************************************************
+ **
+ ** Function:        uart_speed
+ **
+ ** Description:     Return the baud rate corresponding to the frequency.
+ **
+ ** Return Value:    Baudrate
+ *
+ *****************************************************************************/
+
+static int32 uart_speed(int32 s) {
+  switch (s) {
+    case 9600:
+      return B9600;
+    case 19200:
+      return B19200;
+    case 38400:
+      return B38400;
+    case 57600:
+      return B57600;
+    case 115200:
+      return B115200;
+    case 230400:
+      return B230400;
+    case 460800:
+      return B460800;
+    case 500000:
+      return B500000;
+    case 576000:
+      return B576000;
+    case 921600:
+      return B921600;
+    case 1000000:
+      return B1000000;
+    case 1152000:
+      return B1152000;
+    case 1500000:
+      return B1500000;
+    case 3000000:
+      return B3000000;
+    default:
+      return B0;
+  }
+}
+
+/******************************************************************************
+ *
+ ** Function            uart_set_speed
+ **
+ ** Description         Set the baud rate speed.
+
+ ** Return Value:       0 On success else -1
+
+ **
+ *****************************************************************************/
+
+static int32 uart_set_speed(int32 fd, struct termios* ti, int32 speed) {
+  cfsetospeed(ti, uart_speed(speed));
+  return tcsetattr(fd, TCSANOW, ti);
+}
+
+/******************************************************************************
+ **
+ ** Name:               init_uart
+ **
+ ** Description         Initialize UART.
+ **
+ ** Return Value        Valid fd on success
+ **
+ *****************************************************************************/
+
+int32 init_uart(int8* dev, int32 dwBaudRate, uint8 ucFlowCtrl) {
+  int32 fd = open(dev, O_RDWR | O_NOCTTY | O_NONBLOCK);
+  if (fd < 0) {
+    VNDDBG("Can't open serial port");
+    return -1;
+  }
+
+  tcflush(fd, TCIOFLUSH);
+
+  if (tcgetattr(fd, &ti) < 0) {
+    VNDDBG("Can't get port settings");
+    close(fd);
+    return -1;
+  }
+
+  cfmakeraw(&ti);
+#ifdef FW_LOADER_V2
+  ti.c_cflag |= CLOCAL | CREAD;
+#else
+  ti.c_cflag |= CLOCAL;
+#endif
+
+  /* Set 1 stop bit & no parity (8-bit data already handled by cfmakeraw) */
+  ti.c_cflag &= ~(CSTOPB | PARENB);
+
+  if (ucFlowCtrl) {
+    ti.c_cflag |= CRTSCTS;
+  } else {
+    ti.c_cflag &= ~CRTSCTS;
+  }
+
+  /*FOR READS: set timeout time w/ no minimum characters needed
+                         (since we read only 1 at at time...)          */
+  ti.c_cc[VMIN] = 0;
+  ti.c_cc[VTIME] = TIMEOUT_SEC * 10;
+
+  if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+    VNDDBG("Can't set port settings");
+    close(fd);
+    return -1;
+  }
+  tcflush(fd, TCIOFLUSH);
+
+  /* Set actual baudrate */
+  if (uart_set_speed(fd, &ti, dwBaudRate) < 0) {
+    VNDDBG("Can't set baud rate");
+    close(fd);
+    return -1;
+  }
+
+  return fd;
+}
+
+/*******************************************************************************
+**
+** Function        uart_init_open
+**
+** Description     Open the serial port with the given configuration
+**
+** Returns         device fd
+**
+*******************************************************************************/
+
+static int uart_init_open(int8* dev, int32 dwBaudRate, uint8 ucFlowCtrl) {
+  int fd = 0, num = 0;
+  do {
+    fd = init_uart(dev, dwBaudRate, ucFlowCtrl);
+    if (fd < 0) {
+      num++;
+      if (num >= 8) {
+        ALOGE("exceed max retry count, return error\n");
+        return -1;
+      } else {
+        ALOGE("open uart port %s failed fd: %d, retrying\n", dev, fd);
+        usleep(50 * 1000);
+        continue;
+      }
+    }
+  } while (fd < 0);
+
+  return fd;
+}
+
+#ifdef UART_DOWNLOAD_FW
+/*******************************************************************************
+**
+** Function        detect_and_download_fw
+**
+** Description     Start firmware download process if fw is not already download
+**
+** Returns         0 : FW is ready
+**                 1 : FW not ready
+**
+*******************************************************************************/
+
+static int detect_and_download_fw() {
+  int download_ret = 0;
+  int fw_downloaded = 0;
+
+/* detect fw status */
+#ifdef FW_LOADER_V2
+  if (bt_vnd_mrvl_check_fw_status_v2()) {
+#else
+  if (bt_vnd_mrvl_check_fw_status()) {
+#endif
+    /* force download only when header is received */
+    fw_downloaded = 0;
+  } else {
+    /* ignore download */
+    fw_downloaded = 1;
+    set_prop_int32(PROP_BLUETOOTH_FW_DOWNLOADED, 1);
+    goto done;
+  }
+
+  VNDDBG(" fw_downloaded %d", fw_downloaded);
+
+  if (!fw_downloaded) {
+#ifndef FW_LOADER_V2
+    init_crc8();
+#endif
+    /* download helper */
+    if (download_helper) {
+#ifdef FW_LOADER_V2
+      download_ret = bt_vnd_mrvl_download_fw_v2(mchar_port, baudrate_dl_helper,
+                                                pFileName_helper);
+#else
+      download_ret = bt_vnd_mrvl_download_fw(mchar_port, baudrate_dl_helper,
+                                             pFileName_helper, iSecondBaudrate);
+#endif
+      if (download_ret != 0) {
+        VNDDBG("helper download failed");
+        goto done;
+      }
+
+      usleep(500000);
+      /* flush additional A5 header if any */
+      tcflush(mchar_fd, TCIFLUSH);
+
+      /* close and open the port and set baud rate to baudrate_dl_image */
+      close(mchar_fd);
+      mchar_fd = uart_init_open(mchar_port, 3000000, 1);
+      usleep(20000);
+      tcflush(mchar_fd, TCIOFLUSH);
+    }
+
+/* download fw image */
+#ifdef FW_LOADER_V2
+    download_ret = bt_vnd_mrvl_download_fw_v2(mchar_port, baudrate_dl_image,
+                                              pFileName_image);
+#else
+    download_ret = bt_vnd_mrvl_download_fw(mchar_port, baudrate_dl_image,
+                                           pFileName_image, iSecondBaudrate);
+#endif
+    if (download_ret != 0) {
+      VNDDBG("fw download failed");
+      goto done;
+    }
+
+    tcflush(mchar_fd, TCIFLUSH);
+    if (uart_sleep_after_dl) usleep(uart_sleep_after_dl * 1000);
+
+    set_prop_int32(PROP_BLUETOOTH_FW_DOWNLOADED, 1);
+  }
+done:
+  return download_ret;
+}
+#endif
+
+/*******************************************************************************
+**
+** Function        config_uart
+**
+** Description     Configure uart w.r.t different fw_init_baudrate
+**                 and bt_baudrate and send relevant HCI command to confirm
+                   uart configuration
+**
+** Returns         0 : Success
+**                 Otherwise : Fail
+**
+*******************************************************************************/
+
+static int config_uart() {
+  int clen;
+  unsigned char set_speed_cmd_3m[8] = {0x01, 0x09, 0xFC, 0x04,
+                                       0xC0, 0xC6, 0x2D, 0x00};
+  unsigned char set_speed_cmd[8] = {0x01, 0x09, 0xFC, 0x04,
+                                    0x00, 0xC2, 0x01, 0x00};
+  unsigned char reset_cmd[4] = {0x01, 0x03, 0x0c, 0x00};
+  int resp_size;
+  unsigned char resp[10] = {0};
+  unsigned char resp_cmp[7] = {0x4, 0xe, 0x4, 0x1, 0x9, 0xfc, 0x0};
+  unsigned char resp_cmp_reset[7] = {0x4, 0xe, 0x4, 0x1, 0x3, 0xc, 0x0};
+
+  if (baudrate_fw_init != baudrate_bt) {
+    /* set baud rate to baudrate_fw_init */
+    if (uart_set_speed(mchar_fd, &ti, baudrate_fw_init) < 0) {
+      VNDDBG("Can't set baud rate");
+      return -1;
+    }
+
+    /* Sending HCI reset CMD  */
+    VNDDBG("start send bt hci reset\n");
+    memset(resp, 0x00, 10);
+    clen = sizeof(reset_cmd);
+    VNDDBG("Write HCI Reset command\n");
+    if (write(mchar_fd, reset_cmd, clen) != clen) {
+      VNDDBG("Failed to write reset command \n");
+      return -1;
+    }
+
+    if ((resp_size = read_hci_event(mchar_fd, resp, 10)) < 0 ||
+        memcmp(resp, resp_cmp_reset, 7)) {
+      VNDDBG("Failed to read HCI RESET CMD response! \n");
+      return -1;
+    }
+    VNDDBG("over send bt hci reset\n");
+
+    /* Set bt chip Baud rate CMD */
+    VNDDBG("start set fw baud rate according to baudrate_bt\n");
+    clen = sizeof(set_speed_cmd);
+    if (baudrate_bt == 3000000) {
+      VNDDBG("set fw baudrate as 3000000\n");
+      if (write(mchar_fd, set_speed_cmd_3m, clen) != clen) {
+        VNDDBG("Failed to write set baud rate command \n");
+        return -1;
+      }
+    } else if (baudrate_bt == 115200) {
+      VNDDBG("set fw baudrate as 115200");
+      if (write(mchar_fd, set_speed_cmd, clen) != clen) {
+        VNDDBG("Failed to write set baud rate command \n");
+        return -1;
+      }
+    }
+
+    VNDDBG("start read hci event\n");
+    memset(resp, 0x00, 10);
+    if ((resp_size = read_hci_event(mchar_fd, resp, 100)) < 0 ||
+        memcmp(resp, resp_cmp, 7)) {
+      VNDDBG("Failed to read set baud rate command response! \n");
+      return -1;
+    }
+    VNDDBG("over send bt chip baudrate\n");
+    /* set host uart speed according to baudrate_bt */
+    VNDDBG("start set host baud rate as baudrate_bt\n");
+    tcflush(mchar_fd, TCIOFLUSH);
+    if (set_speed(mchar_fd, &ti, uart_speed(baudrate_bt))) {
+      VNDDBG("Failed to  set baud rate \n");
+      return -1;
+    }
+    ti.c_cflag |= CRTSCTS;
+    if (tcsetattr(mchar_fd, TCSANOW, &ti) < 0) {
+      VNDDBG("Set Flow Control failed!\n");
+      return -1;
+    }
+    tcflush(mchar_fd, TCIOFLUSH);
+
+  } else {
+    /* set host uart speed according to baudrate_bt */
+    VNDDBG("start set host baud rate as baudrate_bt\n");
+    tcflush(mchar_fd, TCIOFLUSH);
+
+    /* Close and open the port as setting baudrate to baudrate_bt */
+    close(mchar_fd);
+    mchar_fd = uart_init_open(mchar_port, baudrate_bt, 1);
+    usleep(20000);
+    tcflush(mchar_fd, TCIOFLUSH);
+  }
+
+  usleep(20 * 1000);
+  set_prop_int32(PROP_BLUETOOTH_OPENED, 1);
+  return 0;
+}
+
+/*****************************************************************************
+**
+**   BLUETOOTH VENDOR INTERFACE LIBRARY FUNCTIONS
+**
+*****************************************************************************/
+
+static int bt_vnd_init(const bt_vendor_callbacks_t* p_cb,
+                       unsigned char* local_bdaddr) {
+  vnd_cb = p_cb;
+  if (vnd_cb == NULL) {
+    VNDDBG("vnd_cb is NULL");
+  }
+  ALOGI ("bt_vnd_init\n");
+  VNDDBG("bt_vnd_init --- BT Vendor HAL Ver: %s ---\n", BT_HAL_VERSION);
+  if (local_bdaddr) {
+    bdaddr = (unsigned char*)malloc(BD_ADDR_LEN);
+    memcpy(bdaddr, local_bdaddr, 6);
+    if (bdaddr)
+      VNDDBG("bdaddr is %02hhX:%02hhX:%02hhX:%02hhX:%02hhX:%02hhX\n", bdaddr[0],
+             bdaddr[1], bdaddr[2], bdaddr[3], bdaddr[4], bdaddr[5]);
+  }
+  vnd_load_conf(VENDOR_LIB_CONF_FILE);
+  return 0;
+}
+
+/** Requested operations */
+static int bt_vnd_op(bt_vendor_opcode_t opcode, void* param) {
+  int ret = 0;
+  int local_st = 0;
+
+  VNDDBG("opcode = %d\n", opcode);
+  switch (opcode) {
+    case BT_VND_OP_POWER_CTRL: {
+      int* state = (int*)param;
+
+      if (*state == BT_VND_PWR_OFF) {
+        VNDDBG("power off --------------------------------------*\n");
+        if (adapterState == BT_VND_PWR_ON) {
+          VNDDBG("BT adapter switches from ON to OFF .. \n");
+          adapterState = BT_VND_PWR_OFF;
+        }
+      } else if (*state == BT_VND_PWR_ON) {
+        VNDDBG("power on --------------------------------------\n");
+        adapterState = BT_VND_PWR_ON;
+      }
+    } break;
+    case BT_VND_OP_FW_CFG:
+      hw_config_start();
+      break;
+
+    case BT_VND_OP_SCO_CFG:
+      if (vnd_cb) {
+        vnd_cb->scocfg_cb(ret);
+      }
+      break;
+    case BT_VND_OP_USERIAL_OPEN: {
+      VNDDBG("open serial port --------------------------------------\n");
+      int(*fd_array)[] = (int(*)[])param;
+      int idx;
+      int bluetooth_opened;
+      int num = 0;
+      int32_t baudrate = 0;
+
+      if (is_uart_port) {
+        VNDDBG("baudrate_bt %d\n", baudrate_bt);
+        VNDDBG("baudrate_fw_init %d\n", baudrate_fw_init);
+#ifdef UART_DOWNLOAD_FW
+        if (enable_download_fw) {
+          VNDDBG("download_helper %d\n", download_helper);
+          VNDDBG("uart_break_before_change_baudrate %d\n",
+                 uart_break_before_change_baudrate);
+          VNDDBG("baudrate_dl_helper %d\n", baudrate_dl_helper);
+          VNDDBG("baudrate_dl_image %d\n", baudrate_dl_image);
+          VNDDBG("pFileName_helper %s\n", pFileName_helper);
+          VNDDBG("pFileName_image %s\n", pFileName_image);
+          VNDDBG("iSecondBaudrate %d\n", iSecondBaudrate);
+          VNDDBG("uart_break_before_open %d\n", uart_break_before_open);
+          VNDDBG("enable_download_fw %d\n", enable_download_fw);
+          VNDDBG("uart_break_after_dl_helper %d\n", uart_break_after_dl_helper);
+          VNDDBG("uart_sleep_after_dl %d\n", uart_sleep_after_dl);
+        }
+#endif
+      }
+      pthread_mutex_lock(&dev_file_lock);
+
+      if (is_uart_port) {
+        /* ensure libbt can talk to the driver, only need open port once */
+        if (get_prop_int32(PROP_BLUETOOTH_OPENED))
+          mchar_fd = uart_init_open(mchar_port, baudrate_bt, 1);
+        else {
+#ifdef UART_DOWNLOAD_FW
+          if (enable_download_fw) {
+            /* if define micro UART_DOWNLOAD_FW, then open uart must with
+               baudrate 115200,
+               since libbt can only communicate with bootloader with baudrate
+               115200*/
+            /* for 9098 helper is not need, so baudrate_dl_image is 115200, and
+               iSecondBaudrate is true
+               to set baudrate to 3000000 before download FW*/
+            baudrate =
+                (download_helper) ? baudrate_dl_helper : baudrate_dl_image;
+          } else {
+            baudrate = baudrate_fw_init;
+          }
+#else
+          baudrate = baudrate_fw_init;
+#endif
+          mchar_fd = uart_init_open(mchar_port, baudrate, 0);
+        }
+        if (mchar_fd > 0)
+          VNDDBG("open uart port successfully, fd=%d, mchar_port=%s\n",
+                 mchar_fd, mchar_port);
+        else {
+          ALOGE("open UART bt port %s failed fd: %d\n", mchar_port, mchar_fd);
+          pthread_mutex_unlock(&dev_file_lock);
+          return -1;
+        }
+      } else {
+        do {
+          mchar_fd = open(mbt_port, O_RDWR | O_NOCTTY);
+          if (mchar_fd < 0) {
+            num++;
+            if (num >= 8) {
+              ALOGE("exceed max retry count, return error");
+              pthread_mutex_unlock(&dev_file_lock);
+              return -1;
+            } else {
+              ALOGE("open USB/SD port %s failed fd: %d, retrying\n", mbt_port,
+                     mchar_fd);
+              sleep(1);
+              continue;
+            }
+          } else {
+            VNDDBG("open USB or SD port successfully, fd=%d, mbt_port=%s\n",
+                   mchar_fd, mbt_port);
+            is_uart_port = 0;
+          }
+        } while (mchar_fd < 0);
+      }
+
+      if (is_uart_port) {
+#ifdef UART_DOWNLOAD_FW
+        if (enable_download_fw) {
+          if (detect_and_download_fw()) {
+            ALOGE("detect_and_download_fw failed");
+            set_prop_int32(PROP_BLUETOOTH_OPENED, 0);
+            set_prop_int32(PROP_BLUETOOTH_FW_DOWNLOADED, 0);
+            pthread_mutex_unlock(&dev_file_lock);
+            return -1;
+          }
+        } else {
+          ti.c_cflag |= CRTSCTS;
+          if (tcsetattr(mchar_fd, TCSANOW, &ti) < 0) {
+            ALOGE("Set Flow Control failed!\n");
+            return -1;
+          }
+          tcflush(mchar_fd, TCIOFLUSH);
+        }
+#else
+        ti.c_cflag |= CRTSCTS;
+        if (tcsetattr(mchar_fd, TCSANOW, &ti) < 0) {
+          ALOGE("Set Flow Control failed!\n");
+          return -1;
+        }
+        tcflush(mchar_fd, TCIOFLUSH);
+#endif
+        bluetooth_opened = get_prop_int32(PROP_BLUETOOTH_OPENED);
+        if (!bluetooth_opened) {
+#ifdef UART_DOWNLOAD_FW
+          if (!enable_download_fw)
+#endif
+          {
+            /*NXP Bluetooth use combo firmware which is loaded at wifi driver
+            probe.
+            This function will wait to make sure basic client netdev is created
+            */
+            int count =
+                (POLL_DRIVER_MAX_TIME_MS * 1000) / POLL_DRIVER_DURATION_US;
+            FILE* fd;
+
+            while (count-- > 0) {
+              if ((fd = fopen("/sys/class/net/wlan0", "r")) != NULL) {
+                fclose(fd);
+                break;
+              }
+              usleep(POLL_DRIVER_DURATION_US);
+            }
+          }
+
+          if (config_uart()) {
+            ALOGE("config_uart failed");
+            set_prop_int32(PROP_BLUETOOTH_OPENED, 0);
+            set_prop_int32(PROP_BLUETOOTH_FW_DOWNLOADED, 0);
+            pthread_mutex_unlock(&dev_file_lock);
+            return -1;
+          }
+        }
+      }
+
+      for (idx = 0; idx < CH_MAX; idx++) {
+        (*fd_array)[idx] = mchar_fd;
+        ret = 1;
+      }
+      pthread_mutex_unlock(&dev_file_lock);
+      VNDDBG("open serial port over --------------------------------------\n");
+    } break;
+    case BT_VND_OP_USERIAL_CLOSE:
+      /* mBtChar port is blocked on read. Release the port before we close it */
+      pthread_mutex_lock(&dev_file_lock);
+      if (is_uart_port) {
+        if (mchar_fd) {
+          tcflush(mchar_fd, TCIFLUSH);
+          close(mchar_fd);
+          mchar_fd = 0;
+        }
+      } else {
+        ioctl(mchar_fd, MBTCHAR_IOCTL_RELEASE, &local_st);
+        /* Give it sometime before we close the mbtchar */
+        usleep(1000);
+        if (mchar_fd) {
+          if (close(mchar_fd) < 0) {
+            ALOGE("close serial port failed!\n");
+            ret = -1;
+          }
+        }
+      }
+      pthread_mutex_unlock(&dev_file_lock);
+      break;
+    case BT_VND_OP_GET_LPM_IDLE_TIMEOUT:
+      break;
+    case BT_VND_OP_LPM_SET_MODE:
+      if (vnd_cb) {
+        vnd_cb->lpm_cb(ret);
+      }
+      break;
+    case BT_VND_OP_LPM_WAKE_SET_STATE:
+      break;
+    default:
+      ret = -1;
+      break;
+  }
+  return ret;
+}
+
+/** Closes the interface */
+static void bt_vnd_cleanup(void) {
+  VNDDBG("cleanup ...");
+  vnd_cb = NULL;
+  if (bdaddr) {
+    free(bdaddr);
+    bdaddr = NULL;
+  }
+}
+
+/** Entry point of DLib */
+const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {
+    sizeof(bt_vendor_interface_t), bt_vnd_init, bt_vnd_op, bt_vnd_cleanup,
+};
diff --git a/88x9098/bt/libbt/bt_vendor_nxp.h b/88x9098/bt/libbt/bt_vendor_nxp.h
new file mode 100755
index 0000000..bb28a12
--- /dev/null
+++ b/88x9098/bt/libbt/bt_vendor_nxp.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *
+ *  Copyright 2018-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _BT_VENDOR_NXP_H
+#define _BT_VENDOR_NXP_H
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <termios.h>
+#include <time.h>
+#include <unistd.h>
+#include "bt_vendor_lib.h"
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+typedef unsigned long long uint64;
+typedef unsigned int uint32;
+typedef unsigned short uint16;
+typedef unsigned char uint8;
+typedef int int32;
+typedef short int16;
+typedef char int8;
+typedef unsigned char BOOLEAN;
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#define BT_HAL_VERSION "008.002"
+
+#define TIMEOUT_SEC 6
+#define RW_SUCCESSFUL (1)
+#define RW_FAILURE (~RW_SUCCESSFUL)
+
+#define BIT(x) (0x1 << x)
+
+#define TRUE 1
+#define FALSE 0
+#define WRITE_BD_ADDRESS_SIZE 8
+
+/* Run-time configuration file */
+#ifndef VENDOR_LIB_CONF_FILE
+#define VENDOR_LIB_CONF_FILE "/vendor/etc/bluetooth/bt_vendor.conf"
+#endif
+
+#ifndef NXP_VND_DBG
+#define NXP_VND_DBG FALSE
+#endif
+
+#if (NXP_VND_DBG == TRUE)
+#define VNDDBG(fmt, ...) \
+  ALOGD("%s(L%d): " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
+#else
+#define VNDDBG(fmt, ...)
+#endif
+
+/***********************************************************
+ *  Externs
+ ***********************************************************
+ */
+extern unsigned char* bdaddr;
+extern int write_bdaddrss;
+extern uint8_t write_bd_address[WRITE_BD_ADDRESS_SIZE];
+extern const bt_vendor_callbacks_t* vnd_cb;
+
+/*****************************************************************************
+**   Functions Prototype
+*****************************************************************************/
+void hw_config_start(void);
+int32 init_uart(int8* dev, int32 dwBaudRate, uint8 ucFlowCtrl);
+#endif
diff --git a/88x9098/bt/libbt/conf/bt_vendor_8887.conf b/88x9098/bt/libbt/conf/bt_vendor_8887.conf
new file mode 100755
index 0000000..6f60187
--- /dev/null
+++ b/88x9098/bt/libbt/conf/bt_vendor_8887.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttyUSB0
+pFileName_helper =  /vendor/etc/firmware/mrvl/helper_uart_3000000.bin
+pFileName_image = /vendor/etc/firmware/mrvl/uart8887_bt_a2.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=1
diff --git a/88x9098/bt/libbt/conf/bt_vendor_8987.conf b/88x9098/bt/libbt/conf/bt_vendor_8987.conf
new file mode 100755
index 0000000..7f2401e
--- /dev/null
+++ b/88x9098/bt/libbt/conf/bt_vendor_8987.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttyUSB0
+pFileName_helper =  /vendor/etc/firmware/mrvl/helper_uart_3000000.bin
+pFileName_image = /vendor/etc/firmware/mrvl/uart8987_bt.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=1
diff --git a/88x9098/bt/libbt/conf/bt_vendor_8997.conf b/88x9098/bt/libbt/conf/bt_vendor_8997.conf
new file mode 100755
index 0000000..3498ed9
--- /dev/null
+++ b/88x9098/bt/libbt/conf/bt_vendor_8997.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttyUSB0
+pFileName_helper =  /vendor/etc/firmware/mrvl/helper_uart_3000000.bin
+pFileName_image = /vendor/etc/firmware/mrvl/uart8997_bt_v4.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=1
diff --git a/88x9098/bt/libbt/conf/bt_vendor_9098.conf b/88x9098/bt/libbt/conf/bt_vendor_9098.conf
new file mode 100755
index 0000000..3923316
--- /dev/null
+++ b/88x9098/bt/libbt/conf/bt_vendor_9098.conf
@@ -0,0 +1,8 @@
+mchar_port = /dev/ttyUSB0
+pFileName_image = /vendor/etc/firmware/mrvl/uart9098_bt_v0.bin
+baudrate_bt = 3000000
+baudrate_dl_image = 115200
+iSecondBaudrate = 3000000
+bd_address = 12:34:56:78:9a:bc
+baudrate_fw_init = 3000000
+enable_download_fw=1
diff --git a/88x9098/bt/libbt/conf/nxp/evk_8mn/Android.mk b/88x9098/bt/libbt/conf/nxp/evk_8mn/Android.mk
new file mode 100755
index 0000000..04ead09
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/evk_8mn/Android.mk
@@ -0,0 +1,11 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/bluetooth
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
+
diff --git a/88x9098/bt/libbt/conf/nxp/evk_8mn/bt_vendor.conf b/88x9098/bt/libbt/conf/nxp/evk_8mn/bt_vendor.conf
new file mode 100755
index 0000000..6747a9f
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/evk_8mn/bt_vendor.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttymxc0
+pFileName_helper =  /vendor/firmware/mrvl/helper_uart_3000000.bin
+pFileName_image = /vendor/firmware/sdiouart8987_combo_v0.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=0
diff --git a/88x9098/bt/libbt/conf/nxp/evk_8mp/Android.mk b/88x9098/bt/libbt/conf/nxp/evk_8mp/Android.mk
new file mode 100755
index 0000000..04ead09
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/evk_8mp/Android.mk
@@ -0,0 +1,11 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/bluetooth
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
+
diff --git a/88x9098/bt/libbt/conf/nxp/evk_8mp/bt_vendor.conf b/88x9098/bt/libbt/conf/nxp/evk_8mp/bt_vendor.conf
new file mode 100755
index 0000000..890507f
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/evk_8mp/bt_vendor.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttymxc0
+pFileName_helper =  /vendor/firmware/mrvl/helper_uart_3000000.bin
+pFileName_image = /vendor/firmware/mrvl/uart8997_bt_v4.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=0
diff --git a/88x9098/bt/libbt/conf/nxp/evk_8mq/Android.mk b/88x9098/bt/libbt/conf/nxp/evk_8mq/Android.mk
new file mode 100755
index 0000000..465e4a6
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/evk_8mq/Android.mk
@@ -0,0 +1,10 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/bluetooth
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
diff --git a/88x9098/bt/libbt/conf/nxp/evk_8mq/bt_vendor.conf b/88x9098/bt/libbt/conf/nxp/evk_8mq/bt_vendor.conf
new file mode 100755
index 0000000..79805f5
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/evk_8mq/bt_vendor.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttymxc2
+pFileName_helper =  /vendor/firmware/mrvl/helper_uart_3000000.bin
+pFileName_image = /vendor/firmware/mrvl/uart8997_bt_v4.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=0
diff --git a/88x9098/bt/libbt/conf/nxp/mek_8q/Android.mk b/88x9098/bt/libbt/conf/nxp/mek_8q/Android.mk
new file mode 100755
index 0000000..04ead09
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/mek_8q/Android.mk
@@ -0,0 +1,11 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/bluetooth
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
+
diff --git a/88x9098/bt/libbt/conf/nxp/mek_8q/bt_vendor.conf b/88x9098/bt/libbt/conf/nxp/mek_8q/bt_vendor.conf
new file mode 100755
index 0000000..a160956
--- /dev/null
+++ b/88x9098/bt/libbt/conf/nxp/mek_8q/bt_vendor.conf
@@ -0,0 +1,9 @@
+mchar_port = /dev/ttyUSB0
+pFileName_helper = /vendor/firmware/helper_uart_3000000.bin
+pFileName_image = /vendor/firmware/uartuart8987_bt_v0.bin
+baudrate_dl_helper = 115200
+baudrate_dl_image = 3000000
+iSecondBaudrate = 0
+baudrate_fw_init = 115200
+baudrate_bt = 3000000
+enable_download_fw=0
diff --git a/88x9098/bt/libbt/conf/renesas/salvator/Android.mk b/88x9098/bt/libbt/conf/renesas/salvator/Android.mk
new file mode 100755
index 0000000..465e4a6
--- /dev/null
+++ b/88x9098/bt/libbt/conf/renesas/salvator/Android.mk
@@ -0,0 +1,10 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/etc/bluetooth
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
diff --git a/88x9098/bt/libbt/conf/renesas/salvator/bt_vendor.conf b/88x9098/bt/libbt/conf/renesas/salvator/bt_vendor.conf
new file mode 100755
index 0000000..031bb93
--- /dev/null
+++ b/88x9098/bt/libbt/conf/renesas/salvator/bt_vendor.conf
@@ -0,0 +1,6 @@
+mchar_port = /dev/ttySC2
+pFileName_image = /vendor/etc/firmware/pcieuart9098_combo_v1.bin
+baudrate_bt = 3000000
+baudrate_dl_image = 115200
+baudrate_fw_init = 3000000
+enable_download_fw=0
diff --git a/88x9098/bt/libbt/fw_loader_io.c b/88x9098/bt/libbt/fw_loader_io.c
new file mode 100755
index 0000000..e78e63d
--- /dev/null
+++ b/88x9098/bt/libbt/fw_loader_io.c
@@ -0,0 +1,345 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*===================== Include Files ============================================*/
+#include "fw_loader_io.h"
+
+#define LOG_TAG "fw_loader_linux"
+#include <log/log.h>
+#include <cutils/properties.h>
+#define perror(fmt, ...) ALOGE("ERROR : %s(L%d): " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
+
+/*===================== Macros ===================================================*/
+#define TIMEOUT_SEC 6
+
+/*==================== Typedefs =================================================*/
+
+/*===================== Global Vars ==============================================*/
+
+/*==================== Function Prototypes ======================================*/
+
+/*==================== Coded Procedures =========================================*/
+
+/******************************************************************************
+ *
+ * Name: fw_upload_lenValid
+ *
+ * Description:
+ *   This function validates the length from 5 bytes request.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   ucArray: store the 5 bytes request.
+ *
+ * Return Value:
+ *   uiLenToSend: if the length is valid, get value from ucArray.
+ *
+ * Notes:
+ *   None.
+ *
+
+*****************************************************************************/
+BOOLEAN fw_upload_lenValid(uint16 *uiLenToSend, uint8 *ucArray) {
+  uint16 uiLen, uiLenComp;
+  uint16 uiXorOfLen = 0xFFFF;
+  uiLen = ((ucArray[1] & 0xFF) | ((ucArray[2] << 8) & 0xFF00));
+  uiLenComp = ((ucArray[3] & 0xFF) | ((ucArray[4] << 8) & 0xFF00));
+  // LEN valid if len & complement match
+  if ((uiLen ^ uiLenComp) == uiXorOfLen)  // All 1's
+  {
+    *uiLenToSend = uiLen;
+    return TRUE;
+  } else {
+    return FALSE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_GetDataLen
+ *
+ * Description:
+ *   This function gets buf data length.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   *buf: buffer that stores header and following data.
+ *
+ * Return Value:
+ *   length of data part in the buffer.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+uint16 fw_upload_GetDataLen(uint8 *buf) {
+  return (buf[8] | (buf[9] << 8));
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_DelayInMs
+ *
+ * Description:
+ *   This function delays the execution of the program for the time
+ *   specified in uiMs.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   uiMs - Delay in Milliseconds.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+void fw_upload_DelayInMs(uint32 uiMs) {
+  struct timespec ReqTime;
+  time_t sec;
+
+  // Initialize to 0
+  ReqTime.tv_sec = 0;
+  ReqTime.tv_nsec = 0;
+
+  // Calculate the Delay
+  sec = (int)(uiMs / 1000);
+  uiMs = uiMs - (sec * 1000);
+  ReqTime.tv_sec = sec;
+  ReqTime.tv_nsec = uiMs * 1000000L;  // 1 ms = 1000000 ns
+
+  // Sleep
+  while (nanosleep(&ReqTime, &ReqTime) == -1) {
+    continue;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_ComReadChar
+ *
+ * Description:
+ *   Read a character from the port specified by nPortID.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   nPortID : Port ID.
+ *
+ * Return Value:
+ *   Returns the character, if Successful.
+ *   Returns -1 if no character available (OR TIMED-OUT)
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+int32 fw_upload_ComReadChar(int32 mchar_fd) {
+  int32 iResult = 0;
+  uint8 ucNumCharToRead = 1;
+
+  if (read(mchar_fd, &iResult, ucNumCharToRead) == ucNumCharToRead) {
+    return (iResult & 0xFF);
+  } else {
+    return RW_FAILURE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_ComReadChars
+ *
+ * Description:
+ *   Read iCount characters from the port specified by nPortID.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   mchar_fd   : Port ID.
+ *   pBuffer : Destination buffer for the characters read
+ *   iCount    : Number of Characters to be read.
+ *
+ * Return Value:
+ *   Returns the number of characters read if Successful.
+ *   Returns -1 if iCount characters could not be read or if Port ID is invalid.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+int32 fw_upload_ComReadChars(int32 mchar_fd, uint8* pBuffer, uint32 uiCount) {
+  if ((uint32)read(mchar_fd, pBuffer, uiCount) == uiCount) {
+    return uiCount;
+  } else {
+    return RW_FAILURE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_ComWriteChar
+ *
+ * Description:
+ *   Write a character to the port specified by mchar_fd.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   mchar_fd : Port ID.
+ *   iChar   : Character to be written
+ *
+ * Return Value:
+ *   Returns TRUE, if write is Successful.
+ *   Returns FALSE if write is a failure.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+int8 fw_upload_ComWriteChar(int32 mchar_fd, int8 iChar) {
+  uint8 ucNumCharToWrite = 1;
+
+  if (write(mchar_fd, &iChar, ucNumCharToWrite) == ucNumCharToWrite) {
+    return RW_SUCCESSFUL;
+  } else {
+    return RW_FAILURE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_ComWriteChars
+ *
+ * Description:
+ *   Write iLen characters to the port specified by mchar_fd.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   mchar_fd : Port ID.
+ *   pBuffer : Buffer where characters are available to be written to the Port.
+ *   iLen    : Number of Characters to write.
+ *
+ * Return Value:
+ *   Returns TRUE, if write is Successful.
+ *   Returns FALSE if write is a failure.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+int8 fw_upload_ComWriteChars(int32 mchar_fd, uint8* pBuffer, uint32 uiLen) {
+  if ((uint32)write(mchar_fd, pBuffer, uiLen) == uiLen) {
+    return RW_SUCCESSFUL;
+  } else {
+    return RW_FAILURE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_ComGetCTS
+ *
+ * Description:
+ *   Check CTS status
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *
+ * Return Value:
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+int32 fw_upload_ComGetCTS(int32 mchar_fd) {
+  int32 status;
+  ioctl(mchar_fd, TIOCMGET, &status);
+  if (status & TIOCM_CTS) {
+    return 0;
+  } else {
+    return 1;
+  }
+}
+/******************************************************************************
+ *
+ * Name: fw_upload_ComGetBufferSize
+ *
+ * Description:
+ *   Check buffer size
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   mchar_fd
+ *
+ * Return Value:
+ *   size in buffer
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+int32 fw_upload_GetBufferSize(int32 mchar_fd) {
+  int32 bytes = 0;
+  ioctl(mchar_fd, FIONREAD, &bytes);
+  return bytes;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_GetTime
+ *
+ * Description:
+ *   Get the current time
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *
+ * Return Value:
+ *   return the current time
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+
+double fw_upload_GetTime(void) {
+  struct timeval time;
+  double millsectime;
+  gettimeofday(&time, NULL);
+  millsectime = (time.tv_sec * 1000000 + time.tv_usec) / 1000;
+  return millsectime;
+}
+
diff --git a/88x9098/bt/libbt/fw_loader_io.h b/88x9098/bt/libbt/fw_loader_io.h
new file mode 100755
index 0000000..af2d71b
--- /dev/null
+++ b/88x9098/bt/libbt/fw_loader_io.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*===================== Include Files ============================================*/
+#ifndef _FW_LOADER_IO_LINUX_H
+#define _FW_LOADER_IO_LINUX_H
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <termios.h>
+#include <time.h>
+#include <unistd.h>
+#include "bt_vendor_nxp.h"
+/*===================== Macros ===================================================*/
+
+/*==================== Typedefs =================================================*/
+
+/*===================== Global Vars ==============================================*/
+
+/*==================== Function Prototypes ======================================*/
+extern BOOLEAN fw_upload_lenValid(uint16 *uiLenToSend, uint8 *ucArray);
+extern uint16 fw_upload_GetDataLen(uint8 *buf);
+extern int32 fw_upload_ComReadChar(int32 mchar_fd);
+extern int8 fw_upload_ComWriteChar(int32 mchar_fd, int8 iChar);
+extern int8 fw_upload_ComWriteChars(int32 mchar_fd, uint8 *pChBuffer, uint32 uiLen);
+extern int32 fw_upload_ComReadChars(int32 mchar_fd, uint8 *pChBuffer, uint32 uiCount);
+extern void fw_upload_DelayInMs(uint32 uiMs);
+extern int32 fw_upload_ComGetCTS(int32 mchar_fd);
+extern double fw_upload_GetTime(void);
+extern int32 fw_upload_GetBufferSize(int32 mchar_fd);
+#endif  // _FW_LOADER_IO_LINUX_H
+
diff --git a/88x9098/bt/libbt/fw_loader_uart.c b/88x9098/bt/libbt/fw_loader_uart.c
new file mode 100755
index 0000000..2c6537c
--- /dev/null
+++ b/88x9098/bt/libbt/fw_loader_uart.c
@@ -0,0 +1,1443 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*===================== Include Files ============================================*/
+#include "fw_loader_uart.h"
+#include "fw_loader_io.h"
+#include <errno.h>
+#include <memory.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/select.h>
+
+
+#define LOG_TAG "fw_loader"
+#include <log/log.h>
+#include <cutils/properties.h>
+#define printf(fmt, ...) ALOGE("ERROR : %s(L%d): " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define PRINT_INFO(fmt, ...) ALOGI("INFO : %s(L%d): " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
+
+/*--------------------------------fw_loader_io_linux.c-------------------------*/
+#define TIMEOUT_FOR_READ        4000
+
+
+/*===================== Macros ===================================================*/
+#define VERSION "M304"
+#define MAX_LENGTH 0xFFFF  // Maximum 2 byte value
+#define END_SIG_TIMEOUT 2500
+#define MAX_CTS_TIMEOUT 100  // 100ms
+#define STRING_SIZE 6
+#define HDR_LEN 16
+#define CMD4 0x4
+#define CMD6 0x6
+#define CMD7 0x7
+
+#define V1_HEADER_DATA_REQ 0xa5
+#define V1_REQUEST_ACK 0x5a
+#define V1_START_INDICATION 0xaa
+
+#define V3_START_INDICATION 0xab
+#define V3_HEADER_DATA_REQ 0xa7
+#define V3_REQUEST_ACK 0x7a
+#define V3_TIMEOUT_ACK 0x7b
+#define V3_CRC_ERROR 0x7c
+
+#define PRINT(...)         printf(__VA_ARGS__)
+
+#define REQ_HEADER_LEN 1
+#define A6REQ_PAYLOAD_LEN 8
+#define AbREQ_PAYLOAD_LEN 3
+
+#define END_SIG 0x435000
+
+#define GP 0x107 /* x^8 + x^2 + x + 1 */
+#define DI 0x07
+
+#define CRC_ERR_BIT 1 << 0
+#define NAK_REC_BIT 1 << 1
+#define TIMEOUT_REC_ACK_BIT 1 << 2
+#define TIMEOUT_REC_HEAD_BIT 1 << 3
+#define TIMEOUT_REC_DATA_BIT 1 << 4
+#define INVALID_CMD_REC_BIT 1 << 5
+#define WIFI_MIC_FAIL_BIT 1 << 6
+#define BT_MIC_FAIL_BIT 1 << 7
+
+#define SWAPL(x) \
+  (((x >> 24) & 0xff) | ((x >> 8) & 0xff00) | ((x << 8) & 0xff0000L) | ((x << 24) & 0xff000000L))
+
+#define POLYNOMIAL 0x04c11db7L
+
+#define CLKDIVAddr 0x7f00008f
+#define UARTDIVAddr 0x7f000090
+#define UARTMCRAddr 0x7f000091
+#define UARTREINITAddr 0x7f000092
+#define UARTICRAddr 0x7f000093
+
+#define MCR 0x00000022
+#define INIT 0x00000001
+#define ICR 0x000000c7
+#define TIMEOUT_VAL_MILLISEC 4000  // Timeout for getting 0xa5 or 0xab
+
+static unsigned char crc8_table[256]; /* 8-bit table */
+static int made_table = 0;
+
+static unsigned long crc_table[256];
+static BOOLEAN cmd7_Req = FALSE;
+static BOOLEAN EntryPoint_Req = FALSE;
+static uint32 change_baudrata_buffer_len = 0;
+
+
+// CMD5 Header to change bootload baud rate
+int8 m_Buffer_CMD5_Header[16] = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                 0x2c, 0x00, 0x00, 0x00, 0x77, 0xdb, 0xfd, 0xe0};
+
+const UART_BAUDRATE UartCfgTbl[] = {
+    {115200, 16, 0x0075F6FD}, {3000000, 1, 0x00C00000},
+};
+
+//#define DEBUG_PRINT
+/*==================== Typedefs =================================================*/
+
+/*===================== Global Vars ==============================================*/
+// Maximum Length that could be asked by the Helper = 2 bytes
+static uint8 ucByteBuffer[MAX_LENGTH];
+
+// Size of the File to be downloaded
+static uint32 ulTotalFileSize = 0;
+
+// Current size of the Download
+static uint32 ulCurrFileSize = 0;
+static uint32 ulLastOffsetToSend = 0xFFFF;
+static BOOLEAN uiErrCase = FALSE;
+// Received Header
+static uint8 ucRcvdHeader;
+static uint8 ucString[STRING_SIZE];
+static BOOLEAN b16BytesData = FALSE;
+
+static uint16 uiNewLen;
+static uint32 ulNewOffset;
+static uint16 uiNewError;
+static uint8 uiNewCrc;
+
+static uint8 uiProVer;
+static BOOLEAN bVerChecked = FALSE;
+static uint8 ucCalCrc[10];
+
+typedef enum {
+  Ver1,
+  Ver2,
+  Ver3,
+} Version;
+
+uint8 uiErrCnt[16] = {0};
+jmp_buf resync;  // Protocol restart buffer used in timeout cases.
+/*==================== Function Prototypes ======================================*/
+
+/*==================== Coded Procedures =========================================*/
+/******************************************************************************
+
+ *
+ * Name: gen_crc_table
+ *
+ * Description:
+ *   Genrate crc table
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+void fw_upload_gen_crc_table() {
+  int i, j;
+  unsigned long crc_accum;
+
+  for (i = 0; i < 256; i++) {
+    crc_accum = ((unsigned long)i << 24);
+    for (j = 0; j < 8; j++) {
+      if (crc_accum & 0x80000000L) {
+        crc_accum = (crc_accum << 1) ^ POLYNOMIAL;
+      } else {
+        crc_accum = (crc_accum << 1);
+      }
+    }
+    crc_table[i] = crc_accum;
+  }
+
+  return;
+}
+
+/******************************************************************************
+
+ *
+ * Name: update_crc
+ *
+ * Description:
+ *   update the CRC on the data block one byte at a time
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   ata_blk_ptr:   the buffer pointer for updating crc.
+ *   data_blk_size: the size of buffer
+ *
+ * Return Value:
+ *   CRC value.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+unsigned long fw_upload_update_crc(unsigned long crc_accum, char *data_blk_ptr, int data_blk_size) {
+  int i, j;
+
+  for (j = 0; j < data_blk_size; j++) {
+    i = ((int)(crc_accum >> 24) ^ *data_blk_ptr++) & 0xff;
+    crc_accum = (crc_accum << 8) ^ crc_table[i];
+  }
+  return crc_accum;
+}
+
+/******************************************************************************
+ *
+ * Name: init_crc8
+ *
+ * Description:
+ *   This function init crc.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+void init_crc8() {
+  int i, j;
+  unsigned char crc;
+
+  if (!made_table) {
+    for (i = 0; i < 256; i++) {
+      crc = i;
+      for (j = 0; j < 8; j++) crc = (crc << 1) ^ ((crc & 0x80) ? DI : 0);
+      crc8_table[i] = crc & 0xFF;
+      /* printf("table[%d] = %d (0x%X)\n", i, crc, crc); */
+    }
+    made_table = 1;
+  }
+}
+/******************************************************************************
+ *
+ * Name: crc8
+ *
+ * Description:
+ *   This function calculate crc.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   array: array to be calculated.
+ *   len :  len of array.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static unsigned char crc8(unsigned char *array, unsigned char len) {
+  unsigned char CRC = 0;
+  for (; len > 0; len--) {
+    CRC = crc8_table[CRC ^ *array];
+    array++;
+  }
+  return CRC;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitForHeaderSignature(uint32 uiMs)
+ *
+ * Description:
+ *   This function basically waits for reception
+ *   of character 0xa5 on UART Rx. If no 0xa5 is
+ *   received, it will kind of busy wait checking for
+ *   0xa5.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   uiMs:   the expired time.
+ *
+ * Return Value:
+ *   TRUE:   0xa5 or 0xab is received.
+ *   FALSE:  0xa5 or 0xab is not received.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static BOOLEAN
+fw_upload_WaitForHeaderSignature(uint32 uiMs)
+{
+  uint8 ucDone = 0;	// signature not Received Yet.
+  uint64 startTime = 0;
+  uint64 currTime = 0;
+  BOOLEAN bResult = TRUE;
+  startTime = fw_upload_GetTime();
+  while (!ucDone) {
+  ucRcvdHeader = fw_upload_ComReadChar(mchar_fd);
+  if ((ucRcvdHeader == V1_HEADER_DATA_REQ) ||(ucRcvdHeader == V1_START_INDICATION) ||
+      (ucRcvdHeader == V3_START_INDICATION) ||(ucRcvdHeader == V3_HEADER_DATA_REQ)) {
+    ucDone = 1;
+#ifdef DEBUG_PRINT
+    PRINT("\nReceived 0x%x ", ucRcvdHeader);
+#endif
+    if (!bVerChecked) {
+      if ((ucRcvdHeader == V1_HEADER_DATA_REQ) ||(ucRcvdHeader == V1_START_INDICATION)) {
+        uiProVer = Ver1;
+      } else {
+          uiProVer = Ver3;
+	}
+      bVerChecked = TRUE;
+    }
+  } else {
+      if (uiMs) {
+        currTime = fw_upload_GetTime();
+        if (currTime - startTime > uiMs) {
+#ifdef DEBUG_PRINT
+	  PRINT("WaitForHeaderSignature time out");
+#endif
+          bResult = FALSE;
+	  break;
+	}
+      }
+    fw_upload_DelayInMs(1);
+    }
+  }
+  return bResult;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitFor_Len
+ *
+ * Description:
+ *   This function waits to receive the 4 Byte length.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pFile: The handler of file
+ *
+ * Return Value:
+ *   2 Byte Length to send back to the Helper.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static uint16 fw_upload_WaitFor_Len(FILE *pFile) {
+  // Length Variables
+  uint16 uiLen;
+  uint16 uiLenComp;
+  // uiLen and uiLenComp are 1's complement of each other.
+  // In such cases, the XOR of uiLen and uiLenComp will be all 1's
+  // i.e 0xffff.
+  uint16 uiXorOfLen = 0xFFFF;
+
+  // Read the Lengths.
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiLen, 2);
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiLenComp, 2);
+
+  // Check if the length is valid.
+  if ((uiLen ^ uiLenComp) == uiXorOfLen)  // All 1's
+  {
+#ifdef DEBUG_PRINT
+    printf("\n       bootloader asks for %d bytes \n ", uiLen);
+#endif
+    // Successful. Send back the ack.
+    if ((ucRcvdHeader == V1_HEADER_DATA_REQ) || (ucRcvdHeader == V1_START_INDICATION)) {
+      fw_upload_ComWriteChar(mchar_fd, V1_REQUEST_ACK);
+      if (ucRcvdHeader == V1_START_INDICATION) {
+        longjmp(resync, 1);
+      }
+    }
+  } else {
+#ifdef DEBUG_PRINT
+    printf("\n    NAK case: bootloader LEN = %x bytes \n ", uiLen);
+    printf("\n    NAK case: bootloader LENComp = %x bytes \n ", uiLenComp);
+#endif
+    // Failure due to mismatch.
+    fw_upload_ComWriteChar(mchar_fd, (int8)0xbf);
+    // Start all over again.
+    if (pFile != NULL) {
+      longjmp(resync, 1);
+    } else {
+      uiLen = 0;
+    }
+  }
+  return uiLen;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_StoreBytes
+ *
+ * Description:
+ *   This function stores mul-bytes variable to array.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   ulVal: variable to be stored.
+ *   uiSize: size of bytes of this variable.
+ *   uiStored: array to store variable.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static void fw_upload_StoreBytes(uint32 ulVal, uint8 uiSize, uint8 *uiStored) {
+  uint8 i;
+  for (i = 0; i < uiSize; i++) {
+    uiStored[i] = (uint8)(ulVal >> (i * 8)) & 0xFF;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_Send_Ack
+ *
+ * Description:
+ *   This function sends ack to per req.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   uiAck: the ack type.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static void fw_upload_Send_Ack(uint8 uiAck) {
+  uint8 uiAckCrc = 0;
+  if ((uiAck == V3_REQUEST_ACK) || (uiAck == V3_CRC_ERROR)) {
+    fw_upload_ComWriteChar(mchar_fd, uiAck);
+
+    // prepare crc for 0x7A or 0x7C
+    ucCalCrc[0] = uiAck;
+    uiAckCrc = crc8(ucCalCrc, 1);
+    fw_upload_ComWriteChar(mchar_fd, uiAckCrc);
+  } else if (uiAck == V3_TIMEOUT_ACK) {
+    fw_upload_ComWriteChar(mchar_fd, uiAck);
+
+    // prepare crc for 0x7B
+    ucCalCrc[0] = uiAck;
+    fw_upload_StoreBytes(ulNewOffset, sizeof(ulNewOffset), &ucCalCrc[1]);
+    fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ulNewOffset, 4);
+    uiAckCrc = crc8(ucCalCrc, 5);
+    fw_upload_ComWriteChar(mchar_fd, uiAckCrc);
+  }
+#ifdef DEBUG_PRINT
+  printf("\n ===> ACK = %x, CRC = %x \n", uiAck, uiAckCrc);
+#endif
+}
+/******************************************************************************
+ *
+ * Name: fw_upload_Check_ReqCrc
+ *
+ * Description:
+ *   This function check the request crc.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   uiStr: array to put req header + payload.
+ *   uiReq: the request type.
+ *
+ * Return Value:
+ *   result of crc check.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+BOOLEAN fw_upload_Check_ReqCrc(uint8 *uiStr, uint8 uiReq) {
+  uint8 uiCalCrc;
+
+  if (uiReq == V3_HEADER_DATA_REQ) {
+    uiCalCrc = crc8(uiStr, A6REQ_PAYLOAD_LEN + REQ_HEADER_LEN);
+    if (uiCalCrc != uiStr[A6REQ_PAYLOAD_LEN + REQ_HEADER_LEN]) {
+      return FALSE;
+    }
+
+  } else if (uiReq == V3_START_INDICATION) {
+    uiCalCrc = crc8(uiStr, AbREQ_PAYLOAD_LEN + REQ_HEADER_LEN);
+    if (uiCalCrc != uiStr[AbREQ_PAYLOAD_LEN + REQ_HEADER_LEN]) {
+      return FALSE;
+    }
+  }
+
+  return TRUE;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitFor_Req
+ *
+ * Description:
+ *   This function waits for req from bootcode or helper.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static void fw_upload_WaitFor_Req() {
+  uint16 uiChipId;
+  uint8 uiVersion, uiReqCrc, uiTmp[20];
+  BOOLEAN bCrcMatch = FALSE;
+
+  if (ucRcvdHeader == V3_HEADER_DATA_REQ) {
+    // 0xA7 <LEN><Offset><ERR><CRC8>
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiNewLen, 2);
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&ulNewOffset, 4);
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiNewError, 2);
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiNewCrc, 1);
+#ifdef DEBUG_PRINT
+    printf("\n <=== REQ = 0xA6, Len = %x,Off = %x,Err = %x,CRC = %x\n ", uiNewLen, ulNewOffset,
+           uiNewError, uiNewCrc);
+#endif
+    // check crc
+    uiTmp[0] = V3_HEADER_DATA_REQ;
+    fw_upload_StoreBytes((uint32)uiNewLen, sizeof(uiNewLen), &uiTmp[1]);
+    fw_upload_StoreBytes(ulNewOffset, sizeof(ulNewOffset), &uiTmp[3]);
+    fw_upload_StoreBytes(uiNewError, sizeof(uiNewError), &uiTmp[7]);
+    uiTmp[9] = uiNewCrc;
+    bCrcMatch = fw_upload_Check_ReqCrc(uiTmp, V3_HEADER_DATA_REQ);
+
+    if (!bCrcMatch) {
+#ifdef DEBUG_PRINT
+      printf("\n === REQ = 0xA7, CRC Mismatched === ");
+#endif
+      fw_upload_Send_Ack(V3_CRC_ERROR);
+    }
+  } else if (ucRcvdHeader == V3_START_INDICATION) {
+    // 0xAB <CHIP ID> <SW loader REV 1 byte> <CRC8>
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiChipId, 2);
+    uiVersion = fw_upload_ComReadChar(mchar_fd);
+    uiReqCrc = fw_upload_ComReadChar(mchar_fd);
+    PRINT_INFO("\nChipID is : %x, Version is : %x\n", uiChipId, uiVersion);
+
+    // check crc
+    uiTmp[0] = V3_START_INDICATION;
+    fw_upload_StoreBytes((uint32)uiChipId, sizeof(uiChipId), &uiTmp[1]);
+    uiTmp[3] = uiVersion;
+    uiTmp[4] = uiReqCrc;
+    bCrcMatch = fw_upload_Check_ReqCrc(uiTmp, V3_START_INDICATION);
+
+    if (bCrcMatch) {
+#ifdef DEBUG_PRINT
+      printf("\n === REQ = 0xAB, CRC Matched === ");
+#endif
+      fw_upload_Send_Ack(V3_REQUEST_ACK);
+      longjmp(resync, 1);
+    } else {
+#ifdef DEBUG_PRINT
+      printf("\n === REQ = 0xAB, CRC Mismatched === ");
+#endif
+      fw_upload_Send_Ack(V3_CRC_ERROR);
+      longjmp(resync, 1);
+    }
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_GetCmd
+ *
+ * Description:
+ *   This function gets CMD value in the header.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   *buf: buffer that stores header and following data.
+ *
+ * Return Value:
+ *   CMD value part in the buffer.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static uint32 fw_upload_GetCmd(uint8 *buf) {
+  return (buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24));
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_GetHeaderStartBytes
+ *
+ * Description:
+ *   This function gets 0xa5 and it's following 4 bytes length.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+
+*****************************************************************************/
+static void fw_upload_GetHeaderStartBytes(uint8 *ucStr) {
+  BOOLEAN ucDone = FALSE, ucStringCnt = 0, i;
+  while (!ucDone) {
+    ucRcvdHeader = fw_upload_ComReadChar(mchar_fd);
+
+    if (ucRcvdHeader == V1_HEADER_DATA_REQ) {
+      ucStr[ucStringCnt++] = ucRcvdHeader;
+      ucDone = TRUE;
+#ifdef DEBUG_PRINT
+      printf("\nReceived 0x%x\n ", ucRcvdHeader);
+#endif
+    } else {
+      fw_upload_DelayInMs(1);
+    }
+  }
+  while (!fw_upload_GetBufferSize(mchar_fd))
+    ;
+  for (i = 0; i < 4; i++) {
+    ucRcvdHeader = fw_upload_ComReadChar(mchar_fd);
+    ucStr[ucStringCnt++] = ucRcvdHeader;
+  }
+}
+/******************************************************************************
+ *
+ * Name: fw_upload_GetLast5Bytes
+ *
+ * Description:
+ *   This function gets last valid request.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   *buf: buffer that stores header and following data.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+
+*****************************************************************************/
+static void fw_upload_GetLast5Bytes(uint8 *buf) {
+  uint8 a5cnt, i;
+  uint8 ucTemp[STRING_SIZE];
+  uint16 uiTempLen = 0;
+  int32 fifosize;
+  BOOLEAN alla5times = FALSE;
+
+  // initialise
+  memset(ucString, 0x00, STRING_SIZE);
+
+  fifosize = fw_upload_GetBufferSize(mchar_fd);
+
+  fw_upload_GetHeaderStartBytes(ucString);
+  fw_upload_lenValid(&uiTempLen, ucString);
+
+  if ((fifosize < 6) && ((uiTempLen == HDR_LEN) || (uiTempLen == fw_upload_GetDataLen(buf)))) {
+#ifdef DEBUG_PRINT
+    printf("=========>success case\n");
+#endif
+    uiErrCase = FALSE;
+  } else  // start to get last valid 5 bytes
+  {
+#ifdef DEBUG_PRINT
+    printf("=========>fail case\n");
+#endif
+    while (fw_upload_lenValid(&uiTempLen, ucString) == FALSE) {
+      fw_upload_GetHeaderStartBytes(ucString);
+      fifosize -= 5;
+    }
+#ifdef DEBUG_PRINT
+    printf("Error cases 1, 2, 3, 4, 5...\n");
+#endif
+    if (fifosize > 5) {
+      fifosize -= 5;
+      do {
+        do {
+          a5cnt = 0;
+          do {
+            fw_upload_GetHeaderStartBytes(ucTemp);
+            fifosize -= 5;
+          } while ((fw_upload_lenValid(&uiTempLen, ucTemp) == TRUE) && (!alla5times) && (fifosize > 5));
+          // if 5bytes are all 0xa5, continue to clear 0xa5
+          for (i = 0; i < 5; i++) {
+            if (ucTemp[i] == V1_HEADER_DATA_REQ) {
+              a5cnt++;
+            }
+          }
+          alla5times = TRUE;
+        } while (a5cnt == 5);
+#ifdef DEBUG_PRINT
+        printf("a5 count in last 5 bytes: %d\n", a5cnt);
+#endif
+        if (fw_upload_lenValid(&uiTempLen, ucTemp) == FALSE) {
+          for (i = 0; i < (5 - a5cnt); i++) {
+            ucTemp[i + a5cnt] = fw_upload_ComReadChar(mchar_fd);
+          }
+          memcpy(ucString, &ucTemp[a5cnt - 1], 5);
+        } else {
+          memcpy(ucString, ucTemp, 5);
+        }
+      } while (fw_upload_lenValid(&uiTempLen, ucTemp) == FALSE);
+    }
+    uiErrCase = TRUE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_SendBuffer
+ *
+ * Description:
+ *   This function sends buffer with header and following data.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *      uiLenToSend: len of header request.
+ *            ucBuf: the buf to be sent.
+ *   uiHighBaudrate: send the buffer for high baud rate change.
+ * Return Value:
+ *   Returns the len of next header request.
+ *
+ * Notes:
+ *   None.
+ *
+
+*****************************************************************************/
+static uint16 fw_upload_SendBuffer(uint16 uiLenToSend, uint8 *ucBuf, BOOLEAN uiHighBaudrate) {
+  uint16 uiBytesToSend = HDR_LEN, uiFirstChunkSent = 0;
+  uint16 uiDataLen = 0;
+  uint8 ucSentDone = 0;
+  BOOLEAN uiValidLen = FALSE;
+  // Get data len
+  uiDataLen = fw_upload_GetDataLen(ucBuf);
+  // Send buffer
+  while (!ucSentDone) {
+    if (uiBytesToSend == uiLenToSend) {
+      // All good
+      if ((uiBytesToSend == HDR_LEN) && (!b16BytesData)) {
+        if ((uiFirstChunkSent == 0) || ((uiFirstChunkSent == 1) && (uiErrCase == TRUE))) {
+// Write first 16 bytes of buffer
+#ifdef DEBUG_PRINT
+          printf("\n====>  Sending first chunk...\n");
+          printf("\n====>  Sending %d bytes...\n", uiBytesToSend);
+#endif
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucBuf, uiBytesToSend);
+          if (cmd7_Req == TRUE || EntryPoint_Req == TRUE) {
+            uiBytesToSend = HDR_LEN;
+            uiFirstChunkSent = 1;
+          } else {
+            uiBytesToSend = uiDataLen;
+            uiFirstChunkSent = 0;
+            if (uiBytesToSend == HDR_LEN) {
+              b16BytesData = TRUE;
+            }
+          }
+        } else {
+          // Done with buffer
+#ifdef DEBUG_PRINT
+          printf("\nDone with this buffer\n");
+#endif
+          ucSentDone = 1;
+          break;
+        }
+      } else {
+// Write remaining bytes
+#ifdef DEBUG_PRINT
+        printf("\n====>  Sending %d bytes...\n", uiBytesToSend);
+#endif
+        if (uiBytesToSend != 0) {
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ucBuf[HDR_LEN], uiBytesToSend);
+          uiFirstChunkSent = 1;
+          // We should expect 16, then next block will start
+          uiBytesToSend = HDR_LEN;
+		  b16BytesData = FALSE;
+          if (uiHighBaudrate) {
+            return 0;
+          }
+        } else  // end of bin download
+        {
+#ifdef DEBUG_PRINT
+          printf("\n ========== Download Complete =========\n\n");
+#endif
+          return 0;
+        }
+      }
+    } else {
+      // Something not good
+      if ((uiLenToSend & 0x01) == 0x01) {
+        // some kind of error
+        if (uiLenToSend == (HDR_LEN + 1)) {
+// Send first chunk again
+#ifdef DEBUG_PRINT
+          printf("\n1. Resending first chunk...\n");
+#endif
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucBuf, (uiLenToSend - 1));
+          uiBytesToSend = uiDataLen;
+          uiFirstChunkSent = 0;
+        } else if (uiLenToSend == (uiDataLen + 1)) {
+// Send second chunk again
+#ifdef DEBUG_PRINT
+          printf("\n2. Resending second chunk...\n");
+#endif
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ucBuf[HDR_LEN], (uiLenToSend - 1));
+          uiBytesToSend = HDR_LEN;
+          uiFirstChunkSent = 1;
+        }
+      } else if (uiLenToSend == HDR_LEN) {
+// Out of sync. Restart sending buffer
+#ifdef DEBUG_PRINT
+        printf("\n3.  Restart sending the buffer...\n");
+#endif
+        fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucBuf, uiLenToSend);
+        uiBytesToSend = uiDataLen;
+        uiFirstChunkSent = 0;
+      }
+    }
+    // Get last 5 bytes now
+    fw_upload_GetLast5Bytes(ucBuf);
+    // Get next length
+    uiValidLen = FALSE;
+    do {
+      if (fw_upload_lenValid(&uiLenToSend, ucString) == TRUE) {
+        // Valid length received
+        uiValidLen = TRUE;
+#ifdef DEBUG_PRINT
+        printf("\n Valid length = %d \n", uiLenToSend);
+#endif
+        // ACK the bootloader
+        fw_upload_ComWriteChar(mchar_fd, V1_REQUEST_ACK);
+#ifdef DEBUG_PRINT
+        printf("\n  BOOT_HEADER_ACK 0x5a sent \n");
+#endif
+      }
+    } while (!uiValidLen);
+  }
+#ifdef DEBUG_PRINT
+  printf("\n ========== Buffer is successfully sent =========\n\n");
+#endif
+  return uiLenToSend;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_V1SendLenBytes
+ *
+ * Description:
+ *   This function sends Len bytes(header+data) to the boot code.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pFile: bin file being sent.
+ *   uiLenTosend: the length will be sent.
+ *
+ * Return Value:
+ *   the 'len' of next header request.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static uint16 fw_upload_V1SendLenBytes(uint8 * pFileBuffer, uint16 uiLenToSend) {
+  uint16 ucDataLen, uiLen;
+  uint32 ulCmd;
+
+  memset(ucByteBuffer, 0, sizeof(ucByteBuffer));
+
+  cmd7_Req = FALSE;
+  EntryPoint_Req = FALSE;
+  memcpy(ucByteBuffer, pFileBuffer + ulCurrFileSize, uiLenToSend);
+  ulCurrFileSize += uiLenToSend;
+  ulCmd = fw_upload_GetCmd(ucByteBuffer);
+  if (ulCmd == CMD7) {
+    cmd7_Req = TRUE;
+    ucDataLen = 0;
+  } else {
+    ucDataLen = fw_upload_GetDataLen(ucByteBuffer);
+    memcpy(&ucByteBuffer[uiLenToSend], pFileBuffer + ulCurrFileSize,ucDataLen);
+    ulCurrFileSize += ucDataLen;
+    if ((ulCurrFileSize < ulTotalFileSize) && (ulCmd == CMD6 || ulCmd == CMD4)) {
+      EntryPoint_Req = TRUE;
+    }
+  }
+
+#ifdef DEBUG_PRINT
+  printf("The buffer is to be sent: %d", uiLenToSend + ucDataLen);
+#endif
+  // start to send Temp buffer
+  uiLen = fw_upload_SendBuffer(uiLenToSend, ucByteBuffer, FALSE);
+  PRINT_INFO("File downloaded: %8d:%8d\r", ulCurrFileSize, ulTotalFileSize);
+
+  return uiLen;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_V3SendLenBytes
+ *
+ * Description:
+ *   This function sends Len bytes to the Helper.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pFile: bin file being sent.
+ *   uiLenTosend: the length will be sent.
+ *   ulOffset: the offset of current sending.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static void fw_upload_V3SendLenBytes(uint8 * pFileBuffer, uint16 uiLenToSend, uint32 ulOffset) {
+  // Retransmittion of previous block
+  if (ulOffset == ulLastOffsetToSend) {
+#ifdef DEBUG_PRINT
+    printf("\nResend offset %d...\n", ulOffset);
+#endif
+    fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ucByteBuffer, uiLenToSend);
+  } else {
+    // The length requested by the Helper is equal to the Block
+    // sizes used while creating the FW.bin. The usual
+    // block sizes are 128, 256, 512.
+    // uiLenToSend % 16 == 0. This means the previous packet
+    // was error free (CRC ok) or this is the first packet received.
+    //  We can clear the ucByteBuffer and populate fresh data.
+    memset(ucByteBuffer, 0, sizeof(ucByteBuffer));
+    memcpy(ucByteBuffer,pFileBuffer + ulOffset - change_baudrata_buffer_len,uiLenToSend);
+    ulCurrFileSize =ulOffset - change_baudrata_buffer_len + uiLenToSend;
+    fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ucByteBuffer, uiLenToSend);
+    ulLastOffsetToSend = ulOffset;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_Change_Baudrate
+ *
+ * Description:
+ *   This function changes the baud rate of bootrom.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pPortName:        Serial port value.
+ *   iFirstBaudRate:   The default baud rate of boot rom.
+ *   iSecondBaudRate:  The chaned baud rate.
+ *
+ * Return Value:
+ *   TRUE:            Change baud rate successfully
+ *   FALSE:           Change baud rate unsuccessfully
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static int32 fw_Change_Baudrate(int8 *pPortName, int32 iFirstBaudRate, int32 iSecondBaudRate) {
+  uint8 uartConfig[60];
+  uint8 ucBuffer[80];
+  uint32 j;
+  uint32 uartClk = 0x00C00000;
+  uint32 uartDiv = 0x1;
+  uint16 uiLenToSend = 0;
+  uint32 uiCrc = 0;
+  uint32 uiLen = 0;
+  BOOLEAN bRetVal = FALSE;
+  int32 ucResult = -1;
+  uint8 ucLoadPayload = 0;
+  uint32 waitHeaderSigTime = 0;
+  BOOLEAN uiReUsedInitBaudrate = FALSE;
+
+  uint32 mcr = MCR;
+  uint32 init = INIT;
+  uint32 icr = ICR;
+  uint32 brAddr = CLKDIVAddr;
+  uint32 divAddr = UARTDIVAddr;
+  uint32 mcrAddr = UARTMCRAddr;
+  uint32 reInitAddr = UARTREINITAddr;
+  uint32 icrAddr = UARTICRAddr;
+
+  for (j = 0; j < sizeof(UartCfgTbl) / sizeof(UART_BAUDRATE); j++) {
+    if (iSecondBaudRate == (int32)UartCfgTbl[j].iBaudRate) {
+      uartDiv = UartCfgTbl[j].iUartDivisor;
+      uartClk = UartCfgTbl[j].iClkDivisor;
+      ucResult = 0;
+      break;
+    }
+  }
+
+  if (ucResult != 0) {
+    return ucResult;
+  }
+
+  // Generate CRC value for CMD5 payload
+  memcpy(uartConfig + uiLen, &brAddr, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &uartClk, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &divAddr, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &uartDiv, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &mcrAddr, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &mcr, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &reInitAddr, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &init, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &icrAddr, 4);
+  uiLen += 4;
+  memcpy(uartConfig + uiLen, &icr, 4);
+  uiLen += 4;
+
+  fw_upload_gen_crc_table();
+
+  uiCrc = fw_upload_update_crc(0, (char *)&uartConfig, uiLen);
+  uiCrc = SWAPL(uiCrc);
+  memcpy(uartConfig + uiLen, &uiCrc, 4);
+  uiLen += 4;
+
+  while (!bRetVal) {
+    if (ucLoadPayload != 0 || uiReUsedInitBaudrate) {
+      waitHeaderSigTime = TIMEOUT_VAL_MILLISEC;
+    } else {
+      waitHeaderSigTime = 0;
+    }
+    // Wait to Receive 0xa5, 0xaa, 0xab, 0xa7
+    // If the second baudrate is used, wait for 2s to check 0xa5
+    if (fw_upload_WaitForHeaderSignature(waitHeaderSigTime)) {
+      if (ucLoadPayload) {
+	  	if (uiProVer == Ver3) {
+					change_baudrata_buffer_len =
+						HDR_LEN + uiNewLen;
+				}
+        break;
+      }
+    } else {
+      if (uiReUsedInitBaudrate) {
+        ucResult = -2;
+        return ucResult;
+      }
+      if (ucLoadPayload) {
+        // If 0xa5 or 0xa7 is not received by using the second baudrate, change baud rate to the first
+        // baudrate.
+        close(mchar_fd);
+        mchar_fd = init_uart(pPortName, iFirstBaudRate, 0);
+        ucLoadPayload = 0;
+        uiReUsedInitBaudrate = TRUE;
+        continue;
+      }
+    }
+    if (uiProVer == Ver1) {
+      uiLenToSend = fw_upload_WaitFor_Len(NULL);
+      if (uiLenToSend == 0) {
+        continue;
+      } else if (uiLenToSend == HDR_LEN) {
+        // Download CMD5 header and Payload packet.
+        memcpy(ucBuffer, m_Buffer_CMD5_Header, HDR_LEN);
+        memcpy(ucBuffer + HDR_LEN, uartConfig, uiLen);
+        fw_upload_SendBuffer(uiLenToSend, ucBuffer, TRUE);
+        close(mchar_fd);
+        mchar_fd = init_uart(pPortName, iSecondBaudRate, 1);
+        ucLoadPayload = 1;
+      } else {
+        // Download CMD5 header and Payload packet
+        fw_upload_ComWriteChars(mchar_fd, (uint8 *)&uartConfig, uiLen);
+        close(mchar_fd);
+        mchar_fd = init_uart(pPortName, iSecondBaudRate, 1);
+        ucLoadPayload = 1;
+      }
+    } else if (uiProVer == Ver3) {
+      fw_upload_WaitFor_Req();
+      if (uiNewLen != 0) {
+        if (uiNewError == 0) {
+          fw_upload_Send_Ack(V3_REQUEST_ACK);
+          if (ulNewOffset == ulLastOffsetToSend) {
+            if (uiLenToSend == 16) {
+              fw_upload_ComWriteChars(mchar_fd, (uint8 *)m_Buffer_CMD5_Header, uiLenToSend);
+              ulLastOffsetToSend = ulNewOffset;
+            } else {
+              fw_upload_ComWriteChars(mchar_fd, (uint8 *)&uartConfig, uiLenToSend);
+              // Reopen Uart by using the second baudrate after downloading the payload.
+              close(mchar_fd);
+              mchar_fd = init_uart(pPortName, iSecondBaudRate, 1);
+              ucLoadPayload = 1;
+            }
+          }
+        } else  // NAK,TIMEOUT,INVALID COMMAND...
+        {
+          tcflush(mchar_fd, TCIFLUSH);
+          fw_upload_Send_Ack(V3_TIMEOUT_ACK);
+        }
+      }
+    }
+  }
+  return ucResult;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_FW
+ *
+ * Description:
+ *   This function performs the task of FW load over UART.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pPortName:       Com port number.
+ *   iBaudRate:       the initial baud rate.
+ *   ucFlowCtrl:      the flow ctrl of uart.
+ *   pFileName:       the file name for downloading.
+ *   iSecondBaudRate: the second baud rate.
+ *
+ * Return Value:
+ *   TRUE:            Download successfully
+ *   FALSE:           Download unsuccessfully
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static BOOLEAN fw_upload_FW(int8 *pPortName, int32 iBaudRate, int8 *pFileName, int32 iSecondBaudRate) {
+  uint8 *pFileBuffer = NULL;
+  uint32 ulReadLen = 0;
+  FILE *pFile = NULL;
+  BOOLEAN bRetVal = FALSE;
+  int32 result = 0;
+  uint16 uiLenToSend = 0;
+
+  // Open File for reading.
+  pFile = fopen(pFileName, "rb");
+
+  if ((mchar_fd < 0) || (pFile == NULL)) {
+    PRINT_INFO("\nPort is not open or file not found\n");
+    return bRetVal;
+  }
+
+  if (iSecondBaudRate != 0) {
+    uint32 j = 0;
+    result = fw_Change_Baudrate(pPortName, iBaudRate, iSecondBaudRate);
+    switch (result) {
+      case -1:
+        PRINT_INFO("\nSecond baud rate %d is not support\n", iSecondBaudRate);
+        PRINT_INFO("\nFw loader only supports the baud rate as");
+        for (j = 0; j < sizeof(UartCfgTbl) / sizeof(UART_BAUDRATE); j++) {
+          PRINT_INFO(" %d ", UartCfgTbl[j].iBaudRate);
+        }
+        PRINT_INFO("\n");
+        break;
+      case -2:
+        PRINT_INFO("\n0xa5 or 0xaa is not received after changing baud rate in 2s.\n");
+        break;
+      default:
+        break;
+    }
+    if (result != 0) {
+      return bRetVal;
+    }
+  }
+
+  // Calculate the size of the file to be downloaded.
+  result = fseek(pFile, 0, SEEK_END);
+  if (result) {
+    PRINT_INFO("\nfseek failed\n");
+    return bRetVal;
+  }
+
+  ulTotalFileSize = (uint32)ftell(pFile);
+  if (!ulTotalFileSize) {
+    PRINT_INFO("\nError:Download Size is 0\n");
+    return bRetVal;
+  }
+
+  pFileBuffer = (uint8 *) malloc(ulTotalFileSize);
+
+  fseek(pFile, 0, SEEK_SET);
+  if (pFileBuffer) {
+    ulReadLen = fread(pFileBuffer, 1, ulTotalFileSize, pFile);
+    if (ulReadLen != ulTotalFileSize) {
+      PRINT("\nError:Read File Fail\n");
+      return bRetVal;
+    }
+
+  }
+   ulCurrFileSize = 0;
+
+  // Jump to here in case of protocol resync.
+  setjmp(resync);
+
+  while (!bRetVal) {
+    // Wait to Receive 0xa5, 0xaa, 0xab, 0xa7
+    if (!fw_upload_WaitForHeaderSignature(TIMEOUT_VAL_MILLISEC)) {
+      PRINT("\n0xa5,0xaa,0xab or 0xa7 is not received in 4s.\n");
+      return bRetVal;
+    }
+
+    if (uiProVer == Ver1) {
+      // Read the 'Length' bytes requested by Helper
+      uiLenToSend = fw_upload_WaitFor_Len(pFile);
+      do {
+        uiLenToSend = fw_upload_V1SendLenBytes(pFileBuffer, uiLenToSend);
+      } while (uiLenToSend != 0);
+      // If the Length requested is 0, download is complete.
+      if (uiLenToSend == 0) {
+        bRetVal = TRUE;
+        break;
+      }
+    } else if (uiProVer == Ver3) {
+      fw_upload_WaitFor_Req();
+      if (uiNewLen != 0) {
+        if (uiNewError == 0) {
+#ifdef DEBUG_PRINT
+          printf("\n === Succ: REQ = 0xA7, Errcode = 0 ");
+#endif
+          fw_upload_Send_Ack(V3_REQUEST_ACK);
+          fw_upload_V3SendLenBytes(pFileBuffer, uiNewLen, ulNewOffset);
+
+#ifdef DEBUG_PRINT
+          printf("\n sent %d bytes..\n", uiNewLen);
+#endif
+        } else  // NAK,TIMEOUT,INVALID COMMAND...
+        {
+#ifdef DEBUG_PRINT
+          uint8 i;
+          printf("\n === Fail: REQ = 0xA7, Errcode != 0 ");
+          for (i = 0; i < 7; i++) {
+            uiErrCnt[i] += (uiNewError >> i) & 0x1;
+          }
+#endif
+          tcflush(mchar_fd, TCIFLUSH);
+          fw_upload_Send_Ack(V3_TIMEOUT_ACK);
+        }
+      } else {
+        /* check if download complete */
+        if (uiNewError == 0) {
+          fw_upload_Send_Ack(V3_REQUEST_ACK);
+          bRetVal = TRUE;
+          break;
+        } else if (uiNewError & BT_MIC_FAIL_BIT) {
+#ifdef DEBUG_PRINT
+          uiErrCnt[7] += 1;
+#endif
+          fw_upload_Send_Ack(V3_REQUEST_ACK);
+          fseek(pFile, 0, SEEK_SET);
+		  change_baudrata_buffer_len = 0;
+          ulCurrFileSize = 0;
+          ulLastOffsetToSend = 0xFFFF;
+        }
+      }
+      PRINT_INFO("File downloaded: %8d:%8d\r", ulCurrFileSize, ulTotalFileSize);
+    }
+  }
+  return bRetVal;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_check_FW
+ *
+ * Description:
+ *   This function performs the task of FW load over UART.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pPortName:       Com port number.
+ *   iBaudRate:       the initial baud rate.
+ *   ucFlowCtrl:      the flow ctrl of uart.
+ *
+ * Return Value:
+ *   TRUE:            Need Download FW
+ *   FALSE:           No need Download FW
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+BOOLEAN bt_vnd_mrvl_check_fw_status() {
+  BOOLEAN bRetVal = FALSE;
+
+  if (mchar_fd < 0) {
+    PRINT_INFO("\nPort is not open or file not found\n");
+    return bRetVal;
+  }
+
+  // Wait to Receive 0xa5, 0xaa, 0xab, 0xa7
+  bRetVal = fw_upload_WaitForHeaderSignature(1000);
+
+  PRINT_INFO("fw_upload_WaitForHeaderSignature return %d", bRetVal);
+
+  return bRetVal;
+}
+
+/******************************************************************************
+*
+* Name: bt_vnd_mrvl_download_fw
+*
+* Description:
+*   Wrapper of fw_upload_FW.
+*
+* Conditions For Use:
+*   None.
+*
+* Arguments:
+*   pPortName:       Com port number.
+*   iBaudRate:       the initial baud rate.
+*   ucFlowCtrl:      the flow ctrl of uart.
+*   pFileName:       the file name for downloading.
+*   iSecondBaudRate: the second baud rate.
+*
+* Return Value:
+*   0:            Download successfully
+*   1:           Download unsuccessfully
+*
+* Notes:
+*   None.
+*
+*****************************************************************************/
+int bt_vnd_mrvl_download_fw(int8 *pPortName, int32 iBaudrate, int8 *pFileName, int32 iSecondBaudrate) {
+  double endTime;
+  double endTime1;
+  double start;
+  double cost;
+  uint32 end_sig;
+
+  start = fw_upload_GetTime();
+
+  PRINT_INFO("Protocol: NXP Proprietary\n");
+  PRINT_INFO("FW Loader Version: %s\n", VERSION);
+  PRINT_INFO("ComPort : %s\n", pPortName);
+  PRINT_INFO("BaudRate: %d\n", iBaudrate);
+  PRINT_INFO("Filename: %s\n", pFileName);
+  PRINT_INFO("iSecondBaudrate: %d\n", iSecondBaudrate);
+
+  if (fw_upload_FW(pPortName, iBaudrate, pFileName, iSecondBaudrate)) {
+    PRINT_INFO("\nDownload Complete\n");
+    cost = fw_upload_GetTime() - start;
+    PRINT_INFO("time:%f\n", cost);
+    if (uiProVer == Ver1) {
+      fw_upload_DelayInMs(MAX_CTS_TIMEOUT);
+      endTime = fw_upload_GetTime() + MAX_CTS_TIMEOUT;
+      do {
+        if (!fw_upload_ComGetCTS(mchar_fd)) {
+          PRINT_INFO("CTS is low\n");
+          goto done;
+        }
+      } while (endTime > fw_upload_GetTime());
+      PRINT_INFO("wait CTS low timeout \n");
+      goto done;
+    } else if (uiProVer == Ver3) {
+      endTime = fw_upload_GetTime() + END_SIG_TIMEOUT;
+      do {
+        fw_upload_ComReadChars(mchar_fd, (uint8 *)&end_sig, 3);
+        if (end_sig == END_SIG) {
+          endTime1 = fw_upload_GetTime() + MAX_CTS_TIMEOUT;
+          do {
+            if (!fw_upload_ComGetCTS(mchar_fd)) {
+              PRINT_INFO("CTS is low\n");
+              goto done;
+            }
+          } while (endTime > fw_upload_GetTime());
+          goto done;
+        }
+      } while (endTime > fw_upload_GetTime());
+      goto done;
+    }
+  } else {
+    PRINT_INFO("\nDownload Error\n");
+    return 1;
+  }
+
+done:
+  bVerChecked = FALSE;
+  return 0;
+}
diff --git a/88x9098/bt/libbt/fw_loader_uart.h b/88x9098/bt/libbt/fw_loader_uart.h
new file mode 100755
index 0000000..d4729ae
--- /dev/null
+++ b/88x9098/bt/libbt/fw_loader_uart.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _FW_LOADER_H
+#define _FW_LOADER_H
+/*===================== Include Files ============================================*/
+#include "bt_vendor_nxp.h"
+
+/*==================== Typedefs =================================================*/
+
+
+/*===================== Macros ===================================================*/
+
+typedef struct {
+  uint32 iBaudRate;
+  uint32 iUartDivisor;
+  uint32 iClkDivisor;
+} UART_BAUDRATE;
+
+extern int mchar_fd;
+extern int uart_break_before_change_baudrate;
+
+
+/*===================== Global Vars ==============================================*/
+
+/*==================== Function Prototypes ======================================*/
+
+void init_crc8();
+BOOLEAN bt_vnd_mrvl_check_fw_status();
+int bt_vnd_mrvl_download_fw(int8 *pPortName, int32 iBaudRate, int8 *pFileName, int32 iSecondBaudRate);
+#endif  // _FW_LOADER_H
diff --git a/88x9098/bt/libbt/fw_loader_uart_v2.c b/88x9098/bt/libbt/fw_loader_uart_v2.c
new file mode 100755
index 0000000..e297465
--- /dev/null
+++ b/88x9098/bt/libbt/fw_loader_uart_v2.c
@@ -0,0 +1,1144 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/*===================== Include Files ============================================*/
+#include "fw_loader_uart_v2.h"
+#include "fw_loader_io.h"
+#include <errno.h>
+#include <memory.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/select.h>
+#include <malloc.h>
+
+#define LOG_TAG "fw_loader"
+#include <log/log.h>
+#include <cutils/properties.h>
+#define printf(fmt, ...) ALOGE("ERROR : %s(L%d): " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
+
+/*--------------------------------fw_loader_io_linux.c-------------------------*/
+#define TIMEOUT_FOR_READ        4000
+
+
+/*===================== Macros ===================================================*/
+#define VERSION "M206"
+#define MAX_LENGTH 0xFFFF  // Maximum 2 byte value
+#define END_SIG_TIMEOUT 2500
+#define MAX_CTS_TIMEOUT    5000         //5s 
+#define STRING_SIZE 6
+#define HDR_LEN 16
+#define CMD4 0x4
+#define CMD6 0x6
+#define CMD7 0x7
+
+#define DELAY_CMD5_PATCH   250   //250ms
+#define POLL_AA_TIMEOUT    200
+#define TIMEOUT_VAL_MILLISEC  4000       // Timeout for getting 0xa5 or 0xaa or 0xa6, 2 times of helper timeout
+
+#define BOOT_HEADER        0xa5
+#define BOOT_HEADER_ACK    0x5a
+#define HELPER_HEADER      0xa6
+#define HELPER_HEADR_ACK   0x6a
+#define HELPER_TIMEOUT_ACK 0x6b
+#define VERSION_HEADER     0xaa
+
+#define PRINT(...)         printf(__VA_ARGS__)
+
+/*==================== Typedefs =================================================*/
+
+/*===================== Global Vars ==============================================*/
+// Maximum Length that could be asked by the Helper = 2 bytes
+static uint8 ucByteBuffer[MAX_LENGTH];
+
+// Size of the File to be downloaded
+static uint32 ulTotalFileSize = 0;
+
+// Current size of the Download
+static uint32 ulCurrFileSize = 0;
+static uint32 ulLastOffsetToSend = 0xFFFF;
+static BOOLEAN uiErrCase = FALSE;
+static BOOLEAN uiReDownload = FALSE;
+
+// Received Header
+static uint8   ucRcvdHeader = 0xFF;
+static BOOLEAN ucHelperOn = FALSE;
+static uint8   ucString[STRING_SIZE];
+static uint8   ucCmd5Sent = 0;
+static BOOLEAN b16BytesData = FALSE;
+
+//Handler of File
+static FILE* pFile = NULL;
+
+// CMD5 patch to change bootloader timeout to 2 seconds
+uint8 ucCmd5Patch[28] = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x9D, 0x32, 0xBB, 0x11,
+                         0x2C, 0x94, 0x00, 0xA8, 0xEC, 0x70, 0x02, 0x00, 0xB4, 0xD9, 0x9D, 0x26};
+
+jmp_buf resync;  // Protocol restart buffer used in timeout cases.
+/*==================== Function Prototypes ======================================*/
+
+/*==================== Coded Procedures =========================================*/
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitForHeaderSignature()
+ *
+ * Description:
+ *   This function basically waits for reception
+ *   of character 0xa5 on UART Rx. If no 0xa5 is 
+ *   received, it will kind of busy wait checking for
+ *   0xa5.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   uiMs:   the expired time.
+ *
+ * Return Value:
+ *   TRUE:   0xa5 or 0xaa or 0xa6 is received.
+ *   FALSE:  0xa5 or 0xaa or 0xa6 is not received.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static BOOLEAN fw_upload_WaitForHeaderSignature(uint32 uiMs)
+{
+  uint8 ucDone = 0; // signature not Received Yet.
+  uint64 startTime = 0;
+  uint64 currTime = 0;
+  BOOLEAN bResult = TRUE;
+  ucRcvdHeader = 0xFF;
+  startTime = fw_upload_GetTime();
+  while (!ucDone)
+  { 
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&ucRcvdHeader,1);
+    if ((ucRcvdHeader == BOOT_HEADER) || (ucRcvdHeader == VERSION_HEADER) || (ucRcvdHeader == HELPER_HEADER))
+    {
+      ucDone = 1;
+#ifdef DEBUG_PRINT
+      PRINT("\nReceived 0x%x ", ucRcvdHeader);
+#endif
+    }
+    else
+    {
+      if(uiMs)
+      {
+        currTime = fw_upload_GetTime();
+        if(currTime - startTime > uiMs)
+        {
+          bResult = FALSE;
+          break;
+        }
+      }
+      fw_upload_DelayInMs(1);
+    }
+  }
+  return bResult;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitFor_Len
+ *
+ * Description:
+ *   This function waits to receive the 4 Byte length.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   2 Byte Length to send back to the Helper.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static uint16 fw_upload_WaitFor_Len(FILE* pFile)
+{ 
+  uint8  uiVersion; 
+  // Length Variables
+  uint16 uiLen = 0x0;
+  uint16 uiLenComp = 0x0;
+  // uiLen and uiLenComp are 1's complement of each other. 
+  // In such cases, the XOR of uiLen and uiLenComp will be all 1's
+  // i.e 0xffff.
+  uint16 uiXorOfLen = 0xFFFF;
+
+  // Read the Lengths.
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiLen, 2);
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiLenComp, 2);
+
+  // Check if the length is valid.
+  if ((uiLen ^ uiLenComp) == uiXorOfLen) // All 1's
+  {
+#ifdef DEBUG_PRINT
+    PRINT("\n bootloader asks for %d bytes \n ", uiLen);
+#endif
+    // Successful. Send back the ack.
+    if ((ucRcvdHeader == BOOT_HEADER) || (ucRcvdHeader == VERSION_HEADER))
+    {
+      fw_upload_ComWriteChar(mchar_fd, (int8)BOOT_HEADER_ACK);
+	  if (ucRcvdHeader == VERSION_HEADER)
+      {
+        // We have received the Chip Id and Rev Num that the 
+        // helper intended to send. Ignore the received
+	// Chip Id, Rev Num and proceed to Download.
+	uiVersion = (uiLen >> 8) & 0xF0;
+	uiVersion = uiVersion >> 4;
+	PRINT("Helper Version is: %d\n ", uiVersion);
+	if(ucHelperOn == TRUE)
+	{
+	  fseek(pFile, 0, SEEK_SET);
+	  ulCurrFileSize = 0; 
+          ulLastOffsetToSend = 0xFFFF;
+	}
+        // Ensure any pending write data is completely written
+        if (0 == tcdrain(mchar_fd))
+        {
+#ifdef DEBUG_PRINT
+          PRINT("\n\t tcdrain succeeded\n");
+#endif
+        }
+        else
+        {
+#ifdef DEBUG_PRINT
+          PRINT("\n\t Version ACK, tcdrain failed with errno = %d\n", errno);
+#endif
+        }
+
+        longjmp(resync, 1);
+      }
+    }
+  }
+  else
+  {
+#ifdef DEBUG_PRINT
+    PRINT("\n    NAK case: bootloader LEN = %x bytes \n ", uiLen);
+    PRINT("\n    NAK case: bootloader LENComp = %x bytes \n ", uiLenComp);
+#endif
+    // Failure due to mismatch.	  
+    fw_upload_ComWriteChar(mchar_fd, (int8)0xbf);
+    // Start all over again.
+    longjmp(resync, 1);
+  }
+  return uiLen;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_GetHeaderStartBytes
+ *
+ * Description:
+ *   This function gets 0xa5 and it's following 4 bytes length.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static void fw_upload_GetHeaderStartBytes(uint8 *ucStr)
+{
+  BOOLEAN ucDone = FALSE, ucStringCnt = 0, i;
+  
+  while (!ucDone)
+  { 
+    ucRcvdHeader = 0xFF;
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&ucRcvdHeader,1);
+
+    if(ucRcvdHeader == BOOT_HEADER)
+    {
+      ucStr[ucStringCnt++] = ucRcvdHeader;
+      ucDone = TRUE;
+#ifdef DEBUG_PRINT
+      PRINT("\nReceived 0x%x\n ", ucRcvdHeader);
+#endif
+    }
+    else
+    {
+      fw_upload_DelayInMs(1);
+    }
+  }
+  while(!fw_upload_GetBufferSize(mchar_fd));
+  for(i = 0; i < 4; i ++)
+  {
+    ucRcvdHeader = 0xFF;
+    fw_upload_ComReadChars(mchar_fd, (uint8 *)&ucRcvdHeader,1);
+    ucStr[ucStringCnt++] = ucRcvdHeader;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_GetLast5Bytes
+ *
+ * Description:
+ *   This function gets last valid request.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   *buf: buffer that stores header and following data.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static void fw_upload_GetLast5Bytes(uint8 *buf)
+{
+  uint8  a5cnt, i;
+  uint8  ucTemp[STRING_SIZE];
+  uint16 uiTempLen = 0;
+  int32  fifosize;
+  BOOLEAN alla5times = FALSE;
+  
+  // initialise 
+  memset(ucString, 0x00, STRING_SIZE);
+
+  fifosize = fw_upload_GetBufferSize(mchar_fd);
+  
+  fw_upload_GetHeaderStartBytes(ucString);
+  fw_upload_lenValid(&uiTempLen, ucString);
+
+  if((fifosize < 6) && ((uiTempLen == HDR_LEN) || (uiTempLen == fw_upload_GetDataLen(buf))))
+  {
+#ifdef DEBUG_PRINT
+    PRINT("=========>success case\n");
+#endif
+    uiErrCase = FALSE;
+  }
+  else // start to get last valid 5 bytes
+  { 
+#ifdef DEBUG_PRINT
+    PRINT("=========>fail case\n");
+#endif
+    while (fw_upload_lenValid(&uiTempLen, ucString) == FALSE)
+    {
+      fw_upload_GetHeaderStartBytes(ucString);
+      fifosize -= 5;
+    }
+#ifdef DEBUG_PRINT
+      PRINT("Error cases 1, 2, 3, 4, 5...\n");
+#endif
+      if(fifosize > 5)
+      {
+        fifosize -= 5;
+        do
+        {
+          do
+          {
+            a5cnt = 0;
+            do
+            {
+              fw_upload_GetHeaderStartBytes(ucTemp);
+              fifosize -= 5;
+            } while ((fw_upload_lenValid(&uiTempLen, ucTemp) == TRUE) && (!alla5times) && (fifosize > 5));
+            //if 5bytes are all 0xa5, continue to clear 0xa5
+            for (i = 0; i < 5; i ++)
+            {
+              if (ucTemp[i] == BOOT_HEADER)
+              {
+                a5cnt ++; 
+              }
+            }
+            alla5times = TRUE;
+          } while (a5cnt == 5);
+#ifdef DEBUG_PRINT
+          PRINT("a5 count in last 5 bytes: %d\n", a5cnt);
+#endif
+          if (fw_upload_lenValid(&uiTempLen, ucTemp) == FALSE)
+          {
+            for (i = 0; i < (5 - a5cnt); i ++)
+            {
+              ucTemp[i + a5cnt] = fw_upload_ComReadChar(mchar_fd);
+            }
+            memcpy(ucString, &ucTemp[a5cnt-1], 5);
+          }
+          else
+          {
+            memcpy(ucString, ucTemp, 5);
+          }
+        } while (fw_upload_lenValid(&uiTempLen, ucTemp) == FALSE);
+      }
+      uiErrCase = TRUE;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_SendBuffer
+ *
+ * Description:
+ *   This function sends buffer with header and following data.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   uiLenToSend: len of header request.
+ *         ucBuf: the buf to be sent.
+ * Return Value:
+ *   Returns the len of next header request.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+
+uint16 fw_upload_SendBuffer(uint16 uiLenToSend, uint8 *ucBuf)
+{
+  uint16 uiBytesToSend = HDR_LEN, uiFirstChunkSent = 0;
+  uint16 uiDataLen = 0;
+  uint8 ucSentDone = 0;
+  BOOLEAN uiValidLen = FALSE;
+  // Get data len
+  uiDataLen = fw_upload_GetDataLen(ucBuf);
+  // Send buffer
+  while (!ucSentDone)
+  {
+    if (uiBytesToSend == uiLenToSend)
+    {
+      // All good
+      if ((uiBytesToSend == HDR_LEN) && (!b16BytesData))
+      {
+        if ((uiFirstChunkSent == 0) || ((uiFirstChunkSent == 1) && uiErrCase == TRUE))
+     	{
+     	  // Write first 16 bytes of buffer
+#ifdef DEBUG_PRINT
+     	  PRINT("\n====>  Sending first chunk...\n");
+     	  PRINT("\n====>  Sending %d bytes...\n", uiBytesToSend);
+#endif
+     	  fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucBuf, uiBytesToSend); 
+     	  uiBytesToSend = uiDataLen;
+     	  if(uiBytesToSend == HDR_LEN)
+     	  {
+            b16BytesData = TRUE;
+     	  }
+     	  uiFirstChunkSent = 0;
+	}
+     	else
+        {
+     	  // Done with buffer
+     	  ucSentDone = 1;
+     	  break;
+        }
+      }
+      else
+      {
+     	 // Write remaining bytes
+#ifdef DEBUG_PRINT
+     	PRINT("\n====>  Sending %d bytes...\n", uiBytesToSend);
+#endif
+        if(uiBytesToSend != 0)
+        {
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ucBuf[HDR_LEN], uiBytesToSend);
+     	  uiFirstChunkSent = 1;
+     	  // We should expect 16, then next block will start
+          uiBytesToSend = HDR_LEN;
+          b16BytesData = FALSE;
+        }
+        else  //end of bin download
+        {
+#ifdef DEBUG_PRINT
+          PRINT("\n ========== Download Complete =========\n\n");
+#endif
+     	  return 0;
+        }
+      }
+    }
+    else
+    {
+      // Something not good
+      if ((uiLenToSend & 0x01) == 0x01)
+      {
+        // some kind of error
+        if (uiLenToSend == (HDR_LEN + 1))
+        {
+          // Send first chunk again
+#ifdef DEBUG_PRINT
+          PRINT("\n1. Resending first chunk...\n");
+#endif
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucBuf, (uiLenToSend - 1));
+          uiBytesToSend = uiDataLen;
+          uiFirstChunkSent = 0;
+        }
+        else if (uiLenToSend == (uiDataLen + 1))
+        {
+          // Send second chunk again
+#ifdef DEBUG_PRINT
+          PRINT("\n2. Resending second chunk...\n");
+#endif
+          fw_upload_ComWriteChars(mchar_fd, (uint8 *)&ucBuf[HDR_LEN], (uiLenToSend - 1));
+          uiBytesToSend = HDR_LEN;
+          uiFirstChunkSent = 1;
+        }
+      }
+      else if (uiLenToSend == HDR_LEN)
+      {
+        // Out of sync. Restart sending buffer
+#ifdef DEBUG_PRINT
+        PRINT("\n3.  Restart sending the buffer...\n");
+#endif
+        fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucBuf, uiLenToSend);
+        uiBytesToSend = uiDataLen;
+        uiFirstChunkSent = 0;
+      }
+    }
+    // Ensure any pending write data is completely written
+    if (0 == tcdrain(mchar_fd))
+    {
+#ifdef DEBUG_PRINT
+      PRINT("\n\t tcdrain succeeded\n");
+#endif
+    }
+    else
+    {
+#ifdef DEBUG_PRINT
+      PRINT("\n\t tcdrain failed with errno = %d\n", errno);
+#endif
+    }
+    if(!ucCmd5Sent && uiFirstChunkSent == 1)
+    {
+      fw_upload_DelayInMs(DELAY_CMD5_PATCH);
+    }
+    // Get last 5 bytes now
+    fw_upload_GetLast5Bytes(ucBuf);
+    // Get next length
+    uiValidLen = FALSE;
+    do
+    {
+      if (fw_upload_lenValid(&uiLenToSend, ucString) == TRUE)
+      {
+        // Valid length received
+        uiValidLen = TRUE;
+#ifdef DEBUG_PRINT
+        PRINT("\n Valid length = %d \n", uiLenToSend);
+#endif
+        // ACK the bootloader
+       	fw_upload_ComWriteChar(mchar_fd, (int8)BOOT_HEADER_ACK);
+#ifdef DEBUG_PRINT
+        PRINT("\n  BOOT_HEADER_ACK 0x5a sent \n");
+#endif
+      }
+    } while (!uiValidLen);
+  }
+#ifdef DEBUG_PRINT
+  PRINT("\n ========== Buffer is successfully sent =========\n\n");
+#endif
+  return uiLenToSend;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitFor_Offset
+ *
+ * Description:
+ *   This function gets offset value from helper.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   offset value.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static uint32 fw_upload_WaitFor_Offset()
+{  
+  uint32 ulOffset = 0x0;
+  uint32 ulOffsetComp = 0x0;
+
+  // uiLen and uiLenComp are 1's complement of each other. 
+  // In such cases, the XOR of uiLen and uiLenComp will be all 1's
+  // i.e 0xffff.
+  uint32 uiXorOfOffset = 0xFFFFFFFF;
+
+  // Read the Offset.
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&ulOffset, 4);
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&ulOffsetComp, 4);
+
+  // Check if the length is valid.
+  if ((ulOffset ^ ulOffsetComp) == uiXorOfOffset) // All 1's
+  { 
+#ifdef DEBUG_PRINT
+    PRINT("\n    Helper ask for offset %d \n ", ulOffset);
+#endif
+  }
+  else
+  {
+#ifdef DEBUG_PRINT
+    PRINT("\n    NAK case: helper Offset = %x bytes \n ", ulOffset);
+    PRINT("\n    NAK case: helper OffsetComp = %x bytes \n ", ulOffsetComp);
+#endif
+    // Failure due to mismatch.	  
+    fw_upload_ComWriteChar(mchar_fd, (int8)0xbf);
+
+    // Start all over again.
+    longjmp(resync, 1);
+  }
+  return ulOffset;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_WaitFor_ErrCode
+ *
+ * Description:
+ *   This function gets error code from helper.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   None.
+ *
+ * Return Value:
+ *   error code.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static uint16 fw_upload_WaitFor_ErrCode()
+{
+  uint16 uiError = 0x0;
+  uint16 uiErrorCmp = 0x0;
+  uint16 uiXorOfErrCode = 0xFFFF;
+  
+  // Read the Error Code.
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiError, 2);
+  fw_upload_ComReadChars(mchar_fd, (uint8 *)&uiErrorCmp, 2);
+
+  // Check if the Err Code is valid.
+  if ((uiError ^ uiErrorCmp) == uiXorOfErrCode) // All 1's
+  {
+#ifdef DEBUG_PRINT
+    PRINT("\n    Error Code is %d \n ", uiError);
+#endif
+    if(uiError == 0)
+    {
+      // Successful. Send back the ack.
+      fw_upload_ComWriteChar(mchar_fd, (int8)HELPER_HEADR_ACK);
+    }
+    else
+    {
+#ifdef DEBUG_PRINT
+      PRINT("\n    Helper NAK or CRC or Timeout \n ");
+#endif
+      // NAK/CRC/Timeout
+      fw_upload_ComWriteChar(mchar_fd, (int8)HELPER_TIMEOUT_ACK);
+    }
+  }
+  else
+  {
+#ifdef DEBUG_PRINT
+    PRINT("\n    NAK case: helper ErrorCode = %x bytes \n ", uiError);
+    PRINT("\n    NAK case: helper ErrorCodeComp = %x bytes \n ", uiErrorCmp);
+#endif
+    // Failure due to mismatch.	  
+    fw_upload_ComWriteChar(mchar_fd, (int8)0xbf);
+    // Start all over again.
+    longjmp(resync, 1);
+  }
+  return uiError;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_SendLenBytesToHelper
+ *
+ * Description:
+ *   This function sends Len bytes to the Helper.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pFileBuffer: bin file buffer being sent.
+ *   uiLenTosend: the length will be sent.
+ *   ulOffset: the offset of current sending.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static void fw_upload_SendLenBytesToHelper(uint8* pFileBuffer, uint16 uiLenToSend, uint32 ulOffset)
+
+{
+  // Retransmittion of previous block
+  if (ulOffset == ulLastOffsetToSend)
+  {
+#ifdef DEBUG_PRINT
+    PRINT("\nRetx offset %d...\n", ulOffset);
+#endif
+    fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucByteBuffer, uiLenToSend);
+  }
+  else  
+  {
+    //uint16 uiNumRead = 0;
+    // The length requested by the Helper is equal to the Block
+    // sizes used while creating the FW.bin. The usual
+    // block sizes are 128, 256, 512.
+    // uiLenToSend % 16 == 0. This means the previous packet
+    // was error free (CRC ok) or this is the first packet received.
+    //  We can clear the ucByteBuffer and populate fresh data. 
+    memset (ucByteBuffer, 0, sizeof(ucByteBuffer));
+    memcpy(ucByteBuffer,pFileBuffer+ulOffset,uiLenToSend);
+    ulCurrFileSize += uiLenToSend;
+    fw_upload_ComWriteChars(mchar_fd, (uint8 *)ucByteBuffer, uiLenToSend);
+    ulLastOffsetToSend = ulOffset;
+  }
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_SendIntBytes
+ *
+ * Description:
+ *   This function sends 4 bytes and 4bytes' compare.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   4 bytes need to be sent.
+ *
+ * Return Value:
+ *   None.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static void fw_upload_SendIntBytes(uint32 ulBytesToSent)
+{
+  uint8 i, uTemp[9], uiLocalCnt = 0;
+  uint32 ulBytesToSentCmp;
+  
+  ulBytesToSentCmp = ulBytesToSent ^ 0xFFFFFFFF;
+
+  for (i = 0; i < 4; i ++)
+  {
+    uTemp[uiLocalCnt++] = (uint8)(ulBytesToSent >> (i * 8)) & 0xFF;
+  }
+  for (i = 0; i < 4; i ++)
+  {
+    uTemp[uiLocalCnt++] = (uint8)(ulBytesToSentCmp >> (i * 8)) & 0xFF;
+  }
+
+  fw_upload_ComWriteChars(mchar_fd, (uint8 *)uTemp, 8);
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_SendLenBytes
+ *
+ * Description:
+ *   This function sends Len bytes(header+data) to the boot code.    
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pFileBuffer: bin file buffer being sent.
+ *   uiLenTosend: the length will be sent.
+ *
+ * Return Value:
+ *   the 'len' of next header request.
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/ 
+static uint16 fw_upload_SendLenBytes(uint8* pFileBuffer, uint16 uiLenToSend)
+{
+  uint16 ucDataLen, uiLen;
+  //uint16 uiNumRead = 0;
+#ifdef DEBUG_PRINT
+  uint16 i;
+#endif
+  memset (ucByteBuffer, 0, sizeof(ucByteBuffer));
+  if(!ucCmd5Sent)
+  {
+    // put header and data into temp buffer first
+    memcpy(ucByteBuffer, ucCmd5Patch, uiLenToSend); 
+    //get data length from header
+    ucDataLen = fw_upload_GetDataLen(ucByteBuffer);
+    memcpy(&ucByteBuffer[uiLenToSend], &ucCmd5Patch[uiLenToSend], ucDataLen);
+    uiLen = fw_upload_SendBuffer(uiLenToSend, ucByteBuffer);
+    ucCmd5Sent = 1;
+#ifdef DEBUG_PRINT
+    PRINT("\ncmd5 patch is sent\n");
+#endif
+  }
+  else
+  {
+    // fread(void *buffer, size_t size, size_t count, FILE *stream)
+    memcpy(ucByteBuffer,pFileBuffer+ulCurrFileSize,uiLenToSend);
+    ulCurrFileSize += uiLenToSend;
+    ucDataLen = fw_upload_GetDataLen(ucByteBuffer);
+    memcpy(&ucByteBuffer[uiLenToSend],pFileBuffer+ulCurrFileSize,ucDataLen);
+    ulCurrFileSize += ucDataLen;
+#ifdef DEBUG_PRINT
+    PRINT("The buffer is to be sent: %d", uiLenToSend + ucDataLen);
+    for(i = 0; i < (uiLenToSend + ucDataLen); i ++)
+    {
+      if(i % 16 == 0)
+      {
+        PRINT("\n");
+      }
+      PRINT(" %02x ", ucByteBuffer[i]);
+    }
+#endif
+    //start to send Temp buffer
+    uiLen = fw_upload_SendBuffer(uiLenToSend, ucByteBuffer);
+    PRINT("File downloaded: %8d:%8d\r", ulCurrFileSize, ulTotalFileSize);
+  }
+  return uiLen;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_FW
+ *
+ * Description:
+ *   This function performs the task of FW load over UART.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pPortName:       Com port number.
+ *   iBaudRate:       the initial baud rate.
+ *   ucFlowCtrl:      the flow ctrl of uart.
+ *   pFileName:       the file name for downloading.
+ *   iSecondBaudRate: the second baud rate.
+ *
+ * Return Value:
+ *   TRUE:            Download successfully
+ *   FALSE:           Download unsuccessfully
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+static BOOLEAN fw_upload_FW(int8 *pFileName) {
+  uint8 *pFileBuffer = NULL;
+  uint32 ulReadLen = 0;
+  BOOLEAN bRetVal = FALSE;
+  int32 result = 0;
+  uint16 uiLenToSend = 0;
+
+  uint32 ulOffsettoSend = 0;
+  uint16 uiErrCode = 0;
+
+  // Open File for reading.
+  pFile = fopen(pFileName, "rb");
+
+  if ((mchar_fd < 0) || (pFile == NULL)) {
+    printf("\nPort is not open or file not found\n");
+    return bRetVal;
+  }
+
+  // Calculate the size of the file to be downloaded.
+  result = fseek(pFile, 0, SEEK_END);
+  if (result)
+  {
+    printf("\nfseek failed\n");
+    return bRetVal;
+  }
+
+  ulTotalFileSize = (uint32)ftell(pFile);
+  if (!ulTotalFileSize)
+  {
+    printf("\nError:Download Size is 0\n");
+    return bRetVal;
+  }
+
+  pFileBuffer = (uint8 *) malloc(ulTotalFileSize);
+
+  fseek(pFile, 0, SEEK_SET);
+  if (pFileBuffer)
+  {
+    ulReadLen = fread(pFileBuffer, 1, ulTotalFileSize, pFile);
+    if (ulReadLen != ulTotalFileSize)
+    {
+      PRINT("\nError:Read File Fail\n");
+      return bRetVal;
+    }
+
+  }
+  ulCurrFileSize = 0;
+
+  // Jump to here in case of protocol resync.
+  setjmp(resync);
+
+  while (!bRetVal)
+  {
+    // Wait to Receive 0xa5, 0xaa, 0xa6
+    if (!fw_upload_WaitForHeaderSignature(TIMEOUT_VAL_MILLISEC))
+    {
+      PRINT("\n0xa5,0xaa,or 0xa6 is not received in 4s.\n");
+      return bRetVal;
+    }
+
+    // Read the 'Length' bytes requested by Helper
+    uiLenToSend = fw_upload_WaitFor_Len(pFile);
+  
+    if(ucRcvdHeader == HELPER_HEADER)
+    {
+      ucHelperOn = TRUE;
+      ulOffsettoSend = fw_upload_WaitFor_Offset();
+      uiErrCode = fw_upload_WaitFor_ErrCode();
+      if(uiErrCode == 0)
+      {
+        if(uiLenToSend != 0)
+        {
+          fw_upload_SendLenBytesToHelper(pFileBuffer, uiLenToSend, ulOffsettoSend);
+#ifdef DEBUG_PRINT
+          PRINT("\n sent %d bytes..\n", ulOffsettoSend);
+#endif
+        }
+        else    //download complete
+        {
+          tcflush(mchar_fd, TCIFLUSH);
+          fw_upload_SendIntBytes(ulCurrFileSize);
+          fw_upload_DelayInMs(20);
+          if( fw_upload_GetBufferSize(mchar_fd) == 0)
+          {
+            bRetVal = TRUE;
+          }
+        }
+      }
+      else if (uiErrCode > 0)
+      {
+      /*delay 20ms to make multiple uiErrCode == 1 has been sent, after 20ms, if get 
+       *uiErrCode = 1 again, we consider 0x6b is missing.
+       */
+        fw_upload_DelayInMs(20);
+        tcflush(mchar_fd, TCIFLUSH);
+        fw_upload_SendIntBytes(ulOffsettoSend);
+      }
+      PRINT("File downloaded: %8d:%8d\r", ulCurrFileSize, ulTotalFileSize);
+
+      // Ensure any pending write data is completely written
+      if (0 == tcdrain(mchar_fd))
+      {
+#ifdef DEBUG_PRINT
+        PRINT("\n\t tcdrain succeeded\n");
+#endif
+      }
+      else
+      {
+#ifdef DEBUG_PRINT
+        PRINT("\n\t FW download tcdrain failed with errno = %d\n", errno);
+#endif
+      }
+    }
+
+    if(!ucHelperOn)
+    {
+      do
+      {
+        uiLenToSend = fw_upload_SendLenBytes(pFileBuffer, uiLenToSend);
+      }while(uiLenToSend != 0);
+  	  // If the Length requested is 0, download is complete.
+      if (uiLenToSend == 0)
+      {	  
+        bRetVal = TRUE;
+        break;
+      }
+    }
+    
+  }
+  if(pFileBuffer != NULL)
+  {
+    free(pFileBuffer);
+    pFileBuffer = NULL;
+  }
+  return bRetVal;
+}
+
+/******************************************************************************
+ *
+ * Name: fw_upload_check_FW
+ *
+ * Description:
+ *   This function performs the task of FW load over UART.
+ *
+ * Conditions For Use:
+ *   None.
+ *
+ * Arguments:
+ *   pPortName:       Com port number.
+ *   iBaudRate:       the initial baud rate.
+ *   ucFlowCtrl:      the flow ctrl of uart.
+ *
+ * Return Value:
+ *   TRUE:            Need Download FW
+ *   FALSE:           No need Download FW
+ *
+ * Notes:
+ *   None.
+ *
+ *****************************************************************************/
+BOOLEAN bt_vnd_mrvl_check_fw_status_v2() {
+  BOOLEAN bRetVal = FALSE;
+
+  if (mchar_fd < 0) {
+    printf("\nPort is not open or file not found\n");
+    return bRetVal;
+  }
+
+  // Wait to Receive 0xa5, 0xaa, 0xa6
+  bRetVal = fw_upload_WaitForHeaderSignature(200);
+
+  printf("fw_upload_WaitForHeaderSignature return %d", bRetVal);
+
+  return bRetVal;
+}
+
+/******************************************************************************
+*
+* Name: bt_vnd_mrvl_download_fw
+*
+* Description:
+*   Wrapper of fw_upload_FW.
+*
+* Conditions For Use:
+*   None.
+*
+* Arguments:
+*   pPortName:       Com port number.
+*   iBaudRate:       the initial baud rate.
+*   ucFlowCtrl:      the flow ctrl of uart.
+*   pFileName:       the file name for downloading.
+*   iSecondBaudRate: the second baud rate.
+*
+* Return Value:
+*   0:            Download successfully
+*   1:           Download unsuccessfully
+*
+* Notes:
+*   None.
+*
+*****************************************************************************/
+int bt_vnd_mrvl_download_fw_v2(int8 *pPortName, int32 iBaudrate, int8 *pFileName) {
+  double endTime;
+  double start;
+  double cost;
+  uint32 ulResult;
+  uint8 ucByte;
+
+  start = fw_upload_GetTime();
+
+  printf("Protocol: NXP Proprietary\n");
+  printf("FW Loader Version: %s\n", VERSION);
+  printf("ComPort : %s\n", pPortName);
+  printf("BaudRate: %d\n", iBaudrate);
+  printf("Filename: %s\n", pFileName);
+
+  do
+  {
+    ulResult = fw_upload_FW(pFileName);
+    if(ulResult)
+    {
+      printf("\nDownload Complete\n");
+      cost = fw_upload_GetTime() - start;
+      printf("time:%f\n", cost);
+      if(ucHelperOn == TRUE)
+      {
+        endTime = fw_upload_GetTime() + POLL_AA_TIMEOUT;
+        do
+        {
+          if(fw_upload_GetBufferSize(mchar_fd) != 0)
+          {
+            ucByte = 0xff;
+            fw_upload_ComReadChars(mchar_fd, (uint8 *)&ucByte,1);
+            if (ucByte == VERSION_HEADER)
+            {
+              PRINT("\nReDownload\n");
+              uiReDownload = TRUE;
+              ulLastOffsetToSend = 0xFFFF;
+              memset (ucByteBuffer, 0, sizeof(ucByteBuffer));
+            }
+            break;
+          }
+        }while(endTime > fw_upload_GetTime());
+      }
+      if (uiReDownload == FALSE)
+      {
+        endTime = fw_upload_GetTime() + MAX_CTS_TIMEOUT;
+        do
+        {
+          if (!fw_upload_ComGetCTS(mchar_fd))
+          {
+            PRINT("CTS is low\n");
+            if(pFile)
+            {
+              fclose(pFile);
+              pFile = NULL;
+            }
+            goto done;
+          }
+        } while (endTime > fw_upload_GetTime());
+        PRINT("wait CTS low timeout \n");
+        PRINT("Error code is %d\n",ulResult);
+        if(pFile)
+        {
+          fclose(pFile);
+          pFile = NULL;
+        }
+      	goto done;
+      }
+    }
+    else
+    {
+      printf("\nDownload Error\n");
+      return 1;
+    }
+  } while(uiReDownload);
+
+done:
+  return 0;
+}
+
diff --git a/88x9098/bt/libbt/fw_loader_uart_v2.h b/88x9098/bt/libbt/fw_loader_uart_v2.h
new file mode 100755
index 0000000..ac44157
--- /dev/null
+++ b/88x9098/bt/libbt/fw_loader_uart_v2.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ *  Copyright 2009-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef _FW_LOADER_V2_H
+#define _FW_LOADER_V2_H
+/*===================== Include Files ============================================*/
+#include "bt_vendor_nxp.h"
+
+/*==================== Typedefs =================================================*/
+
+
+/*===================== Macros ===================================================*/
+
+extern int mchar_fd;
+
+/*===================== Global Vars ==============================================*/
+
+/*==================== Function Prototypes ======================================*/
+
+void init_crc8();
+BOOLEAN bt_vnd_mrvl_check_fw_status_v2();
+int bt_vnd_mrvl_download_fw_v2(int8 *pPortName, int32 iBaudRate, int8 *pFileName);
+#endif  // _FW_LOADER_H
+
diff --git a/88x9098/bt/libbt/hardware_nxp.c b/88x9098/bt/libbt/hardware_nxp.c
new file mode 100755
index 0000000..e4a49e6
--- /dev/null
+++ b/88x9098/bt/libbt/hardware_nxp.c
@@ -0,0 +1,537 @@
+/******************************************************************************
+ *
+ *  Copyright 2012-2013, 2020-2021 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "hardware_nxp"
+
+#include <log/log.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+
+#include "bt_vendor_nxp.h"
+#include "bt_hci_bdroid.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#ifndef NXP_INIT_SCO_CFG_INCLUDED
+#define NXP_INIT_SCO_CFG_INCLUDED TRUE
+#endif
+
+#ifndef USE_CONTROLLER_BDADDR
+#define USE_CONTROLLER_BDADDR TRUE
+#endif
+
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+#define HCI_CMD_NXP_WRITE_VOICE_SETTINGS 0x0C26
+#define HCI_CMD_NXP_WRITE_PCM_SETTINGS 0xFC07
+#define HCI_CMD_NXP_WRITE_PCM_SYNC_SETTINGS 0xFC28
+#define HCI_CMD_NXP_WRITE_PCM_LINK_SETTINGS 0xFC29
+#define HCI_CMD_NXP_SET_SCO_DATA_PATH 0xFC1D
+
+#define WRITE_VOICE_SETTINGS_SIZE 2
+#define WRITE_PCM_SETTINGS_SIZE 1
+#define WRITE_PCM_SYNC_SETTINGS_SIZE 3
+#define WRITE_PCM_LINK_SETTINGS_SIZE 2
+#define SET_SCO_DATA_PATH_SIZE 1
+#endif
+
+#define HCI_CMD_NXP_WRITE_BD_ADDRESS 0xFC22
+#define HCI_BT_SET_EVENTMASK_OCF 0x0001
+#define HCI_CONTROLLER_CMD_OGF 0x03
+#define HCI_RESET_OCF 0x03
+#define HCI_DISABLE_PAGE_SCAN_OCF 0x001a
+#define HCI_READ_LOCAL_BDADDR 0x1009
+#define HCI_COMMAND_COMPLETE_EVT 0x0E
+#define HCI_PACKET_TYPE_EVENT 0x04
+
+#define WRITE_BD_ADDRESS_SIZE 8
+#define HCI_CMD_PREAMBLE_SIZE 3
+#define HCI_EVT_CMD_CMPL_OPCODE 3
+
+/*1 byte for event code, 1 byte for parameter length (Volume 2, Part E, 5.4.4)
+ */
+#define HCI_EVENT_PREAMBLE_SIZE 2
+/*2 bytes for opcode, 1 byte for parameter length (Volume 2, Part E, 5.4.1) */
+#define HCI_COMMAND_PREAMBLE_SIZE 3
+#define WRITE_BD_ADDRESS_SIZE 8
+#define HCI_EVT_CMD_CMPL_LOCAL_BDADDR_ARRAY 6
+#define BD_ADDR_LEN 6
+
+#define STREAM_TO_UINT16(u16, p)                                \
+  do {                                                          \
+    u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); \
+    (p) += 2;                                                   \
+  } while (0)
+
+#define UINT16_TO_STREAM(p, u16)    \
+  do {                              \
+    *(p)++ = (uint8_t)(u16);        \
+    *(p)++ = (uint8_t)((u16) >> 8); \
+  } while (0)
+
+#define UINT8_TO_STREAM(p, u8) \
+  { *(p)++ = (uint8_t)(u8); }
+
+#define OpCodePack(ogf, ocf) (uint16_t)((ocf & 0x03ff) | (ogf << 10))
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+struct bt_evt_param_t {
+  uint16_t cmd;
+  uint8_t cmd_ret_param;
+};
+
+/***********************************************************
+ *  Prototype
+ ***********************************************************
+ */
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+static void hw_sco_config(void);
+#endif
+static void hw_config_set_bdaddr(void);
+#if (USE_CONTROLLER_BDADDR == TRUE)
+static void hw_config_read_bdaddr(void);
+#endif
+/***********************************************************
+ *  Local variables
+ ***********************************************************
+ */
+
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+/*Write_Voice_Setting - Use Linear Input coding, uLaw Air coding, 16bit sample
+ * size*/
+static uint8_t write_voice_settings[WRITE_VOICE_SETTINGS_SIZE] = {0x61, 0x00};
+/** #PCM settings PCM 0: PCM slave role, 2: PCM master */
+static uint8_t write_pcm_settings[WRITE_PCM_SETTINGS_SIZE] = {0x00};
+/** PCM SYNC settings, 16k short sync with CLK 2.048MHz */
+static uint8_t write_pcm_sync_settings[WRITE_PCM_SYNC_SETTINGS_SIZE] = {
+    0x03, 0x00, 0x04};
+/**PCM LINK settings, SCO slot1*/
+static uint8_t write_pcm_link_settings[WRITE_PCM_LINK_SETTINGS_SIZE] = {0x04,
+                                                                        0x00};
+/** PCM LINK settings, SCO slot1 */
+static uint8_t set_sco_data_path[SET_SCO_DATA_PATH_SIZE] = {0x01};
+#endif
+
+/***********************************************************
+**  HELPER FUNCTIONS
+***********************************************************/
+static char* cmd_to_str(uint16_t cmd) {
+  switch (cmd) {
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+    case HCI_CMD_NXP_WRITE_PCM_SETTINGS:
+      return "write_pcm_settings";
+    case HCI_CMD_NXP_WRITE_PCM_SYNC_SETTINGS:
+      return "write_pcm_sync_settings";
+    case HCI_CMD_NXP_WRITE_PCM_LINK_SETTINGS:
+      return "write_pcm_link_settings";
+    case HCI_CMD_NXP_SET_SCO_DATA_PATH:
+      return "set_sco_data_path";
+    case HCI_CMD_NXP_WRITE_VOICE_SETTINGS:
+      return "write_voice_settings";
+#endif
+    case HCI_CMD_NXP_WRITE_BD_ADDRESS:
+      return "write_bd_address";
+    default:
+      break;
+  }
+
+  return "unknown command";
+}
+
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+static HC_BT_HDR* build_cmd_buf(uint16_t cmd, uint8_t pl_len,
+                                uint8_t* payload) {
+  HC_BT_HDR* p_buf;
+  uint16_t cmd_len = HCI_CMD_PREAMBLE_SIZE + pl_len;
+  uint8_t* p;
+
+  assert(vnd_cb && payload);
+
+  p_buf = (HC_BT_HDR*)vnd_cb->alloc(BT_HC_HDR_SIZE + cmd_len);
+
+  if (!p_buf) return NULL;
+
+  p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+  p_buf->offset = 0;
+  p_buf->layer_specific = 0;
+  p_buf->len = cmd_len;
+
+  p = (uint8_t*)(p_buf + 1);
+
+  /* opcode */
+  UINT16_TO_STREAM(p, cmd);
+
+  /* length of payload */
+  *p = pl_len;
+  ++p;
+
+  /* payload */
+  memcpy(p, payload, pl_len);
+
+  return p_buf;
+}
+
+static void parse_evt_buf(HC_BT_HDR* p_evt_buf,
+                          struct bt_evt_param_t* evt_params) {
+  uint8_t* p = (uint8_t*)(p_evt_buf + 1) + HCI_EVT_CMD_CMPL_OPCODE;
+
+  assert(p_evt_buf && evt_params);
+
+  /* opcode */
+  STREAM_TO_UINT16(evt_params->cmd, p);
+
+  /* command return parameter */
+  evt_params->cmd_ret_param = *p;
+}
+
+/*******************************************************************************
+**
+** Function         hw_sco_config_cb
+**
+** Description      Callback function for PCM SCO configuration request
+**
+** Returns          None
+**
+*******************************************************************************/
+
+static void hw_sco_config_cb(void* p_mem) {
+  HC_BT_HDR* p_evt_buf = (HC_BT_HDR*)p_mem;
+  struct bt_evt_param_t evt_params = {0, 0};
+  uint16_t cmd;
+  HC_BT_HDR* p_buf;
+
+  assert(vnd_cb && p_mem);
+
+  parse_evt_buf(p_evt_buf, &evt_params);
+
+  /* free the buffer */
+  vnd_cb->dealloc(p_evt_buf);
+
+  switch (evt_params.cmd) {
+    case HCI_CMD_NXP_WRITE_PCM_SETTINGS:
+      /* Send HCI_CMD_NXP_WRITE_PCM_SYNC_SETTINGS */
+      cmd = HCI_CMD_NXP_WRITE_PCM_SYNC_SETTINGS;
+      p_buf = build_cmd_buf(cmd, WRITE_PCM_SYNC_SETTINGS_SIZE,
+                            write_pcm_sync_settings);
+      break;
+
+    case HCI_CMD_NXP_WRITE_PCM_SYNC_SETTINGS:
+      /* Send HCI_CMD_NXP_WRITE_PCM_LINK_SETTINGS */
+      cmd = HCI_CMD_NXP_WRITE_PCM_LINK_SETTINGS;
+      p_buf = build_cmd_buf(cmd, WRITE_PCM_LINK_SETTINGS_SIZE,
+                            write_pcm_link_settings);
+      break;
+
+    case HCI_CMD_NXP_WRITE_PCM_LINK_SETTINGS:
+      /* Send HCI_CMD_NXP_SET_SCO_DATA_PATH */
+      cmd = HCI_CMD_NXP_SET_SCO_DATA_PATH;
+      p_buf = build_cmd_buf(cmd, SET_SCO_DATA_PATH_SIZE, set_sco_data_path);
+      break;
+
+    case HCI_CMD_NXP_SET_SCO_DATA_PATH:
+      /* Send HCI_CMD_NXP_WRITE_VOICE_SETTINGS */
+      cmd = HCI_CMD_NXP_WRITE_VOICE_SETTINGS;
+      p_buf =
+          build_cmd_buf(cmd, WRITE_VOICE_SETTINGS_SIZE, write_voice_settings);
+      break;
+    case HCI_CMD_NXP_WRITE_VOICE_SETTINGS:
+      /* sco config succeeds */
+      ALOGI("SCO PCM config succeeds!");
+      vnd_cb->scocfg_cb(BT_VND_OP_RESULT_SUCCESS);
+      /* fw config succeeds */
+      ALOGI("FW config succeeds!");
+      vnd_cb->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+      return;
+
+    default:
+      ALOGE("Received event for unexpected cmd (0x%04hX). Fail.",
+            evt_params.cmd);
+      p_buf = NULL;
+      break;
+  } /* switch (evt_params.cmd) */
+
+  if (p_buf) {
+    ALOGI("Sending hci command 0x%04hX (%s)", cmd, cmd_to_str(cmd));
+    if (vnd_cb->xmit_cb(cmd, p_buf, hw_sco_config_cb))
+      return;
+    else
+      vnd_cb->dealloc(p_buf);
+  }
+
+  ALOGE("Vendor lib scocfg aborted");
+  vnd_cb->scocfg_cb(BT_VND_OP_RESULT_FAIL);
+  /* fw config succeeds */
+  ALOGI("FW config succeeds!");
+  vnd_cb->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+}
+
+/*******************************************************************************
+**
+** Function         hw_sco_config
+**
+** Description      Configure SCO related hardware settings
+**
+** Returns          None
+**
+*******************************************************************************/
+static void hw_sco_config(void) {
+  HC_BT_HDR* p_buf;
+  uint16_t cmd;
+
+  ALOGV("Start SCO config ...");
+  assert(vnd_cb);
+
+  /* Start with HCI_CMD_NXP_WRITE_PCM_SETTINGS */
+  cmd = HCI_CMD_NXP_WRITE_PCM_SETTINGS;
+  p_buf = build_cmd_buf(cmd, WRITE_PCM_SETTINGS_SIZE, write_pcm_settings);
+
+  if (p_buf) {
+    ALOGI("Sending hci command 0x%04hX (%s)", cmd, cmd_to_str(cmd));
+    if (vnd_cb->xmit_cb(cmd, p_buf, hw_sco_config_cb))
+      return;
+    else
+      vnd_cb->dealloc(p_buf);
+  }
+
+  ALOGE("Vendor lib scocfg aborted");
+  vnd_cb->scocfg_cb(BT_VND_OP_RESULT_FAIL);
+  /* fw config succeeds */
+  ALOGI("FW config succeeds!");
+  vnd_cb->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+}
+#endif
+
+/*******************************************************************************
+**
+** Function        make_command
+**
+** Description     Prepare packet using opcode and parameter size
+**
+** Returns         Pointer to base address of HC_BT_HDR structure
+**
+*******************************************************************************/
+
+static HC_BT_HDR* make_command(uint16_t opcode, size_t parameter_size) {
+  HC_BT_HDR* packet = (HC_BT_HDR*)malloc(
+      sizeof(HC_BT_HDR) + HCI_COMMAND_PREAMBLE_SIZE + parameter_size);
+  if (!packet) {
+    VNDDBG("%s Failed to allocate buffer\n", __func__);
+    return NULL;
+  }
+  uint8_t* stream = packet->data;
+  packet->event = 0;
+  packet->offset = 0;
+  packet->layer_specific = 0;
+  packet->len = HCI_COMMAND_PREAMBLE_SIZE + parameter_size;
+  UINT16_TO_STREAM(stream, opcode);
+  UINT8_TO_STREAM(stream, parameter_size);
+  return packet;
+}
+
+/*******************************************************************************
+**
+** Function         hw_config_callback
+**
+** Description      Callback function for controller configuration
+**
+** Returns          None
+**
+*******************************************************************************/
+static void hw_config_callback(void* packet) {
+  uint8_t* stream, event, event_code, status, opcode_offset;
+  uint16_t opcode;
+#if (USE_CONTROLLER_BDADDR == TRUE)
+  char* p_tmp;
+  HC_BT_HDR* p_evt_buf = (HC_BT_HDR*)packet;
+  const uint8_t cmp_bdaddr[BD_ADDR_LEN*4] = { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\
+          0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\
+          0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+#endif
+  stream = ((HC_BT_HDR*)packet)->data;
+  event = ((HC_BT_HDR*)packet)->event;
+  opcode_offset = HCI_EVENT_PREAMBLE_SIZE + 1;  // Skip num packets.
+
+  if (event == HCI_PACKET_TYPE_EVENT) {
+    event_code = stream[0];
+    opcode = stream[opcode_offset] | (stream[opcode_offset + 1] << 8);
+    if (event_code == HCI_COMMAND_COMPLETE_EVT) {
+      status = stream[opcode_offset + 2];
+      ALOGI("opcode 0x%04x status 0x%02x\n", opcode, status);
+      if (opcode == OpCodePack(HCI_CONTROLLER_CMD_OGF, HCI_RESET_OCF)) {
+        VNDDBG("Receive hci reset complete event");
+#if (USE_CONTROLLER_BDADDR == TRUE)
+        if (write_bdaddrss == 0) {
+          hw_config_read_bdaddr();
+        } else {
+          hw_config_set_bdaddr();
+        }
+#else
+        hw_config_set_bdaddr();
+#endif
+      } else if (opcode == HCI_CMD_NXP_WRITE_BD_ADDRESS) {
+        VNDDBG("Receive BD_ADDRESS write config event.\n");
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+        hw_sco_config();
+#else
+        /* fw config succeeds */
+        VNDDBG("FW config succeeds!");
+        if (vnd_cb) {
+          vnd_cb->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+        }
+#endif
+      }
+#if (USE_CONTROLLER_BDADDR == TRUE)
+      else if (opcode == HCI_READ_LOCAL_BDADDR) {
+        p_tmp = (char*)(p_evt_buf + 1) + HCI_EVT_CMD_CMPL_LOCAL_BDADDR_ARRAY;
+        if ( (memcmp(p_tmp, cmp_bdaddr+(BD_ADDR_LEN*0), BD_ADDR_LEN) == 0)
+          || (memcmp(p_tmp, cmp_bdaddr+(BD_ADDR_LEN*1), BD_ADDR_LEN) == 0)
+          || (memcmp(p_tmp, cmp_bdaddr+(BD_ADDR_LEN*2), BD_ADDR_LEN) == 0)
+          || (memcmp(p_tmp, cmp_bdaddr+(BD_ADDR_LEN*3), BD_ADDR_LEN) == 0) ) {
+          hw_config_set_bdaddr();
+        } else {
+          VNDDBG("Controller OTP bdaddr %02X:%02X:%02X:%02X:%02X:%02X",
+                 *(p_tmp + 5), *(p_tmp + 4), *(p_tmp + 3), *(p_tmp + 2),
+                 *(p_tmp + 1), *p_tmp);
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+          hw_sco_config();
+#else
+          /* fw config succeeds */
+          VNDDBG("FW config succeeds!");
+          if (vnd_cb) {
+            vnd_cb->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+          }
+#endif
+        }
+      }
+#endif
+    }
+  }
+}
+
+/*******************************************************************************
+**
+** Function         bt_bdaddress_set
+**
+** Description      Sets the bdaddress as per address received from stack/OTP/
+                    bt_vendor.conf
+**
+** Returns          None
+**
+*******************************************************************************/
+static void bt_bdaddress_set(void) {
+  uint16_t opcode;
+  HC_BT_HDR* packet;
+  opcode = HCI_CMD_NXP_WRITE_BD_ADDRESS;
+  packet = make_command(opcode, WRITE_BD_ADDRESS_SIZE);
+  if (packet) {
+    memcpy(&packet->data[3], write_bd_address, WRITE_BD_ADDRESS_SIZE);
+    if (vnd_cb->xmit_cb(opcode, packet, hw_config_callback)) {
+      ALOGI("Sending hci command 0x%04hX (%s)", opcode, cmd_to_str(opcode));
+      VNDDBG("bdaddr is %02hhX:%02hhX:%02hhX:%02hhX:%02hhX:%02hhX\n",
+             write_bd_address[7], write_bd_address[6], write_bd_address[5],
+             write_bd_address[4], write_bd_address[3], write_bd_address[2]);
+    }
+  } else {
+    VNDDBG("%s no valid packet \n", __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function         hw_config_set_bdaddr
+**
+** Description      Program controller's Bluetooth Device Address
+**
+** Returns          None
+**
+*******************************************************************************/
+
+static void hw_config_set_bdaddr(void) {
+  /* bd_address is not set in bt_vendor.conf */
+  VNDDBG("%s", __func__);
+  if (write_bdaddrss == 0) {
+    if (bdaddr == NULL) {
+#if (NXP_INIT_SCO_CFG_INCLUDED == TRUE)
+      hw_sco_config();
+#else
+      /* fw config succeeds */
+      VNDDBG("FW config succeeds!");
+      if (vnd_cb) vnd_cb->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+#endif
+      return;
+    } else if (bdaddr) {
+      for (int i = 0; i < 6; i++) {
+        write_bd_address[7 - i] = bdaddr[i];
+      }
+    }
+  }
+  bt_bdaddress_set();
+  if (write_bdaddrss == 1) write_bdaddrss = 0;
+}
+
+#if (USE_CONTROLLER_BDADDR == TRUE)
+/*******************************************************************************
+**
+** Function         hw_config_read_bdaddr
+**
+** Description      Read controller's Bluetooth Device Address
+**
+** Returns          None
+**
+*******************************************************************************/
+static void hw_config_read_bdaddr(void) {
+  uint16_t opcode;
+  HC_BT_HDR* packet;
+  opcode = HCI_READ_LOCAL_BDADDR;
+  packet = make_command(opcode, 0);
+  if (packet) {
+    if (vnd_cb->xmit_cb(opcode, packet, hw_config_callback))
+      VNDDBG("%s send out command successfully\n", __func__);
+  } else {
+    VNDDBG("%s no valid packet \n", __func__);
+  }
+}
+#endif
+
+/*******************************************************************************
+**
+** Function        hw_config_start
+**
+** Description     Start controller initialization process
+**
+** Returns         None
+**
+*******************************************************************************/
+void hw_config_start(void) {
+  uint16_t opcode;
+  HC_BT_HDR* packet;
+  opcode = OpCodePack(HCI_CONTROLLER_CMD_OGF, HCI_RESET_OCF);
+  packet = make_command(opcode, 0);
+  if (packet) {
+    if (vnd_cb->xmit_cb(opcode, packet, hw_config_callback))
+      VNDDBG("hci reset command sent out successfully\n");
+  } else {
+    VNDDBG("%s no valid packet \n", __func__);
+  }
+}
diff --git a/88x9098/bt/libbt/readme b/88x9098/bt/libbt/readme
new file mode 100755
index 0000000..4905299
--- /dev/null
+++ b/88x9098/bt/libbt/readme
@@ -0,0 +1,65 @@
+/******************************************************************************
+ *
+ *  Copyright 2018-2020 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+libbt supports to configure some key parameters with conf file in default path /vendor/etc/bluetooth/bt_vendor.conf
+
+use "key = value" to set parameters in conf file
+
+optional keys are listed below:
+
+	mchar_port: port path used by Uart interface, the default BT uart port in libbt is /dev/ttyUSB0 
+                          if it's not the same as default port, could set mchar_port in conf file like below
+                          mchar_port = /dev/ttyXXX
+
+	mbt_port: port path used by SD or USB interface, the default BT SD/USB port in libbt is /dev/mbtchar0
+	               if it's not the same as default port, could set mbt_port in conf file like below
+		        mbt_port = /dev/mbtcharX
+
+	is_uart_port: set to 1 when using Uart interface like below
+                           is_uart_port = 1
+
+	baudrate_fw_init: default bardrate when bluetooth fw active after download. The default value is 115200 in libbt. It's not necessary to configure this key in conf unless it need to choose other baudrate.
+
+	baudrate_bt: the baudrate expect to working on when bt running. The default value is 3000000 in libbt. It's not necessary to configure this key in conf unless it need to choose other baudrate. 
+	
+	uart_break_before_open: set to 1 when need to send break before open port, default value in libbt is 0. It's not necessary to configure this key in conf.
+    bd_address: set bdaddress by configuration file, bdaddress is comprised by 6 bytes. You are expected to input as the format of "bd_address = xx:xx:xx:xx:xx:xx", where 'x' should be hexadecimal digits.
+
+       Below parameters are for fw download, if not use fw download by libbt, don't set any of below in conf file
+
+	enable_download_fw: set to 1 if need to download uart bt fw by libbt when bootup, default value is 0 in libbt, it always download combo fw by wifi side
+
+	pFileName_image: bt fw path, example: pFileName_image = /vendor/firmware/mrvl/uart8997_bt_v4.bin
+
+	pFileName_helper: bt fw helper path, example: pFileName_helper = /vendor/etc/firmware/mrvl/helper_uart_3000000.bin
+
+	iSecondBaudrate: second baudrate used when download fw. The default value is 0 in libbt, only need to configure it if for 90xx chips.
+	example: iSecondBaudrate = 3000000
+	
+
+       Below parameters are not necessary to configure in conf file when download fw by libbt.
+
+	baudrate_dl_helper: baudrate used when download helper. The default value is 115200 in libbt, only need to configure it if choose other baudrate. 
+
+	baudrate_dl_image: baudrate used when start download fw. The default value is 3000000 in libbt, only need to configure it if choose other baudrate.  
+	
+	uart_break_before_change_baudrate: set to 1 when need to send break before change bootloader baudrate. Default value in libbt is 0. Not necessary to set it in conf
+
+	uart_break_after_dl_helper: set to 1 when need to send break after helper has been downloaded, and before download fw. Default value in libbt is 0. Not necessary to set it in conf
+
+	uart_sleep_after_dl: sleep time after bt fw is downloaded, unit in ms. The default value is 700 ms, only need to configure it if need sleep for more time.
diff --git a/88x9098/bt/libbt/tags b/88x9098/bt/libbt/tags
new file mode 100755
index 0000000..f53017b
--- /dev/null
+++ b/88x9098/bt/libbt/tags
@@ -0,0 +1,348 @@
+!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
+!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
+!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
+!_TAG_PROGRAM_NAME	Exuberant Ctags	//
+!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
+!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
+A6REQ_PAYLOAD_LEN	fw_loader_uart.c	64;"	d	file:
+AbREQ_PAYLOAD_LEN	fw_loader_uart.c	65;"	d	file:
+BDROID_DIR	Android.mk	/^BDROID_DIR := $(TOP_DIR)system\/bt$/;"	m
+BD_ADDR_LEN	bt_vendor_nxp.c	80;"	d	file:
+BD_ADDR_LEN	hardware_nxp.c	76;"	d	file:
+BIT	bt_vendor_nxp.h	54;"	d
+BLUETOOTH_VENDOR_LIB_INTERFACE	bt_vendor_nxp.c	/^const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {$/;"	v
+BOARD_UART_DOWNLOAD_FW	Android.mk	/^BOARD_UART_DOWNLOAD_FW := true$/;"	m
+BOARD_UART_FW_LOADER_VERSION	Android.mk	/^BOARD_UART_FW_LOADER_VERSION = v3$/;"	m
+BOOLEAN	bt_vendor_nxp.h	/^typedef unsigned char BOOLEAN;$/;"	t
+BOOT_HEADER	fw_loader_uart_v2.c	54;"	d	file:
+BOOT_HEADER_ACK	fw_loader_uart_v2.c	55;"	d	file:
+BT_HAL_VERSION	bt_vendor_nxp.h	48;"	d
+BT_MIC_FAIL_BIT	fw_loader_uart.c	79;"	d	file:
+CLKDIVAddr	fw_loader_uart.c	86;"	d	file:
+CMD4	fw_loader_uart.c	47;"	d	file:
+CMD4	fw_loader_uart_v2.c	46;"	d	file:
+CMD6	fw_loader_uart.c	48;"	d	file:
+CMD6	fw_loader_uart_v2.c	47;"	d	file:
+CMD7	fw_loader_uart.c	49;"	d	file:
+CMD7	fw_loader_uart_v2.c	48;"	d	file:
+CONF_COMMENT	bt_vendor_nxp.c	75;"	d	file:
+CONF_DELIMITERS	bt_vendor_nxp.c	76;"	d	file:
+CONF_MAX_LINE_LEN	bt_vendor_nxp.c	78;"	d	file:
+CONF_VALUES_DELIMITERS	bt_vendor_nxp.c	77;"	d	file:
+CRC_ERR_BIT	fw_loader_uart.c	72;"	d	file:
+DELAY_CMD5_PATCH	fw_loader_uart_v2.c	50;"	d	file:
+DI	fw_loader_uart.c	70;"	d	file:
+END_SIG	fw_loader_uart.c	67;"	d	file:
+END_SIG_TIMEOUT	fw_loader_uart.c	43;"	d	file:
+END_SIG_TIMEOUT	fw_loader_uart_v2.c	42;"	d	file:
+EntryPoint_Req	fw_loader_uart.c	/^static BOOLEAN EntryPoint_Req = FALSE;$/;"	v	file:
+FALSE	bt_vendor_nxp.h	57;"	d
+GP	fw_loader_uart.c	69;"	d	file:
+HCI_BT_SET_EVENTMASK_OCF	hardware_nxp.c	57;"	d	file:
+HCI_CMD_NXP_SET_SCO_DATA_PATH	hardware_nxp.c	47;"	d	file:
+HCI_CMD_NXP_WRITE_BD_ADDRESS	hardware_nxp.c	56;"	d	file:
+HCI_CMD_NXP_WRITE_PCM_LINK_SETTINGS	hardware_nxp.c	46;"	d	file:
+HCI_CMD_NXP_WRITE_PCM_SETTINGS	hardware_nxp.c	44;"	d	file:
+HCI_CMD_NXP_WRITE_PCM_SYNC_SETTINGS	hardware_nxp.c	45;"	d	file:
+HCI_CMD_NXP_WRITE_VOICE_SETTINGS	hardware_nxp.c	43;"	d	file:
+HCI_CMD_PREAMBLE_SIZE	hardware_nxp.c	66;"	d	file:
+HCI_COMMAND_COMPLETE_EVT	hardware_nxp.c	62;"	d	file:
+HCI_COMMAND_PREAMBLE_SIZE	hardware_nxp.c	73;"	d	file:
+HCI_CONTROLLER_CMD_OGF	hardware_nxp.c	58;"	d	file:
+HCI_DISABLE_PAGE_SCAN_OCF	hardware_nxp.c	60;"	d	file:
+HCI_EVENT_PREAMBLE_SIZE	hardware_nxp.c	71;"	d	file:
+HCI_EVT_CMD_CMPL_LOCAL_BDADDR_ARRAY	hardware_nxp.c	75;"	d	file:
+HCI_EVT_CMD_CMPL_OPCODE	hardware_nxp.c	67;"	d	file:
+HCI_PACKET_TYPE_EVENT	hardware_nxp.c	63;"	d	file:
+HCI_READ_LOCAL_BDADDR	hardware_nxp.c	61;"	d	file:
+HCI_RESET_OCF	hardware_nxp.c	59;"	d	file:
+HDR_LEN	fw_loader_uart.c	46;"	d	file:
+HDR_LEN	fw_loader_uart_v2.c	45;"	d	file:
+HELPER_HEADER	fw_loader_uart_v2.c	56;"	d	file:
+HELPER_HEADR_ACK	fw_loader_uart_v2.c	57;"	d	file:
+HELPER_TIMEOUT_ACK	fw_loader_uart_v2.c	58;"	d	file:
+ICR	fw_loader_uart.c	94;"	d	file:
+INIT	fw_loader_uart.c	93;"	d	file:
+INVALID_CMD_REC_BIT	fw_loader_uart.c	77;"	d	file:
+LOCAL_MODULE	Android.mk	/^LOCAL_MODULE := libbt-vendor$/;"	m
+LOCAL_MODULE	conf/nxp/evk_8mn/Android.mk	/^LOCAL_MODULE := bt_vendor.conf$/;"	m
+LOCAL_MODULE	conf/nxp/evk_8mp/Android.mk	/^LOCAL_MODULE := bt_vendor.conf$/;"	m
+LOCAL_MODULE	conf/nxp/evk_8mq/Android.mk	/^LOCAL_MODULE := bt_vendor.conf$/;"	m
+LOCAL_MODULE	conf/nxp/mek_8q/Android.mk	/^LOCAL_MODULE := bt_vendor.conf$/;"	m
+LOCAL_MODULE_CLASS	conf/nxp/evk_8mn/Android.mk	/^LOCAL_MODULE_CLASS := ETC$/;"	m
+LOCAL_MODULE_CLASS	conf/nxp/evk_8mp/Android.mk	/^LOCAL_MODULE_CLASS := ETC$/;"	m
+LOCAL_MODULE_CLASS	conf/nxp/evk_8mq/Android.mk	/^LOCAL_MODULE_CLASS := ETC$/;"	m
+LOCAL_MODULE_CLASS	conf/nxp/mek_8q/Android.mk	/^LOCAL_MODULE_CLASS := ETC$/;"	m
+LOCAL_MODULE_OWNER	Android.mk	/^LOCAL_MODULE_OWNER := nxp$/;"	m
+LOCAL_MODULE_PATH	conf/nxp/evk_8mn/Android.mk	/^LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)\/etc\/bluetooth$/;"	m
+LOCAL_MODULE_PATH	conf/nxp/evk_8mp/Android.mk	/^LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)\/etc\/bluetooth$/;"	m
+LOCAL_MODULE_PATH	conf/nxp/evk_8mq/Android.mk	/^LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)\/etc\/bluetooth$/;"	m
+LOCAL_MODULE_PATH	conf/nxp/mek_8q/Android.mk	/^LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)\/etc\/bluetooth$/;"	m
+LOCAL_MODULE_TAGS	Android.mk	/^LOCAL_MODULE_TAGS := optional$/;"	m
+LOCAL_MULTILIB	Android.mk	/^LOCAL_MULTILIB := both$/;"	m
+LOCAL_PATH	Android.mk	/^LOCAL_PATH := $(call my-dir)$/;"	m
+LOCAL_PATH	conf/nxp/evk_8mn/Android.mk	/^LOCAL_PATH := $(call my-dir)$/;"	m
+LOCAL_PATH	conf/nxp/evk_8mp/Android.mk	/^LOCAL_PATH := $(call my-dir)$/;"	m
+LOCAL_PATH	conf/nxp/evk_8mq/Android.mk	/^LOCAL_PATH := $(call my-dir)$/;"	m
+LOCAL_PATH	conf/nxp/mek_8q/Android.mk	/^LOCAL_PATH := $(call my-dir)$/;"	m
+LOCAL_PROPRIETARY_MODULE	Android.mk	/^LOCAL_PROPRIETARY_MODULE := true$/;"	m
+LOCAL_SHARED_LIBRARIES	Android.mk	/^LOCAL_SHARED_LIBRARIES := \\$/;"	m
+LOCAL_SRC_FILES	Android.mk	/^LOCAL_SRC_FILES := \\$/;"	m
+LOCAL_SRC_FILES	conf/nxp/evk_8mn/Android.mk	/^LOCAL_SRC_FILES := $(LOCAL_MODULE)$/;"	m
+LOCAL_SRC_FILES	conf/nxp/evk_8mp/Android.mk	/^LOCAL_SRC_FILES := $(LOCAL_MODULE)$/;"	m
+LOCAL_SRC_FILES	conf/nxp/evk_8mq/Android.mk	/^LOCAL_SRC_FILES := $(LOCAL_MODULE)$/;"	m
+LOCAL_SRC_FILES	conf/nxp/mek_8q/Android.mk	/^LOCAL_SRC_FILES := $(LOCAL_MODULE)$/;"	m
+LOG_TAG	bt_vendor_nxp.c	28;"	d	file:
+LOG_TAG	fw_loader_io.c	22;"	d	file:
+LOG_TAG	fw_loader_uart.c	30;"	d	file:
+LOG_TAG	fw_loader_uart_v2.c	30;"	d	file:
+LOG_TAG	hardware_nxp.c	19;"	d	file:
+MAX_CTS_TIMEOUT	fw_loader_uart.c	44;"	d	file:
+MAX_CTS_TIMEOUT	fw_loader_uart_v2.c	43;"	d	file:
+MAX_LENGTH	fw_loader_uart.c	42;"	d	file:
+MAX_LENGTH	fw_loader_uart_v2.c	41;"	d	file:
+MBTCHAR_IOCTL_RELEASE	bt_vendor_nxp.c	62;"	d	file:
+MCR	fw_loader_uart.c	92;"	d	file:
+NAK_REC_BIT	fw_loader_uart.c	73;"	d	file:
+NXP_INIT_SCO_CFG_INCLUDED	hardware_nxp.c	35;"	d	file:
+NXP_VND_DBG	bt_vendor_nxp.h	66;"	d
+OpCodePack	hardware_nxp.c	93;"	d	file:
+POLL_AA_TIMEOUT	fw_loader_uart_v2.c	51;"	d	file:
+POLL_DRIVER_DURATION_US	bt_vendor_nxp.c	72;"	d	file:
+POLL_DRIVER_MAX_TIME_MS	bt_vendor_nxp.c	73;"	d	file:
+POLYNOMIAL	fw_loader_uart.c	84;"	d	file:
+PRINT	fw_loader_uart.c	61;"	d	file:
+PRINT	fw_loader_uart_v2.c	61;"	d	file:
+PRINT_INFO	fw_loader_uart.c	34;"	d	file:
+PROP_BLUETOOTH_DELAY	bt_vendor_nxp.c	66;"	d	file:
+PROP_BLUETOOTH_FW_DOWNLOADED	bt_vendor_nxp.c	65;"	d	file:
+PROP_BLUETOOTH_OPENED	bt_vendor_nxp.c	64;"	d	file:
+REQ_HEADER_LEN	fw_loader_uart.c	63;"	d	file:
+RW_FAILURE	bt_vendor_nxp.h	52;"	d
+RW_SUCCESSFUL	bt_vendor_nxp.h	51;"	d
+SET_SCO_DATA_PATH_SIZE	hardware_nxp.c	53;"	d	file:
+STREAM_TO_UINT16	hardware_nxp.c	78;"	d	file:
+STRING_SIZE	fw_loader_uart.c	45;"	d	file:
+STRING_SIZE	fw_loader_uart_v2.c	44;"	d	file:
+SWAPL	fw_loader_uart.c	81;"	d	file:
+TIMEOUT_FOR_READ	fw_loader_uart.c	37;"	d	file:
+TIMEOUT_FOR_READ	fw_loader_uart_v2.c	36;"	d	file:
+TIMEOUT_REC_ACK_BIT	fw_loader_uart.c	74;"	d	file:
+TIMEOUT_REC_DATA_BIT	fw_loader_uart.c	76;"	d	file:
+TIMEOUT_REC_HEAD_BIT	fw_loader_uart.c	75;"	d	file:
+TIMEOUT_SEC	bt_vendor_nxp.h	50;"	d
+TIMEOUT_SEC	fw_loader_io.c	28;"	d	file:
+TIMEOUT_VAL_MILLISEC	fw_loader_uart.c	95;"	d	file:
+TIMEOUT_VAL_MILLISEC	fw_loader_uart_v2.c	52;"	d	file:
+TRUE	bt_vendor_nxp.h	56;"	d
+UARTDIVAddr	fw_loader_uart.c	87;"	d	file:
+UARTICRAddr	fw_loader_uart.c	90;"	d	file:
+UARTMCRAddr	fw_loader_uart.c	88;"	d	file:
+UARTREINITAddr	fw_loader_uart.c	89;"	d	file:
+UART_BAUDRATE	fw_loader_uart.h	/^} UART_BAUDRATE;$/;"	t	typeref:struct:__anon1
+UINT16_TO_STREAM	hardware_nxp.c	84;"	d	file:
+UINT8_TO_STREAM	hardware_nxp.c	90;"	d	file:
+UNUSED	bt_vendor_nxp.c	79;"	d	file:
+USE_CONTROLLER_BDADDR	hardware_nxp.c	39;"	d	file:
+UartCfgTbl	fw_loader_uart.c	/^const UART_BAUDRATE UartCfgTbl[] = {$/;"	v
+V1_HEADER_DATA_REQ	fw_loader_uart.c	51;"	d	file:
+V1_REQUEST_ACK	fw_loader_uart.c	52;"	d	file:
+V1_START_INDICATION	fw_loader_uart.c	53;"	d	file:
+V3_CRC_ERROR	fw_loader_uart.c	59;"	d	file:
+V3_HEADER_DATA_REQ	fw_loader_uart.c	56;"	d	file:
+V3_REQUEST_ACK	fw_loader_uart.c	57;"	d	file:
+V3_START_INDICATION	fw_loader_uart.c	55;"	d	file:
+V3_TIMEOUT_ACK	fw_loader_uart.c	58;"	d	file:
+VENDOR_LIB_CONF_FILE	bt_vendor_nxp.h	62;"	d
+VERSION	fw_loader_uart.c	41;"	d	file:
+VERSION	fw_loader_uart_v2.c	40;"	d	file:
+VERSION_HEADER	fw_loader_uart_v2.c	59;"	d	file:
+VNDDBG	bt_vendor_nxp.h	70;"	d
+VNDDBG	bt_vendor_nxp.h	73;"	d
+Ver1	fw_loader_uart.c	/^  Ver1,$/;"	e	enum:__anon2	file:
+Ver2	fw_loader_uart.c	/^  Ver2,$/;"	e	enum:__anon2	file:
+Ver3	fw_loader_uart.c	/^  Ver3,$/;"	e	enum:__anon2	file:
+Version	fw_loader_uart.c	/^} Version;$/;"	t	typeref:enum:__anon2	file:
+WIFI_MIC_FAIL_BIT	fw_loader_uart.c	78;"	d	file:
+WRITE_BD_ADDRESS_SIZE	bt_vendor_nxp.h	58;"	d
+WRITE_BD_ADDRESS_SIZE	hardware_nxp.c	65;"	d	file:
+WRITE_BD_ADDRESS_SIZE	hardware_nxp.c	74;"	d	file:
+WRITE_PCM_LINK_SETTINGS_SIZE	hardware_nxp.c	52;"	d	file:
+WRITE_PCM_SETTINGS_SIZE	hardware_nxp.c	50;"	d	file:
+WRITE_PCM_SYNC_SETTINGS_SIZE	hardware_nxp.c	51;"	d	file:
+WRITE_VOICE_SETTINGS_SIZE	hardware_nxp.c	49;"	d	file:
+_BT_VENDOR_NXP_H	bt_vendor_nxp.h	20;"	d
+_FW_LOADER_H	fw_loader_uart.h	20;"	d
+_FW_LOADER_IO_LINUX_H	fw_loader_io.h	21;"	d
+_FW_LOADER_V2_H	fw_loader_uart_v2.h	20;"	d
+adapterState	bt_vendor_nxp.c	/^static uint8_t adapterState;$/;"	v	file:
+b16BytesData	fw_loader_uart.c	/^static BOOLEAN b16BytesData = FALSE;$/;"	v	file:
+b16BytesData	fw_loader_uart_v2.c	/^static BOOLEAN b16BytesData = FALSE;$/;"	v	file:
+bVerChecked	fw_loader_uart.c	/^static BOOLEAN bVerChecked = FALSE;$/;"	v	file:
+baudrate_bt	bt_vendor_nxp.c	/^static int32_t baudrate_bt = 3000000;$/;"	v	file:
+baudrate_dl_helper	bt_vendor_nxp.c	/^static int32_t baudrate_dl_helper = 115200;$/;"	v	file:
+baudrate_dl_image	bt_vendor_nxp.c	/^static int32_t baudrate_dl_image = 3000000;$/;"	v	file:
+baudrate_fw_init	bt_vendor_nxp.c	/^static int32_t baudrate_fw_init = 115200;$/;"	v	file:
+bdaddr	bt_vendor_nxp.c	/^unsigned char* bdaddr = NULL;$/;"	v
+bt_bdaddress_set	hardware_nxp.c	/^static void bt_bdaddress_set(void) {$/;"	f	file:
+bt_evt_param_t	hardware_nxp.c	/^struct bt_evt_param_t {$/;"	s	file:
+bt_vnd_cleanup	bt_vendor_nxp.c	/^static void bt_vnd_cleanup(void) {$/;"	f	file:
+bt_vnd_init	bt_vendor_nxp.c	/^static int bt_vnd_init(const bt_vendor_callbacks_t* p_cb,$/;"	f	file:
+bt_vnd_mrvl_check_fw_status	fw_loader_uart.c	/^BOOLEAN bt_vnd_mrvl_check_fw_status() {$/;"	f
+bt_vnd_mrvl_check_fw_status_v2	fw_loader_uart_v2.c	/^BOOLEAN bt_vnd_mrvl_check_fw_status_v2() {$/;"	f
+bt_vnd_mrvl_download_fw	fw_loader_uart.c	/^int bt_vnd_mrvl_download_fw(int8 *pPortName, int32 iBaudrate, int8 *pFileName, int32 iSecondBaudrate) {$/;"	f
+bt_vnd_mrvl_download_fw_v2	fw_loader_uart_v2.c	/^int bt_vnd_mrvl_download_fw_v2(int8 *pPortName, int32 iBaudrate, int8 *pFileName) {$/;"	f
+bt_vnd_op	bt_vendor_nxp.c	/^static int bt_vnd_op(bt_vendor_opcode_t opcode, void* param) {$/;"	f	file:
+build_cmd_buf	hardware_nxp.c	/^static HC_BT_HDR* build_cmd_buf(uint16_t cmd, uint8_t pl_len,$/;"	f	file:
+change_baudrata_buffer_len	fw_loader_uart.c	/^static uint32 change_baudrata_buffer_len = 0;$/;"	v	file:
+cmd	hardware_nxp.c	/^  uint16_t cmd;$/;"	m	struct:bt_evt_param_t	file:
+cmd7_Req	fw_loader_uart.c	/^static BOOLEAN cmd7_Req = FALSE;$/;"	v	file:
+cmd_ret_param	hardware_nxp.c	/^  uint8_t cmd_ret_param;$/;"	m	struct:bt_evt_param_t	file:
+cmd_to_str	hardware_nxp.c	/^static char* cmd_to_str(uint16_t cmd) {$/;"	f	file:
+conf_action_t	bt_vendor_nxp.c	/^typedef int(conf_action_t)(char* p_conf_name, char* p_conf_value, int param);$/;"	t	file:
+conf_entry	bt_vendor_nxp.c	/^  const char* conf_entry;$/;"	m	struct:__anon3	file:
+conf_entry_t	bt_vendor_nxp.c	/^} conf_entry_t;$/;"	t	typeref:struct:__anon3	file:
+conf_table	bt_vendor_nxp.c	/^static const conf_entry_t conf_table[] = {$/;"	v	file:
+config_uart	bt_vendor_nxp.c	/^static int config_uart() {$/;"	f	file:
+crc8	fw_loader_uart.c	/^static unsigned char crc8(unsigned char *array, unsigned char len) {$/;"	f	file:
+crc8_table	fw_loader_uart.c	/^static unsigned char crc8_table[256]; \/* 8-bit table *\/$/;"	v	file:
+crc_table	fw_loader_uart.c	/^static unsigned long crc_table[256];$/;"	v	file:
+detect_and_download_fw	bt_vendor_nxp.c	/^static int detect_and_download_fw() {$/;"	f	file:
+dev_file_lock	bt_vendor_nxp.c	/^static pthread_mutex_t dev_file_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
+download_helper	bt_vendor_nxp.c	/^static int download_helper = 0;$/;"	v	file:
+enable_download_fw	bt_vendor_nxp.c	/^static int enable_download_fw = 0;$/;"	v	file:
+fw_Change_Baudrate	fw_loader_uart.c	/^static int32 fw_Change_Baudrate(int8 *pPortName, int32 iFirstBaudRate, int32 iSecondBaudRate) {$/;"	f	file:
+fw_upload_Check_ReqCrc	fw_loader_uart.c	/^BOOLEAN fw_upload_Check_ReqCrc(uint8 *uiStr, uint8 uiReq) {$/;"	f
+fw_upload_ComGetCTS	fw_loader_io.c	/^int32 fw_upload_ComGetCTS(int32 mchar_fd) {$/;"	f
+fw_upload_ComReadChar	fw_loader_io.c	/^int32 fw_upload_ComReadChar(int32 mchar_fd) {$/;"	f
+fw_upload_ComReadChars	fw_loader_io.c	/^int32 fw_upload_ComReadChars(int32 mchar_fd, uint8* pBuffer, uint32 uiCount) {$/;"	f
+fw_upload_ComWriteChar	fw_loader_io.c	/^int8 fw_upload_ComWriteChar(int32 mchar_fd, int8 iChar) {$/;"	f
+fw_upload_ComWriteChars	fw_loader_io.c	/^int8 fw_upload_ComWriteChars(int32 mchar_fd, uint8* pBuffer, uint32 uiLen) {$/;"	f
+fw_upload_DelayInMs	fw_loader_io.c	/^void fw_upload_DelayInMs(uint32 uiMs) {$/;"	f
+fw_upload_FW	fw_loader_uart.c	/^static BOOLEAN fw_upload_FW(int8 *pPortName, int32 iBaudRate, int8 *pFileName, int32 iSecondBaudRate) {$/;"	f	file:
+fw_upload_FW	fw_loader_uart_v2.c	/^static BOOLEAN fw_upload_FW(int8 *pFileName) {$/;"	f	file:
+fw_upload_GetBufferSize	fw_loader_io.c	/^int32 fw_upload_GetBufferSize(int32 mchar_fd) {$/;"	f
+fw_upload_GetCmd	fw_loader_uart.c	/^static uint32 fw_upload_GetCmd(uint8 *buf) {$/;"	f	file:
+fw_upload_GetDataLen	fw_loader_io.c	/^uint16 fw_upload_GetDataLen(uint8 *buf) {$/;"	f
+fw_upload_GetHeaderStartBytes	fw_loader_uart.c	/^static void fw_upload_GetHeaderStartBytes(uint8 *ucStr) {$/;"	f	file:
+fw_upload_GetHeaderStartBytes	fw_loader_uart_v2.c	/^static void fw_upload_GetHeaderStartBytes(uint8 *ucStr)$/;"	f	file:
+fw_upload_GetLast5Bytes	fw_loader_uart.c	/^static void fw_upload_GetLast5Bytes(uint8 *buf) {$/;"	f	file:
+fw_upload_GetLast5Bytes	fw_loader_uart_v2.c	/^static void fw_upload_GetLast5Bytes(uint8 *buf)$/;"	f	file:
+fw_upload_GetTime	fw_loader_io.c	/^double fw_upload_GetTime(void) {$/;"	f
+fw_upload_SendBuffer	fw_loader_uart.c	/^static uint16 fw_upload_SendBuffer(uint16 uiLenToSend, uint8 *ucBuf, BOOLEAN uiHighBaudrate) {$/;"	f	file:
+fw_upload_SendBuffer	fw_loader_uart_v2.c	/^uint16 fw_upload_SendBuffer(uint16 uiLenToSend, uint8 *ucBuf)$/;"	f
+fw_upload_SendIntBytes	fw_loader_uart_v2.c	/^static void fw_upload_SendIntBytes(uint32 ulBytesToSent)$/;"	f	file:
+fw_upload_SendLenBytes	fw_loader_uart_v2.c	/^static uint16 fw_upload_SendLenBytes(uint8* pFileBuffer, uint16 uiLenToSend)$/;"	f	file:
+fw_upload_SendLenBytesToHelper	fw_loader_uart_v2.c	/^static void fw_upload_SendLenBytesToHelper(uint8* pFileBuffer, uint16 uiLenToSend, uint32 ulOffset)$/;"	f	file:
+fw_upload_Send_Ack	fw_loader_uart.c	/^static void fw_upload_Send_Ack(uint8 uiAck) {$/;"	f	file:
+fw_upload_StoreBytes	fw_loader_uart.c	/^static void fw_upload_StoreBytes(uint32 ulVal, uint8 uiSize, uint8 *uiStored) {$/;"	f	file:
+fw_upload_V1SendLenBytes	fw_loader_uart.c	/^static uint16 fw_upload_V1SendLenBytes(uint8 * pFileBuffer, uint16 uiLenToSend) {$/;"	f	file:
+fw_upload_V3SendLenBytes	fw_loader_uart.c	/^static void fw_upload_V3SendLenBytes(uint8 * pFileBuffer, uint16 uiLenToSend, uint32 ulOffset) {$/;"	f	file:
+fw_upload_WaitForHeaderSignature	fw_loader_uart.c	/^fw_upload_WaitForHeaderSignature(uint32 uiMs)$/;"	f	file:
+fw_upload_WaitForHeaderSignature	fw_loader_uart_v2.c	/^static BOOLEAN fw_upload_WaitForHeaderSignature(uint32 uiMs)$/;"	f	file:
+fw_upload_WaitFor_ErrCode	fw_loader_uart_v2.c	/^static uint16 fw_upload_WaitFor_ErrCode()$/;"	f	file:
+fw_upload_WaitFor_Len	fw_loader_uart.c	/^static uint16 fw_upload_WaitFor_Len(FILE *pFile) {$/;"	f	file:
+fw_upload_WaitFor_Len	fw_loader_uart_v2.c	/^static uint16 fw_upload_WaitFor_Len(FILE* pFile)$/;"	f	file:
+fw_upload_WaitFor_Offset	fw_loader_uart_v2.c	/^static uint32 fw_upload_WaitFor_Offset()$/;"	f	file:
+fw_upload_WaitFor_Req	fw_loader_uart.c	/^static void fw_upload_WaitFor_Req() {$/;"	f	file:
+fw_upload_gen_crc_table	fw_loader_uart.c	/^void fw_upload_gen_crc_table() {$/;"	f
+fw_upload_lenValid	fw_loader_io.c	/^BOOLEAN fw_upload_lenValid(uint16 *uiLenToSend, uint8 *ucArray) {$/;"	f
+fw_upload_update_crc	fw_loader_uart.c	/^unsigned long fw_upload_update_crc(unsigned long crc_accum, char *data_blk_ptr, int data_blk_size) {$/;"	f
+get_prop_int32	bt_vendor_nxp.c	/^static int get_prop_int32(char* name) {$/;"	f	file:
+hw_config_callback	hardware_nxp.c	/^static void hw_config_callback(void* packet) {$/;"	f	file:
+hw_config_read_bdaddr	hardware_nxp.c	/^static void hw_config_read_bdaddr(void) {$/;"	f	file:
+hw_config_set_bdaddr	hardware_nxp.c	/^static void hw_config_set_bdaddr(void) {$/;"	f	file:
+hw_config_start	hardware_nxp.c	/^void hw_config_start(void) {$/;"	f
+hw_sco_config	hardware_nxp.c	/^static void hw_sco_config(void) {$/;"	f	file:
+hw_sco_config_cb	hardware_nxp.c	/^static void hw_sco_config_cb(void* p_mem) {$/;"	f	file:
+iBaudRate	fw_loader_uart.h	/^  uint32 iBaudRate;$/;"	m	struct:__anon1
+iClkDivisor	fw_loader_uart.h	/^  uint32 iClkDivisor;$/;"	m	struct:__anon1
+iSecondBaudrate	bt_vendor_nxp.c	/^static int32_t iSecondBaudrate = 0;$/;"	v	file:
+iUartDivisor	fw_loader_uart.h	/^  uint32 iUartDivisor;$/;"	m	struct:__anon1
+init_crc8	fw_loader_uart.c	/^void init_crc8() {$/;"	f
+init_uart	bt_vendor_nxp.c	/^int32 init_uart(int8* dev, int32 dwBaudRate, uint8 ucFlowCtrl) {$/;"	f
+int16	bt_vendor_nxp.h	/^typedef short int16;$/;"	t
+int32	bt_vendor_nxp.h	/^typedef int int32;$/;"	t
+int8	bt_vendor_nxp.h	/^typedef char int8;$/;"	t
+is_uart_port	bt_vendor_nxp.c	/^static int is_uart_port = 0;$/;"	v	file:
+m_Buffer_CMD5_Header	fw_loader_uart.c	/^int8 m_Buffer_CMD5_Header[16] = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,$/;"	v
+made_table	fw_loader_uart.c	/^static int made_table = 0;$/;"	v	file:
+make_command	hardware_nxp.c	/^static HC_BT_HDR* make_command(uint16_t opcode, size_t parameter_size) {$/;"	f	file:
+mbt_port	bt_vendor_nxp.c	/^static char mbt_port[512] = "\/dev\/mbtchar0";$/;"	v	file:
+mchar_fd	bt_vendor_nxp.c	/^int mchar_fd = 0;$/;"	v
+mchar_port	bt_vendor_nxp.c	/^static char mchar_port[512] = "\/dev\/ttyUSB0";$/;"	v	file:
+pFile	fw_loader_uart_v2.c	/^static FILE* pFile = NULL;$/;"	v	file:
+pFileName_helper	bt_vendor_nxp.c	/^static char pFileName_helper[512] = "\/vendor\/firmware\/helper_uart_3000000.bin";$/;"	v	file:
+pFileName_image	bt_vendor_nxp.c	/^static char pFileName_image[512] = "\/vendor\/firmware\/uart8997_bt_v4.bin";$/;"	v	file:
+p_action	bt_vendor_nxp.c	/^  conf_action_t* p_action;$/;"	m	struct:__anon3	file:
+param	bt_vendor_nxp.c	/^  int param;$/;"	m	struct:__anon3	file:
+parse_evt_buf	hardware_nxp.c	/^static void parse_evt_buf(HC_BT_HDR* p_evt_buf,$/;"	f	file:
+perror	fw_loader_io.c	25;"	d	file:
+printf	fw_loader_uart.c	33;"	d	file:
+printf	fw_loader_uart_v2.c	33;"	d	file:
+read_hci_event	bt_vendor_nxp.c	/^static int read_hci_event(int fd, unsigned char* buf, int size) {$/;"	f	file:
+resync	fw_loader_uart.c	/^jmp_buf resync;  \/\/ Protocol restart buffer used in timeout cases.$/;"	v
+resync	fw_loader_uart_v2.c	/^jmp_buf resync;  \/\/ Protocol restart buffer used in timeout cases.$/;"	v
+set_baudrate_bt	bt_vendor_nxp.c	/^static int set_baudrate_bt(char* p_conf_name, char* p_conf_value, int param) {$/;"	f	file:
+set_baudrate_dl_helper	bt_vendor_nxp.c	/^static int set_baudrate_dl_helper(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_baudrate_dl_image	bt_vendor_nxp.c	/^static int set_baudrate_dl_image(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_baudrate_fw_init	bt_vendor_nxp.c	/^static int set_baudrate_fw_init(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_bd_address_buf	bt_vendor_nxp.c	/^static int set_bd_address_buf(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_enable_download_fw	bt_vendor_nxp.c	/^static int set_enable_download_fw(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_iSecondBaudrate	bt_vendor_nxp.c	/^static int set_iSecondBaudrate(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_is_uart_port	bt_vendor_nxp.c	/^static int set_is_uart_port(char* p_conf_name, char* p_conf_value, int param) {$/;"	f	file:
+set_mbt_port	bt_vendor_nxp.c	/^static int set_mbt_port(char* p_conf_name, char* p_conf_value, int param) {$/;"	f	file:
+set_mchar_port	bt_vendor_nxp.c	/^static int set_mchar_port(char* p_conf_name, char* p_conf_value, int param) {$/;"	f	file:
+set_pFileName_helper	bt_vendor_nxp.c	/^static int set_pFileName_helper(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_pFileName_image	bt_vendor_nxp.c	/^static int set_pFileName_image(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_prop_int32	bt_vendor_nxp.c	/^static int set_prop_int32(char* name, int value) {$/;"	f	file:
+set_sco_data_path	hardware_nxp.c	/^static uint8_t set_sco_data_path[SET_SCO_DATA_PATH_SIZE] = {0x01};$/;"	v	file:
+set_speed	bt_vendor_nxp.c	/^static int set_speed(int fd, struct termios* ti, int speed) {$/;"	f	file:
+set_uart_break_after_dl_helper	bt_vendor_nxp.c	/^static int set_uart_break_after_dl_helper(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+set_uart_break_before_change_baudrate	bt_vendor_nxp.c	/^static int set_uart_break_before_change_baudrate(char* p_conf_name,$/;"	f	file:
+set_uart_break_before_open	bt_vendor_nxp.c	/^static int set_uart_break_before_open(char* p_conf_name, char* p_conf_value,$/;"	f	file:
+ti	bt_vendor_nxp.c	/^struct termios ti;$/;"	v	typeref:struct:termios
+uart_break_after_dl_helper	bt_vendor_nxp.c	/^static int uart_break_after_dl_helper = 0;$/;"	v	file:
+uart_break_before_change_baudrate	bt_vendor_nxp.c	/^int uart_break_before_change_baudrate = 0;$/;"	v
+uart_break_before_open	bt_vendor_nxp.c	/^static int uart_break_before_open = 0;$/;"	v	file:
+uart_init_open	bt_vendor_nxp.c	/^static int uart_init_open(int8* dev, int32 dwBaudRate, uint8 ucFlowCtrl) {$/;"	f	file:
+uart_set_speed	bt_vendor_nxp.c	/^static int32 uart_set_speed(int32 fd, struct termios* ti, int32 speed) {$/;"	f	file:
+uart_sleep_after_dl	bt_vendor_nxp.c	/^static int uart_sleep_after_dl = 700;$/;"	v	file:
+uart_speed	bt_vendor_nxp.c	/^static int32 uart_speed(int32 s) {$/;"	f	file:
+ucByteBuffer	fw_loader_uart.c	/^static uint8 ucByteBuffer[MAX_LENGTH];$/;"	v	file:
+ucByteBuffer	fw_loader_uart_v2.c	/^static uint8 ucByteBuffer[MAX_LENGTH];$/;"	v	file:
+ucCalCrc	fw_loader_uart.c	/^static uint8 ucCalCrc[10];$/;"	v	file:
+ucCmd5Patch	fw_loader_uart_v2.c	/^uint8 ucCmd5Patch[28] = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x9D, 0x32, 0xBB, 0x11,$/;"	v
+ucCmd5Sent	fw_loader_uart_v2.c	/^static uint8   ucCmd5Sent = 0;$/;"	v	file:
+ucHelperOn	fw_loader_uart_v2.c	/^static BOOLEAN ucHelperOn = FALSE;$/;"	v	file:
+ucRcvdHeader	fw_loader_uart.c	/^static uint8 ucRcvdHeader;$/;"	v	file:
+ucRcvdHeader	fw_loader_uart_v2.c	/^static uint8   ucRcvdHeader = 0xFF;$/;"	v	file:
+ucString	fw_loader_uart.c	/^static uint8 ucString[STRING_SIZE];$/;"	v	file:
+ucString	fw_loader_uart_v2.c	/^static uint8   ucString[STRING_SIZE];$/;"	v	file:
+uiErrCase	fw_loader_uart.c	/^static BOOLEAN uiErrCase = FALSE;$/;"	v	file:
+uiErrCase	fw_loader_uart_v2.c	/^static BOOLEAN uiErrCase = FALSE;$/;"	v	file:
+uiErrCnt	fw_loader_uart.c	/^uint8 uiErrCnt[16] = {0};$/;"	v
+uiNewCrc	fw_loader_uart.c	/^static uint8 uiNewCrc;$/;"	v	file:
+uiNewError	fw_loader_uart.c	/^static uint16 uiNewError;$/;"	v	file:
+uiNewLen	fw_loader_uart.c	/^static uint16 uiNewLen;$/;"	v	file:
+uiProVer	fw_loader_uart.c	/^static uint8 uiProVer;$/;"	v	file:
+uiReDownload	fw_loader_uart_v2.c	/^static BOOLEAN uiReDownload = FALSE;$/;"	v	file:
+uint16	bt_vendor_nxp.h	/^typedef unsigned short uint16;$/;"	t
+uint32	bt_vendor_nxp.h	/^typedef unsigned int uint32;$/;"	t
+uint64	bt_vendor_nxp.h	/^typedef unsigned long long uint64;$/;"	t
+uint8	bt_vendor_nxp.h	/^typedef unsigned char uint8;$/;"	t
+ulCurrFileSize	fw_loader_uart.c	/^static uint32 ulCurrFileSize = 0;$/;"	v	file:
+ulCurrFileSize	fw_loader_uart_v2.c	/^static uint32 ulCurrFileSize = 0;$/;"	v	file:
+ulLastOffsetToSend	fw_loader_uart.c	/^static uint32 ulLastOffsetToSend = 0xFFFF;$/;"	v	file:
+ulLastOffsetToSend	fw_loader_uart_v2.c	/^static uint32 ulLastOffsetToSend = 0xFFFF;$/;"	v	file:
+ulNewOffset	fw_loader_uart.c	/^static uint32 ulNewOffset;$/;"	v	file:
+ulTotalFileSize	fw_loader_uart.c	/^static uint32 ulTotalFileSize = 0;$/;"	v	file:
+ulTotalFileSize	fw_loader_uart_v2.c	/^static uint32 ulTotalFileSize = 0;$/;"	v	file:
+vnd_cb	bt_vendor_nxp.c	/^const bt_vendor_callbacks_t* vnd_cb = NULL;$/;"	v
+vnd_load_conf	bt_vendor_nxp.c	/^static void vnd_load_conf(const char* p_path) {$/;"	f	file:
+write_bd_address	bt_vendor_nxp.c	/^uint8_t write_bd_address[WRITE_BD_ADDRESS_SIZE] = {$/;"	v
+write_bdaddrss	bt_vendor_nxp.c	/^int write_bdaddrss = 0;$/;"	v
+write_pcm_link_settings	hardware_nxp.c	/^static uint8_t write_pcm_link_settings[WRITE_PCM_LINK_SETTINGS_SIZE] = {0x04,$/;"	v	file:
+write_pcm_settings	hardware_nxp.c	/^static uint8_t write_pcm_settings[WRITE_PCM_SETTINGS_SIZE] = {0x00};$/;"	v	file:
+write_pcm_sync_settings	hardware_nxp.c	/^static uint8_t write_pcm_sync_settings[WRITE_PCM_SYNC_SETTINGS_SIZE] = {$/;"	v	file:
+write_voice_settings	hardware_nxp.c	/^static uint8_t write_voice_settings[WRITE_VOICE_SETTINGS_SIZE] = {0x61, 0x00};$/;"	v	file:
diff --git a/88x9098/bt/muart_src/.config b/88x9098/bt/muart_src/.config
new file mode 100644
index 0000000..8b81e9b
--- /dev/null
+++ b/88x9098/bt/muart_src/.config
@@ -0,0 +1,2 @@
+CONFIG_X86=y
+CONFIG_FEATURE_PACK=default
diff --git a/88x9098/bt/muart_src/Makefile b/88x9098/bt/muart_src/Makefile
new file mode 100644
index 0000000..4589fc8
--- /dev/null
+++ b/88x9098/bt/muart_src/Makefile
@@ -0,0 +1,342 @@
+#
+# Makefile for UART Linux Bluetooth HCI device drivers.
+#
+
+
+ifneq ($(M),)
+CONFIG_FILE := $(M)/.config
+-include $(CONFIG_FILE)
+else
+CONFIG_FILE := $(PWD)/.config
+-include $(CONFIG_FILE)
+endif
+
+ifeq ($(CONFIG_BG2), y)
+CONFIG_PXA9XX=y
+CONFIG_PXA3XX=y
+KERNELDIR ?= /usr/src/arm/linux-3.0.8-bg2
+CROSS_COMPILE ?= /usr/local/arm-eabi-4.4.3/bin/arm-eabi-
+endif
+
+ifeq ($(CONFIG_HIKEY), y)
+ARCH ?= arm64
+CROSS_COMPILE ?= /usr/local/arm/aarch64-linux-android-4.9/bin/aarch64-linux-android-
+KERNELDIR ?= /usr/src/arm/Kernel_hikey960_AndroidP_kernel4.9
+endif
+
+ifeq ($(CONFIG_MMP2), y)
+ARCH ?= arm
+KERNELDIR ?= /home/marvell/mmp2/android/kernel/kernel
+CROSS_COMPILE ?= /home/marvell/mmp2/android/vendor/marvell/generic/toolchain/arm-marvell-linux-gnueabi-vfp-4.2.0/bin/arm-marvell-linux-gnueabi-
+endif
+
+ifeq ($(CONFIG_IMX8), y)
+ARCH ?= arm64
+ifeq ($(KMINORVER),10Y_AR)
+KERNELDIR ?= /usr/src/arm/androidR_kernel/kernel_imx_5_10_y
+CROSS_COMPILE ?= aarch64-linux-gnu-
+endif
+ifeq ($(KMINORVER),1035_AR)
+KERNELDIR ?= /usr/src/arm/androidR_kernel/kernel_imx_5_10_35
+CROSS_COMPILE ?= aarch64-linux-gnu-
+endif
+ifeq ($(KMINORVER),1072_AR)
+KERNELDIR ?= /usr/src/arm/androidR_kernel/kernel_imx_5_10_72
+CROSS_COMPILE ?= aarch64-linux-gnu-
+endif
+ifeq ($(KMINORVER),1072_AAR)
+KERNELDIR ?= /usr/src/arm/Android_auto/kernel_imx_5_10_72_Auto
+CROSS_COMPILE ?= aarch64-linux-gnu-
+endif
+ifeq ($(KMINORVER),1072_AS)
+KERNELDIR ?= /usr/src/arm/androidS_kernel/kernel_imx_5_10_72
+CROSS_COMPILE ?= aarch64-linux-gnu-
+endif
+ifeq ($(KMINORVER),1072_AAS)
+KERNELDIR ?= /usr/src/arm/Android_auto/androidS_kernel/kernel_imx_5_10_72_Auto
+CROSS_COMPILE ?= aarch64-linux-gnu-
+endif
+ifeq ($(KMINORVER),47)
+KERNELDIR ?= /usr/src/arm/androidQ_kernel/kernel_imx_5_4_47
+CROSS_COMPILE ?= /usr/local/arm/androidQ_toolchain/aarch64-linux-android-4.9/bin/aarch64-linux-android-
+endif
+ifeq ($(KMINORVER),24)
+KERNELDIR ?= /usr/src/arm/androidQ_kernel/kernel_imx_5_4_24
+CROSS_COMPILE ?= /usr/local/arm/androidQ_toolchain/aarch64-linux-android-4.9/bin/aarch64-linux-android-
+endif
+ifeq ($(KMINORVER),3)
+KERNELDIR ?= /usr/src/arm/androidQ_kernel/kernel_imx_5_4_3
+CROSS_COMPILE ?= /usr/local/arm/androidQ_toolchain/aarch64-linux-android-4.9/bin/aarch64-linux-android-
+endif
+ifeq ($(KMINORVER),42)
+KERNELDIR ?= /usr/src/arm/androidQ_kernel/kernel_imx
+CROSS_COMPILE ?= /usr/local/arm/androidQ_toolchain/aarch64-linux-android-4.9/bin/aarch64-linux-android-
+endif
+ifeq ($(KMINORVER),10Y_LNX)
+KERNELDIR ?= /usr/src/arm/linux_5_10_y_kernel/linux-nxp
+CROSS_COMPILE ?= /opt/fsl-imx-internal-xwayland/5.10-gatesgarth/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-
+endif
+ifeq ($(KMINORVER),1035_LNX)
+KERNELDIR ?= /usr/src/arm/linux_5_10_35_kernel/linux-nxp
+CROSS_COMPILE ?= /opt/fsl-imx-internal-xwayland/5.10-gatesgarth/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-
+endif
+ifeq ($(KMINORVER),1072_LNX)
+KERNELDIR ?= /opt2/src/arm/linux-lts-nxp
+CROSS_COMPILE ?= /opt/fsl-imx-internal-xwayland/5.10-gatesgarth/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-
+endif
+ifeq ($(KMINORVER),1035_RC2_LNX)
+KERNELDIR ?= /usr/src/arm/linux_5_10_35_rc2_kernel/linux-nxp
+CROSS_COMPILE ?= /opt/fsl-imx-internal-xwayland/5.10-gatesgarth/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-
+endif
+ifeq ($(KMINORVER),47_LNX)
+KERNELDIR ?= /usr/src/arm/linux_5_4_47_kernel/linux-imx
+CROSS_COMPILE ?= /opt/fsl-imx-internal-xwayland/5.4-zeus/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-
+endif
+endif
+
+
+ifeq ($(CONFIG_T3T), y)
+ARCH ?= arm
+ifeq ($(KVER),3)
+ifeq ($(KMINORVER),110_JB)
+KERNELDIR ?= /usr/src/arm/linux-3.1.10-JB-T3T/
+else
+KERNELDIR ?= /usr/src/arm/linux-3.1.10-T3T/
+endif
+else
+ifeq ($(KMINORVER),39)
+KERNELDIR ?= /usr/src/arm/linux-2.6.39-T3T
+else
+KERNELDIR ?= /Projects2/Tegra/T3T/kernel/linux-2.6/out
+endif
+endif
+CROSS_COMPILE ?= /usr/local/arm-eabi-4.4.3/bin/arm-eabi-
+endif
+
+ifeq ($(CONFIG_PXA978T), y)
+CONFIG_PXA9XX=y
+endif
+ifeq ($(CONFIG_PXA955), y)
+CONFIG_PXA9XX=y
+endif
+ifeq ($(CONFIG_PXA950), y)
+CONFIG_PXA9XX=y
+endif
+ifeq ($(CONFIG_PXA920), y)
+CONFIG_PXA9XX=y
+endif
+ifeq ($(CONFIG_PXA9XX), y)
+EXTRA_CFLAGS += -DPXA9XX
+ifeq ($(CONFIG_PXA955), y)
+EXTRA_CFLAGS += -DPXA955
+KERNELDIR ?= /home/marvell/pxa_955/pxa955_froyo_147/kernel/kernel
+CROSS_COMPILE ?= /home/marvell/pxa_955/pxa955_froyo_147/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
+else
+ifeq ($(CONFIG_PXA950), y)
+EXTRA_CFLAGS += -DPXA950
+KERNELDIR ?= /usr/src/arm/linux-2.6.29-pxa950
+CROSS_COMPILE ?= /usr/local/arm-marvell-linux-gnueabi/bin/arm-marvell-linux-gnueabi-
+else
+ifeq ($(CONFIG_PXA978T), y)
+KERNELDIR ?= /usr/src/arm/linux-3.0.8-pxa978t
+CROSS_COMPILE ?= /usr/local/arm-marvell-linux-gnueabi/bin/arm-marvell-linux-gnueabi-
+else
+ifeq ($(CONFIG_PXA920), y)
+EXTRA_CFLAGS += -DPXA920
+ifeq ($(KVER),3)
+KERNELDIR ?= /usr/src/arm/linux-3.0.8-pxa920
+else
+ifeq ($(KMINORVER),35)
+KERNELDIR ?= /usr/src/arm/linux-2.6.35-pxa920
+else
+ifeq ($(KMINORVER),32)
+KERNELDIR ?= /usr/src/arm/linux-2.6.32-pxa920
+else
+KERNELDIR ?= /usr/src/arm/linux-2.6.29-pxa920
+endif
+endif
+endif
+CROSS_COMPILE ?= /usr/local/arm-marvell-linux-gnueabi/bin/arm-marvell-linux-gnueabi-
+else
+ifeq ($(KMINORVER),25)
+KERNELDIR ?= /usr/src/arm/linux-2.6.25-pxa9xx
+CROSS_COMPILE ?= /usr/local/arm/4.1.1/bin/arm-linux-
+else
+KERNELDIR ?= /usr/src/arm/linux-2.6.24-pxa9xx
+CROSS_COMPILE ?= /usr/local/arm/4.1.1/bin/arm-linux-
+endif
+endif
+endif
+endif
+endif
+ARCH ?= arm
+else
+ifeq ($(CONFIG_MOORESTOWN), y)
+KERNELDIR ?= /home/marvell/release_20100316/kernel
+CROSS_COMPILE ?= /home/marvell/release_20100316/prebuilt/linux-x86/toolchain/i686-unknown-linux-gnu-4.2.1/bin/i686-unknown-linux-gnu-
+else
+KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+endif
+endif
+
+# Debug Option
+# DEBUG LEVEL n/1/2:
+# n: NO DEBUG
+# 1: PRINTM(MSG,...), PRINTM(FATAL,...), PRINTM(WARN,...) and PRINTM(INFO,...)
+# 2: All PRINTM()
+CONFIG_DEBUG=1
+
+ifeq ($(CONFIG_DEBUG),1)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+endif
+
+ifeq ($(CONFIG_DEBUG),2)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+	EXTRA_CFLAGS += -DDEBUG_LEVEL2
+endif
+
+	EXTRA_CFLAGS += -DFPNUM='"XX"'
+
+ifeq ($(CONFIG_AMP), y)
+EXTRA_CFLAGS += -DBT_AMP
+ifneq ($(CONFIG_MBT_EXT),y)
+	EXTRA_CFLAGS += -I$(PWD)/include
+endif
+endif
+
+ifeq ($(CONFIG_MBT_EXT),y)
+	EXTRA_CFLAGS += -DMBT_EXT
+endif
+
+# Enable BT_HCIUART_PS and MULTI_CARD_PS_SUPPORT
+CONFIG_BT_HCIUART_PS=y
+CONFIG_MULTI_CARD_PS_SUPPORT=y
+
+ifeq ($(CONFIG_BT_HCIUART_PS), y)
+EXTRA_CFLAGS += -DCONFIG_BT_HCIUART_PS
+ifeq ($(CONFIG_MULTI_CARD_PS_SUPPORT), y)
+EXTRA_CFLAGS += -DCONFIG_MULTI_CARD_PS
+endif
+endif
+
+hci_uart-y							:= mbt_char.o
+hci_uart-y							+= hci_ldisc.o
+hci_uart-y							+= hci_wrapper.o
+hci_uart-$(CONFIG_BT_HCIUART_H4)	+= hci_h4.o
+hci_uart-$(CONFIG_BT_HCIUART_BCSP)	+= hci_bcsp.o
+hci_uart-$(CONFIG_BT_HCIUART_LL)	+= hci_ll.o
+hci_uart-$(CONFIG_BT_HCIUART_PS)	+= hci_ps.o
+hci_uart-objs				:= $(hci_uart-y)
+
+obj-m	:= hci_uart.o
+
+BINDIR = ../bin_muart
+KMODPATH := kernel/drivers/bluetooth
+
+PWD   := $(shell pwd)
+
+default:
+ifeq ($(CONFIG_PXA9XX), y)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+else
+ifeq ($(CONFIG_HIKEY), y)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+else
+ifeq ($(CONFIG_MMP2), y)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+else
+ifeq ($(CONFIG_IMX8), y)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+else
+ifeq ($(CONFIG_T3T), y)
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+else
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+endif
+endif
+endif
+endif
+endif
+
+build: default
+	@if [ ! -d $(BINDIR) ]; then \
+		mkdir $(BINDIR); \
+	fi
+	@cp -f hci_uart.ko $(BINDIR)
+	@cp -f README $(BINDIR)
+
+clean:
+	find . -name "*.o" -exec rm {} \;
+	find . -name "*.*~" -exec rm {} \;
+	find . -name "*.d" -exec rm {} \;
+	find . -name "*.mod.c" -exec rm {} \;
+	find . -name "*.ko" -exec rm {} \;
+	find . -name "*.symvers" -exec rm {} \;
+	find . -name "*.dwo" -exec rm {} \;
+	find . -name "*dwo" -exec rm {} \;
+	find . -name ".*.cmd" -exec rm {} \;
+	rm -rf .tmp_versions
+
+install:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install INSTALL_MOD_DIR=$(KMODPATH)
+
+PXA9XX PXA955 PXA950 PXA920 X86 MOORESTOWN BG2 PXA978T HIKEY MMP2 T3T IMX8:
+	@echo CONFIG_$@=y > $(CONFIG_FILE)
+
+3.1.10_JB:
+	@echo "KVER=3" >> $(CONFIG_FILE)
+	@echo "KMINORVER=110_JB" >> $(CONFIG_FILE)
+
+3.1.10:
+	@echo "KVER=3" >> $(CONFIG_FILE)
+	@echo "KMINORVER=110" >> $(CONFIG_FILE)
+
+3.0.8:
+	@echo "KVER=3" >> $(CONFIG_FILE)
+	@echo "KMINORVER=08" >> $(CONFIG_FILE)
+
+2.6.25:
+	@echo "KMINORVER=25" >> $(CONFIG_FILE)
+
+2.6.32:
+	@echo "KMINORVER=32" >> $(CONFIG_FILE)
+
+2.6.35:
+	@echo "KMINORVER=35" >> $(CONFIG_FILE)
+
+2.6.39:
+	@echo "KMINORVER=39" >> $(CONFIG_FILE)
+5.4.47:
+	@echo "KMINORVER=47" >> $(CONFIG_FILE)
+5.4.24:
+	@echo "KMINORVER=24" >> $(CONFIG_FILE)
+5.10.Y_IMX_AR:
+	@echo "KMINORVER=10Y_AR" >> $(CONFIG_FILE)
+5.10.35_IMX_AR:
+	@echo "KMINORVER=1035_AR" >> $(CONFIG_FILE)
+5.10.72_IMX_AR:
+	@echo "KMINORVER=1072_AR" >> $(CONFIG_FILE)
+5.10.72_IMX_AAR:
+	@echo "KMINORVER=1072_AAR" >> $(CONFIG_FILE)
+5.10.72_IMX_AS:
+	@echo "KMINORVER=1072_AS" >> $(CONFIG_FILE)
+5.10.72_IMX_AAS:
+	@echo "KMINORVER=1072_AAS" >> $(CONFIG_FILE)
+5.4.3:
+	@echo "KMINORVER=3" >> $(CONFIG_FILE)
+4.19.42:
+	@echo "KMINORVER=42" >> $(CONFIG_FILE)
+5.10.Y_IMX_LNX:
+	@echo "KMINORVER=10Y_LNX" >> $(CONFIG_FILE)
+5.10.72_IMX_LNX:
+	@echo "KMINORVER=1072_LNX" >> $(CONFIG_FILE)
+5.10.35_IMX_LNX:
+	@echo "KMINORVER=1035_LNX" >> $(CONFIG_FILE)
+5.10.35_RC2_IMX_LNX:
+	@echo "KMINORVER=1035_RC2_LNX" >> $(CONFIG_FILE)
+5.4.47_IMX_LNX:
+	@echo "KMINORVER=47_LNX" >> $(CONFIG_FILE)
+
+
+AMP:
+	@echo "CONFIG_AMP=y" >> $(CONFIG_FILE)
diff --git a/88x9098/bt/muart_src/README b/88x9098/bt/muart_src/README
new file mode 100644
index 0000000..773bda6
--- /dev/null
+++ b/88x9098/bt/muart_src/README
@@ -0,0 +1,126 @@
+================================================================================
+		U S E R  M A N U A L  F O R   hci_uart
+
+NAME
+	hci_uart.ko - driver for bluetooth uart device
+
+Building the driver
+-------------------
+	For X86 platform:
+	Modify ".config" to set "CONFIG_X86=y" or make X86
+	For Moorestown platform:
+	Modify ".config" to set "CONFIG_MOORESTOWN=y" or make MOORESTOWN
+	For PXA9XX platfrom:
+	Modify ".config" to set "CONFIG_PXA9XX=y" or make PXA9XX [2.6.25]
+	For PXA955 platfrom:
+	Modify ".config" to set "CONFIG_PXA955=y" or make PXA955
+	For PXA950 platfrom:
+	Modify ".config" to set "CONFIG_PXA950=y" or make PXA950
+	For PXA920 platfrom:
+	Modify ".config" to set "CONFIG_PXA920=y" or make PXA920 [2.6.32]
+
+	For X86/PXA9XX/.. platform AMP build:
+	Modify ".config" to set "CONFIG_AMP=y" or make X86|PXA9XX|.. [2.6.25] AMP
+
+	make clean
+	make build
+	The binary can be found in ../bin_muart directory.
+
+Installing the driver
+---------------------
+	make install
+
+Loading the driver
+---------------------
+	insmod hci_uart.ko [wakeupmode=0|1|2|3] [ps_mode=0|1]
+
+	The module takes two optional parameters -
+	The bit settings of drv_mode are,
+		Bit 0: BT/AMP/BLE
+		Bit 1: FM
+		Bit 2: NFC
+
+	reset:
+	0 -- Don't Send HCI reset command on initialization (default)
+	1 -- Send HCI reset command on initialization
+
+	ps_mode:
+	0 -- disable ps_mode
+	1 -- enable ps_mode
+
+	wakeupmode:
+	0 -- wakeupmode DTR
+	1 -- wakeupmode BREAK
+	2 -- wakeupmode extended BREAK
+	3 -- wakeupmode RTS
+	The default wakeupmode is BREAK.
+
+	drvdbg=<bit mask of driver debug message control>
+
+	txcrc:
+	0 -- Don't Transmit every BCSP packet with CRC
+	1 -- Transmit every BCSP packet with CRC (default)
+
+	hciextn:
+	0 -- Don't Convert HCI Extensions into BCSP packets
+	1 -- Convert HCI Extensions into BCSP packets (default)
+
+Get driver ps settings
+----------------------
+    cat /proc/mbt_uart/hciX/config
+    cat /proc/mbt_uart/config
+    This command is used to get the current driver power save settings.
+
+Enable power save mode
+----------------------
+psmode=[n]
+    This command is used to enable/disable auto sleep mode
+
+	where the option is:
+			1 	-- Enable auto sleep mode
+			0 	-- Disable auto sleep mode
+	Usage:
+                echo "psmode=1" > /proc/mbt_uart/hciX/config  	#enable power save mode
+
+                echo "psmode=0" > /proc/mbt_uart/hciX/config    #disable power save mode
+		echo "psmode=1" > /proc/mbt_uart/config		#enable power save mode
+
+		echo "psmode=0" > /proc/mbt_uart/config		#disable power save mode
+
+Configure Inactive Time Interval
+--------------------------------
+interval=[n]
+    This command is used to change the inactive time interval (mili-second)
+
+    Usage:
+	echo "interval=2000" > /proc/mbt_uart/hciX/config  #set inavtive time interval to 2000 mili-second
+        echo "interval=2000" > /proc/mbt_uart/config  #set inavtive time interval to 2000 mili-second
+
+Configure wakeup method
+-----------------------
+wakeupmode=[n]
+    This command is used to configure wakeup method. This command is only allowed in full power mode.
+
+    where the option is:
+            0 	-- DTR
+            1 	-- BREAK
+            2   -- extended BREAK
+            3   -- RTS
+
+    Usage:
+        echo "wakeupmode=0" > /proc/mbt_uart/hciX/config  #set wakeup method to DTR
+
+        echo "wakeupmode=1" > /proc/mbt_uart/hciX/config  #set wakeup method to BREAK
+
+        echo "wakeupmode=2" > /proc/mbt_uart/hciX/config  #set wakeup method to extended BREAK
+
+        echo "wakeupmode=3" > /proc/mbt_uart/hciX/config  #set wakeup method to RTS
+        echo "wakeupmode=0" > /proc/mbt_uart/config  #set wakeup method to DTR
+
+        echo "wakeupmode=1" > /proc/mbt_uart/config  #set wakeup method to BREAK
+
+        echo "wakeupmode=2" > /proc/mbt_uart/config  #set wakeup method to extended BREAK
+
+        echo "wakeupmode=3" > /proc/mbt_uart/config  #set wakeup method to RTS
+
+================================================================================
diff --git a/88x9098/bt/muart_src/bt_drv.h b/88x9098/bt/muart_src/bt_drv.h
new file mode 100644
index 0000000..925d523
--- /dev/null
+++ b/88x9098/bt/muart_src/bt_drv.h
@@ -0,0 +1,297 @@
+#ifdef GPL_FILE
+/** @file bt_drv.h
+  *  @brief This header file contains global constant/enum definitions,
+  *  global variable declaration.
+  *
+  *
+  * Copyright 2018-2020 NXP
+  *
+  * This software file (the File) is distributed by NXP
+  * under the terms of the GNU General Public License Version 2, June 1991
+  * (the License).  You may use, redistribute and/or modify the File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available by writing to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+  * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+#else
+/** @file bt_drv.h
+ *  @brief This header file contains global constant/enum definitions,
+ *  global variable declaration.
+ *
+  *
+  * Copyright 2018-2020 NXP
+  *
+  * NXP CONFIDENTIAL
+  * The source code contained or described herein and all documents related to
+  * the source code (Materials) are owned by NXP, its
+  * suppliers and/or its licensors. Title to the Materials remains with NXP,
+  * its suppliers and/or its licensors. The Materials contain
+  * trade secrets and proprietary and confidential information of NXP, its
+  * suppliers and/or its licensors. The Materials are protected by worldwide copyright
+  * and trade secret laws and treaty provisions. No part of the Materials may be
+  * used, copied, reproduced, modified, published, uploaded, posted,
+  * transmitted, distributed, or disclosed in any way without NXP's prior
+  * express written permission.
+  *
+  * No license under any patent, copyright, trade secret or other intellectual
+  * property right is granted to or conferred upon you by disclosure or delivery
+  * of the Materials, either expressly, by implication, inducement, estoppel or
+  * otherwise. Any license under such intellectual property rights must be
+  * express and approved by NXP in writing.
+  *
+  */
+#endif
+
+#ifndef _BT_DRV_H_
+#define _BT_DRV_H_
+
+#ifndef BIT
+/** BIT definition */
+#define BIT(x) (1UL << (x))
+#endif
+
+#ifdef MBT_64BIT
+typedef u64 t_ptr;
+#else
+typedef u32 t_ptr;
+#endif
+
+#define MBTCHAR_MAJOR_NUM    (0)
+
+/** Define drv_mode bit */
+#define DRV_MODE_BT         BIT(0)
+#define DRV_MODE_FM        BIT(1)
+#define DRV_MODE_NFC       BIT(2)
+
+/** Define devFeature bit */
+#define DEV_FEATURE_BT     BIT(0)
+#define DEV_FEATURE_BTAMP     BIT(1)
+#define DEV_FEATURE_BLE     BIT(2)
+#define DEV_FEATURE_FM     BIT(3)
+#define DEV_FEATURE_NFC     BIT(4)
+
+/** Define maximum number of radio func supported */
+#define MAX_RADIO_FUNC     3
+
+/** Debug Macro Definition */
+
+extern u32 drvdbg;
+
+/** Debug level : Message */
+#define	DBG_MSG			BIT(0)
+/** Debug level : Fatal */
+#define DBG_FATAL		BIT(1)
+/** Debug level : Error */
+#define DBG_ERROR		BIT(2)
+/** Debug level : Data */
+#define DBG_DATA		BIT(3)
+/** Debug level : Command */
+#define DBG_CMD			BIT(4)
+/** Debug level : Event */
+#define DBG_EVENT		BIT(5)
+/** Debug level : Interrupt */
+#define DBG_INTR		BIT(6)
+
+/** Debug entry : Data dump */
+#define DBG_DAT_D		BIT(16)
+/** Debug entry : Data dump */
+#define DBG_CMD_D		BIT(17)
+
+/** Debug level : Entry */
+#define DBG_ENTRY		BIT(28)
+/** Debug level : Warning */
+#define DBG_WARN		BIT(29)
+/** Debug level : Informative */
+#define DBG_INFO		BIT(30)
+
+/** Print informative message */
+#define	PRINTM_INFO(msg...)  do {} while(0)
+/** Print warning message */
+#define	PRINTM_WARN(msg...)  do {} while(0)
+/** Print entry message */
+#define	PRINTM_ENTRY(msg...) do {} while(0)
+
+/** Print interrupt message */
+#define	PRINTM_INTR(msg...)  do {if (drvdbg & DBG_INTR)  printk(KERN_DEBUG msg);} while(0)
+/** Print event message */
+#define	PRINTM_EVENT(msg...) do {if (drvdbg & DBG_EVENT) printk(KERN_DEBUG msg);} while(0)
+/** Print command message */
+#define	PRINTM_CMD(msg...)   do {if (drvdbg & DBG_CMD)   printk(KERN_DEBUG msg);} while(0)
+/** Print data message */
+#define	PRINTM_DATA(msg...)  do {if (drvdbg & DBG_DATA)  printk(KERN_DEBUG msg);} while(0)
+/** Print error message */
+#define	PRINTM_ERROR(msg...) do {if (drvdbg & DBG_ERROR) printk(KERN_ERR msg);} while(0)
+/** Print fatal message */
+#define	PRINTM_FATAL(msg...) do {if (drvdbg & DBG_FATAL) printk(KERN_ERR msg);} while(0)
+/** Print message */
+#define	PRINTM_MSG(msg...)   do {if (drvdbg & DBG_MSG)   printk(KERN_ALERT msg);} while(0)
+
+/** Print data dump message */
+#define	PRINTM_DAT_D(msg...)  do {if (drvdbg & DBG_DAT_D)  printk(KERN_DEBUG msg);} while(0)
+/** Print data dump message */
+#define	PRINTM_CMD_D(msg...)  do {if (drvdbg & DBG_CMD_D)  printk(KERN_DEBUG msg);} while(0)
+
+/** Print message with required level */
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+/** Debug dump buffer length */
+#define DBG_DUMP_BUF_LEN 	64
+/** Maximum number of dump per line */
+#define MAX_DUMP_PER_LINE	16
+/** Maximum data dump length */
+#define MAX_DATA_DUMP_LEN	48
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+	int i;
+	char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+	char *ptr = dbgdumpbuf;
+
+	printk(KERN_DEBUG "%s: len=%d\n", prompt, len);
+	for (i = 1; i <= len; i++) {
+		ptr += snprintf(ptr, 4, "%02x ", *buf);
+		buf++;
+		if (i % MAX_DUMP_PER_LINE == 0) {
+			*ptr = 0;
+			printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+			ptr = dbgdumpbuf;
+		}
+	}
+	if (len % MAX_DUMP_PER_LINE) {
+		*ptr = 0;
+		printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+	}
+}
+
+/** Debug hexdump of debug data */
+#define DBG_HEXDUMP_ERROR(x,y,z)     do {if (drvdbg & DBG_ERROR) hexdump(x,y,z);} while(0)
+#define DBG_HEXDUMP_DAT_D(x,y,z)     do {if (drvdbg & DBG_DAT_D) hexdump(x,y,z);} while(0)
+/** Debug hexdump of debug command */
+#define DBG_HEXDUMP_CMD_D(x,y,z)     do {if (drvdbg & DBG_CMD_D) hexdump(x,y,z);} while(0)
+
+/** Debug hexdump */
+#define DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+
+/** Mark entry point */
+#define ENTER()                 PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+                                                        __FILE__, __LINE__)
+/** Mark exit point */
+#define LEAVE()                 PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+                                                        __FILE__, __LINE__)
+
+/** Length of device name */
+#define DEV_NAME_LEN				32
+/** Bluetooth upload size */
+#define	BT_UPLD_SIZE				2312
+/** Bluetooth status success */
+#define BT_STATUS_SUCCESS			(0)
+/** Bluetooth status failure */
+#define BT_STATUS_FAILURE			(-1)
+
+#ifndef	TRUE
+/** True value */
+#define TRUE			1
+#endif
+#ifndef	FALSE
+/** False value */
+#define	FALSE			0
+#endif
+
+/** Set thread state */
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+/** Time to wait until Host Sleep state change in millisecond */
+#define WAIT_UNTIL_HS_STATE_CHANGED 2000
+/** Time to wait cmd resp in millisecond */
+#define WAIT_UNTIL_CMD_RESP	    5000
+
+/** Sleep until a condition gets true or a timeout elapses */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	interruptible_sleep_on_timeout(&waitq, ((timeout) * HZ / 1000))
+#else
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, ((timeout) * HZ / 1000))
+#endif
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+
+/** Disable interrupt */
+#define OS_INT_DISABLE	spin_lock_irqsave(&priv->driver_lock, priv->driver_flags)
+/** Enable interrupt */
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&priv->driver_lock, priv->driver_flags)
+
+#ifndef HCI_BT_AMP
+/** BT_AMP flag for device type */
+#define  HCI_BT_AMP			0x80
+#endif
+
+/** Device type of BT */
+#define DEV_TYPE_BT             0x00
+/** Device type of AMP */
+#define DEV_TYPE_AMP			0x01
+/** Device type of FM */
+#define DEV_TYPE_FM                    0x02
+/** Device type of NFC */
+#define DEV_TYPE_NFC                  0x04
+
+#ifndef MAX
+/** Return maximum of two */
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+/** This is for firmware specific length */
+#define HCI_EXTRA_LEN			36
+
+/** Command buffer size for Nxp driver */
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+
+/** Bluetooth Rx packet buffer size for Nxp driver */
+#define MRVDRV_BT_RX_PACKET_BUFFER_SIZE \
+	(HCI_MAX_FRAME_SIZE + HCI_EXTRA_LEN)
+
+#ifdef SD
+/** Buffer size to allocate */
+#define ALLOC_BUF_SIZE		(((MAX(MRVDRV_BT_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+					+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+#else
+#define ALLOC_BUF_SIZE		(MAX(MRVDRV_BT_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + BT_HEADER_LEN )
+#endif
+
+/** Request FW timeout in second */
+#define REQUEST_FW_TIMEOUT		30
+
+/** The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+#ifdef MULTI_INTERFACE_DNLD
+/** The number of times to try when waiting for downloaded firmware to
+    become active when multiple interface is present */
+#define MAX_MULTI_INTERFACE_POLL_TRIES  1000
+#endif
+
+/** The number of times to try when waiting for downloaded firmware to
+     become active. (polling the scratch register). */
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+#ifdef BT_SLEEP_TIMEOUT
+/** default idle time */
+#define DEFAULT_IDLE_TIME           0
+#endif /* BT_SLEEP_TIMEOUT */
+
+#endif /* _BT_DRV_H_ */
diff --git a/88x9098/bt/muart_src/gpl-2.0.txt b/88x9098/bt/muart_src/gpl-2.0.txt
new file mode 100644
index 0000000..2c62266
--- /dev/null
+++ b/88x9098/bt/muart_src/gpl-2.0.txt
@@ -0,0 +1,339 @@
+              GNU GENERAL PUBLIC LICENSE
+ 		       Version 2, June 1991
+
+  Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+  Everyone is permitted to copy and distribute verbatim copies
+  of this license document, but changing it is not allowed.
+
+ 			    Preamble
+
+   The licenses for most software are designed to take away your
+ freedom to share and change it.  By contrast, the GNU General Public
+ License is intended to guarantee your freedom to share and change free
+ software--to make sure the software is free for all its users.  This
+ General Public License applies to most of the Free Software
+ Foundation's software and to any other program whose authors commit to
+ using it.  (Some other Free Software Foundation software is covered by
+ the GNU Lesser General Public License instead.)  You can apply it to
+ your programs, too.
+
+   When we speak of free software, we are referring to freedom, not
+ price.  Our General Public Licenses are designed to make sure that you
+ have the freedom to distribute copies of free software (and charge for
+ this service if you wish), that you receive source code or can get it
+ if you want it, that you can change the software or use pieces of it
+ in new free programs; and that you know you can do these things.
+
+   To protect your rights, we need to make restrictions that forbid
+ anyone to deny you these rights or to ask you to surrender the rights.
+ These restrictions translate to certain responsibilities for you if you
+ distribute copies of the software, or if you modify it.
+
+   For example, if you distribute copies of such a program, whether
+ gratis or for a fee, you must give the recipients all the rights that
+ you have.  You must make sure that they, too, receive or can get the
+ source code.  And you must show them these terms so they know their
+ rights.
+
+   We protect your rights with two steps: (1) copyright the software, and
+ (2) offer you this license which gives you legal permission to copy,
+ distribute and/or modify the software.
+
+   Also, for each author's protection and ours, we want to make certain
+ that everyone understands that there is no warranty for this free
+ software.  If the software is modified by someone else and passed on, we
+ want its recipients to know that what they have is not the original, so
+ that any problems introduced by others will not reflect on the original
+ authors' reputations.
+
+   Finally, any free program is threatened constantly by software
+ patents.  We wish to avoid the danger that redistributors of a free
+ program will individually obtain patent licenses, in effect making the
+ program proprietary.  To prevent this, we have made it clear that any
+ patent must be licensed for everyone's free use or not licensed at all.
+
+   The precise terms and conditions for copying, distribution and
+ modification follow.
+
+ 		    GNU GENERAL PUBLIC LICENSE
+    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+   0. This License applies to any program or other work which contains
+ a notice placed by the copyright holder saying it may be distributed
+ under the terms of this General Public License.  The "Program", below,
+ refers to any such program or work, and a "work based on the Program"
+ means either the Program or any derivative work under copyright law:
+ that is to say, a work containing the Program or a portion of it,
+ either verbatim or with modifications and/or translated into another
+ language.  (Hereinafter, translation is included without limitation in
+ the term "modification".)  Each licensee is addressed as "you".
+
+ Activities other than copying, distribution and modification are not
+ covered by this License; they are outside its scope.  The act of
+ running the Program is not restricted, and the output from the Program
+ is covered only if its contents constitute a work based on the
+ Program (independent of having been made by running the Program).
+ Whether that is true depends on what the Program does.
+
+   1. You may copy and distribute verbatim copies of the Program's
+ source code as you receive it, in any medium, provided that you
+ conspicuously and appropriately publish on each copy an appropriate
+ copyright notice and disclaimer of warranty; keep intact all the
+ notices that refer to this License and to the absence of any warranty;
+ and give any other recipients of the Program a copy of this License
+ along with the Program.
+
+ You may charge a fee for the physical act of transferring a copy, and
+ you may at your option offer warranty protection in exchange for a fee.
+
+   2. You may modify your copy or copies of the Program or any portion
+ of it, thus forming a work based on the Program, and copy and
+ distribute such modifications or work under the terms of Section 1
+ above, provided that you also meet all of these conditions:
+
+     a) You must cause the modified files to carry prominent notices
+     stating that you changed the files and the date of any change.
+
+     b) You must cause any work that you distribute or publish, that in
+     whole or in part contains or is derived from the Program or any
+     part thereof, to be licensed as a whole at no charge to all third
+     parties under the terms of this License.
+
+     c) If the modified program normally reads commands interactively
+     when run, you must cause it, when started running for such
+     interactive use in the most ordinary way, to print or display an
+     announcement including an appropriate copyright notice and a
+     notice that there is no warranty (or else, saying that you provide
+     a warranty) and that users may redistribute the program under
+     these conditions, and telling the user how to view a copy of this
+     License.  (Exception: if the Program itself is interactive but
+     does not normally print such an announcement, your work based on
+     the Program is not required to print an announcement.)
+
+ These requirements apply to the modified work as a whole.  If
+ identifiable sections of that work are not derived from the Program,
+ and can be reasonably considered independent and separate works in
+ themselves, then this License, and its terms, do not apply to those
+ sections when you distribute them as separate works.  But when you
+ distribute the same sections as part of a whole which is a work based
+ on the Program, the distribution of the whole must be on the terms of
+ this License, whose permissions for other licensees extend to the
+ entire whole, and thus to each and every part regardless of who wrote it.
+
+ Thus, it is not the intent of this section to claim rights or contest
+ your rights to work written entirely by you; rather, the intent is to
+ exercise the right to control the distribution of derivative or
+ collective works based on the Program.
+
+ In addition, mere aggregation of another work not based on the Program
+ with the Program (or with a work based on the Program) on a volume of
+ a storage or distribution medium does not bring the other work under
+ the scope of this License.
+
+   3. You may copy and distribute the Program (or a work based on it,
+ under Section 2) in object code or executable form under the terms of
+ Sections 1 and 2 above provided that you also do one of the following:
+
+     a) Accompany it with the complete corresponding machine-readable
+     source code, which must be distributed under the terms of Sections
+     1 and 2 above on a medium customarily used for software interchange; or,
+
+     b) Accompany it with a written offer, valid for at least three
+     years, to give any third party, for a charge no more than your
+     cost of physically performing source distribution, a complete
+     machine-readable copy of the corresponding source code, to be
+     distributed under the terms of Sections 1 and 2 above on a medium
+     customarily used for software interchange; or,
+
+     c) Accompany it with the information you received as to the offer
+     to distribute corresponding source code.  (This alternative is
+     allowed only for noncommercial distribution and only if you
+     received the program in object code or executable form with such
+     an offer, in accord with Subsection b above.)
+
+ The source code for a work means the preferred form of the work for
+ making modifications to it.  For an executable work, complete source
+ code means all the source code for all modules it contains, plus any
+ associated interface definition files, plus the scripts used to
+ control compilation and installation of the executable.  However, as a
+ special exception, the source code distributed need not include
+ anything that is normally distributed (in either source or binary
+ form) with the major components (compiler, kernel, and so on) of the
+ operating system on which the executable runs, unless that component
+ itself accompanies the executable.
+
+ If distribution of executable or object code is made by offering
+ access to copy from a designated place, then offering equivalent
+ access to copy the source code from the same place counts as
+ distribution of the source code, even though third parties are not
+ compelled to copy the source along with the object code.
+
+   4. You may not copy, modify, sublicense, or distribute the Program
+ except as expressly provided under this License.  Any attempt
+ otherwise to copy, modify, sublicense or distribute the Program is
+ void, and will automatically terminate your rights under this License.
+ However, parties who have received copies, or rights, from you under
+ this License will not have their licenses terminated so long as such
+ parties remain in full compliance.
+
+   5. You are not required to accept this License, since you have not
+ signed it.  However, nothing else grants you permission to modify or
+ distribute the Program or its derivative works.  These actions are
+ prohibited by law if you do not accept this License.  Therefore, by
+ modifying or distributing the Program (or any work based on the
+ Program), you indicate your acceptance of this License to do so, and
+ all its terms and conditions for copying, distributing or modifying
+ the Program or works based on it.
+
+   6. Each time you redistribute the Program (or any work based on the
+ Program), the recipient automatically receives a license from the
+ original licensor to copy, distribute or modify the Program subject to
+ these terms and conditions.  You may not impose any further
+ restrictions on the recipients' exercise of the rights granted herein.
+ You are not responsible for enforcing compliance by third parties to
+ this License.
+
+   7. If, as a consequence of a court judgment or allegation of patent
+ infringement or for any other reason (not limited to patent issues),
+ conditions are imposed on you (whether by court order, agreement or
+ otherwise) that contradict the conditions of this License, they do not
+ excuse you from the conditions of this License.  If you cannot
+ distribute so as to satisfy simultaneously your obligations under this
+ License and any other pertinent obligations, then as a consequence you
+ may not distribute the Program at all.  For example, if a patent
+ license would not permit royalty-free redistribution of the Program by
+ all those who receive copies directly or indirectly through you, then
+ the only way you could satisfy both it and this License would be to
+ refrain entirely from distribution of the Program.
+
+ If any portion of this section is held invalid or unenforceable under
+ any particular circumstance, the balance of the section is intended to
+ apply and the section as a whole is intended to apply in other
+ circumstances.
+
+ It is not the purpose of this section to induce you to infringe any
+ patents or other property right claims or to contest validity of any
+ such claims; this section has the sole purpose of protecting the
+ integrity of the free software distribution system, which is
+ implemented by public license practices.  Many people have made
+ generous contributions to the wide range of software distributed
+ through that system in reliance on consistent application of that
+ system; it is up to the author/donor to decide if he or she is willing
+ to distribute software through any other system and a licensee cannot
+ impose that choice.
+
+ This section is intended to make thoroughly clear what is believed to
+ be a consequence of the rest of this License.
+
+   8. If the distribution and/or use of the Program is restricted in
+ certain countries either by patents or by copyrighted interfaces, the
+ original copyright holder who places the Program under this License
+ may add an explicit geographical distribution limitation excluding
+ those countries, so that distribution is permitted only in or among
+ countries not thus excluded.  In such case, this License incorporates
+ the limitation as if written in the body of this License.
+
+   9. The Free Software Foundation may publish revised and/or new versions
+ of the General Public License from time to time.  Such new versions will
+ be similar in spirit to the present version, but may differ in detail to
+ address new problems or concerns.
+
+ Each version is given a distinguishing version number.  If the Program
+ specifies a version number of this License which applies to it and "any
+ later version", you have the option of following the terms and conditions
+ either of that version or of any later version published by the Free
+ Software Foundation.  If the Program does not specify a version number of
+ this License, you may choose any version ever published by the Free Software
+ Foundation.
+
+   10. If you wish to incorporate parts of the Program into other free
+ programs whose distribution conditions are different, write to the author
+ to ask for permission.  For software which is copyrighted by the Free
+ Software Foundation, write to the Free Software Foundation; we sometimes
+ make exceptions for this.  Our decision will be guided by the two goals
+ of preserving the free status of all derivatives of our free software and
+ of promoting the sharing and reuse of software generally.
+
+ 			    NO WARRANTY
+
+   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+ FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+ OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+ PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+ OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+ TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+ PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+ REPAIR OR CORRECTION.
+
+   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+ WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+ REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+ INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+ OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+ TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+ YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+ PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+ POSSIBILITY OF SUCH DAMAGES.
+
+ 		     END OF TERMS AND CONDITIONS
+
+ 	    How to Apply These Terms to Your New Programs
+
+   If you develop a new program, and you want it to be of the greatest
+ possible use to the public, the best way to achieve this is to make it
+ free software which everyone can redistribute and change under these terms.
+
+   To do so, attach the following notices to the program.  It is safest
+ to attach them to the start of each source file to most effectively
+ convey the exclusion of warranty; and each file should have at least
+ the "copyright" line and a pointer to where the full notice is found.
+
+     <one line to give the program's name and a brief idea of what it does.>
+     Copyright (C) <year>  <name of author>
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License along
+     with this program; if not, write to the Free Software Foundation, Inc.,
+     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Also add information on how to contact you by electronic and paper mail.
+
+ If the program is interactive, make it output a short notice like this
+ when it starts in an interactive mode:
+
+     Gnomovision version 69, Copyright (C) year name of author
+     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+     This is free software, and you are welcome to redistribute it
+     under certain conditions; type `show c' for details.
+
+ The hypothetical commands `show w' and `show c' should show the appropriate
+ parts of the General Public License.  Of course, the commands you use may
+ be called something other than `show w' and `show c'; they could even be
+ mouse-clicks or menu items--whatever suits your program.
+
+ You should also get your employer (if you work as a programmer) or your
+ school, if any, to sign a "copyright disclaimer" for the program, if
+ necessary.  Here is a sample; alter the names:
+
+   Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+   `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+   <signature of Ty Coon>, 1 April 1989
+   Ty Coon, President of Vice
+
+ This General Public License does not permit incorporating your program into
+ proprietary programs.  If your program is a subroutine library, you may
+ consider it more useful to permit linking proprietary applications with the
+ library.  If this is what you want to do, use the GNU Lesser General
+ Public License instead of this License.
diff --git a/88x9098/bt/muart_src/hci_bcsp.c b/88x9098/bt/muart_src/hci_bcsp.c
new file mode 100644
index 0000000..f2d60ec
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_bcsp.c
@@ -0,0 +1,873 @@
+/*
+ *
+ *  Bluetooth HCI UART driver
+ *
+ *  Copyright (C) 2002-2003  Fabrizio Gennari <fabrizio.gennari@philips.com>
+ *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/poll.h>
+
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/ioctl.h>
+#include <linux/skbuff.h>
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include <amp/bluetooth/bluetooth.h>
+#include <amp/bluetooth/hci_core.h>
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+
+#include "hci_uart.h"
+#include "bt_drv.h"
+
+#define VERSION "0.3"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+static int txcrc = 1;
+static int hciextn = 1;
+#else
+static bool txcrc = 1;
+static bool hciextn = 1;
+#endif
+
+#define BCSP_TXWINSIZE	4
+
+#define BCSP_ACK_PKT	0x05
+#define BCSP_LE_PKT	0x06
+
+struct bcsp_struct {
+	struct hci_uart *hu;
+	struct sk_buff_head unack;	/* Unack'ed packets queue */
+	struct sk_buff_head rel;	/* Reliable packets queue */
+	struct sk_buff_head unrel;	/* Unreliable packets queue */
+
+	unsigned long rx_count;
+	struct sk_buff *rx_skb;
+	u8 rxseq_txack;		/* rxseq == txack. */
+	u8 rxack;		/* Last packet sent by us that the peer ack'ed */
+	struct timer_list tbcsp;
+
+	enum {
+		BCSP_W4_PKT_DELIMITER,
+		BCSP_W4_PKT_START,
+		BCSP_W4_BCSP_HDR,
+		BCSP_W4_DATA,
+		BCSP_W4_CRC
+	} rx_state;
+
+	enum {
+		BCSP_ESCSTATE_NOESC,
+		BCSP_ESCSTATE_ESC
+	} rx_esc_state;
+
+	u8 use_crc;
+	u16 message_crc;
+	u8 txack_req;		/* Do we need to send ack's to the peer? */
+
+	/* Reliable packet sequence number - used to assign seq to each rel
+	   pkt. */
+	u8 msgq_txseq;
+};
+
+/* ---- BCSP CRC calculation ---- */
+
+/* Table for calculating CRC for polynomial 0x1021, LSB processed first,
+initial value 0xffff, bits shifted in reverse order. */
+
+static const u16 crc_table[] = {
+	0x0000, 0x1081, 0x2102, 0x3183,
+	0x4204, 0x5285, 0x6306, 0x7387,
+	0x8408, 0x9489, 0xa50a, 0xb58b,
+	0xc60c, 0xd68d, 0xe70e, 0xf78f
+};
+
+/* Initialise the crc calculator */
+#define BCSP_CRC_INIT(x) x = 0xffff
+
+/*
+   Update crc with next data byte
+
+   Implementation note
+        The data byte is treated as two nibbles.  The crc is generated
+        in reverse, i.e., bits are fed into the register from the top.
+*/
+static void
+bcsp_crc_update(u16 * crc, u8 d)
+{
+	u16 reg = *crc;
+
+	reg = (reg >> 4) ^ crc_table[(reg ^ d) & 0x000f];
+	reg = (reg >> 4) ^ crc_table[(reg ^ (d >> 4)) & 0x000f];
+
+	*crc = reg;
+}
+
+/*
+   Get reverse of generated crc
+
+   Implementation note
+        The crc generator (bcsp_crc_init() and bcsp_crc_update())
+        creates a reversed crc, so it needs to be swapped back before
+        being passed on.
+*/
+static u16
+bcsp_crc_reverse(u16 crc)
+{
+	u16 b, rev;
+
+	for (b = 0, rev = 0; b < 16; b++) {
+		rev = rev << 1;
+		rev |= (crc & 1);
+		crc = crc >> 1;
+	}
+
+	return (rev);
+}
+
+/* ---- BCSP core ---- */
+
+static void
+bcsp_slip_msgdelim(struct sk_buff *skb)
+{
+	const char pkt_delim = 0xc0;
+
+	memcpy(skb_put(skb, 1), &pkt_delim, 1);
+}
+
+static void
+bcsp_slip_one_byte(struct sk_buff *skb, u8 c)
+{
+	const char esc_c0[2] = { 0xdb, 0xdc };
+	const char esc_db[2] = { 0xdb, 0xdd };
+
+	switch (c) {
+	case 0xc0:
+		memcpy(skb_put(skb, 2), &esc_c0, 2);
+		break;
+	case 0xdb:
+		memcpy(skb_put(skb, 2), &esc_db, 2);
+		break;
+	default:
+		memcpy(skb_put(skb, 1), &c, 1);
+	}
+}
+
+static int
+bcsp_enqueue(struct hci_uart *hu, struct sk_buff *skb)
+{
+	struct bcsp_struct *bcsp = hu->priv;
+
+	if (skb->len > 0xFFF) {
+		PRINTM(ERROR, "Packet too long\n");
+		kfree_skb(skb);
+		return 0;
+	}
+
+	switch (bt_cb(skb)->pkt_type) {
+	case HCI_ACLDATA_PKT:
+	case HCI_COMMAND_PKT:
+		skb_queue_tail(&bcsp->rel, skb);
+		break;
+
+	case HCI_SCODATA_PKT:
+		skb_queue_tail(&bcsp->unrel, skb);
+		break;
+
+	default:
+		PRINTM(ERROR, "Unknow packet type\n");
+		kfree_skb(skb);
+		break;
+	}
+
+	return 0;
+}
+
+static struct sk_buff *
+bcsp_prepare_pkt(struct bcsp_struct *bcsp, u8 * data, int len, int pkt_type)
+{
+	struct sk_buff *nskb;
+	u8 hdr[4], chan;
+	u16 BCSP_CRC_INIT(bcsp_txmsg_crc);
+	int rel, i;
+
+	switch (pkt_type) {
+	case HCI_ACLDATA_PKT:
+		chan = 6;	/* BCSP ACL channel */
+		rel = 1;	/* reliable channel */
+		break;
+	case HCI_COMMAND_PKT:
+		chan = 5;	/* BCSP cmd/evt channel */
+		rel = 1;	/* reliable channel */
+		break;
+	case HCI_SCODATA_PKT:
+		chan = 7;	/* BCSP SCO channel */
+		rel = 0;	/* unreliable channel */
+		break;
+	case BCSP_LE_PKT:
+		chan = 1;	/* BCSP LE channel */
+		rel = 0;	/* unreliable channel */
+		break;
+	case BCSP_ACK_PKT:
+		chan = 0;	/* BCSP internal channel */
+		rel = 0;	/* unreliable channel */
+		break;
+	default:
+		PRINTM(ERROR, "Unknow packet type\n");
+		return NULL;
+	}
+
+	if (hciextn && chan == 5) {
+		struct hci_command_hdr *hdr = (struct hci_command_hdr *)data;
+
+		/* Vendor specific commands */
+		if (hci_opcode_ogf(__le16_to_cpu(hdr->opcode)) == 0x3f) {
+			u8 desc = *(data + HCI_COMMAND_HDR_SIZE);
+			if ((desc & 0xf0) == 0xc0) {
+				data += HCI_COMMAND_HDR_SIZE + 1;
+				len -= HCI_COMMAND_HDR_SIZE + 1;
+				chan = desc & 0x0f;
+			}
+		}
+	}
+
+	/* Max len of packet: (original len +4(bcsp hdr) +2(crc))*2 (because
+	   bytes 0xc0 and 0xdb are escaped, worst case is when the packet is
+	   all made of 0xc0 and 0xdb :) ) + 2 (0xc0 delimiters at start and
+	   end). */
+
+	nskb = alloc_skb((len + 6) * 2 + 2, GFP_ATOMIC);
+	if (!nskb)
+		return NULL;
+
+	bt_cb(nskb)->pkt_type = pkt_type;
+
+	bcsp_slip_msgdelim(nskb);
+
+	hdr[0] = bcsp->rxseq_txack << 3;
+	bcsp->txack_req = 0;
+	PRINTM(DATA, "Request packet %u to card\n", bcsp->rxseq_txack);
+
+	if (rel) {
+		hdr[0] |= 0x80 + bcsp->msgq_txseq;
+		PRINTM(DATA, "Sending packet with seqno %u\n",
+		       bcsp->msgq_txseq);
+		bcsp->msgq_txseq = (bcsp->msgq_txseq + 1) & 0x07;
+	}
+
+	if (bcsp->use_crc)
+		hdr[0] |= 0x40;
+
+	hdr[1] = ((len << 4) & 0xff) | chan;
+	hdr[2] = len >> 4;
+	hdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);
+
+	/* Put BCSP header */
+	for (i = 0; i < 4; i++) {
+		bcsp_slip_one_byte(nskb, hdr[i]);
+
+		if (bcsp->use_crc)
+			bcsp_crc_update(&bcsp_txmsg_crc, hdr[i]);
+	}
+
+	/* Put payload */
+	for (i = 0; i < len; i++) {
+		bcsp_slip_one_byte(nskb, data[i]);
+
+		if (bcsp->use_crc)
+			bcsp_crc_update(&bcsp_txmsg_crc, data[i]);
+	}
+
+	/* Put CRC */
+	if (bcsp->use_crc) {
+		bcsp_txmsg_crc = bcsp_crc_reverse(bcsp_txmsg_crc);
+		bcsp_slip_one_byte(nskb, (u8) ((bcsp_txmsg_crc >> 8) & 0x00ff));
+		bcsp_slip_one_byte(nskb, (u8) (bcsp_txmsg_crc & 0x00ff));
+	}
+
+	bcsp_slip_msgdelim(nskb);
+	return nskb;
+}
+
+/* This is a rewrite of pkt_avail in ABCSP */
+static struct sk_buff *
+bcsp_dequeue(struct hci_uart *hu)
+{
+	struct bcsp_struct *bcsp = hu->priv;
+	unsigned long flags;
+	struct sk_buff *skb;
+
+	/* First of all, check for unreliable messages in the queue, since they
+	   have priority */
+
+	if ((skb = skb_dequeue(&bcsp->unrel)) != NULL) {
+		struct sk_buff *nskb =
+			bcsp_prepare_pkt(bcsp, skb->data, skb->len,
+					 bt_cb(skb)->pkt_type);
+		if (nskb) {
+			kfree_skb(skb);
+			return nskb;
+		} else {
+			skb_queue_head(&bcsp->unrel, skb);
+			PRINTM(ERROR,
+			       "Could not dequeue pkt because alloc_skb failed\n");
+		}
+	}
+
+	/* Now, try to send a reliable pkt. We can only send a reliable packet
+	   if the number of packets sent but not yet ack'ed is < than the
+	   winsize */
+
+	spin_lock_irqsave_nested(&bcsp->unack.lock, flags,
+				 SINGLE_DEPTH_NESTING);
+
+	if (bcsp->unack.qlen < BCSP_TXWINSIZE &&
+	    (skb = skb_dequeue(&bcsp->rel)) != NULL) {
+		struct sk_buff *nskb =
+			bcsp_prepare_pkt(bcsp, skb->data, skb->len,
+					 bt_cb(skb)->pkt_type);
+		if (nskb) {
+			__skb_queue_tail(&bcsp->unack, skb);
+			mod_timer(&bcsp->tbcsp, jiffies + HZ / 4);
+			spin_unlock_irqrestore(&bcsp->unack.lock, flags);
+			return nskb;
+		} else {
+			skb_queue_head(&bcsp->rel, skb);
+			PRINTM(ERROR,
+			       "Could not dequeue pkt because alloc_skb failed\n");
+		}
+	}
+
+	spin_unlock_irqrestore(&bcsp->unack.lock, flags);
+
+	/* We could not send a reliable packet, either because there are none
+	   or because there are too many unack'ed pkts. Did we receive any
+	   packets we have not acknowledged yet ? */
+
+	if (bcsp->txack_req) {
+		/* if so, craft an empty ACK pkt and send it on BCSP unreliable
+		   channel 0 */
+		struct sk_buff *nskb =
+			bcsp_prepare_pkt(bcsp, NULL, 0, BCSP_ACK_PKT);
+		return nskb;
+	}
+
+	/* We have nothing to send */
+	return NULL;
+}
+
+static int
+bcsp_flush(struct hci_uart *hu)
+{
+	PRINTM(CMD, "bcsp flush hu %p\n", hu);
+	return 0;
+}
+
+/* Remove ack'ed packets */
+static void
+bcsp_pkt_cull(struct bcsp_struct *bcsp)
+{
+	unsigned long flags;
+	struct sk_buff *skb;
+	int i, pkts_to_be_removed;
+	u8 seqno;
+
+	spin_lock_irqsave(&bcsp->unack.lock, flags);
+
+	pkts_to_be_removed = bcsp->unack.qlen;
+	seqno = bcsp->msgq_txseq;
+
+	while (pkts_to_be_removed) {
+		if (bcsp->rxack == seqno)
+			break;
+		pkts_to_be_removed--;
+		seqno = (seqno - 1) & 0x07;
+	}
+
+	if (bcsp->rxack != seqno)
+		PRINTM(ERROR, "Peer acked invalid packet\n");
+
+	PRINTM(DATA, "Removing %u pkts out of %u, up to seqno %u\n",
+	       pkts_to_be_removed, bcsp->unack.qlen, (seqno - 1) & 0x07);
+
+	for (i = 0, skb = ((struct sk_buff *)&bcsp->unack)->next;
+	     i < pkts_to_be_removed && skb != (struct sk_buff *)&bcsp->unack;
+	     i++) {
+		struct sk_buff *nskb;
+
+		nskb = skb->next;
+		__skb_unlink(skb, &bcsp->unack);
+		kfree_skb(skb);
+		skb = nskb;
+	}
+
+	if (bcsp->unack.qlen == 0)
+		del_timer(&bcsp->tbcsp);
+
+	spin_unlock_irqrestore(&bcsp->unack.lock, flags);
+
+	if (i != pkts_to_be_removed)
+		PRINTM(ERROR, "Removed only %u out of %u pkts\n", i,
+		       pkts_to_be_removed);
+}
+
+/* Handle BCSP link-establishment packets. When we
+   detect a "sync" packet, symptom that the BT module has reset,
+   we do nothing :) (yet) */
+static void
+bcsp_handle_le_pkt(struct hci_uart *hu)
+{
+	struct bcsp_struct *bcsp = hu->priv;
+	u8 conf_pkt[4] = { 0xad, 0xef, 0xac, 0xed };
+	u8 conf_rsp_pkt[4] = { 0xde, 0xad, 0xd0, 0xd0 };
+	u8 sync_pkt[4] = { 0xda, 0xdc, 0xed, 0xed };
+
+	/* spot "conf" pkts and reply with a "conf rsp" pkt */
+	if (bcsp->rx_skb->data[1] >> 4 == 4 && bcsp->rx_skb->data[2] == 0 &&
+	    !memcmp(&bcsp->rx_skb->data[4], conf_pkt, 4)) {
+		struct sk_buff *nskb = alloc_skb(4, GFP_ATOMIC);
+
+		PRINTM(DATA, "Found a LE conf pkt\n");
+
+		if (!nskb)
+			return;
+		memcpy(skb_put(nskb, 4), conf_rsp_pkt, 4);
+		bt_cb(nskb)->pkt_type = BCSP_LE_PKT;
+
+		skb_queue_head(&bcsp->unrel, nskb);
+		hci_uart_tx_wakeup(hu);
+	}
+	/* Spot "sync" pkts. If we find one...disaster! */
+	else if (bcsp->rx_skb->data[1] >> 4 == 4 && bcsp->rx_skb->data[2] == 0
+		 && !memcmp(&bcsp->rx_skb->data[4], sync_pkt, 4)) {
+		PRINTM(ERROR, "Found a LE sync pkt, card has reset\n");
+	}
+}
+
+static inline void
+bcsp_unslip_one_byte(struct bcsp_struct *bcsp, unsigned char byte)
+{
+	const u8 c0 = 0xc0, db = 0xdb;
+
+	switch (bcsp->rx_esc_state) {
+	case BCSP_ESCSTATE_NOESC:
+		switch (byte) {
+		case 0xdb:
+			bcsp->rx_esc_state = BCSP_ESCSTATE_ESC;
+			break;
+		default:
+			memcpy(skb_put(bcsp->rx_skb, 1), &byte, 1);
+			if ((bcsp->rx_skb->data[0] & 0x40) != 0 &&
+			    bcsp->rx_state != BCSP_W4_CRC)
+				bcsp_crc_update(&bcsp->message_crc, byte);
+			bcsp->rx_count--;
+		}
+		break;
+
+	case BCSP_ESCSTATE_ESC:
+		switch (byte) {
+		case 0xdc:
+			memcpy(skb_put(bcsp->rx_skb, 1), &c0, 1);
+			if ((bcsp->rx_skb->data[0] & 0x40) != 0 &&
+			    bcsp->rx_state != BCSP_W4_CRC)
+				bcsp_crc_update(&bcsp->message_crc, 0xc0);
+			bcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;
+			bcsp->rx_count--;
+			break;
+
+		case 0xdd:
+			memcpy(skb_put(bcsp->rx_skb, 1), &db, 1);
+			if ((bcsp->rx_skb->data[0] & 0x40) != 0 &&
+			    bcsp->rx_state != BCSP_W4_CRC)
+				bcsp_crc_update(&bcsp->message_crc, 0xdb);
+			bcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;
+			bcsp->rx_count--;
+			break;
+
+		default:
+			PRINTM(ERROR, "Invalid byte %02x after esc byte\n",
+			       byte);
+			kfree_skb(bcsp->rx_skb);
+			bcsp->rx_skb = NULL;
+			bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+			bcsp->rx_count = 0;
+		}
+	}
+}
+
+static void
+bcsp_complete_rx_pkt(struct hci_uart *hu)
+{
+	struct bcsp_struct *bcsp = hu->priv;
+	int pass_up;
+
+	if (bcsp->rx_skb->data[0] & 0x80) {	/* reliable pkt */
+		PRINTM(DATA, "Received seqno %u from card\n",
+		       bcsp->rxseq_txack);
+		bcsp->rxseq_txack++;
+		bcsp->rxseq_txack %= 0x8;
+		bcsp->txack_req = 1;
+
+		/* If needed, transmit an ack pkt */
+		hci_uart_tx_wakeup(hu);
+	}
+
+	bcsp->rxack = (bcsp->rx_skb->data[0] >> 3) & 0x07;
+	PRINTM(DATA, "Request for pkt %u from card\n", bcsp->rxack);
+
+	bcsp_pkt_cull(bcsp);
+	if ((bcsp->rx_skb->data[1] & 0x0f) == 6 && bcsp->rx_skb->data[0] & 0x80) {
+		bt_cb(bcsp->rx_skb)->pkt_type = HCI_ACLDATA_PKT;
+		pass_up = 1;
+	} else if ((bcsp->rx_skb->data[1] & 0x0f) == 5 &&
+		   bcsp->rx_skb->data[0] & 0x80) {
+		bt_cb(bcsp->rx_skb)->pkt_type = HCI_EVENT_PKT;
+		pass_up = 1;
+	} else if ((bcsp->rx_skb->data[1] & 0x0f) == 7) {
+		bt_cb(bcsp->rx_skb)->pkt_type = HCI_SCODATA_PKT;
+		pass_up = 1;
+	} else if ((bcsp->rx_skb->data[1] & 0x0f) == 1 &&
+		   !(bcsp->rx_skb->data[0] & 0x80)) {
+		bcsp_handle_le_pkt(hu);
+		pass_up = 0;
+	} else
+		pass_up = 0;
+
+	if (!pass_up) {
+		struct hci_event_hdr hdr;
+		u8 desc = (bcsp->rx_skb->data[1] & 0x0f);
+
+		if (desc != 0 && desc != 1) {
+			if (hciextn) {
+				desc |= 0xc0;
+				skb_pull(bcsp->rx_skb, 4);
+				memcpy(skb_push(bcsp->rx_skb, 1), &desc, 1);
+
+				hdr.evt = 0xff;
+				hdr.plen = bcsp->rx_skb->len;
+				memcpy(skb_push
+				       (bcsp->rx_skb, HCI_EVENT_HDR_SIZE), &hdr,
+				       HCI_EVENT_HDR_SIZE);
+				bt_cb(bcsp->rx_skb)->pkt_type = HCI_EVENT_PKT;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+				hci_recv_frame(bcsp->rx_skb);
+#else
+				hci_recv_frame(hu->hdev, bcsp->rx_skb);
+#endif
+#else
+				hci_recv_frame(bcsp->rx_skb);
+#endif
+			} else {
+				PRINTM(ERROR,
+				       "Packet for unknown channel (%u %s)\n",
+				       bcsp->rx_skb->data[1] & 0x0f,
+				       bcsp->rx_skb->
+				       data[0] & 0x80 ? "reliable" :
+				       "unreliable");
+				kfree_skb(bcsp->rx_skb);
+			}
+		} else
+			kfree_skb(bcsp->rx_skb);
+	} else {
+		/* Pull out BCSP hdr */
+		skb_pull(bcsp->rx_skb, 4);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+		hci_recv_frame(bcsp->rx_skb);
+#else
+		hci_recv_frame(hu->hdev, bcsp->rx_skb);
+#endif
+#else
+		hci_recv_frame(bcsp->rx_skb);
+#endif
+	}
+
+	bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+	bcsp->rx_skb = NULL;
+}
+
+/* Recv data */
+static int
+bcsp_recv(struct hci_uart *hu, void *data, int count)
+{
+	struct bcsp_struct *bcsp = hu->priv;
+	register unsigned char *ptr;
+
+	PRINTM(DATA, "hu %p count %d rx_state %d rx_count %ld\n",
+	       hu, count, bcsp->rx_state, bcsp->rx_count);
+
+	ptr = data;
+	while (count) {
+		if (bcsp->rx_count) {
+			if (*ptr == 0xc0) {
+				PRINTM(ERROR, "Short BCSP packet\n");
+				kfree_skb(bcsp->rx_skb);
+				bcsp->rx_state = BCSP_W4_PKT_START;
+				bcsp->rx_count = 0;
+			} else
+				bcsp_unslip_one_byte(bcsp, *ptr);
+
+			ptr++;
+			count--;
+			continue;
+		}
+
+		switch (bcsp->rx_state) {
+		case BCSP_W4_BCSP_HDR:
+			if ((0xff & (u8) ~
+			     (bcsp->rx_skb->data[0] + bcsp->rx_skb->data[1] +
+			      bcsp->rx_skb->data[2])) !=
+			    bcsp->rx_skb->data[3]) {
+				PRINTM(ERROR, "Error in BCSP hdr checksum\n");
+				kfree_skb(bcsp->rx_skb);
+				bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+				bcsp->rx_count = 0;
+				continue;
+			}
+			if (bcsp->rx_skb->data[0] & 0x80	/* reliable pkt
+								 */
+			    && (bcsp->rx_skb->data[0] & 0x07) !=
+			    bcsp->rxseq_txack) {
+				PRINTM(ERROR,
+				       "Out-of-order packet arrived, got %u expected %u\n",
+				       bcsp->rx_skb->data[0] & 0x07,
+				       bcsp->rxseq_txack);
+
+				kfree_skb(bcsp->rx_skb);
+				bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+				bcsp->rx_count = 0;
+				continue;
+			}
+			bcsp->rx_state = BCSP_W4_DATA;
+			bcsp->rx_count = (bcsp->rx_skb->data[1] >> 4) + (bcsp->rx_skb->data[2] << 4);	/* May
+													   be
+													   0
+													 */
+			continue;
+
+		case BCSP_W4_DATA:
+			if (bcsp->rx_skb->data[0] & 0x40) {	/* pkt with crc
+								 */
+				bcsp->rx_state = BCSP_W4_CRC;
+				bcsp->rx_count = 2;
+			} else
+				bcsp_complete_rx_pkt(hu);
+			continue;
+
+		case BCSP_W4_CRC:
+			if (bcsp_crc_reverse(bcsp->message_crc) !=
+			    (bcsp->rx_skb->data[bcsp->rx_skb->len - 2] << 8) +
+			    bcsp->rx_skb->data[bcsp->rx_skb->len - 1]) {
+				PRINTM(ERROR,
+				       "Checksum failed: computed %04x received %04x\n",
+				       bcsp_crc_reverse(bcsp->message_crc),
+				       (bcsp->rx_skb->
+					data[bcsp->rx_skb->len - 2] << 8) +
+				       bcsp->rx_skb->data[bcsp->rx_skb->len -
+							  1]);
+
+				kfree_skb(bcsp->rx_skb);
+				bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+				bcsp->rx_count = 0;
+				continue;
+			}
+			skb_trim(bcsp->rx_skb, bcsp->rx_skb->len - 2);
+			bcsp_complete_rx_pkt(hu);
+			continue;
+
+		case BCSP_W4_PKT_DELIMITER:
+			switch (*ptr) {
+			case 0xc0:
+				bcsp->rx_state = BCSP_W4_PKT_START;
+				break;
+			default:
+				PRINTM(ERROR, "Ignoring byte %02x\n", *ptr);
+				break;
+			}
+			ptr++;
+			count--;
+			break;
+
+		case BCSP_W4_PKT_START:
+			switch (*ptr) {
+			case 0xc0:
+				ptr++;
+				count--;
+				break;
+
+			default:
+				bcsp->rx_state = BCSP_W4_BCSP_HDR;
+				bcsp->rx_count = 4;
+				bcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;
+				BCSP_CRC_INIT(bcsp->message_crc);
+
+				/* Do not increment ptr or decrement count
+				   Allocate packet. Max len of a BCSP pkt=
+				   0xFFF (payload) +4 (header) +2 (crc) */
+
+				bcsp->rx_skb = bt_skb_alloc(0x1005, GFP_ATOMIC);
+				if (!bcsp->rx_skb) {
+					PRINTM(ERROR,
+					       "Can't allocate mem for new packet\n");
+					bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+					bcsp->rx_count = 0;
+					return 0;
+				}
+				bcsp->rx_skb->dev = (void *)hu->hdev;
+				break;
+			}
+			break;
+		}
+	}
+	return count;
+}
+
+/* Arrange to retransmit all messages in the relq. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+static void
+bcsp_timed_event(struct timer_list *t)
+{
+	struct bcsp_struct *bcsp = from_timer(bcsp, t, tbcsp);
+	struct hci_uart *hu = bcsp->hu;
+#else
+static void
+bcsp_timed_event(unsigned long arg)
+{
+	struct hci_uart *hu = (struct hci_uart *)arg;
+	struct bcsp_struct *bcsp = hu->priv;
+#endif
+	struct sk_buff *skb;
+	unsigned long flags;
+
+	PRINTM(EVENT, "hu %p retransmitting %u pkts\n", hu, bcsp->unack.qlen);
+
+	spin_lock_irqsave_nested(&bcsp->unack.lock, flags,
+				 SINGLE_DEPTH_NESTING);
+
+	while ((skb = __skb_dequeue_tail(&bcsp->unack)) != NULL) {
+		bcsp->msgq_txseq = (bcsp->msgq_txseq - 1) & 0x07;
+		skb_queue_head(&bcsp->rel, skb);
+	}
+
+	spin_unlock_irqrestore(&bcsp->unack.lock, flags);
+
+	hci_uart_tx_wakeup(hu);
+}
+
+static int
+bcsp_open(struct hci_uart *hu)
+{
+	struct bcsp_struct *bcsp;
+
+	PRINTM(CMD, "bcsp open hu %p\n", hu);
+
+	bcsp = kzalloc(sizeof(*bcsp), GFP_ATOMIC);
+	if (!bcsp)
+		return -ENOMEM;
+
+	hu->priv = bcsp;
+	bcsp->hu = hu;
+	skb_queue_head_init(&bcsp->unack);
+	skb_queue_head_init(&bcsp->rel);
+	skb_queue_head_init(&bcsp->unrel);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	timer_setup(&bcsp->tbcsp, bcsp_timed_event, 0);
+#else
+	init_timer(&bcsp->tbcsp);
+	bcsp->tbcsp.function = bcsp_timed_event;
+	bcsp->tbcsp.data = (u_long) hu;
+#endif
+
+	bcsp->rx_state = BCSP_W4_PKT_DELIMITER;
+
+	if (txcrc)
+		bcsp->use_crc = 1;
+
+	return 0;
+}
+
+static int
+bcsp_close(struct hci_uart *hu)
+{
+	struct bcsp_struct *bcsp = hu->priv;
+	hu->priv = NULL;
+
+	PRINTM(CMD, "bcsp close hu %p\n", hu);
+
+	skb_queue_purge(&bcsp->unack);
+	skb_queue_purge(&bcsp->rel);
+	skb_queue_purge(&bcsp->unrel);
+	del_timer(&bcsp->tbcsp);
+
+	kfree(bcsp);
+	return 0;
+}
+
+static struct hci_uart_proto bcsp = {
+	.id = HCI_UART_BCSP,
+	.open = bcsp_open,
+	.close = bcsp_close,
+	.enqueue = bcsp_enqueue,
+	.dequeue = bcsp_dequeue,
+	.recv = bcsp_recv,
+	.flush = bcsp_flush
+};
+
+int
+bcsp_init(void)
+{
+	int err = hci_uart_register_proto(&bcsp);
+
+	if (!err)
+		PRINTM(MSG, "HCI BCSP protocol initialized\n");
+	else
+		PRINTM(ERROR, "HCI BCSP protocol registration failed\n");
+
+	return err;
+}
+
+int
+bcsp_deinit(void)
+{
+	return hci_uart_unregister_proto(&bcsp);
+}
+
+module_param(txcrc, bool, 0644);
+MODULE_PARM_DESC(txcrc, "Transmit CRC with every BCSP packet");
+
+module_param(hciextn, bool, 0644);
+MODULE_PARM_DESC(hciextn, "Convert HCI Extensions into BCSP packets");
diff --git a/88x9098/bt/muart_src/hci_h4.c b/88x9098/bt/muart_src/hci_h4.c
new file mode 100644
index 0000000..2855dc4
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_h4.c
@@ -0,0 +1,594 @@
+/*
+ *
+ *  Bluetooth HCI UART driver
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/poll.h>
+
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/ioctl.h>
+#include <linux/skbuff.h>
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include <amp/bluetooth/bluetooth.h>
+#include <amp/bluetooth/hci_core.h>
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+
+#include "hci_uart.h"
+#include "bt_drv.h"
+
+#define VERSION "1.2"
+
+struct h4_struct {
+	unsigned long rx_state;
+	unsigned long rx_count;
+	struct sk_buff *rx_skb;
+	struct sk_buff_head txq;
+};
+
+/* H4 receiver States */
+#define H4_W4_PACKET_TYPE	0
+#define H4_W4_EVENT_HDR		1
+#define H4_W4_ACL_HDR		2
+#define H4_W4_SCO_HDR		3
+#define H4_W4_DATA		4
+
+/* Initialize protocol */
+static int
+h4_open(struct hci_uart *hu)
+{
+	struct h4_struct *h4;
+
+	PRINTM(CMD, "h4 open %p\n", hu);
+
+	h4 = kzalloc(sizeof(*h4), GFP_ATOMIC);
+	if (!h4)
+		return -ENOMEM;
+
+	skb_queue_head_init(&h4->txq);
+
+	hu->priv = h4;
+	return 0;
+}
+
+/* Flush protocol data */
+static int
+h4_flush(struct hci_uart *hu)
+{
+	struct h4_struct *h4 = hu->priv;
+
+	PRINTM(CMD, "h4 flush hu %p\n", hu);
+
+	skb_queue_purge(&h4->txq);
+
+	return 0;
+}
+
+/* Close protocol */
+static int
+h4_close(struct hci_uart *hu)
+{
+	struct h4_struct *h4 = hu->priv;
+
+	hu->priv = NULL;
+
+	PRINTM(CMD, "h4 close hu %p\n", hu);
+
+	skb_queue_purge(&h4->txq);
+
+	if (h4->rx_skb)
+		kfree_skb(h4->rx_skb);
+
+	hu->priv = NULL;
+	kfree(h4);
+
+	return 0;
+}
+
+/* Enqueue frame for transmittion (padding, crc, etc) */
+static int
+h4_enqueue(struct hci_uart *hu, struct sk_buff *skb)
+{
+	struct h4_struct *h4 = hu->priv;
+
+	PRINTM(INFO, "h4 enqueue skb %p\n", skb);
+
+	/* Prepend skb with frame type */
+	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
+	skb_queue_tail(&h4->txq, skb);
+
+	return 0;
+}
+
+static inline int
+h4_check_data_len(struct h4_struct *h4, int len)
+{
+	register int room = skb_tailroom(h4->rx_skb);
+
+	PRINTM(INFO, "h4_check_data_len: len %d room %d\n", len, room);
+
+	if (!len) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+		hci_recv_frame(h4->rx_skb);
+#else
+		hci_recv_frame((struct hci_dev *)h4->rx_skb->dev, h4->rx_skb);
+#endif
+#else
+		hci_recv_frame(h4->rx_skb);
+#endif
+	} else if (len > room) {
+		PRINTM(ERROR, "Data length is too large\n");
+		kfree_skb(h4->rx_skb);
+	} else {
+		h4->rx_state = H4_W4_DATA;
+		h4->rx_count = len;
+		return len;
+	}
+
+	h4->rx_state = H4_W4_PACKET_TYPE;
+	h4->rx_skb = NULL;
+	h4->rx_count = 0;
+
+	return 0;
+}
+
+/* Recv data */
+static int
+h4_recv(struct hci_uart *hu, void *data, int count)
+{
+	struct h4_struct *h4 = hu->priv;
+	register char *ptr;
+	struct hci_event_hdr *eh;
+	struct hci_acl_hdr *ah;
+	struct hci_sco_hdr *sh;
+	register int len, type = 0, dlen;
+
+	struct hci_dev *hdev = NULL;
+	struct m_dev *mdev_fm = &(hu->m_dev[FM_SEQ]);
+	struct m_dev *mdev_nfc = &(hu->m_dev[NFC_SEQ]);
+	struct nfc_dev *nfc_dev =
+		(struct nfc_dev *)hu->m_dev[NFC_SEQ].dev_pointer;
+	struct fm_dev *fm_dev = (struct fm_dev *)hu->m_dev[FM_SEQ].dev_pointer;
+
+	hdev = (struct hci_dev *)hu->hdev;
+
+	PRINTM(INFO, "h4_recv: hu %p count %d rx_state %ld rx_count %ld\n",
+	       hu, count, h4->rx_state, h4->rx_count);
+
+	ptr = data;
+	while (count) {
+		if (h4->rx_count) {
+			len = min_t(unsigned int, h4->rx_count, count);
+			memcpy(skb_put(h4->rx_skb, len), ptr, len);
+			h4->rx_count -= len;
+			count -= len;
+			ptr += len;
+
+			if (h4->rx_count)
+				continue;
+
+			switch (h4->rx_state) {
+			case H4_W4_DATA:
+				type = bt_cb(h4->rx_skb)->pkt_type;
+				PRINTM(DATA, "H4 Rx: type=%d len=%d\n", type,
+				       h4->rx_skb->len);
+#ifdef CONFIG_BT_HCIUART_PS
+				if (type == HCI_EVENT_PKT)
+#ifdef CONFIG_MULTI_CARD_PS
+					ps_check_event_packet(hu, h4->rx_skb);
+#else
+					ps_check_event_packet(h4->rx_skb);
+#endif
+#endif
+				if (type == HCI_EVENT_PKT) {
+					switch (h4->rx_skb->data[0]) {
+					case 0x0E:
+							/** cmd complete */
+						if (h4->rx_skb->data[3] == 0x80
+						    && h4->rx_skb->data[4] ==
+						    0xFE) {
+								/** FM cmd complete */
+							if (fm_dev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									mdev_fm;
+								mdev_recv_frame
+									(h4->
+									 rx_skb);
+								mdev_fm->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						} else if (h4->rx_skb->
+							   data[3] == 0x81 &&
+							   h4->rx_skb->
+							   data[4] == 0xFE) {
+								/** NFC cmd complete */
+							if (nfc_dev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									mdev_nfc;
+								mdev_recv_frame
+									(h4->
+									 rx_skb);
+								mdev_nfc->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						} else {
+							if (hdev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									hdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+								hci_recv_frame
+									(h4->
+									 rx_skb);
+#else
+								hci_recv_frame
+									(hdev,
+									 h4->
+									 rx_skb);
+#endif
+#else
+								hci_recv_frame
+									(h4->
+									 rx_skb);
+#endif
+								hdev->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						}
+						break;
+					case 0x0F:
+							/** cmd status */
+						if (h4->rx_skb->data[4] == 0x80
+						    && h4->rx_skb->data[5] ==
+						    0xFE) {
+								/** FM cmd ststus */
+							if (fm_dev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									mdev_fm;
+								mdev_recv_frame
+									(h4->
+									 rx_skb);
+								mdev_fm->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						} else if (h4->rx_skb->
+							   data[4] == 0x81 &&
+							   h4->rx_skb->
+							   data[5] == 0xFE) {
+								/** NFC cmd ststus */
+							if (nfc_dev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									mdev_nfc;
+								mdev_recv_frame
+									(h4->
+									 rx_skb);
+								mdev_nfc->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						} else {
+								/** BT cmd status */
+							if (hdev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									hdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+								hci_recv_frame
+									(h4->
+									 rx_skb);
+#else
+								hci_recv_frame
+									(hdev,
+									 h4->
+									 rx_skb);
+#endif
+#else
+								hci_recv_frame
+									(h4->
+									 rx_skb);
+#endif
+								hdev->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						}
+						break;
+					case 0xFF:
+							/** Vendor specific pkt */
+						if (h4->rx_skb->data[2] == 0xC0) {
+								/** NFC EVT */
+							if (nfc_dev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									mdev_nfc;
+								mdev_recv_frame
+									(h4->
+									 rx_skb);
+								mdev_nfc->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						} else if (h4->rx_skb->
+							   data[2] >= 0x80 &&
+							   h4->rx_skb->
+							   data[2] <= 0xAF) {
+								/** FM EVT */
+							if (fm_dev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									mdev_fm;
+								mdev_recv_frame
+									(h4->
+									 rx_skb);
+								mdev_fm->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						} else {
+								/** BT EVT */
+							if (hdev) {
+								h4->rx_skb->
+									dev =
+									(void *)
+									hdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+								hci_recv_frame
+									(h4->
+									 rx_skb);
+#else
+								hci_recv_frame
+									(hdev,
+									 h4->
+									 rx_skb);
+#endif
+#else
+								hci_recv_frame
+									(h4->
+									 rx_skb);
+#endif
+								hdev->stat.
+									byte_rx
+									+=
+									(len +
+									 HCI_EVENT_HDR_SIZE);
+							}
+						}
+						break;
+					default:
+							/** BT EVT */
+
+						if (hdev) {
+							h4->rx_skb->dev =
+								(void *)hdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+							hci_recv_frame(h4->
+								       rx_skb);
+#else
+							hci_recv_frame(hdev,
+								       h4->
+								       rx_skb);
+#endif
+#else
+							hci_recv_frame(h4->
+								       rx_skb);
+#endif
+							hdev->stat.byte_rx +=
+								(len +
+								 HCI_EVENT_HDR_SIZE);
+						}
+
+						break;
+					}
+				} else {
+					if (hdev) {
+						h4->rx_skb->dev = (void *)hdev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+						hci_recv_frame(h4->rx_skb);
+#else
+						hci_recv_frame(hdev,
+							       h4->rx_skb);
+#endif
+#else
+						hci_recv_frame(h4->rx_skb);
+#endif
+					}
+					if (type == HCI_ACLDATA_PKT)
+						hdev->stat.byte_rx +=
+							(len +
+							 HCI_ACL_HDR_SIZE);
+					else if (type == HCI_SCODATA_PKT)
+						hdev->stat.byte_rx +=
+							(len +
+							 HCI_SCO_HDR_SIZE);
+				}
+
+				h4->rx_state = H4_W4_PACKET_TYPE;
+				h4->rx_skb = NULL;
+				continue;
+
+			case H4_W4_EVENT_HDR:
+				eh = hci_event_hdr(h4->rx_skb);
+				PRINTM(INFO,
+				       "Event header: evt 0x%2.2x plen %d\n",
+				       eh->evt, eh->plen);
+
+				h4_check_data_len(h4, eh->plen);
+				continue;
+
+			case H4_W4_ACL_HDR:
+				ah = hci_acl_hdr(h4->rx_skb);
+				dlen = __le16_to_cpu(ah->dlen);
+
+				PRINTM(INFO, "ACL header: dlen %d\n", dlen);
+
+				h4_check_data_len(h4, dlen);
+				continue;
+
+			case H4_W4_SCO_HDR:
+				sh = hci_sco_hdr(h4->rx_skb);
+
+				PRINTM(INFO, "SCO header: dlen %d\n", sh->dlen);
+
+				h4_check_data_len(h4, sh->dlen);
+				continue;
+			}
+		}
+
+		/* H4_W4_PACKET_TYPE */
+		switch (*ptr) {
+		case HCI_EVENT_PKT:
+			PRINTM(INFO, "Event packet\n");
+			h4->rx_state = H4_W4_EVENT_HDR;
+			h4->rx_count = HCI_EVENT_HDR_SIZE;
+			type = HCI_EVENT_PKT;
+			break;
+
+		case HCI_ACLDATA_PKT:
+			PRINTM(INFO, "ACL packet\n");
+			h4->rx_state = H4_W4_ACL_HDR;
+			h4->rx_count = HCI_ACL_HDR_SIZE;
+			type = HCI_ACLDATA_PKT;
+			break;
+
+		case HCI_SCODATA_PKT:
+			PRINTM(INFO, "SCO packet\n");
+			h4->rx_state = H4_W4_SCO_HDR;
+			h4->rx_count = HCI_SCO_HDR_SIZE;
+			type = HCI_SCODATA_PKT;
+			break;
+
+		default:
+			PRINTM(ERROR, "Unknown HCI packet type %2.2x\n",
+			       (__u8) * ptr);
+			hu->hdev->stat.err_rx++;
+			ptr++;
+			count--;
+			continue;
+		};
+
+		ptr++;
+		count--;
+
+		/* Allocate packet */
+		h4->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
+		if (!h4->rx_skb) {
+			PRINTM(ERROR, "Can't allocate mem for new packet\n");
+			h4->rx_state = H4_W4_PACKET_TYPE;
+			h4->rx_count = 0;
+			return 0;
+		}
+
+		bt_cb(h4->rx_skb)->pkt_type = type;
+	}
+
+	return count;
+}
+
+static struct sk_buff *
+h4_dequeue(struct hci_uart *hu)
+{
+	struct h4_struct *h4 = hu->priv;
+	return skb_dequeue(&h4->txq);
+}
+
+static struct hci_uart_proto h4p = {
+	.id = HCI_UART_H4,
+	.open = h4_open,
+	.close = h4_close,
+	.recv = h4_recv,
+	.enqueue = h4_enqueue,
+	.dequeue = h4_dequeue,
+	.flush = h4_flush,
+};
+
+int
+h4_init(void)
+{
+	int err = hci_uart_register_proto(&h4p);
+
+	if (!err)
+		PRINTM(MSG, "HCI H4 protocol initialized\n");
+	else
+		PRINTM(ERROR, "HCI H4 protocol registration failed");
+
+	return err;
+}
+
+int
+h4_deinit(void)
+{
+	return hci_uart_unregister_proto(&h4p);
+}
diff --git a/88x9098/bt/muart_src/hci_ldisc.c b/88x9098/bt/muart_src/hci_ldisc.c
new file mode 100644
index 0000000..5475415
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_ldisc.c
@@ -0,0 +1,930 @@
+/*
+ *
+ *  Bluetooth HCI UART driver
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright 2018-2021 NXP
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/poll.h>
+
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/ioctl.h>
+#include <linux/skbuff.h>
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include <amp/bluetooth/bluetooth.h>
+#include <amp/bluetooth/hci_core.h>
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+
+#include "include/hci.h"
+#include "hci_uart.h"
+#include "bt_drv.h"
+#include "mbt_char.h"
+#include "hci_wrapper.h"
+
+/* HU device list */
+LIST_HEAD(hu_dev_list);
+static DEFINE_SPINLOCK(hu_list_lock);
+
+#define VERSION "2.2-M2614100"
+
+/** Default Driver mode */
+int drv_mode = (DRV_MODE_BT | DRV_MODE_FM | DRV_MODE_NFC);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+int reset = 0;
+#else
+bool reset = 0;
+#endif
+
+static struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];
+
+int
+hci_uart_register_proto(struct hci_uart_proto *p)
+{
+	if (p->id >= HCI_UART_MAX_PROTO)
+		return -EINVAL;
+
+	if (hup[p->id])
+		return -EEXIST;
+
+	hup[p->id] = p;
+
+	return 0;
+}
+
+int
+hci_uart_unregister_proto(struct hci_uart_proto *p)
+{
+	if (p->id >= HCI_UART_MAX_PROTO)
+		return -EINVAL;
+
+	if (!hup[p->id])
+		return -EINVAL;
+
+	hup[p->id] = NULL;
+
+	return 0;
+}
+
+static struct hci_uart_proto *
+hci_uart_get_proto(unsigned int id)
+{
+	if (id >= HCI_UART_MAX_PROTO)
+		return NULL;
+
+	return hup[id];
+}
+
+static inline void
+hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)
+{
+	struct hci_dev *hdev = hu->hdev;
+#ifdef CONFIG_BT_HCIUART_PS
+	struct tty_struct *tty = hu->tty;
+#endif
+
+	/* Update HCI stat counters */
+	switch (pkt_type) {
+	case HCI_COMMAND_PKT:
+		hdev->stat.cmd_tx++;
+		break;
+
+	case HCI_ACLDATA_PKT:
+		hdev->stat.acl_tx++;
+		break;
+
+	case HCI_SCODATA_PKT:
+		hdev->stat.cmd_tx++;
+		break;
+#ifdef CONFIG_BT_HCIUART_PS
+	case MRVL_ENTER_PS_CHAR:
+		clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+#ifdef CONFIG_MULTI_CARD_PS
+		ps_send_char_complete(hu, pkt_type);
+#else
+		ps_send_char_complete(pkt_type);
+#endif
+		break;
+	case MRVL_EXIT_PS_CHAR:
+#ifdef CONFIG_MULTI_CARD_PS
+		ps_send_char_complete(hu, pkt_type);
+#else
+		ps_send_char_complete(pkt_type);
+#endif
+		break;
+#endif
+	}
+}
+
+static inline struct sk_buff *
+hci_uart_dequeue(struct hci_uart *hu)
+{
+	struct sk_buff *skb = hu->tx_skb;
+
+	if (!skb)
+		skb = hu->proto->dequeue(hu);
+	else
+		hu->tx_skb = NULL;
+
+	return skb;
+}
+
+int
+hci_uart_tx_wakeup(struct hci_uart *hu)
+{
+
+	if (test_and_set_bit(HCI_UART_SENDING, &hu->tx_state)) {
+		set_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);
+		return 0;
+	}
+#ifdef CONFIG_BT_HCIUART_PS
+#ifdef CONFIG_MULTI_CARD_PS
+	if (ps_wakeup(hu)) {
+#else
+	if (ps_wakeup()) {
+#endif
+		clear_bit(HCI_UART_SENDING, &hu->tx_state);
+		return 0;
+	}
+#ifdef CONFIG_MULTI_CARD_PS
+	ps_start_timer(hu);
+#else
+	ps_start_timer();
+#endif
+#endif
+
+	PRINTM(INFO, "hci_uart_tx_wakeup\n");
+
+	schedule_work(&hu->write_work);
+
+	return 0;
+}
+
+static void
+hci_uart_write_work(struct work_struct *work)
+{
+	struct hci_uart *hu = container_of(work, struct hci_uart, write_work);
+	struct tty_struct *tty = hu->tty;
+	struct hci_dev *hdev = hu->hdev;
+	struct sk_buff *skb;
+
+restart:
+	clear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);
+
+	while ((skb = hci_uart_dequeue(hu))) {
+		int len;
+
+		DBG_HEXDUMP(DAT_D, "hci_uart TX", skb->data, skb->len);
+
+		set_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+		len = TTY_FUNC->write(tty, skb->data, skb->len);
+		if (hdev == (struct hci_dev *)skb->dev) {
+			hdev->stat.byte_tx += len;
+		} else {
+			struct m_dev *mdev = NULL;
+			mdev = (struct m_dev *)skb->dev;
+			mdev->stat.byte_tx += len;
+		}
+
+		skb_pull(skb, len);
+		if (skb->len) {
+			hu->tx_skb = skb;
+			break;
+		}
+
+		hci_uart_tx_complete(hu, bt_cb(skb)->pkt_type);
+		kfree_skb(skb);
+	}
+
+	if (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state))
+		goto restart;
+
+	clear_bit(HCI_UART_SENDING, &hu->tx_state);
+}
+
+/* ------- Interface to HCI layer ------ */
+/* Initialize device */
+int
+hci_uart_open(struct hci_dev *hdev)
+{
+#if (defined(CONFIG_MULTI_CARD_PS) && defined(CONFIG_BT_HCIUART_PS))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+	struct hci_uart *hu = (struct hci_uart *)hdev->driver_data;
+#else
+	struct hci_uart *hu = (struct hci_uart *)hci_get_drvdata(hdev);
+#endif
+#else
+	struct hci_uart *hu = (struct hci_uart *)hdev->driver_data;
+#endif
+#endif
+	PRINTM(CMD, "hci uart %s open %p\n", hdev->name, hdev);
+	/* Nothing to do for UART driver */
+	set_bit(HCI_RUNNING, &hdev->flags);
+#ifdef CONFIG_BT_HCIUART_PS
+#ifdef CONFIG_MULTI_CARD_PS
+	ps_init(hu);
+#else
+	ps_init();
+#endif
+#endif
+	return 0;
+}
+
+/* Reset device */
+int
+hci_uart_flush(struct hci_dev *hdev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+	struct hci_uart *hu = (struct hci_uart *)hdev->driver_data;
+#else
+	struct hci_uart *hu = (struct hci_uart *)hci_get_drvdata(hdev);
+#endif
+#else
+	struct hci_uart *hu = (struct hci_uart *)hdev->driver_data;
+#endif
+	struct tty_struct *tty = hu->tty;
+
+	PRINTM(CMD, "hci uart flush hdev %p tty %p\n", hdev, tty);
+
+	if (hu->tx_skb) {
+		kfree_skb(hu->tx_skb);
+		hu->tx_skb = NULL;
+	}
+
+	/* Flush any pending characters in the driver and discipline. */
+	tty_ldisc_flush(tty);
+	if (TTY_FUNC && TTY_FUNC->flush_buffer)
+		TTY_FUNC->flush_buffer(tty);
+
+	if (test_bit(HCI_UART_PROTO_SET, &hu->flags))
+		hu->proto->flush(hu);
+
+	return 0;
+}
+
+/* Close device */
+int
+hci_uart_close(struct hci_dev *hdev)
+{
+	PRINTM(CMD, "hci uart close hdev %p\n", hdev);
+
+	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
+		return 0;
+
+	hci_uart_flush(hdev);
+	hdev->flush = NULL;
+	return 0;
+}
+
+/* Send frames from HCI layer */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+int
+hci_uart_send_frame(struct sk_buff *skb)
+#else
+int
+hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+#endif
+#else
+int
+hci_uart_send_frame(struct sk_buff *skb)
+#endif
+{
+	struct tty_struct *tty;
+	struct hci_uart *hu;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+#else
+	skb->dev = (void *)hdev;
+#endif
+#else
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+#endif
+
+	if (!hdev) {
+		PRINTM(ERROR, "Frame for uknown device (hdev=NULL)\n");
+		return -ENODEV;
+	}
+	if (!test_bit(HCI_RUNNING, &hdev->flags))
+		return -EBUSY;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+	hu = (struct hci_uart *)hdev->driver_data;
+#else
+	hu = (struct hci_uart *)hci_get_drvdata(hdev);
+#endif
+#else
+	hu = (struct hci_uart *)hdev->driver_data;
+#endif
+	tty = hu->tty;
+	if (!tty) {
+		PRINTM(ERROR, "tty is not ready\n");
+		return -ENODEV;
+	}
+
+	PRINTM(DATA, "%s: Tx type %d len %d\n", hdev->name,
+	       bt_cb(skb)->pkt_type, skb->len);
+
+	hu->proto->enqueue(hu, skb);
+
+	hci_uart_tx_wakeup(hu);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+void
+hci_uart_destruct(struct hci_dev *hdev)
+{
+	if (!hdev)
+		return;
+
+	PRINTM(CMD, "hci uart destruct %s\n", hdev->name);
+	kfree(hdev->driver_data);
+}
+#endif
+
+static atomic_t intf_cnt = ATOMIC_INIT(0);
+struct class *chardev_class = NULL;
+/* ------ LDISC part ------ */
+/* hci_uart_tty_open
+ *
+ *     Called when line discipline changed to HCI_UART.
+ *
+ * Arguments:
+ *     tty    pointer to tty info structure
+ * Return Value:
+ *     0 if success, otherwise error code
+ */
+static int
+hci_uart_tty_open(struct tty_struct *tty)
+{
+	struct hci_uart *hu = (void *)tty->disc_data;
+	unsigned char id = 0;
+	unsigned long flags;
+	struct list_head *head = &hu_dev_list, *p;
+
+	if (hu)
+		return -EEXIST;
+
+	if (!(hu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL))) {
+		PRINTM(ERROR, "Can't allocate control structure\n");
+		return -ENFILE;
+	}
+
+	spin_lock_irqsave(&hu_list_lock, flags);
+	{
+		/* Find first available device id */
+		list_for_each(p, &hu_dev_list) {
+			if (list_entry(p, struct hci_uart, hu_list_head)->id !=
+			    id)
+				 break;
+			head = p;
+			id++;
+		}
+		hu->id = id;
+	}
+	list_add(&hu->hu_list_head, head);
+	spin_unlock_irqrestore(&hu_list_lock, flags);
+
+	tty->disc_data = hu;
+	hu->tty = tty;
+	tty->receive_room = 65536;
+
+	INIT_WORK(&hu->write_work, hci_uart_write_work);
+	hu->chardev_class = chardev_class;
+	atomic_inc(&intf_cnt);
+
+	spin_lock_init(&hu->rx_lock);
+
+	/* Flush any pending characters in the driver and line discipline. */
+
+	/* FIXME: why is this needed. Note don't use ldisc_ref here as the open
+	   path is before the ldisc is referencable */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	if (tty->ldisc->ops->flush_buffer)
+		tty->ldisc->ops->flush_buffer(tty);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+	if (tty->ldisc.ops->flush_buffer)
+		tty->ldisc.ops->flush_buffer(tty);
+#else
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+#endif
+#endif
+	if (TTY_FUNC && TTY_FUNC->flush_buffer)
+		TTY_FUNC->flush_buffer(tty);
+
+#ifdef CONFIG_BT_HCIUART_PS
+#ifdef CONFIG_MULTI_CARD_PS
+	if (0 == ps_init_work(hu))
+		ps_init_timer(hu);
+#else
+	ps_init_timer(tty);
+#endif
+#endif
+	return 0;
+}
+
+/* hci_uart_tty_close()
+ *
+ *    Called when the line discipline is changed to something
+ *    else, the tty is closed, or the tty detects a hangup.
+ */
+static void
+hci_uart_tty_close(struct tty_struct *tty)
+{
+	struct hci_uart *hu = (void *)tty->disc_data;
+	unsigned long flags;
+	struct list_head *p = NULL;
+	struct list_head *n = NULL;
+
+	PRINTM(CMD, "hci uart tty close\n");
+
+	/* Detach from the tty */
+	tty->disc_data = NULL;
+
+	if (hu) {
+		struct hci_dev *hdev = hu->hdev;
+
+#if defined(CONFIG_BT_HCIUART_PS) && defined(CONFIG_MULTI_CARD_PS)
+		ps_cancel_timer(hu);
+		ps_proc_remove(hu);
+#endif
+
+		if (hdev)
+			hci_uart_close(hdev);
+		cancel_work_sync(&hu->write_work);
+
+		if (test_and_clear_bit(HCI_UART_PROTO_SET, &hu->flags)) {
+			hu->proto->close(hu);
+
+			if (drv_mode & DRV_MODE_BT) {
+				hci_unregister_dev(hdev);
+				hci_free_dev(hdev);
+			}
+			if (drv_mode & DRV_MODE_FM) {
+				mdev_unregister_dev(&hu->m_dev[FM_SEQ], FM_SEQ);
+			}
+			if (drv_mode & DRV_MODE_NFC) {
+				mdev_unregister_dev(&hu->m_dev[NFC_SEQ],
+						    NFC_SEQ);
+			}
+		}
+		atomic_dec(&intf_cnt);
+		hu->chardev_class = NULL;
+		spin_lock_irqsave(&hu_list_lock, flags);
+		list_for_each_safe(p, n, &hu_dev_list) {
+			if (hu->id ==
+			    list_entry(p, struct hci_uart, hu_list_head)->id) {
+				list_del(p);
+			}
+		}
+		spin_unlock_irqrestore(&hu_list_lock, flags);
+	}
+#if defined(CONFIG_BT_HCIUART_PS) && !defined(CONFIG_MULTI_CARD_PS)
+	ps_cancel_timer();
+#endif
+}
+
+/* hci_uart_tty_wakeup()
+ *
+ *    Callback for transmit wakeup. Called when low level
+ *    device driver can accept more send data.
+ *
+ * Arguments:        tty    pointer to associated tty instance data
+ * Return Value:    None
+ */
+static void
+hci_uart_tty_wakeup(struct tty_struct *tty)
+{
+	struct hci_uart *hu = (void *)tty->disc_data;
+
+	PRINTM(INFO, "hci_uart_tty_wakeup\n");
+
+	if (!hu)
+		return;
+
+	clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+
+	if (tty != hu->tty)
+		return;
+	if (test_bit(HCI_UART_PROTO_SET, &hu->flags))
+		hci_uart_tx_wakeup(hu);
+}
+
+/* hci_uart_tty_receive()
+ *
+ *     Called by tty low level driver when receive data is
+ *     available.
+ *
+ * Arguments:  tty          pointer to tty isntance data
+ *             data         pointer to received data
+ *             flags        pointer to flags for data
+ *             count        count of received data in bytes
+ *
+ * Return Value:    None
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+static void
+hci_uart_tty_receive(struct tty_struct *tty, const u8 * data, const char *flags,
+		     int count)
+#else
+static void
+hci_uart_tty_receive(struct tty_struct *tty, const u8 * data, char *flags,
+		     int count)
+#endif
+{
+	struct hci_uart *hu = (void *)tty->disc_data;
+
+	if (!hu || tty != hu->tty)
+		return;
+
+	if (!test_bit(HCI_UART_PROTO_SET, &hu->flags))
+		return;
+
+#ifdef CONFIG_BT_HCIUART_PS
+	DBG_HEXDUMP(DAT_D, "hci uart tty rx", (u8 *) data, count);
+#ifdef CONFIG_MULTI_CARD_PS
+	ps_start_timer(hu);
+#else
+	ps_start_timer();
+#endif
+#endif
+	spin_lock(&hu->rx_lock);
+	hu->proto->recv(hu, (void *)data, count);
+	spin_unlock(&hu->rx_lock);
+
+	if (test_and_clear_bit(TTY_THROTTLED, &tty->flags) &&
+	    TTY_FUNC->unthrottle)
+		TTY_FUNC->unthrottle(tty);
+}
+
+static int
+hci_uart_register_dev(struct hci_uart *hu)
+{
+
+	struct hci_dev *hdev = NULL;
+	int ret = 0;
+
+	PRINTM(CMD, "hci_uart_register_dev\n");
+
+	if (drv_mode & DRV_MODE_BT) {
+		hdev = hci_alloc_dev();
+		if (!hdev) {
+			PRINTM(ERROR, "Can't allocate HCI device\n");
+			return -ENOMEM;
+		}
+		hu->hdev = hdev;
+
+		hdev->open = hci_uart_open;
+		hdev->close = hci_uart_close;
+		hdev->flush = hci_uart_flush;
+		hdev->send = hci_uart_send_frame;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+		hdev->destruct = hci_uart_destruct;
+		hdev->owner = THIS_MODULE;
+		hdev->driver_data = hu;
+#else
+#if defined(BT_AMP) && !defined(MBT_EXT)
+		hdev->driver_data = hu;
+#else
+		hci_set_drvdata(hdev, hu);
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+		SET_HCIDEV_DEV(hdev, hu->tty->dev);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
+		hdev->bus = HCI_UART;
+#else
+		hdev->type = HCI_UART;
+#endif /* >= 2.6.34 */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+		if (!reset)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+			set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);
+#else
+			set_bit(HCI_QUIRK_NO_RESET, &hdev->quirks);
+#endif
+#else
+		if (reset)
+			set_bit(HCI_QUIRK_RESET_ON_INIT, &hdev->quirks);
+#endif /* >= 2.6.29 */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
+		hdev->dev_type = DEV_TYPE_BT;
+#endif
+		ret = hci_register_dev(hdev);
+		if (ret < 0) {
+			PRINTM(ERROR, "Can't register HCI device\n");
+			hci_free_dev(hdev);
+			return -ENODEV;
+		}
+		snprintf(hu->m_dev[BT_SEQ].name, sizeof(hu->m_dev[BT_SEQ].name),
+			 hdev->name);
+	}
+
+	if (drv_mode & DRV_MODE_FM) {
+		hu->m_dev[FM_SEQ].driver_data = hu;
+		if ((ret = mdev_register_dev(&hu->m_dev[FM_SEQ], FM_SEQ)))
+			goto err_mdev_reg;
+	}
+	if (drv_mode & DRV_MODE_NFC) {
+		hu->m_dev[NFC_SEQ].driver_data = hu;
+		if ((ret = mdev_register_dev(&hu->m_dev[NFC_SEQ], NFC_SEQ)))
+			goto err_mdev_reg;
+	}
+
+#if defined(CONFIG_BT_HCIUART_PS) && defined(CONFIG_MULTI_CARD_PS)
+	ps_proc_init(hu);
+#endif
+	return ret;
+
+err_mdev_reg:
+	if (drv_mode & DRV_MODE_BT) {
+		hci_unregister_dev(hdev);
+		hci_free_dev(hdev);
+	}
+	if (drv_mode & DRV_MODE_FM) {
+		mdev_unregister_dev(&hu->m_dev[FM_SEQ], FM_SEQ);
+	}
+	if (drv_mode & DRV_MODE_NFC) {
+		mdev_unregister_dev(&hu->m_dev[NFC_SEQ], NFC_SEQ);
+	}
+	return ret;
+}
+
+static int
+hci_uart_set_proto(struct hci_uart *hu, int id)
+{
+	struct hci_uart_proto *p;
+	int err;
+	p = hci_uart_get_proto(id);
+	if (!p)
+		return -EPROTONOSUPPORT;
+
+	err = p->open(hu);
+	if (err)
+		return err;
+
+	hu->proto = p;
+
+	err = hci_uart_register_dev(hu);
+	if (err) {
+		p->close(hu);
+		return err;
+	}
+	return 0;
+}
+
+/* hci_uart_tty_ioctl()
+ *
+ *    Process IOCTL system call for the tty device.
+ *
+ * Arguments:
+ *
+ *    tty        pointer to tty instance data
+ *    file       pointer to open file object for device
+ *    cmd        IOCTL command code
+ *    arg        argument for IOCTL call (cmd dependent)
+ *
+ * Return Value:    Command dependent
+ */
+static int
+hci_uart_tty_ioctl(struct tty_struct *tty, struct file *file,
+		   unsigned int cmd, unsigned long arg)
+{
+	struct hci_uart *hu = (void *)tty->disc_data;
+	int err = 0;
+
+	PRINTM(CMD, "hci_uart_tty_ioctl: %d\n", cmd);
+
+	/* Verify the status of the device */
+	if (!hu)
+		return -EBADF;
+
+	switch (cmd) {
+	case HCIUARTSETPROTO:
+		if (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {
+			err = hci_uart_set_proto(hu, arg);
+			if (err) {
+				clear_bit(HCI_UART_PROTO_SET, &hu->flags);
+				return err;
+			}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,12,0)
+			tty->port->low_latency = 1;
+#endif
+#else
+			tty->low_latency = 1;
+#endif
+		} else
+			return -EBUSY;
+		break;
+
+	case HCIUARTGETPROTO:
+		if (test_bit(HCI_UART_PROTO_SET, &hu->flags))
+			return hu->proto->id;
+		return -EUNATCH;
+
+	case HCIUARTGETDEVICE:
+		if (test_bit(HCI_UART_PROTO_SET, &hu->flags))
+			return hu->hdev->id;
+		return -EUNATCH;
+
+	default:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+		err = n_tty_ioctl_helper(tty, file, cmd, arg);
+#else
+		err = n_tty_ioctl(tty, file, cmd, arg);
+#endif
+		break;
+	};
+
+	return err;
+}
+
+/*
+ * We don't provide read/write/poll interface for user space.
+ */
+static ssize_t
+hci_uart_tty_read(struct tty_struct *tty, struct file *file,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 20)
+		  unsigned char *buf, size_t nr,
+		  void **cookie, unsigned long offset)
+#else
+		  unsigned char __user * buf, size_t nr)
+#endif
+{
+	return 0;
+}
+
+static ssize_t
+hci_uart_tty_write(struct tty_struct *tty, struct file *file,
+		   const unsigned char *data, size_t count)
+{
+	return 0;
+}
+
+static unsigned int
+hci_uart_tty_poll(struct tty_struct *tty, struct file *filp, poll_table * wait)
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+static struct tty_ldisc_ops hci_uart_ldisc = {
+#else
+static struct tty_ldisc hci_uart_ldisc = {
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	.magic = TTY_LDISC_MAGIC,
+#endif
+	.owner = THIS_MODULE,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+	.num = N_HCI,
+#endif
+	.name = "n_hci",
+	.open = hci_uart_tty_open,
+	.close = hci_uart_tty_close,
+	.read = hci_uart_tty_read,
+	.write = hci_uart_tty_write,
+	.ioctl = hci_uart_tty_ioctl,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+	.compat_ioctl = hci_uart_tty_ioctl,
+#endif
+	.poll = hci_uart_tty_poll,
+	.receive_buf = hci_uart_tty_receive,
+	.write_wakeup = hci_uart_tty_wakeup,
+};
+
+static int __init
+hci_uart_init(void)
+{
+	int err;
+
+	PRINTM(MSG, "HCI UART driver ver %s", VERSION);
+	chardev_class = class_create(THIS_MODULE, MODULE_NAME);
+	if (IS_ERR(chardev_class)) {
+		PRINTM(ERROR, "Unable to allocate class\n");
+		return PTR_ERR(chardev_class);
+	}
+
+	/* Register the tty discipline */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+	if ((err = tty_register_ldisc(&hci_uart_ldisc))) {
+#else
+	if ((err = tty_register_ldisc(N_HCI, &hci_uart_ldisc))) {
+#endif
+		PRINTM(ERROR, "HCI line discipline registration failed. (%d)\n",
+		       err);
+		return err;
+	}
+#ifdef CONFIG_BT_HCIUART_H4
+	h4_init();
+#endif
+#ifdef CONFIG_BT_HCIUART_BCSP
+	bcsp_init();
+#endif
+#ifdef CONFIG_BT_HCIUART_LL
+	ll_init();
+#endif
+#ifdef CONFIG_BT_HCIUART_PS
+	proc_init();
+#endif
+	return 0;
+}
+
+static void __exit
+hci_uart_exit(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
+	int err;
+#endif
+	/** Destroy char device class */
+	class_destroy(chardev_class);
+
+#ifdef CONFIG_BT_HCIUART_H4
+	h4_deinit();
+#endif
+#ifdef CONFIG_BT_HCIUART_BCSP
+	bcsp_deinit();
+#endif
+#ifdef CONFIG_BT_HCIUART_LL
+	ll_deinit();
+#endif
+
+	/* Release tty registration of line discipline */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+	tty_unregister_ldisc(&hci_uart_ldisc);
+#else
+	if ((err = tty_unregister_ldisc(N_HCI)))
+		PRINTM(ERROR, "Can't unregister HCI line discipline (%d)\n",
+		       err);
+#endif
+
+#ifdef CONFIG_BT_HCIUART_PS
+	muart_proc_remove();
+#endif
+}
+
+module_init(hci_uart_init);
+module_exit(hci_uart_exit);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+module_param(reset, int, 0644);
+#else
+module_param(reset, bool, 0644);
+#endif
+MODULE_PARM_DESC(reset, "Send HCI reset command on initialization");
+
+MODULE_AUTHOR
+	("Maxim Krasnyansky <maxk@qualcomm.com>, Marcel Holtmann <marcel@holtmann.org>");
+MODULE_DESCRIPTION("Bluetooth HCI UART driver ver " VERSION " (FP-" FPNUM ")");
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_LDISC(N_HCI);
+module_param(drv_mode, int, 0);
+MODULE_PARM_DESC(drv_mode, "Bit 0: BT/AMP/BLE; Bit 1: FM; Bit 2: NFC");
diff --git a/88x9098/bt/muart_src/hci_ll.c b/88x9098/bt/muart_src/hci_ll.c
new file mode 100644
index 0000000..83d88a2
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_ll.c
@@ -0,0 +1,591 @@
+/*
+ *  Texas Instruments' Bluetooth HCILL UART protocol
+ *
+ *  HCILL (HCI Low Level) is a Texas Instruments' power management
+ *  protocol extension to H4.
+ *
+ *  Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ *  Written by Ohad Ben-Cohen <ohad@bencohen.org>
+ *
+ *  Acknowledgements:
+ *  This file is based on hci_h4.c, which was written
+ *  by Maxim Krasnyansky and Marcel Holtmann.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2
+ *  as published by the Free Software Foundation
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/poll.h>
+
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/ioctl.h>
+#include <linux/skbuff.h>
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include <amp/bluetooth/bluetooth.h>
+#include <amp/bluetooth/hci_core.h>
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+
+#include "hci_uart.h"
+#include "bt_drv.h"
+
+/* HCILL commands */
+#define HCILL_GO_TO_SLEEP_IND	0x30
+#define HCILL_GO_TO_SLEEP_ACK	0x31
+#define HCILL_WAKE_UP_IND	0x32
+#define HCILL_WAKE_UP_ACK	0x33
+
+/* HCILL receiver States */
+#define HCILL_W4_PACKET_TYPE	0
+#define HCILL_W4_EVENT_HDR	1
+#define HCILL_W4_ACL_HDR	2
+#define HCILL_W4_SCO_HDR	3
+#define HCILL_W4_DATA		4
+
+/* HCILL states */
+enum hcill_states_e {
+	HCILL_ASLEEP,
+	HCILL_ASLEEP_TO_AWAKE,
+	HCILL_AWAKE,
+	HCILL_AWAKE_TO_ASLEEP
+};
+
+struct hcill_cmd {
+	u8 cmd;
+} __attribute__ ((packed));
+
+struct ll_struct {
+	unsigned long rx_state;
+	unsigned long rx_count;
+	struct sk_buff *rx_skb;
+	struct sk_buff_head txq;
+	spinlock_t hcill_lock;	/* HCILL state lock */
+	unsigned long hcill_state;	/* HCILL power state */
+	struct sk_buff_head tx_wait_q;	/* HCILL wait queue */
+};
+
+/*
+ * Builds and sends an HCILL command packet.
+ * These are very simple packets with only 1 cmd byte
+ */
+static int
+send_hcill_cmd(u8 cmd, struct hci_uart *hu)
+{
+	int err = 0;
+	struct sk_buff *skb = NULL;
+	struct ll_struct *ll = hu->priv;
+	struct hcill_cmd *hcill_packet;
+
+	PRINTM(CMD, "hu %p cmd 0x%x\n", hu, cmd);
+
+	/* allocate packet */
+	skb = bt_skb_alloc(1, GFP_ATOMIC);
+	if (!skb) {
+		PRINTM(ERROR, "cannot allocate memory for HCILL packet\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* prepare packet */
+	hcill_packet = (struct hcill_cmd *)skb_put(skb, 1);
+	hcill_packet->cmd = cmd;
+	skb->dev = (void *)hu->hdev;
+
+	/* send packet */
+	skb_queue_tail(&ll->txq, skb);
+out:
+	return err;
+}
+
+/* Initialize protocol */
+static int
+ll_open(struct hci_uart *hu)
+{
+	struct ll_struct *ll;
+
+	PRINTM(CMD, "ll open\n");
+
+	ll = kzalloc(sizeof(*ll), GFP_ATOMIC);
+	if (!ll)
+		return -ENOMEM;
+
+	skb_queue_head_init(&ll->txq);
+	skb_queue_head_init(&ll->tx_wait_q);
+	spin_lock_init(&ll->hcill_lock);
+
+	ll->hcill_state = HCILL_AWAKE;
+
+	hu->priv = ll;
+
+	return 0;
+}
+
+/* Flush protocol data */
+static int
+ll_flush(struct hci_uart *hu)
+{
+	struct ll_struct *ll = hu->priv;
+
+	PRINTM(CMD, "ll flush hu %p\n", hu);
+
+	skb_queue_purge(&ll->tx_wait_q);
+	skb_queue_purge(&ll->txq);
+
+	return 0;
+}
+
+/* Close protocol */
+static int
+ll_close(struct hci_uart *hu)
+{
+	struct ll_struct *ll = hu->priv;
+
+	PRINTM(CMD, "ll close hu %p\n", hu);
+
+	skb_queue_purge(&ll->tx_wait_q);
+	skb_queue_purge(&ll->txq);
+
+	if (ll->rx_skb)
+		kfree_skb(ll->rx_skb);
+
+	hu->priv = NULL;
+
+	kfree(ll);
+
+	return 0;
+}
+
+/*
+ * internal function, which does common work of the device wake up process:
+ * 1. places all pending packets (waiting in tx_wait_q list) in txq list.
+ * 2. changes internal state to HCILL_AWAKE.
+ * Note: assumes that hcill_lock spinlock is taken,
+ * shouldn't be called otherwise!
+ */
+static void
+__ll_do_awake(struct ll_struct *ll)
+{
+	struct sk_buff *skb = NULL;
+
+	while ((skb = skb_dequeue(&ll->tx_wait_q)))
+		skb_queue_tail(&ll->txq, skb);
+
+	ll->hcill_state = HCILL_AWAKE;
+}
+
+/*
+ * Called upon a wake-up-indication from the device
+ */
+static void
+ll_device_want_to_wakeup(struct hci_uart *hu)
+{
+	unsigned long flags;
+	struct ll_struct *ll = hu->priv;
+
+	PRINTM(CMD, "Wake up hu %p\n", hu);
+
+	/* lock hcill state */
+	spin_lock_irqsave(&ll->hcill_lock, flags);
+
+	switch (ll->hcill_state) {
+	case HCILL_ASLEEP_TO_AWAKE:
+		/*
+		 * This state means that both the host and the BRF chip
+		 * have simultaneously sent a wake-up-indication packet.
+		 * Traditionaly, in this case, receiving a wake-up-indication
+		 * was enough and an additional wake-up-ack wasn't needed.
+		 * This has changed with the BRF6350, which does require an
+		 * explicit wake-up-ack. Other BRF versions, which do not
+		 * require an explicit ack here, do accept it, thus it is
+		 * perfectly safe to always send one.
+		 */
+		PRINTM(CMD, "dual wake-up-indication\n");
+		/* deliberate fall-through - do not add break */
+		/* Fall Through */
+	case HCILL_ASLEEP:
+		/* acknowledge device wake up */
+		if (send_hcill_cmd(HCILL_WAKE_UP_ACK, hu) < 0) {
+			PRINTM(ERROR, "cannot acknowledge device wake up\n");
+			goto out;
+		}
+		break;
+	default:
+		/* any other state is illegal */
+		PRINTM(ERROR, "received HCILL_WAKE_UP_IND in state %ld\n",
+		       ll->hcill_state);
+		break;
+	}
+
+	/* send pending packets and change state to HCILL_AWAKE */
+	__ll_do_awake(ll);
+
+out:
+	spin_unlock_irqrestore(&ll->hcill_lock, flags);
+
+	/* actually send the packets */
+	hci_uart_tx_wakeup(hu);
+}
+
+/*
+ * Called upon a sleep-indication from the device
+ */
+static void
+ll_device_want_to_sleep(struct hci_uart *hu)
+{
+	unsigned long flags;
+	struct ll_struct *ll = hu->priv;
+
+	PRINTM(CMD, "Sleep hu %p\n", hu);
+
+	/* lock hcill state */
+	spin_lock_irqsave(&ll->hcill_lock, flags);
+
+	/* sanity check */
+	if (ll->hcill_state != HCILL_AWAKE)
+		PRINTM(ERROR, "ERR: HCILL_GO_TO_SLEEP_IND in state %ld\n",
+		       ll->hcill_state);
+
+	/* acknowledge device sleep */
+	if (send_hcill_cmd(HCILL_GO_TO_SLEEP_ACK, hu) < 0) {
+		PRINTM(ERROR, "cannot acknowledge device sleep\n");
+		goto out;
+	}
+
+	/* update state */
+	ll->hcill_state = HCILL_ASLEEP;
+
+out:
+	spin_unlock_irqrestore(&ll->hcill_lock, flags);
+
+	/* actually send the sleep ack packet */
+	hci_uart_tx_wakeup(hu);
+}
+
+/*
+ * Called upon wake-up-acknowledgement from the device
+ */
+static void
+ll_device_woke_up(struct hci_uart *hu)
+{
+	unsigned long flags;
+	struct ll_struct *ll = hu->priv;
+
+	PRINTM(EVENT, "ll device woke up hu %p\n", hu);
+
+	/* lock hcill state */
+	spin_lock_irqsave(&ll->hcill_lock, flags);
+
+	/* sanity check */
+	if (ll->hcill_state != HCILL_ASLEEP_TO_AWAKE)
+		PRINTM(ERROR, "received HCILL_WAKE_UP_ACK in state %ld\n",
+		       ll->hcill_state);
+
+	/* send pending packets and change state to HCILL_AWAKE */
+	__ll_do_awake(ll);
+
+	spin_unlock_irqrestore(&ll->hcill_lock, flags);
+
+	/* actually send the packets */
+	hci_uart_tx_wakeup(hu);
+}
+
+/* Enqueue frame for transmittion (padding, crc, etc) */
+/* may be called from two simultaneous tasklets */
+static int
+ll_enqueue(struct hci_uart *hu, struct sk_buff *skb)
+{
+	unsigned long flags = 0;
+	struct ll_struct *ll = hu->priv;
+
+	PRINTM(DATA, "ll enqueue hu %p skb %p\n", hu, skb);
+
+	/* Prepend skb with frame type */
+	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
+
+	/* lock hcill state */
+	spin_lock_irqsave(&ll->hcill_lock, flags);
+
+	/* act according to current state */
+	switch (ll->hcill_state) {
+	case HCILL_AWAKE:
+		PRINTM(DATA, "device awake, sending normally\n");
+		skb_queue_tail(&ll->txq, skb);
+		break;
+	case HCILL_ASLEEP:
+		PRINTM(DATA, "device asleep, waking up and queueing packet\n");
+		/* save packet for later */
+		skb_queue_tail(&ll->tx_wait_q, skb);
+		/* awake device */
+		if (send_hcill_cmd(HCILL_WAKE_UP_IND, hu) < 0) {
+			PRINTM(ERROR, "cannot wake up device\n");
+			break;
+		}
+		ll->hcill_state = HCILL_ASLEEP_TO_AWAKE;
+		break;
+	case HCILL_ASLEEP_TO_AWAKE:
+		PRINTM(DATA, "device waking up, queueing packet\n");
+		/* transient state; just keep packet for later */
+		skb_queue_tail(&ll->tx_wait_q, skb);
+		break;
+	default:
+		PRINTM(ERROR, "illegal hcill state: %ld (losing packet)\n",
+		       ll->hcill_state);
+		kfree_skb(skb);
+		break;
+	}
+
+	spin_unlock_irqrestore(&ll->hcill_lock, flags);
+
+	return 0;
+}
+
+static inline int
+ll_check_data_len(struct ll_struct *ll, int len)
+{
+	register int room = skb_tailroom(ll->rx_skb);
+
+	PRINTM(DATA, "ll_check_data_len: len %d room %d\n", len, room);
+
+	if (!len) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+		hci_recv_frame(ll->rx_skb);
+#else
+		hci_recv_frame((struct hci_dev *)ll->rx_skb->dev, ll->rx_skb);
+#endif
+#else
+		hci_recv_frame(ll->rx_skb);
+#endif
+	} else if (len > room) {
+		PRINTM(ERROR, "Data length is too large\n");
+		kfree_skb(ll->rx_skb);
+	} else {
+		ll->rx_state = HCILL_W4_DATA;
+		ll->rx_count = len;
+		return len;
+	}
+
+	ll->rx_state = HCILL_W4_PACKET_TYPE;
+	ll->rx_skb = NULL;
+	ll->rx_count = 0;
+
+	return 0;
+}
+
+/* Recv data */
+static int
+ll_recv(struct hci_uart *hu, void *data, int count)
+{
+	struct ll_struct *ll = hu->priv;
+	register char *ptr;
+	struct hci_event_hdr *eh;
+	struct hci_acl_hdr *ah;
+	struct hci_sco_hdr *sh;
+	register int len, type, dlen;
+
+	PRINTM(DATA, "ll_recv: hu %p count %d rx_state %ld rx_count %ld\n", hu,
+	       count, ll->rx_state, ll->rx_count);
+
+	ptr = data;
+	while (count) {
+		if (ll->rx_count) {
+			len = min_t(unsigned int, ll->rx_count, count);
+			memcpy(skb_put(ll->rx_skb, len), ptr, len);
+			ll->rx_count -= len;
+			count -= len;
+			ptr += len;
+
+			if (ll->rx_count)
+				continue;
+
+			switch (ll->rx_state) {
+			case HCILL_W4_DATA:
+				PRINTM(DATA, "Complete data\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+				hci_recv_frame(ll->rx_skb);
+#else
+				hci_recv_frame(hu->hdev, ll->rx_skb);
+#endif
+#else
+				hci_recv_frame(ll->rx_skb);
+#endif
+
+				ll->rx_state = HCILL_W4_PACKET_TYPE;
+				ll->rx_skb = NULL;
+				continue;
+
+			case HCILL_W4_EVENT_HDR:
+				eh = (struct hci_event_hdr *)ll->rx_skb->data;
+
+				PRINTM(DATA,
+				       "Event header: evt 0x%2.2x plen %d\n",
+				       eh->evt, eh->plen);
+
+				ll_check_data_len(ll, eh->plen);
+				continue;
+
+			case HCILL_W4_ACL_HDR:
+				ah = (struct hci_acl_hdr *)ll->rx_skb->data;
+				dlen = __le16_to_cpu(ah->dlen);
+
+				PRINTM(DATA, "ACL header: dlen %d\n", dlen);
+
+				ll_check_data_len(ll, dlen);
+				continue;
+
+			case HCILL_W4_SCO_HDR:
+				sh = (struct hci_sco_hdr *)ll->rx_skb->data;
+
+				PRINTM(DATA, "SCO header: dlen %d\n", sh->dlen);
+
+				ll_check_data_len(ll, sh->dlen);
+				continue;
+			}
+		}
+
+		/* HCILL_W4_PACKET_TYPE */
+		switch (*ptr) {
+		case HCI_EVENT_PKT:
+			PRINTM(DATA, "Event packet\n");
+			ll->rx_state = HCILL_W4_EVENT_HDR;
+			ll->rx_count = HCI_EVENT_HDR_SIZE;
+			type = HCI_EVENT_PKT;
+			break;
+
+		case HCI_ACLDATA_PKT:
+			PRINTM(DATA, "ACL packet\n");
+			ll->rx_state = HCILL_W4_ACL_HDR;
+			ll->rx_count = HCI_ACL_HDR_SIZE;
+			type = HCI_ACLDATA_PKT;
+			break;
+
+		case HCI_SCODATA_PKT:
+			PRINTM(DATA, "SCO packet\n");
+			ll->rx_state = HCILL_W4_SCO_HDR;
+			ll->rx_count = HCI_SCO_HDR_SIZE;
+			type = HCI_SCODATA_PKT;
+			break;
+
+			/* HCILL signals */
+		case HCILL_GO_TO_SLEEP_IND:
+			PRINTM(DATA, "HCILL_GO_TO_SLEEP_IND packet\n");
+			ll_device_want_to_sleep(hu);
+			ptr++;
+			count--;
+			continue;
+
+		case HCILL_GO_TO_SLEEP_ACK:
+			/* shouldn't happen */
+			PRINTM(ERROR,
+			       "received HCILL_GO_TO_SLEEP_ACK (in state %ld)\n",
+			       ll->hcill_state);
+			ptr++;
+			count--;
+			continue;
+
+		case HCILL_WAKE_UP_IND:
+			PRINTM(DATA, "HCILL_WAKE_UP_IND packet\n");
+			ll_device_want_to_wakeup(hu);
+			ptr++;
+			count--;
+			continue;
+
+		case HCILL_WAKE_UP_ACK:
+			PRINTM(DATA, "HCILL_WAKE_UP_ACK packet\n");
+			ll_device_woke_up(hu);
+			ptr++;
+			count--;
+			continue;
+
+		default:
+			PRINTM(ERROR, "Unknown HCI packet type %2.2x\n",
+			       (__u8) * ptr);
+			hu->hdev->stat.err_rx++;
+			ptr++;
+			count--;
+			continue;
+		};
+
+		ptr++;
+		count--;
+
+		/* Allocate packet */
+		ll->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
+		if (!ll->rx_skb) {
+			PRINTM(ERROR, "Can't allocate mem for new packet\n");
+			ll->rx_state = HCILL_W4_PACKET_TYPE;
+			ll->rx_count = 0;
+			return 0;
+		}
+
+		ll->rx_skb->dev = (void *)hu->hdev;
+		bt_cb(ll->rx_skb)->pkt_type = type;
+	}
+
+	return count;
+}
+
+static struct sk_buff *
+ll_dequeue(struct hci_uart *hu)
+{
+	struct ll_struct *ll = hu->priv;
+	return skb_dequeue(&ll->txq);
+}
+
+static struct hci_uart_proto llp = {
+	.id = HCI_UART_LL,
+	.open = ll_open,
+	.close = ll_close,
+	.recv = ll_recv,
+	.enqueue = ll_enqueue,
+	.dequeue = ll_dequeue,
+	.flush = ll_flush,
+};
+
+int
+ll_init(void)
+{
+	int err = hci_uart_register_proto(&llp);
+
+	if (!err)
+		PRINTM(MSG, "HCILL protocol initialized\n");
+	else
+		PRINTM(ERROR, "HCILL protocol registration failed\n");
+
+	return err;
+}
+
+int
+ll_deinit(void)
+{
+	return hci_uart_unregister_proto(&llp);
+}
diff --git a/88x9098/bt/muart_src/hci_ps.c b/88x9098/bt/muart_src/hci_ps.c
new file mode 100644
index 0000000..b559bf6
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_ps.c
@@ -0,0 +1,1404 @@
+/*
+ *
+ *  Bluetooth HCI UART driver
+ *
+ *
+ * Copyright 2018-2020 NXP
+ *
+ * This software file (the File) is distributed by NXP
+ * under the terms of the GNU General Public License Version 2, June 1991
+ * (the License).  You may use, redistribute and/or modify the File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/poll.h>
+
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/ioctl.h>
+#include <linux/skbuff.h>
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include <amp/bluetooth/bluetooth.h>
+#include <amp/bluetooth/hci_core.h>
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+#include <linux/proc_fs.h>
+
+#ifdef PXA9XX
+#if defined(PXA950) || defined(PXA920)
+#include <mach/mfp.h>
+#include <mach/gpio.h>
+#else
+#include <asm/arch/mfp-pxa9xx.h>
+#include <asm/arch/gpio.h>
+#endif
+#endif
+#include "hci_uart.h"
+#include "bt_drv.h"
+
+#define DEFAULT_DEBUG_MASK	(DBG_MSG | DBG_FATAL | DBG_ERROR)
+u32 drvdbg = DEFAULT_DEBUG_MASK;
+/** proc diretory root */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define PROC_DIR    NULL
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#define PROC_DIR    &proc_root
+#else
+#define PROC_DIR    proc_net
+#endif
+
+#define DEFAULT_BUF_SIZE 512
+
+/** Default file permission */
+#define DEFAULT_FILE_PERM  0644
+
+/** Default time period in mili-second */
+#define DEFAULT_TIME_PERIOD 2000
+
+/** wakeup method DTR */
+#define WAKEUP_METHOD_DTR       0
+/** wakeup method break */
+#define WAKEUP_METHOD_BREAK     1
+/** wake up method EX break */
+#define WAKEUP_METHOD_EXT_BREAK  2
+/** wake up method RTS */
+#define WAKEUP_METHOD_RTS       3
+
+/** wakeup method invalid */
+#define  WAKEUP_METHOD_INVALID  0xff
+/** ps mode disable */
+#define PS_MODE_DISABLE         0
+/** ps mode enable */
+#define PS_MODE_ENABLE          1
+/** ps cmd exit ps  */
+#define PS_CMD_EXIT_PS          1
+/** ps cmd enter ps */
+#define PS_CMD_ENTER_PS         2
+/** ps state awake */
+#define PS_STATE_AWAKE                0
+/** ps state SLEEP */
+#define PS_STATE_SLEEP                1
+
+/** OGF */
+#define OGF				0x3F
+/** Bluetooth command : Sleep mode */
+#define BT_CMD_AUTO_SLEEP_MODE		0x23
+/** Bluetooth Power State : Enable */
+#define BT_PS_ENABLE			0x02
+/** Bluetooth Power State : Disable */
+#define BT_PS_DISABLE			0x03
+/** Bluetooth command: Wakeup method */
+#define BT_CMD_WAKEUP_METHOD    0x53
+
+#define BT_HOST_WAKEUP_METHOD_NONE      0x00
+#define BT_HOST_WAKEUP_METHOD_DTR       0x01
+#define BT_HOST_WAKEUP_METHOD_BREAK     0x02
+#define BT_HOST_WAKEUP_METHOD_GPIO      0x03
+#define BT_HOST_WAKEUP_DEFAULT_GPIO     5
+
+#define BT_CTRL_WAKEUP_METHOD_DSR       0x00
+#define BT_CTRL_WAKEUP_METHOD_BREAK     0x01
+#define BT_CTRL_WAKEUP_METHOD_GPIO      0x02
+#define BT_CTRL_WAKEUP_METHOD_EXT_BREAK  0x04
+#define BT_CTRL_WAKEUP_METHOD_RTS       0x05
+
+#define BT_CTRL_WAKEUP_DEFAULT_GPIO     4
+
+#define  HCI_OP_AUTO_SLEEP_MODE 0xfc23
+#define  HCI_OP_WAKEUP_METHOD   0xfc53
+#define SEND_WAKEUP_METHOD_CMD          0x01
+#define SEND_AUTO_SLEEP_MODE_CMD        0x02
+
+typedef struct _BT_CMD {
+    /** OCF OGF */
+	u16 ocf_ogf;
+    /** Length */
+	u8 length;
+    /** Data */
+	u8 data[4];
+} __attribute__ ((packed)) BT_CMD;
+
+/** Proc directory entry */
+static struct proc_dir_entry *proc_bt = NULL;
+
+struct ps_data {
+	u32 ps_mode;
+	u32 cur_psmode;
+	u32 ps_state;
+	u32 ps_cmd;
+	u32 interval;
+	u32 wakeupmode;
+	u32 cur_wakeupmode;
+	u32 send_cmd;
+	struct work_struct work;
+	struct tty_struct *tty;
+	struct timer_list ps_timer;
+	u32 timer_on;
+};
+
+#ifndef CONFIG_MULTI_CARD_PS
+static struct ps_data g_data;
+#endif
+int wakeupmode = WAKEUP_METHOD_BREAK;
+int ps_mode = PS_MODE_DISABLE;
+struct proc_data {
+    /** Read length */
+	int rdlen;
+    /** Read buffer */
+	char *rdbuf;
+    /** Write length */
+	int wrlen;
+    /** Maximum write length */
+	int maxwrlen;
+    /** Write buffer */
+	char *wrbuf;
+};
+
+/** Debug dump buffer length */
+#define DBG_DUMP_BUF_LEN 	64
+/** Maximum number of dump per line */
+#define MAX_DUMP_PER_LINE	16
+/** Maximum data dump length */
+#define MAX_DATA_DUMP_LEN	48
+
+/** convert string to number */
+int
+string_to_number(char *s)
+{
+	int r = 0;
+	int base = 0;
+	int pn = 1;
+
+	if (strncmp(s, "-", 1) == 0) {
+		pn = -1;
+		s++;
+	}
+	if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0)) {
+		base = 16;
+		s += 2;
+	} else
+		base = 10;
+
+	for (; *s != 0; s++) {
+		if ((*s >= '0') && (*s <= '9'))
+			r = (r * base) + (*s - '0');
+		else if ((*s >= 'A') && (*s <= 'F'))
+			r = (r * base) + (*s - 'A' + 10);
+		else if ((*s >= 'a') && (*s <= 'f'))
+			r = (r * base) + (*s - 'a' + 10);
+		else
+			break;
+	}
+
+	return (r * pn);
+}
+
+static int
+is_device_ready(struct hci_uart *hu)
+{
+	struct hci_dev *hdev = NULL;
+	if (!hu) {
+		PRINTM(ERROR, "hu is NULL\n");
+		return -ENODEV;
+	}
+	if (!hu->proto || !hu->hdev || !hu->tty) {
+		PRINTM(ERROR, "Device not ready! proto=%p, hdev=%p, tty=%p\n",
+		       hu->proto, hu->hdev, hu->tty);
+		return -ENODEV;
+	}
+	hdev = hu->hdev;
+	if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+		PRINTM(ERROR, "HCI_RUNNING is not set\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+/*
+ * Builds and sends an PS command packet.
+ */
+static int
+send_ps_cmd(u8 cmd, struct hci_uart *hu)
+{
+	int err = 0;
+	struct sk_buff *skb = NULL;
+	BT_CMD *pCmd;
+
+	PRINTM(CMD, "hu %p cmd 0x%x\n", hu, cmd);
+
+	/* allocate packet */
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (!skb) {
+		PRINTM(ERROR, "cannot allocate memory for HCILL packet\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	pCmd = (BT_CMD *) skb->data;
+	pCmd->ocf_ogf = (OGF << 10) | BT_CMD_AUTO_SLEEP_MODE;
+	pCmd->length = 1;
+	if (cmd == PS_MODE_ENABLE)
+		pCmd->data[0] = BT_PS_ENABLE;
+	else
+		pCmd->data[0] = BT_PS_DISABLE;
+
+	bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+	skb_put(skb, sizeof(BT_CMD) - 4 + pCmd->length);
+	skb->dev = (void *)hu->hdev;
+
+	/* send packet */
+	hu->proto->enqueue(hu, skb);
+	hci_uart_tx_wakeup(hu);
+
+out:
+	return err;
+}
+
+/*
+ * Builds and sends an wake up method command packet.
+ */
+static int
+send_wakeup_method_cmd(u8 cmd, struct hci_uart *hu)
+{
+	int err = 0;
+	struct sk_buff *skb = NULL;
+	BT_CMD *pCmd;
+
+	PRINTM(CMD, "hu %p cmd 0x%x\n", hu, cmd);
+
+	/* allocate packet */
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (!skb) {
+		PRINTM(ERROR, "cannot allocate memory for HCILL packet\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	pCmd = (BT_CMD *) skb->data;
+	pCmd->ocf_ogf = (OGF << 10) | BT_CMD_WAKEUP_METHOD;
+	pCmd->length = 4;
+	pCmd->data[0] = BT_HOST_WAKEUP_METHOD_NONE;
+	pCmd->data[1] = BT_HOST_WAKEUP_DEFAULT_GPIO;
+	switch (cmd) {
+	case WAKEUP_METHOD_DTR:
+		pCmd->data[2] = BT_CTRL_WAKEUP_METHOD_DSR;
+		break;
+	case WAKEUP_METHOD_EXT_BREAK:
+		pCmd->data[2] = BT_CTRL_WAKEUP_METHOD_EXT_BREAK;
+		break;
+	case WAKEUP_METHOD_RTS:
+		pCmd->data[2] = BT_CTRL_WAKEUP_METHOD_RTS;
+		break;
+	case WAKEUP_METHOD_BREAK:
+	default:
+		pCmd->data[2] = BT_CTRL_WAKEUP_METHOD_BREAK;
+		break;
+	}
+	pCmd->data[3] = BT_CTRL_WAKEUP_DEFAULT_GPIO;
+
+	bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+
+	skb_put(skb, sizeof(BT_CMD) - 4 + pCmd->length);
+	skb->dev = (void *)hu->hdev;
+
+	/* send packet */
+	hu->proto->enqueue(hu, skb);
+	hci_uart_tx_wakeup(hu);
+
+out:
+	return err;
+}
+
+/*
+ * Builds and sends an char packet.
+ */
+static int
+send_char(char ch, struct hci_uart *hu)
+{
+	int err = 0;
+	struct sk_buff *skb = NULL;
+
+	PRINTM(INFO, "hu %p char=%c 0x%x\n", hu, ch, ch);
+
+	/* allocate packet */
+	skb = bt_skb_alloc(1, GFP_ATOMIC);
+	if (!skb) {
+		PRINTM(ERROR, "cannot allocate memory for HCILL packet\n");
+		err = -ENOMEM;
+		goto out;
+	}
+	bt_cb(skb)->pkt_type = ch;
+	skb->dev = (void *)hu->hdev;
+
+	/* send packet */
+	if (hu->tx_skb)
+		hu->proto->enqueue(hu, skb);
+	else {
+		memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
+		hu->tx_skb = skb;
+	}
+	hci_uart_tx_wakeup(hu);
+
+out:
+	return err;
+}
+
+/** This function handle the generic file close */
+static void
+proc_on_close(struct inode *inode, struct file *file)
+{
+	struct proc_data *pdata = file->private_data;
+	char *line;
+#ifdef CONFIG_MULTI_CARD_PS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct hci_uart *hu = PDE_DATA(inode);
+#else
+	struct hci_uart *hu = PDE(inode)->data;
+#endif
+	struct ps_data *psdata = hu->psdata;
+	u32 ps_mode = psdata->ps_mode;
+	u32 wakeup = psdata->cur_wakeupmode;
+#else
+	struct hci_uart *hu = NULL;
+	u32 ps_mode = g_data.ps_mode;
+	u32 wakeup = g_data.cur_wakeupmode;
+#endif
+	if (!pdata->wrlen)
+		return;
+	line = pdata->wrbuf;
+	while (line[0]) {
+		if (!strncmp(line, "psmode", strlen("psmode"))) {
+			line += strlen("psmode") + 1;
+			ps_mode = (u32) string_to_number(line);
+			if (ps_mode > PS_MODE_ENABLE)
+#ifdef CONFIG_MULTI_CARD_PS
+				ps_mode = psdata->ps_mode;
+#else
+				ps_mode = g_data.ps_mode;
+#endif
+		}
+		if (!strncmp(line, "interval", strlen("interval"))) {
+			line += strlen("interval") + 1;
+#ifdef CONFIG_MULTI_CARD_PS
+			psdata->interval = (u32) string_to_number(line);
+#else
+			g_data.interval = (u32) string_to_number(line);
+#endif
+		}
+		if (!strncmp(line, "drvdbg", strlen("drvdbg"))) {
+			line += strlen("drvdbg") + 1;
+			drvdbg = (u32) string_to_number(line);
+		}
+		if (!strncmp(line, "wakeupmode", strlen("wakeupmode"))) {
+			line += strlen("wakeupmode") + 1;
+			wakeup = (u32) string_to_number(line);
+			if (wakeup > WAKEUP_METHOD_RTS)
+#ifdef CONFIG_MULTI_CARD_PS
+				wakeup = psdata->cur_wakeupmode;
+#else
+				wakeup = g_data.cur_wakeupmode;
+#endif
+		}
+		while (line[0] && line[0] != '\n')
+			line++;
+		if (line[0])
+			line++;
+	}
+#ifdef CONFIG_MULTI_CARD_PS
+	if ((psdata->cur_psmode == PS_MODE_DISABLE) &&
+	    (ps_mode == PS_MODE_DISABLE) &&
+	    (wakeup != psdata->cur_wakeupmode)) {
+		psdata->wakeupmode = wakeup;
+		if (psdata->tty) {
+			if (0 == is_device_ready(hu)) {
+				psdata->send_cmd |= SEND_WAKEUP_METHOD_CMD;
+				send_wakeup_method_cmd(psdata->wakeupmode, hu);
+			}
+		}
+	}
+	if (ps_mode != psdata->ps_mode)
+		psdata->ps_mode = ps_mode;
+	if (ps_mode != psdata->cur_psmode) {
+		if (psdata->tty) {
+			if (0 == is_device_ready(hu)) {
+				psdata->send_cmd |= SEND_AUTO_SLEEP_MODE_CMD;
+				send_ps_cmd(psdata->ps_mode, hu);
+			}
+		}
+	}
+#else
+	if ((g_data.cur_psmode == PS_MODE_DISABLE) &&
+	    (ps_mode == PS_MODE_DISABLE) && (wakeup != g_data.cur_wakeupmode)) {
+		g_data.wakeupmode = wakeup;
+		if (g_data.tty) {
+			hu = (void *)g_data.tty->disc_data;
+			if (0 == is_device_ready(hu)) {
+				g_data.send_cmd |= SEND_WAKEUP_METHOD_CMD;
+				send_wakeup_method_cmd(g_data.wakeupmode, hu);
+			}
+		}
+	}
+	if (ps_mode != g_data.ps_mode)
+		g_data.ps_mode = ps_mode;
+	if (ps_mode != g_data.cur_psmode) {
+		if (g_data.tty) {
+			hu = (void *)g_data.tty->disc_data;
+			if (0 == is_device_ready(hu)) {
+				g_data.send_cmd |= SEND_AUTO_SLEEP_MODE_CMD;
+				send_ps_cmd(g_data.ps_mode, hu);
+			}
+		}
+	}
+#endif
+	return;
+}
+
+/** This function handle generic proc file close */
+static int
+proc_close(struct inode *inode, struct file *file)
+{
+	struct proc_data *pdata = file->private_data;
+	if (pdata) {
+		proc_on_close(inode, file);
+		if (pdata->rdbuf)
+			kfree(pdata->rdbuf);
+		if (pdata->wrbuf)
+			kfree(pdata->wrbuf);
+		kfree(pdata);
+	}
+	return 0;
+}
+
+/** This function handle generic proc file read */
+static ssize_t
+proc_read(struct file *file, char __user * buffer, size_t len, loff_t * offset)
+{
+	loff_t pos = *offset;
+	struct proc_data *pdata = (struct proc_data *)file->private_data;
+	if ((!pdata->rdbuf) || (pos < 0))
+		return -EINVAL;
+	if (pos >= pdata->rdlen)
+		return 0;
+	if (len > pdata->rdlen - pos)
+		len = pdata->rdlen - pos;
+	if (copy_to_user(buffer, pdata->rdbuf + pos, len))
+		return -EFAULT;
+	*offset = pos + len;
+	return len;
+}
+
+/** This function handle generic proc file write */
+static ssize_t
+proc_write(struct file *file,
+	   const char __user * buffer, size_t len, loff_t * offset)
+{
+	loff_t pos = *offset;
+	struct proc_data *pdata = (struct proc_data *)file->private_data;
+
+	if (!pdata->wrbuf || (pos < 0))
+		return -EINVAL;
+	if (pos >= pdata->maxwrlen)
+		return 0;
+	if (len > pdata->maxwrlen - pos)
+		len = pdata->maxwrlen - pos;
+	if (copy_from_user(pdata->wrbuf + pos, buffer, len))
+		return -EFAULT;
+	if (pos + len > pdata->wrlen)
+		pdata->wrlen = len + file->f_pos;
+	*offset = pos + len;
+	return len;
+}
+
+/** This function handle the generic file open */
+static int
+proc_open(struct inode *inode, struct file *file)
+{
+	struct proc_data *pdata;
+	char *p;
+#ifdef CONFIG_MULTI_CARD_PS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct hci_uart *hu = PDE_DATA(inode);
+#else
+	struct hci_uart *hu = PDE(inode)->data;
+#endif
+	struct ps_data *psdata = hu->psdata;
+#endif
+	if ((file->private_data =
+	     kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL) {
+		PRINTM(ERROR, "Can not allocate memmory for proc_data\n");
+		return -ENOMEM;
+	}
+	pdata = (struct proc_data *)file->private_data;
+	if ((pdata->rdbuf = kmalloc(DEFAULT_BUF_SIZE, GFP_KERNEL)) == NULL) {
+		PRINTM(ERROR, "Can not allocate memory for rdbuf\n");
+		kfree(file->private_data);
+		return -ENOMEM;
+	}
+	if ((pdata->wrbuf = kzalloc(DEFAULT_BUF_SIZE, GFP_KERNEL)) == NULL) {
+		PRINTM(ERROR, "Can not allocate memory for wrbuf\n");
+		kfree(pdata->rdbuf);
+		kfree(file->private_data);
+		return -ENOMEM;
+	}
+	pdata->maxwrlen = DEFAULT_BUF_SIZE;
+	p = pdata->rdbuf;
+#ifdef CONFIG_MULTI_CARD_PS
+	p += sprintf(p, "psmode=%d\n", psdata->ps_mode);
+	p += sprintf(p, "psstate=%d\n", psdata->ps_state);
+	p += sprintf(p, "interval=%d\n", psdata->interval);
+	p += sprintf(p, "wakeupmode=%d\n", psdata->wakeupmode);
+	p += sprintf(p, "current psmode=%d\n", psdata->cur_psmode);
+	p += sprintf(p, "current wakeupmode=%d\n", psdata->cur_wakeupmode);
+	p += sprintf(p, "sendcmd=%d\n", psdata->send_cmd);
+#else
+	p += sprintf(p, "psmode=%d\n", g_data.ps_mode);
+	p += sprintf(p, "psstate=%d\n", g_data.ps_state);
+	p += sprintf(p, "interval=%d\n", g_data.interval);
+	p += sprintf(p, "wakeupmode=%d\n", g_data.wakeupmode);
+	p += sprintf(p, "current psmode=%d\n", g_data.cur_psmode);
+	p += sprintf(p, "current wakeupmode=%d\n", g_data.cur_wakeupmode);
+	p += sprintf(p, "sendcmd=%d\n", g_data.send_cmd);
+#endif
+	p += sprintf(p, "drvdbg=%d\n", drvdbg);
+	pdata->rdlen = strlen(pdata->rdbuf);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static struct proc_ops proc_rw_ops = {
+	.proc_read = proc_read,
+	.proc_write = proc_write,
+	.proc_open = proc_open,
+	.proc_release = proc_close
+};
+#else
+static struct file_operations proc_rw_ops = {
+	.read = proc_read,
+	.write = proc_write,
+	.open = proc_open,
+	.release = proc_close
+};
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void
+ps_timeout_func(struct timer_list *t)
+{
+	struct ps_data *data = from_timer(data, t, ps_timer);
+#else
+void
+ps_timeout_func(unsigned long context)
+{
+	struct ps_data *data = (struct ps_data *)context;
+#endif
+	struct tty_struct *tty = data->tty;
+	struct hci_uart *hu = NULL;
+	data->timer_on = 0;
+	if (!data->tty)
+		return;
+	hu = (struct hci_uart *)tty->disc_data;
+	if (!hu)
+		return;
+	if (test_bit(HCI_UART_SENDING, &hu->tx_state)) {
+#ifdef CONFIG_MULTI_CARD_PS
+		ps_start_timer(hu);
+#else
+		ps_start_timer();
+#endif
+	} else {
+		data->ps_cmd = PS_CMD_ENTER_PS;
+		schedule_work(&data->work);
+	}
+}
+
+static void
+set_dtr(struct tty_struct *tty, int on_off)
+{
+#ifdef PXA9XX
+	if (on_off) {
+		gpio_set_value(mfp_to_gpio(MFP_PIN_GPIO13), 0);
+		PRINTM(CMD, "Set DTR ON\n");
+	} else {
+		gpio_set_value(mfp_to_gpio(MFP_PIN_GPIO13), 1);
+		PRINTM(CMD, "Clear DTR\n");
+	}
+#else
+	u32 old_state = 0;
+	u32 new_state = 0;
+	if (TTY_FUNC->tiocmget) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+		old_state = TTY_FUNC->tiocmget(tty, NULL);
+#else
+		old_state = TTY_FUNC->tiocmget(tty);
+#endif
+		if (on_off)
+			new_state = old_state | TIOCM_DTR;
+		else
+			new_state = old_state & ~TIOCM_DTR;
+		if (new_state == old_state)
+			return;
+		if (TTY_FUNC->tiocmset) {
+			if (on_off) {
+				PRINTM(CMD, "Set DTR ON\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+				TTY_FUNC->tiocmset(tty, NULL, TIOCM_DTR, 0);
+#else
+				TTY_FUNC->tiocmset(tty, TIOCM_DTR, 0);
+#endif
+			} else {
+				PRINTM(CMD, "Clear DTR\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+				TTY_FUNC->tiocmset(tty, NULL, 0, TIOCM_DTR);
+#else
+				TTY_FUNC->tiocmset(tty, 0, TIOCM_DTR);
+#endif
+			}
+		}
+	}
+#endif
+	return;
+}
+
+static void
+set_break(struct tty_struct *tty, int on_off)
+{
+	if (TTY_FUNC->break_ctl) {
+		if (on_off) {
+			PRINTM(CMD, "Turn on break\n");
+			TTY_FUNC->break_ctl(tty, -1);	/* turn on break */
+		} else {
+			PRINTM(CMD, "Turn off break\n");
+			TTY_FUNC->break_ctl(tty, 0);	/* turn off break */
+		}
+	}
+	return;
+}
+
+static int
+get_cts(struct tty_struct *tty)
+{
+	u32 state = 0;
+	if (TTY_FUNC->tiocmget) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+		state = TTY_FUNC->tiocmget(tty, NULL);
+#else
+		state = TTY_FUNC->tiocmget(tty);
+#endif
+		if (state & TIOCM_CTS) {
+			PRINTM(CMD, "CTS is low\n");
+			return 1;	// CTS LOW
+		} else {
+			PRINTM(CMD, "CTS is high\n");
+			return 0;	// CTS HIGH
+		}
+	}
+	return -1;
+}
+
+static void
+set_rts(struct tty_struct *tty, int on_off)
+{
+	u32 old_state = 0;
+	u32 new_state = 0;
+	if (TTY_FUNC->tiocmget) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+		old_state = TTY_FUNC->tiocmget(tty, NULL);
+#else
+		old_state = TTY_FUNC->tiocmget(tty);
+#endif
+		if (on_off)
+			new_state = old_state | TIOCM_RTS;
+		else
+			new_state = old_state & ~TIOCM_RTS;
+		if (new_state == old_state)
+			return;
+		if (TTY_FUNC->tiocmset) {
+			if (on_off) {
+				PRINTM(CMD, "Set RTS ON\n");	// set RTS high
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+				TTY_FUNC->tiocmset(tty, NULL, TIOCM_RTS, 0);
+#else
+				TTY_FUNC->tiocmset(tty, TIOCM_RTS, 0);
+#endif
+			} else {
+				PRINTM(CMD, "Clear RTS\n");	// set RTS LOW
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+				TTY_FUNC->tiocmset(tty, NULL, 0, TIOCM_RTS);
+#else
+				TTY_FUNC->tiocmset(tty, 0, TIOCM_RTS);
+#endif
+			}
+		}
+	}
+	return;
+}
+
+static void
+ps_control(struct ps_data *data, u8 ps_state)
+{
+	struct hci_uart *hu = NULL;
+	if (data->ps_state == ps_state)
+		return;
+	if (data->tty) {
+		switch (data->cur_wakeupmode) {
+		case WAKEUP_METHOD_DTR:
+			if (ps_state == PS_STATE_AWAKE)
+				set_dtr(data->tty, 1);	// DTR ON
+			else
+				set_dtr(data->tty, 0);	// DTR OFF
+			data->ps_state = ps_state;
+			break;
+		case WAKEUP_METHOD_BREAK:
+			if (ps_state == PS_STATE_AWAKE)
+				set_break(data->tty, 0);	// break OFF
+			else
+				set_break(data->tty, 1);	// break ON
+			data->ps_state = ps_state;
+			break;
+		case WAKEUP_METHOD_EXT_BREAK:
+			if (ps_state == PS_STATE_AWAKE) {
+				set_break(data->tty, 1);	// break ON
+				set_break(data->tty, 0);	// break OFF
+				data->ps_state = ps_state;
+			} else {
+				hu = (struct hci_uart *)data->tty->disc_data;
+				if (0 == is_device_ready(hu))
+					send_char(MRVL_ENTER_PS_CHAR, hu);
+			}
+			break;
+		case WAKEUP_METHOD_RTS:
+			if (ps_state == PS_STATE_AWAKE) {
+				set_rts(data->tty, 0);	// RTS to high
+				mdelay(5);
+				set_rts(data->tty, 1);	// RTS to low
+				data->ps_state = ps_state;
+				hu = (struct hci_uart *)data->tty->disc_data;
+				if (0 == is_device_ready(hu))
+					send_char(MRVL_EXIT_PS_CHAR, hu);
+			} else {
+				hu = (struct hci_uart *)data->tty->disc_data;
+				if (0 == is_device_ready(hu))
+					send_char(MRVL_ENTER_PS_CHAR, hu);
+			}
+			break;
+		default:
+			break;
+		}
+		if (ps_state == PS_STATE_AWAKE) {
+			hu = (struct hci_uart *)data->tty->disc_data;
+			/* actually send the packets */
+			PRINTM(DATA, "Send tx data...\n");
+			if (hu)
+				hci_uart_tx_wakeup(hu);
+		}
+	}
+}
+
+static void
+ps_work_func(struct work_struct *work)
+{
+	struct ps_data *data = container_of(work, struct ps_data, work);
+	if (data->tty) {
+		if ((data->ps_cmd == PS_CMD_ENTER_PS) &&
+		    (data->cur_psmode == PS_MODE_ENABLE)) {
+			ps_control(data, PS_STATE_SLEEP);
+		} else if (data->ps_cmd == PS_CMD_EXIT_PS) {
+			ps_control(data, PS_STATE_AWAKE);
+		}
+	}
+}
+
+#ifdef CONFIG_MULTI_CARD_PS
+int
+ps_init_work(struct hci_uart *hu)
+{
+	struct ps_data *psdata;
+
+	if (!(psdata = kzalloc(sizeof(struct ps_data), GFP_KERNEL))) {
+		PRINTM(ERROR, "Can't allocate control structure\n");
+		return -ENFILE;
+	}
+	PRINTM(MSG, "ps_init_work...\n");
+	hu->psdata = psdata;
+
+	memset(psdata, 0, sizeof(*psdata));
+	psdata->interval = DEFAULT_TIME_PERIOD;
+	psdata->timer_on = 0;
+	psdata->tty = NULL;
+	psdata->ps_state = PS_STATE_AWAKE;
+	psdata->ps_mode = ps_mode;
+	psdata->ps_cmd = 0;
+	psdata->send_cmd = 0;
+	switch (wakeupmode) {
+	case WAKEUP_METHOD_DTR:
+		psdata->wakeupmode = WAKEUP_METHOD_DTR;
+		break;
+	case WAKEUP_METHOD_EXT_BREAK:
+		psdata->wakeupmode = WAKEUP_METHOD_EXT_BREAK;
+		break;
+	case WAKEUP_METHOD_RTS:
+		psdata->wakeupmode = WAKEUP_METHOD_RTS;
+		break;
+	case WAKEUP_METHOD_BREAK:
+	default:
+		psdata->wakeupmode = WAKEUP_METHOD_BREAK;
+		break;
+	}
+	psdata->cur_psmode = PS_MODE_DISABLE;
+	psdata->cur_wakeupmode = WAKEUP_METHOD_INVALID;
+	INIT_WORK(&psdata->work, ps_work_func);
+	return 0;
+}
+#else /* CONFIG_MULTI_CARD_PS */
+void
+ps_init_work(void)
+{
+	PRINTM(MSG, "ps_init_work...\n");
+	memset(&g_data, 0, sizeof(g_data));
+	g_data.interval = DEFAULT_TIME_PERIOD;
+	g_data.timer_on = 0;
+	g_data.tty = NULL;
+	g_data.ps_state = PS_STATE_AWAKE;
+	g_data.ps_mode = ps_mode;
+	g_data.ps_cmd = 0;
+	g_data.send_cmd = 0;
+	switch (wakeupmode) {
+	case WAKEUP_METHOD_DTR:
+		g_data.wakeupmode = WAKEUP_METHOD_DTR;
+		break;
+	case WAKEUP_METHOD_EXT_BREAK:
+		g_data.wakeupmode = WAKEUP_METHOD_EXT_BREAK;
+		break;
+	case WAKEUP_METHOD_RTS:
+		g_data.wakeupmode = WAKEUP_METHOD_RTS;
+		break;
+	case WAKEUP_METHOD_BREAK:
+	default:
+		g_data.wakeupmode = WAKEUP_METHOD_BREAK;
+		break;
+	}
+	g_data.cur_psmode = PS_MODE_DISABLE;
+	g_data.cur_wakeupmode = WAKEUP_METHOD_INVALID;
+	INIT_WORK(&g_data.work, ps_work_func);
+}
+#endif /* CONFIG_MULTI_CARD_PS */
+
+/** This function init proc entry  */
+int
+proc_init(void)
+{
+#ifndef CONFIG_MULTI_CARD_PS
+	u8 ret = 0;
+	struct proc_dir_entry *entry;
+	if (!proc_bt) {
+		proc_bt = proc_mkdir("mbt_uart", PROC_DIR);
+		if (!proc_bt) {
+			PRINTM(ERROR, "Could not mkdir mbt_uart!\n");
+			ret = -1;
+			goto done;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+		entry = proc_create_data("config", S_IFREG | DEFAULT_FILE_PERM,
+					 proc_bt, &proc_rw_ops, NULL);
+		if (entry == NULL)
+#else
+		entry = create_proc_entry("config", S_IFREG | DEFAULT_FILE_PERM,
+					  proc_bt);
+		if (entry) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+			entry->owner = THIS_MODULE;
+#endif
+			entry->proc_fops = &proc_rw_ops;
+		} else
+#endif
+			PRINTM(ERROR, "MUART: Fail to create proc\n");
+	}
+	ps_init_work();
+done:
+	return ret;
+#else /* CONFIG_MULTI_CARD_PS */
+	if (!proc_bt) {
+		proc_bt = proc_mkdir("mbt_uart", PROC_DIR);
+		if (!proc_bt) {
+			PRINTM(ERROR, "Could not mkdir mbt_uart!\n");
+			return -1;
+		}
+	}
+	return 0;
+#endif /* CONFIG_MULTI_CARD_PS */
+}
+
+/** remove proc file */
+void
+muart_proc_remove(void)
+{
+	if (proc_bt) {
+#ifndef CONFIG_MULTI_CARD_PS
+		remove_proc_entry("config", proc_bt);
+#endif
+		remove_proc_entry("mbt_uart", PROC_DIR);
+		proc_bt = NULL;
+	}
+	return;
+}
+
+#ifdef CONFIG_MULTI_CARD_PS
+void
+ps_send_char_complete(struct hci_uart *hu, u8 ch)
+{
+	struct ps_data *psdata = hu->psdata;
+
+	PRINTM(CMD, "Send char %c done\n", ch);
+	if (psdata->ps_mode == PS_MODE_ENABLE) {
+		if (ch == MRVL_ENTER_PS_CHAR)
+			psdata->ps_state = PS_STATE_SLEEP;
+		else if (ch == MRVL_EXIT_PS_CHAR)
+			psdata->ps_state = PS_STATE_AWAKE;
+	}
+}
+
+void
+ps_init_timer(struct hci_uart *hu)
+{
+	struct ps_data *psdata = hu->psdata;
+	PRINTM(MSG, "ps_init_timer...\n");
+	psdata->timer_on = 0;
+	psdata->tty = hu->tty;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	timer_setup(&psdata->ps_timer, ps_timeout_func, 0);
+#else
+	init_timer(&psdata->ps_timer);
+	psdata->ps_timer.function = ps_timeout_func;
+	psdata->ps_timer.data = (unsigned long)psdata;
+#endif
+	return;
+}
+
+void
+ps_start_timer(struct hci_uart *hu)
+{
+	struct ps_data *psdata = hu->psdata;
+
+	if (psdata->cur_psmode == PS_MODE_ENABLE) {
+		psdata->timer_on = 1;
+		mod_timer(&psdata->ps_timer,
+			  jiffies + (psdata->interval * HZ) / 1000);
+	}
+}
+
+void
+ps_cancel_timer(struct hci_uart *hu)
+{
+	struct ps_data *psdata = hu->psdata;
+
+	if (psdata) {
+		flush_scheduled_work();
+		if (psdata->timer_on)
+			del_timer(&psdata->ps_timer);
+		if ((psdata->cur_psmode == PS_MODE_ENABLE) &&
+		    (psdata->cur_wakeupmode == WAKEUP_METHOD_BREAK)) {
+			// set_break off
+			set_break(psdata->tty, 0);
+		}
+		psdata->tty = NULL;
+		kfree(psdata);
+	}
+	return;
+}
+
+int
+ps_wakeup(struct hci_uart *hu)
+{
+	struct ps_data *psdata = hu->psdata;
+
+	if (psdata->ps_state == PS_STATE_AWAKE)
+		return 0;
+	psdata->ps_cmd = PS_CMD_EXIT_PS;
+	schedule_work(&psdata->work);
+	return 1;
+}
+
+void
+ps_init(struct hci_uart *hu)
+{
+	struct ps_data *psdata = hu->psdata;
+	int mode = 0;
+	struct ktermios old_termios;
+	PRINTM(MSG, "ps_init...\n");
+	if (!psdata || !psdata->tty)
+		return;
+	if (1 != get_cts(psdata->tty)) {
+		/* firmware is sleeping */
+		mode = psdata->cur_wakeupmode;
+		if (mode == WAKEUP_METHOD_INVALID)
+			mode = wakeupmode;
+		switch (mode) {
+		case WAKEUP_METHOD_BREAK:
+			// set RTS
+			set_rts(psdata->tty, 1);
+			// break on
+			set_break(psdata->tty, 1);
+			// break off
+			set_break(psdata->tty, 0);
+			mdelay(5);
+			break;
+		case WAKEUP_METHOD_DTR:
+			// set RTS
+			set_rts(psdata->tty, 1);
+			set_dtr(psdata->tty, 0);
+			set_dtr(psdata->tty, 1);
+			mdelay(5);
+			break;
+		default:
+			break;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+		old_termios = psdata->tty->termios;
+		psdata->tty->termios.c_cflag &= ~CRTSCTS;	/* Clear the
+								   flow control
+								 */
+		psdata->TTY_FUNC->set_termios(psdata->tty, &old_termios);
+		old_termios = psdata->tty->termios;
+		psdata->tty->termios.c_cflag |= CRTSCTS;	/* Enable the
+								   flow control
+								 */
+		psdata->TTY_FUNC->set_termios(psdata->tty, &old_termios);
+#else
+		old_termios = *(psdata->tty->termios);
+		psdata->tty->termios->c_cflag &= ~CRTSCTS;	/* Clear the
+								   flow control
+								 */
+		psdata->TTY_FUNC->set_termios(psdata->tty, &old_termios);
+		old_termios = *(psdata->tty->termios);
+		psdata->tty->termios->c_cflag |= CRTSCTS;	/* Enable the
+								   flow control
+								 */
+		psdata->TTY_FUNC->set_termios(psdata->tty, &old_termios);
+#endif
+	}
+
+	psdata->send_cmd = 0;
+	if (0 == is_device_ready(hu)) {
+
+		if (psdata->cur_wakeupmode != psdata->wakeupmode) {
+			psdata->send_cmd |= SEND_WAKEUP_METHOD_CMD;
+			send_wakeup_method_cmd(psdata->wakeupmode, hu);
+		}
+		if (psdata->cur_psmode != psdata->ps_mode) {
+			psdata->send_cmd |= SEND_AUTO_SLEEP_MODE_CMD;
+			send_ps_cmd(psdata->ps_mode, hu);
+		}
+	}
+}
+
+void
+ps_check_event_packet(struct hci_uart *hu, struct sk_buff *skb)
+{
+	struct hci_event_hdr *hdr = (void *)skb->data;
+	struct hci_ev_cmd_complete *ev = NULL;
+	u8 event = hdr->evt;
+	u16 opcode;
+	u8 status = 0;
+	struct ps_data *psdata = hu->psdata;
+
+	if (!psdata->send_cmd)
+		return;
+	if (event == HCI_EV_CMD_COMPLETE) {
+		ev = (void *)(skb->data + sizeof(struct hci_event_hdr));
+		opcode = __le16_to_cpu(ev->opcode);
+		switch (opcode) {
+		case HCI_OP_AUTO_SLEEP_MODE:
+			status = *((u8 *) ev +
+				   sizeof(struct hci_ev_cmd_complete));
+			if (!status)
+				psdata->cur_psmode = psdata->ps_mode;
+			else
+				psdata->ps_mode = psdata->cur_psmode;
+			psdata->send_cmd &= ~SEND_AUTO_SLEEP_MODE_CMD;
+			if (psdata->cur_psmode == PS_MODE_ENABLE)
+				ps_start_timer(hu);
+			else
+				ps_wakeup(hu);
+			PRINTM(CMD, "status=%d,ps_mode=%d\n", status,
+			       psdata->cur_psmode);
+			break;
+		case HCI_OP_WAKEUP_METHOD:
+			status = *((u8 *) ev +
+				   sizeof(struct hci_ev_cmd_complete));
+			psdata->send_cmd &= ~SEND_WAKEUP_METHOD_CMD;
+			if (!status)
+				psdata->cur_wakeupmode = psdata->wakeupmode;
+			else
+				psdata->wakeupmode = psdata->cur_wakeupmode;
+			PRINTM(CMD, "status=%d,wakeupmode=%d\n", status,
+			       psdata->cur_wakeupmode);
+			break;
+		default:
+			break;
+		}
+	}
+	return;
+}
+
+/** This function init power save specific proc entries  */
+int
+ps_proc_init(struct hci_uart *hu)
+{
+	u8 ret = 0;
+	struct proc_dir_entry *entry;
+
+	if (proc_bt && !hu->proc_bt) {
+		strcpy(hu->proc_name, hu->hdev->name);
+		hu->proc_bt = proc_mkdir(hu->proc_name, proc_bt);
+		if (!hu->proc_bt) {
+			PRINTM(ERROR, "Could not mkdir %s!\n", hu->proc_name);
+			ret = -1;
+			goto done;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+		entry = proc_create_data("config", S_IFREG | DEFAULT_FILE_PERM,
+					 hu->proc_bt, &proc_rw_ops, hu);
+		if (entry == NULL)
+#else
+		entry = create_proc_entry("config", S_IFREG | DEFAULT_FILE_PERM,
+					  hu->proc_bt);
+		if (entry) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+			entry->owner = THIS_MODULE;
+#endif
+			entry->proc_fops = &proc_rw_ops;
+			entry->data = hu;
+		} else
+#endif
+			PRINTM(ERROR, "MUART: Fail to create proc\n");
+	}
+done:
+	return ret;
+}
+
+/** remove power save proc files */
+void
+ps_proc_remove(struct hci_uart *hu)
+{
+	if (proc_bt && hu->proc_bt) {
+		remove_proc_entry("config", hu->proc_bt);
+		remove_proc_entry(hu->proc_name, proc_bt);
+		hu->proc_bt = NULL;
+	}
+	return;
+}
+
+#else /* CONFIG_MULTI_CARD_PS */
+void
+ps_send_char_complete(u8 ch)
+{
+	PRINTM(CMD, "Send char %c done\n", ch);
+	if (g_data.ps_mode == PS_MODE_ENABLE) {
+		if (ch == MRVL_ENTER_PS_CHAR)
+			g_data.ps_state = PS_STATE_SLEEP;
+		else if (ch == MRVL_EXIT_PS_CHAR)
+			g_data.ps_state = PS_STATE_AWAKE;
+	}
+}
+
+void
+ps_init_timer(struct tty_struct *tty)
+{
+	PRINTM(MSG, "ps_init_timer...\n");
+	g_data.timer_on = 0;
+	g_data.tty = tty;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	timer_setup(&g_data.ps_timer, ps_timeout_func, 0);
+#else
+	init_timer(&g_data.ps_timer);
+	g_data.ps_timer.function = ps_timeout_func;
+	g_data.ps_timer.data = (unsigned long)&g_data;
+#endif
+	return;
+}
+
+void
+ps_start_timer(void)
+{
+	if (g_data.cur_psmode == PS_MODE_ENABLE) {
+		g_data.timer_on = 1;
+		mod_timer(&g_data.ps_timer,
+			  jiffies + (g_data.interval * HZ) / 1000);
+	}
+}
+
+void
+ps_cancel_timer(void)
+{
+	flush_scheduled_work();
+	if (g_data.timer_on)
+		del_timer(&g_data.ps_timer);
+	if ((g_data.cur_psmode == PS_MODE_ENABLE) &&
+	    (g_data.cur_wakeupmode == WAKEUP_METHOD_BREAK)) {
+		// set_break off
+		set_break(g_data.tty, 0);
+	}
+	g_data.tty = NULL;
+	return;
+}
+
+int
+ps_wakeup(void)
+{
+	if (g_data.ps_state == PS_STATE_AWAKE)
+		return 0;
+	g_data.ps_cmd = PS_CMD_EXIT_PS;
+	schedule_work(&g_data.work);
+	return 1;
+}
+
+void
+ps_init(void)
+{
+	struct hci_uart *hu = NULL;
+	int mode = 0;
+	struct ktermios old_termios;
+	PRINTM(MSG, "ps_init...\n");
+	if (!g_data.tty)
+		return;
+	if (1 != get_cts(g_data.tty)) {
+		/* firmware is sleeping */
+		mode = g_data.cur_wakeupmode;
+		if (mode == WAKEUP_METHOD_INVALID)
+			mode = wakeupmode;
+		switch (mode) {
+		case WAKEUP_METHOD_BREAK:
+			// set RTS
+			set_rts(g_data.tty, 1);
+			// break on
+			set_break(g_data.tty, 1);
+			// break off
+			set_break(g_data.tty, 0);
+			mdelay(5);
+			break;
+		case WAKEUP_METHOD_DTR:
+			// set RTS
+			set_rts(g_data.tty, 1);
+			set_dtr(g_data.tty, 0);
+			set_dtr(g_data.tty, 1);
+			mdelay(5);
+			break;
+		default:
+			break;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+		old_termios = g_data.tty->termios;
+		g_data.tty->termios.c_cflag &= ~CRTSCTS;	/* Clear the
+								   flow control
+								 */
+		g_data.TTY_FUNC->set_termios(g_data.tty, &old_termios);
+		old_termios = g_data.tty->termios;
+		g_data.tty->termios.c_cflag |= CRTSCTS;	/* Enable the flow
+							   control */
+		g_data.TTY_FUNC->set_termios(g_data.tty, &old_termios);
+#else
+		old_termios = *(g_data.tty->termios);
+		g_data.tty->termios->c_cflag &= ~CRTSCTS;	/* Clear the
+								   flow control
+								 */
+		g_data.TTY_FUNC->set_termios(g_data.tty, &old_termios);
+		old_termios = *(g_data.tty->termios);
+		g_data.tty->termios->c_cflag |= CRTSCTS;	/* Enable the
+								   flow control
+								 */
+		g_data.TTY_FUNC->set_termios(g_data.tty, &old_termios);
+#endif
+	}
+
+	g_data.send_cmd = 0;
+	hu = (void *)g_data.tty->disc_data;
+	if (0 == is_device_ready(hu)) {
+
+		if (g_data.cur_wakeupmode != g_data.wakeupmode) {
+			g_data.send_cmd |= SEND_WAKEUP_METHOD_CMD;
+			send_wakeup_method_cmd(g_data.wakeupmode, hu);
+		}
+		if (g_data.cur_psmode != g_data.ps_mode) {
+			g_data.send_cmd |= SEND_AUTO_SLEEP_MODE_CMD;
+			send_ps_cmd(g_data.ps_mode, hu);
+		}
+	}
+}
+
+void
+ps_check_event_packet(struct sk_buff *skb)
+{
+	struct hci_event_hdr *hdr = (void *)skb->data;
+	struct hci_ev_cmd_complete *ev = NULL;
+	u8 event = hdr->evt;
+	u16 opcode;
+	u8 status = 0;
+	if (!g_data.send_cmd)
+		return;
+	if (event == HCI_EV_CMD_COMPLETE) {
+		ev = (void *)(skb->data + sizeof(struct hci_event_hdr));
+		opcode = __le16_to_cpu(ev->opcode);
+		switch (opcode) {
+		case HCI_OP_AUTO_SLEEP_MODE:
+			status = *((u8 *) ev +
+				   sizeof(struct hci_ev_cmd_complete));
+			if (!status)
+				g_data.cur_psmode = g_data.ps_mode;
+			else
+				g_data.ps_mode = g_data.cur_psmode;
+			g_data.send_cmd &= ~SEND_AUTO_SLEEP_MODE_CMD;
+			if (g_data.cur_psmode == PS_MODE_ENABLE)
+				ps_start_timer();
+			else
+				ps_wakeup();
+			PRINTM(CMD, "status=%d,ps_mode=%d\n", status,
+			       g_data.cur_psmode);
+			break;
+		case HCI_OP_WAKEUP_METHOD:
+			status = *((u8 *) ev +
+				   sizeof(struct hci_ev_cmd_complete));
+			g_data.send_cmd &= ~SEND_WAKEUP_METHOD_CMD;
+			if (!status)
+				g_data.cur_wakeupmode = g_data.wakeupmode;
+			else
+				g_data.wakeupmode = g_data.cur_wakeupmode;
+			PRINTM(CMD, "status=%d,wakeupmode=%d\n", status,
+			       g_data.cur_wakeupmode);
+			break;
+		default:
+			break;
+		}
+	}
+	return;
+}
+#endif /* CONFIG_MULTI_CARD_PS */
+
+module_param(ps_mode, int, 0);
+MODULE_PARM_DESC(ps_mode, "ps mode: 0 disable ps mode, 1 enable ps mode");
+module_param(wakeupmode, int, 0);
+MODULE_PARM_DESC(wakeupmode, "wakeup mode");
+module_param(drvdbg, uint, 0660);
+MODULE_PARM_DESC(drvdbg, "Driver Debug");
diff --git a/88x9098/bt/muart_src/hci_uart.h b/88x9098/bt/muart_src/hci_uart.h
new file mode 100644
index 0000000..49d0cb5
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_uart.h
@@ -0,0 +1,162 @@
+/*
+ *
+ *  Bluetooth HCI UART driver
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright 2018-2020 NXP
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef _HCI_UART_H_
+#define _HCI_UART_H_
+
+#include <linux/version.h>
+#include "hci_wrapper.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define TTY_FUNC tty->ops
+#else
+#define TTY_FUNC tty->driver
+#endif
+
+#ifndef N_HCI
+#define N_HCI	15
+#endif
+
+/* Ioctls */
+#define HCIUARTSETPROTO		_IOW('U', 200, int)
+#define HCIUARTGETPROTO		_IOR('U', 201, int)
+#define HCIUARTGETDEVICE	_IOR('U', 202, int)
+
+/* UART protocols */
+#define HCI_UART_MAX_PROTO	5
+
+#define HCI_UART_H4	0
+#define HCI_UART_BCSP	1
+#define HCI_UART_3WIRE	2
+#define HCI_UART_H4DS	3
+#define HCI_UART_LL	4
+#define MAX_RADIO_FUNC	3
+struct hci_uart;
+
+struct hci_uart_proto {
+	unsigned int id;
+	int (*open) (struct hci_uart * hu);
+	int (*close) (struct hci_uart * hu);
+	int (*flush) (struct hci_uart * hu);
+	int (*recv) (struct hci_uart * hu, void *data, int len);
+	int (*enqueue) (struct hci_uart * hu, struct sk_buff * skb);
+	struct sk_buff *(*dequeue) (struct hci_uart * hu);
+};
+
+struct hci_uart {
+	struct tty_struct *tty;
+	struct m_dev m_dev[MAX_RADIO_FUNC];
+	struct hci_dev *hdev;
+	unsigned long flags;
+
+	struct work_struct write_work;
+	struct hci_uart_proto *proto;
+	void *priv;
+
+	struct sk_buff *tx_skb;
+	unsigned long tx_state;
+	spinlock_t rx_lock;
+#if defined(CONFIG_BT_HCIUART_PS) && defined(CONFIG_MULTI_CARD_PS)
+	struct ps_data *psdata;
+	struct proc_dir_entry *proc_bt;
+	char proc_name[IFNAMSIZ];
+#endif
+	struct class *chardev_class;
+	struct list_head hu_list_head;
+	__u16 id;
+};
+
+/* HCI_UART flag bits */
+#define HCI_UART_PROTO_SET	0
+
+/* TX states  */
+#define HCI_UART_SENDING	1
+#define HCI_UART_TX_WAKEUP	2
+
+int hci_uart_register_proto(struct hci_uart_proto *p);
+int hci_uart_unregister_proto(struct hci_uart_proto *p);
+int hci_uart_tx_wakeup(struct hci_uart *hu);
+
+#ifdef CONFIG_BT_HCIUART_H4
+int h4_init(void);
+int h4_deinit(void);
+#endif
+
+#ifdef CONFIG_BT_HCIUART_BCSP
+int bcsp_init(void);
+int bcsp_deinit(void);
+#endif
+
+#ifdef CONFIG_BT_HCIUART_LL
+int ll_init(void);
+int ll_deinit(void);
+#endif
+
+#ifdef CONFIG_BT_HCIUART_PS
+#define MRVL_ENTER_PS_CHAR      'D'
+#define MRVL_EXIT_PS_CHAR       'W'
+int proc_init(void);
+void muart_proc_remove(void);
+#ifdef CONFIG_MULTI_CARD_PS
+int ps_proc_init(struct hci_uart *hu);
+void ps_proc_remove(struct hci_uart *hu);
+int ps_init_work(struct hci_uart *hu);
+void ps_init_timer(struct hci_uart *hu);
+void ps_start_timer(struct hci_uart *hu);
+void ps_cancel_timer(struct hci_uart *hu);
+int ps_wakeup(struct hci_uart *hu);
+void ps_init(struct hci_uart *hu);
+void ps_check_event_packet(struct hci_uart *hu, struct sk_buff *skb);
+void ps_send_char_complete(struct hci_uart *hu, u8 ch);
+#else
+void ps_init_timer(struct tty_struct *tty);
+void ps_start_timer(void);
+void ps_cancel_timer(void);
+int ps_wakeup(void);
+void ps_init(void);
+void ps_check_event_packet(struct sk_buff *skb);
+void ps_send_char_complete(u8 ch);
+#endif
+#endif
+
+int hci_uart_open(struct hci_dev *hdev);
+/* Close device */
+int hci_uart_close(struct hci_dev *hdev);
+/* Reset device */
+int hci_uart_flush(struct hci_dev *hdev);
+/* Send frames from HCI layer */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+#if defined(BT_AMP) && !defined(MBT_EXT)
+int hci_uart_send_frame(struct sk_buff *skb);
+#else
+int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb);
+#endif
+#else
+int hci_uart_send_frame(struct sk_buff *skb);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+void hci_uart_destruct(struct hci_dev *hdev);
+#endif
+#endif // _HCI_UART_H_
diff --git a/88x9098/bt/muart_src/hci_wrapper.c b/88x9098/bt/muart_src/hci_wrapper.c
new file mode 100644
index 0000000..1956c63
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_wrapper.c
@@ -0,0 +1,434 @@
+/** @file hci_wrapper.c
+  *
+  * @brief This file contains the char device function calls
+  *
+  * Copyright 2018-2020 NXP
+  *
+  * This software file (the File) is distributed by NXP
+  * under the terms of the GNU General Public License Version 2, June 1991
+  * (the License).  You may use, redistribute and/or modify the File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available by writing to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+  * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/proc_fs.h>
+
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+
+#include <linux/path.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include "include/amp/bluetooth/bluetooth.h"
+#include "include/amp/bluetooth/hci_core.h"
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+#include <linux/tty.h>
+
+#include "mbt_char.h"
+#include "hci_wrapper.h"
+#include "bt_drv.h"
+#include "hci_uart.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+extern int reset;
+#else
+extern bool reset;
+#endif
+
+#define AID_SYSTEM        1000	/* system server */
+
+#define AID_BLUETOOTH     1002	/* bluetooth subsystem */
+
+/* HCI device list */
+LIST_HEAD(hci_dev_list);
+int fmchar_minor = 0;
+int nfcchar_minor = 0;
+
+/**
+ *  @brief This function queries the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *  @param arg     arguement
+ *
+ *  @return 	   BT_STATUS_SUCCESS  or other
+ */
+void
+mdev_query(struct m_dev *m_dev, unsigned long arg)
+{
+	ENTER();
+	if (copy_to_user((void *)arg, &m_dev->type, sizeof(m_dev->type)))
+		PRINTM(ERROR, "IOCTL_QUERY_TYPE: Fail copy to user\n");
+
+	LEAVE();
+}
+
+/**
+ *  @brief This function handles the wrapper_dev ioctl
+ *
+ *  @param hev     A pointer to wrapper_dev structure
+ *  @cmd   	   ioctl cmd
+ *  @arg   	   argument
+ *  @return 	   -ENOIOCTLCMD
+ */
+int
+mdev_ioctl(struct m_dev *m_dev, unsigned int cmd, unsigned long arg)
+{
+	ENTER();
+	LEAVE();
+	return -ENOIOCTLCMD;
+}
+
+/**
+ *  @brief This function handles wrapper device destruct
+ *
+ *  @param hdev    A pointer to m_dev structure
+ *
+ *  @return 	   N/A
+ */
+void
+mdev_destruct(struct m_dev *m_dev)
+{
+	ENTER();
+	LEAVE();
+	return;
+}
+
+/* Send frames from HCI layer */
+int
+mdev_send_frame(struct m_dev *m_dev, struct sk_buff *skb)
+{
+	struct tty_struct *tty;
+	struct hci_uart *hu;
+
+	if (!m_dev) {
+		PRINTM(ERROR, "Frame for uknown device (m_dev=NULL)\n");
+		return -ENODEV;
+	}
+	if (!test_bit(HCI_RUNNING, &m_dev->flags)) {
+		return -EBUSY;
+	}
+
+	hu = (struct hci_uart *)m_dev->driver_data;
+	if (!hu) {
+		return -ENODEV;
+	}
+	tty = hu->tty;
+	if (!tty) {
+		PRINTM(ERROR, "tty is not ready\n");
+		return -ENODEV;
+	}
+
+	PRINTM(DATA, "%s: send frame type %d len %d\n", m_dev->name,
+	       bt_cb(skb)->pkt_type, skb->len);
+	hu->proto->enqueue(hu, skb);
+
+	hci_uart_tx_wakeup(hu);
+
+	return 0;
+}
+
+/**
+ *  @brief This function flushes the transmit queue
+ *
+ *  @param m_dev     A pointer to m_dev structure
+ *
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+
+int
+mdev_flush(struct m_dev *m_dev)
+{
+	struct hci_uart *hu = (struct hci_uart *)m_dev->driver_data;
+	struct tty_struct *tty = hu->tty;
+
+	PRINTM(CMD, "mdev_flush: m_dev %p tty %p\n", m_dev, tty);
+
+	return 0;
+}
+
+/**
+ *  @brief This function closes the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+int
+mdev_close(struct m_dev *m_dev)
+{
+	ENTER();
+	mdev_req_lock(m_dev);
+	if (!test_and_clear_bit(HCI_RUNNING, &m_dev->flags)) {
+		mdev_req_unlock(m_dev);
+		LEAVE();
+		return 0;
+	}
+	mdev_req_unlock(m_dev);
+
+	if (m_dev->flush)
+		m_dev->flush(m_dev);
+	LEAVE();
+	return 0;
+}
+
+/* ------- Interface to HCI layer ------ */
+/* Initialize device */
+int
+mdev_open(struct m_dev *m_dev)
+{
+	PRINTM(CMD, "%s open %p\n", m_dev->name, m_dev);
+	/* Nothing to do for UART driver */
+	set_bit(HCI_RUNNING, &m_dev->flags);
+	return 0;
+}
+
+/**
+ *  @brief This function initializes the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *
+ *  @return 	   BT_STATUS_SUCCESS  or other
+ */
+void
+init_m_dev(struct m_dev *m_dev)
+{
+	m_dev->dev_pointer = NULL;
+	m_dev->type = HCI_UART;
+	m_dev->dev_type = 0;
+	m_dev->spec_type = 0;
+	skb_queue_head_init(&m_dev->rx_q);
+	init_waitqueue_head(&m_dev->req_wait_q);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+	init_MUTEX(&m_dev->req_lock);
+#else
+	sema_init(&m_dev->req_lock, 1);
+#endif
+	memset(&m_dev->stat, 0, sizeof(struct hci_dev_stats));
+	m_dev->open = mdev_open;
+	m_dev->close = mdev_close;
+	m_dev->flush = mdev_flush;
+	m_dev->send = mdev_send_frame;
+	m_dev->destruct = mdev_destruct;
+	m_dev->ioctl = mdev_ioctl;
+	m_dev->query = mdev_query;
+	m_dev->owner = THIS_MODULE;
+
+}
+
+/**
+ *  @brief Alloc bt device
+ *
+ *  @return    pointer to structure mbt_dev or NULL
+ */
+struct hci_dev *
+alloc_hci_dev(void)
+{
+	struct hci_dev *hdev;
+	ENTER();
+
+	hdev = kzalloc(sizeof(struct hci_dev), GFP_KERNEL);
+	if (!hdev) {
+		LEAVE();
+		return NULL;
+	}
+
+	LEAVE();
+	return hdev;
+}
+
+/**
+ *  @brief Alloc fm device
+ *
+ *  @return    pointer to structure fm_dev or NULL
+ */
+struct fm_dev *
+alloc_fm_dev(void)
+{
+	struct fm_dev *fm_dev;
+	ENTER();
+
+	fm_dev = kzalloc(sizeof(struct fm_dev), GFP_KERNEL);
+	if (!fm_dev) {
+		LEAVE();
+		return NULL;
+	}
+
+	LEAVE();
+	return fm_dev;
+}
+
+/**
+ *  @brief Alloc nfc device
+ *
+ *  @return    pointer to structure nfc_dev or NULL
+ */
+struct nfc_dev *
+alloc_nfc_dev(void)
+{
+	struct nfc_dev *nfc_dev;
+	ENTER();
+
+	nfc_dev = kzalloc(sizeof(struct nfc_dev), GFP_KERNEL);
+	if (!nfc_dev) {
+		LEAVE();
+		return NULL;
+	}
+
+	LEAVE();
+	return nfc_dev;
+}
+
+/**
+ *  @brief Frees m_dev
+ *
+ *  @return    N/A
+ */
+void
+free_m_dev(struct m_dev *m_dev)
+{
+	ENTER();
+	if (m_dev->dev_pointer)
+		kfree(m_dev->dev_pointer);
+	LEAVE();
+}
+
+/**
+ *  @brief Unregister HCI device
+ *  @param hdev   pointer to structure hci_dev
+ *  @return    0
+ */
+int
+mdev_unregister_dev(struct m_dev *m_dev, u8 mseq)
+{
+	struct hci_uart *hu = m_dev->driver_data;
+	chardev_cleanup_one(m_dev, hu->chardev_class);
+	free_m_dev(m_dev);
+
+	LEAVE();
+	return 0;
+}
+
+int
+mdev_register_dev(struct m_dev *m_dev, u8 mseq)
+{
+	struct fm_dev *fm_dev = NULL;
+	struct nfc_dev *nfc_dev = NULL;
+	struct hci_uart *hu = m_dev->driver_data;
+	struct class *chardev_class = hu->chardev_class;
+	struct char_dev *char_dev = NULL;
+	char dev_file[16];
+
+	int ret = 0;
+	switch (mseq) {
+	case FM_SEQ:
+			/** alloc fm_dev */
+		fm_dev = alloc_fm_dev();
+		if (!fm_dev) {
+			PRINTM(ERROR, "Can not allocate fm dev\n");
+			return -ENOMEM;
+		}
+
+			/** init m_dev */
+		init_m_dev(m_dev);
+		m_dev->dev_type = FM_TYPE;
+		m_dev->spec_type = GENERIC_SPEC;
+		m_dev->dev_pointer = (void *)fm_dev;
+		fmchar_minor = hu->id;
+
+			/** create char device for FM */
+		char_dev = kzalloc(sizeof(struct char_dev), GFP_KERNEL);
+		if (!char_dev) {
+			return -ENOMEM;
+		}
+		char_dev->minor = FMCHAR_MINOR_BASE + fmchar_minor;
+		char_dev->dev_type = FM_TYPE;
+		snprintf(fm_dev->name, sizeof(fm_dev->name), "mfmchar%d",
+			 fmchar_minor);
+		snprintf(dev_file, sizeof(dev_file), "/dev/mfmchar%d",
+			 fmchar_minor);
+
+			/** register char dev */
+		register_char_dev(char_dev, chardev_class, MODULE_NAME,
+				  fm_dev->name);
+
+			/** chmod for FM char device */
+		mbtchar_chmod(dev_file, 0666);
+
+			/** register m_dev to FM char device */
+		m_dev->index = char_dev->minor;
+		char_dev->m_dev = m_dev;
+
+			/** create proc device */
+		snprintf(m_dev->name, sizeof(m_dev->name), fm_dev->name);
+//                      bt_proc_init(priv, &(priv->bt_dev.m_dev[FM_SEQ]), FM_SEQ);
+		break;
+
+	case NFC_SEQ:
+			/** alloc nfc_dev */
+		nfc_dev = alloc_nfc_dev();
+		if (!nfc_dev) {
+			PRINTM(ERROR, "Can not allocate nfc dev\n");
+			return -ENOMEM;
+		}
+
+			/** init m_dev */
+		init_m_dev(m_dev);
+		m_dev->dev_type = NFC_TYPE;
+		m_dev->spec_type = GENERIC_SPEC;
+		m_dev->dev_pointer = (void *)nfc_dev;
+		nfcchar_minor = hu->id;
+
+			/** create char device for NFC */
+		char_dev = kzalloc(sizeof(struct char_dev), GFP_KERNEL);
+		if (!char_dev) {
+			return -ENOMEM;
+		}
+		char_dev->minor = NFCCHAR_MINOR_BASE + nfcchar_minor;
+		char_dev->dev_type = NFC_TYPE;
+		snprintf(nfc_dev->name, sizeof(nfc_dev->name), "mnfcchar%d",
+			 nfcchar_minor);
+		snprintf(dev_file, sizeof(dev_file), "/dev/mnfcchar%d",
+			 nfcchar_minor);
+
+			/** register char dev */
+		register_char_dev(char_dev, chardev_class, MODULE_NAME,
+				  nfc_dev->name);
+
+			/** chmod for NFC char device */
+		mbtchar_chmod(dev_file, 0666);
+
+			/** register m_dev to NFC char device */
+		m_dev->index = char_dev->minor;
+		char_dev->m_dev = m_dev;
+
+			/** create proc device */
+		snprintf(m_dev->name, sizeof(m_dev->name), nfc_dev->name);
+//                      bt_proc_init(priv, &(priv->bt_dev.m_dev[NFC_SEQ]), NFC_SEQ);
+		break;
+	}
+	return ret;
+}
diff --git a/88x9098/bt/muart_src/hci_wrapper.h b/88x9098/bt/muart_src/hci_wrapper.h
new file mode 100644
index 0000000..55188fb
--- /dev/null
+++ b/88x9098/bt/muart_src/hci_wrapper.h
@@ -0,0 +1,157 @@
+/** @file hci_wrapper.h
+  * @brief This file contains HCI related definitions
+  *
+  * Copyright 2018-2020 NXP
+  *
+  * This software file (the File) is distributed by NXP
+  * under the terms of the GNU General Public License Version 2, June 1991
+  * (the License).  You may use, redistribute and/or modify the File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available by writing to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+  * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+
+#ifndef _HCI_WRAPPER_H_
+#define _HCI_WRAPPER_H_
+
+/** Define module name */
+#define MODULE_NAME  "bt_fm_nfc_urt"
+
+/**  Define Seq num */
+#define BT_SEQ      0
+#define FM_SEQ      1
+#define NFC_SEQ     2
+
+/** Define dev type */
+#define BT_TYPE     1
+#define BT_AMP_TYPE 2
+#define FM_TYPE     3
+#define NFC_TYPE    4
+
+/** Define spec type */
+#define BLUEZ_SPEC     1
+#define IANYWHERE_SPEC 2
+#define GENERIC_SPEC   3
+
+/** Define lock/unlock wrapper */
+#define mdev_req_lock(d)		down(&d->req_lock)
+#define mdev_req_unlock(d)		up(&d->req_lock)
+
+/** Define struct m_dev */
+struct m_dev {
+	char name[10];
+	int index;
+	unsigned long flags;
+	__u8 type;
+	spinlock_t lock;
+	struct semaphore req_lock;
+	struct sk_buff_head rx_q;
+	wait_queue_head_t req_wait_q;
+	struct hci_dev_stats stat;
+	struct module *owner;
+	void *dev_pointer;
+	int dev_type;
+	int spec_type;
+	void *driver_data;
+
+	int (*open) (struct m_dev * m_dev);
+	int (*close) (struct m_dev * m_dev);
+	int (*flush) (struct m_dev * m_dev);
+	int (*send) (struct m_dev * m_dev, struct sk_buff * skb);
+	void (*destruct) (struct m_dev * m_dev);
+	void (*notify) (struct m_dev * m_dev, unsigned int evt);
+	int (*ioctl) (struct m_dev * m_dev, unsigned int cmd,
+		      unsigned long arg);
+	void (*query) (struct m_dev * mdev, unsigned long arg);
+
+};
+
+/** Define struct mbt_dev */
+struct mbt_dev {
+	/** maybe could add some private member later */
+	char name[10];
+	unsigned long flags;
+};
+
+/** Define 'fm' interface specific struct fm_dev */
+struct fm_dev {
+	/** maybe could add some private member later */
+	char name[10];
+	unsigned long flags;
+};
+
+/** Define 'nfc' interface specific struct fm_dev */
+struct nfc_dev {
+	/** maybe could add some private member later */
+	char name[10];
+	unsigned long flags;
+};
+
+/** This function frees m_dev allocation */
+void free_m_dev(struct m_dev *m_dev);
+
+void mdev_query(struct m_dev *m_dev, unsigned long arg);
+
+int mdev_ioctl(struct m_dev *m_dev, unsigned int cmd, unsigned long arg);
+
+void mdev_destruct(struct m_dev *m_dev);
+
+int mdev_flush(struct m_dev *m_dev);
+
+int mdev_close(struct m_dev *m_dev);
+
+int mdev_open(struct m_dev *m_dev);
+
+void init_m_dev(struct m_dev *m_dev);
+
+struct hci_dev *alloc_hci_dev(void);
+
+struct fm_dev *alloc_fm_dev(void);
+
+struct nfc_dev *alloc_nfc_dev(void);
+
+void free_m_dev(struct m_dev *m_dev);
+
+/**
+ *  @brief This function receives frames
+ *
+ *  @param skb     A pointer to struct sk_buff
+ *  @return 	   0--success otherwise error code
+ */
+static inline int
+mdev_recv_frame(struct sk_buff *skb)
+{
+	struct m_dev *m_dev = (struct m_dev *)skb->dev;
+	if (!m_dev || (!test_bit(HCI_UP, &m_dev->flags)
+		       && !test_bit(HCI_INIT, &m_dev->flags))) {
+		kfree_skb(skb);
+		return -ENXIO;
+	}
+
+	/* Incomming skb */
+	bt_cb(skb)->incoming = 1;
+
+	/* Time stamp */
+	__net_timestamp(skb);
+
+	/* Queue frame for rx task */
+	skb_queue_tail(&m_dev->rx_q, skb);
+
+	/* Wakeup rx thread */
+	wake_up_interruptible(&m_dev->req_wait_q);
+
+	return 0;
+}
+
+int mdev_register_dev(struct m_dev *m_dev, u8 mseq);
+
+int mdev_unregister_dev(struct m_dev *m_dev, u8 mseq);
+
+#endif /* _HCI_WRAPPER_H_ */
diff --git a/88x9098/bt/muart_src/include/amp/bluetooth/bluetooth.h b/88x9098/bt/muart_src/include/amp/bluetooth/bluetooth.h
new file mode 100644
index 0000000..0761f0c
--- /dev/null
+++ b/88x9098/bt/muart_src/include/amp/bluetooth/bluetooth.h
@@ -0,0 +1,189 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __BLUETOOTH_H
+#define __BLUETOOTH_H
+
+#include <asm/types.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+#include <linux/poll.h>
+#include <net/sock.h>
+
+#ifndef AF_BLUETOOTH
+#define AF_BLUETOOTH	31
+#define PF_BLUETOOTH	AF_BLUETOOTH
+#endif
+
+/* Reserv for core and drivers use */
+#define BT_SKB_RESERVE	8
+
+#define BTPROTO_L2CAP	0
+#define BTPROTO_HCI	1
+#define BTPROTO_SCO	2
+#define BTPROTO_RFCOMM	3
+#define BTPROTO_BNEP	4
+#define BTPROTO_CMTP	5
+#define BTPROTO_HIDP	6
+#define BTPROTO_AVDTP	7
+
+#define SOL_HCI		0
+#define SOL_L2CAP	6
+#define SOL_SCO		17
+#define SOL_RFCOMM	18
+
+#define BT_INFO(fmt, arg...) printk(KERN_ALERT "Bluetooth: " fmt "\n" , ## arg)
+#define BT_DBG(fmt, arg...)  printk(KERN_ALERT "%s: " fmt "\n" , __FUNCTION__ , ## arg)
+#define BT_ERR(fmt, arg...)  printk(KERN_ALERT "%s: " fmt "\n" , __FUNCTION__ , ## arg)
+
+/* Connection and socket states */
+enum {
+	BT_CONNECTED = 1,	/* Equal to TCP_ESTABLISHED to make net code
+				   happy */
+	BT_OPEN,
+	BT_BOUND,
+	BT_LISTEN,
+	BT_CONNECT,
+	BT_CONNECT2,
+	BT_CONFIG,
+	BT_DISCONN,
+	BT_CLOSED,
+	BT_CONNECT_AMP_WAIT,
+};
+
+/* Endianness conversions */
+#define htobs(a)	__cpu_to_le16(a)
+#define htobl(a)	__cpu_to_le32(a)
+#define btohs(a)	__le16_to_cpu(a)
+#define btohl(a)	__le32_to_cpu(a)
+
+/* BD Address */
+typedef struct {
+	__u8 b[6];
+} __attribute__ ((packed)) bdaddr_t;
+
+#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0}})
+#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff}})
+
+/* Copy, swap, convert BD Address */
+static inline int
+bacmp(bdaddr_t * ba1, bdaddr_t * ba2)
+{
+	return memcmp(ba1, ba2, sizeof(bdaddr_t));
+}
+
+static inline void
+bacpy(bdaddr_t * dst, bdaddr_t * src)
+{
+	memcpy(dst, src, sizeof(bdaddr_t));
+}
+
+void baswap(bdaddr_t * dst, bdaddr_t * src);
+char *batostr(bdaddr_t * ba);
+bdaddr_t *strtoba(char *str);
+
+/* Common socket structures and functions */
+
+#define bt_sk(__sk) ((struct bt_sock *) __sk)
+
+struct bt_sock {
+	struct sock sk;
+	bdaddr_t src;
+	bdaddr_t dst;
+	struct list_head accept_q;
+	struct sock *parent;
+};
+
+struct bt_sock_list {
+	struct hlist_head head;
+	rwlock_t lock;
+};
+
+int bt_sock_register(int proto, struct net_proto_family *ops);
+int bt_sock_unregister(int proto);
+void bt_sock_link(struct bt_sock_list *l, struct sock *s);
+void bt_sock_unlink(struct bt_sock_list *l, struct sock *s);
+int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
+		    size_t len, int flags);
+uint bt_sock_poll(struct file *file, struct socket *sock, poll_table * wait);
+int bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
+int bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
+
+void bt_accept_enqueue(struct sock *parent, struct sock *sk);
+void bt_accept_unlink(struct sock *sk);
+struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);
+
+/* Skb helpers */
+struct bt_skb_cb {
+	__u8 pkt_type;
+	__u8 incoming;
+};
+#define bt_cb(skb) ((struct bt_skb_cb *)(skb->cb))
+
+static inline struct sk_buff *
+bt_skb_alloc(unsigned int len, gfp_t how)
+{
+	struct sk_buff *skb;
+
+	if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
+		skb_reserve(skb, BT_SKB_RESERVE);
+		bt_cb(skb)->incoming = 0;
+	}
+	return skb;
+}
+
+static inline struct sk_buff *
+bt_skb_send_alloc(struct sock *sk, unsigned long len, int nb, int *err)
+{
+	struct sk_buff *skb;
+
+	if ((skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err))) {
+		skb_reserve(skb, BT_SKB_RESERVE);
+		bt_cb(skb)->incoming = 0;
+	}
+
+	return skb;
+}
+
+static inline int
+skb_frags_no(struct sk_buff *skb)
+{
+	register struct sk_buff *frag = skb_shinfo(skb)->frag_list;
+	register int n = 1;
+
+	for (; frag; frag = frag->next, n++) ;
+	return n;
+}
+
+int bt_err(__u16 code);
+
+extern int hci_sock_init(void);
+extern int hci_sock_cleanup(void);
+
+extern int bt_sysfs_init(void);
+extern void bt_sysfs_cleanup(void);
+
+extern struct class *bt_class;
+
+#endif /* __BLUETOOTH_H */
diff --git a/88x9098/bt/muart_src/include/amp/bluetooth/hci.h b/88x9098/bt/muart_src/include/amp/bluetooth/hci.h
new file mode 100644
index 0000000..5414ecb
--- /dev/null
+++ b/88x9098/bt/muart_src/include/amp/bluetooth/hci.h
@@ -0,0 +1,1186 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_H
+#define __HCI_H
+
+#define HCI_MAX_ACL_SIZE	2048	// 1024
+#define HCI_MAX_SCO_SIZE	255
+#define HCI_MAX_EVENT_SIZE	260
+#define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
+
+/* HCI dev events */
+#define HCI_DEV_REG			1
+#define HCI_DEV_UNREG			2
+#define HCI_DEV_UP			3
+#define HCI_DEV_DOWN			4
+#define HCI_DEV_SUSPEND			5
+#define HCI_DEV_RESUME			6
+
+/* HCI notify events */
+#define HCI_NOTIFY_CONN_ADD		1
+#define HCI_NOTIFY_CONN_DEL		2
+#define HCI_NOTIFY_VOICE_SETTING	3
+
+/* HCI device types */
+#define HCI_VIRTUAL	0
+#define HCI_USB		1
+#define HCI_PCCARD	2
+#define HCI_UART	3
+#define HCI_RS232	4
+#define HCI_PCI		5
+#define HCI_SDIO	6
+
+/* HCI AMP device types */
+#define HCI_BT_AMP	0x80
+#define HCI_AMP_SDIO	HCI_BT_AMP|HCI_SDIO
+/* HCI device quirks */
+enum {
+	HCI_QUIRK_RESET_ON_INIT,
+	HCI_QUIRK_RAW_DEVICE,
+	HCI_QUIRK_FIXUP_BUFFER_SIZE
+};
+
+/* HCI device flags */
+enum {
+	HCI_UP,
+	HCI_INIT,
+	HCI_RUNNING,
+
+	HCI_PSCAN,
+	HCI_ISCAN,
+	HCI_AUTH,
+	HCI_ENCRYPT,
+	HCI_INQUIRY,
+
+	HCI_RAW,
+
+	HCI_SECMGR
+};
+
+/* HCI ioctl defines */
+#define HCIDEVUP	_IOW('H', 201, int)
+#define HCIDEVDOWN	_IOW('H', 202, int)
+#define HCIDEVRESET	_IOW('H', 203, int)
+#define HCIDEVRESTAT	_IOW('H', 204, int)
+
+#define HCIGETDEVLIST	_IOR('H', 210, int)
+#define HCIGETDEVINFO	_IOR('H', 211, int)
+#define HCIGETCONNLIST	_IOR('H', 212, int)
+#define HCIGETCONNINFO	_IOR('H', 213, int)
+#define HCIGETAUTHINFO	_IOR('H', 215, int)
+#define HCIGETAMPINFO	_IOR('H', 216, int)
+#define HCIGETAMPASSOC	_IOR('H', 217, int)
+#define HCIGETREGDATA	_IOR('H', 218, int)
+
+#define HCISETRAW	_IOW('H', 220, int)
+#define HCISETSCAN	_IOW('H', 221, int)
+#define HCISETAUTH	_IOW('H', 222, int)
+#define HCISETENCRYPT	_IOW('H', 223, int)
+#define HCISETPTYPE	_IOW('H', 224, int)
+#define HCISETLINKPOL	_IOW('H', 225, int)
+#define HCISETLINKMODE	_IOW('H', 226, int)
+#define HCISETACLMTU	_IOW('H', 227, int)
+#define HCISETSCOMTU	_IOW('H', 228, int)
+
+#define HCISETSECMGR	_IOW('H', 230, int)
+#define HCISETREGDATA	_IOR('H', 231, int)
+
+#define HCIINQUIRY	_IOR('H', 240, int)
+
+/* HCI timeouts */
+#define HCI_CONNECT_TIMEOUT	(40000)	/* 40 seconds */
+#define HCI_DISCONN_TIMEOUT	(20000)	/* 20 seconds */
+#define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
+#define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
+#define HCI_CMD_TIMEOUT		(2000)	/* 2 seconds */
+
+/* HCI data types */
+#define HCI_COMMAND_PKT		0x01
+#define HCI_ACLDATA_PKT		0x02
+#define HCI_SCODATA_PKT		0x03
+#define HCI_EVENT_PKT		0x04
+#define HCI_VENDOR_PKT		0xff
+
+/* HCI packet types */
+#define HCI_DM1		0x0008
+#define HCI_DM3		0x0400
+#define HCI_DM5		0x4000
+#define HCI_DH1		0x0010
+#define HCI_DH3		0x0800
+#define HCI_DH5		0x8000
+
+#define HCI_HV1		0x0020
+#define HCI_HV2		0x0040
+#define HCI_HV3		0x0080
+
+#define SCO_PTYPE_MASK	(HCI_HV1 | HCI_HV2 | HCI_HV3)
+#define ACL_PTYPE_MASK	(~SCO_PTYPE_MASK)
+
+/* eSCO packet types */
+#define ESCO_HV1	0x0001
+#define ESCO_HV2	0x0002
+#define ESCO_HV3	0x0004
+#define ESCO_EV3	0x0008
+#define ESCO_EV4	0x0010
+#define ESCO_EV5	0x0020
+
+#define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+
+/* ACL flags */
+#define ACL_CONT		0x01
+#define ACL_START		0x02
+#define ACL_ACTIVE_BCAST	0x04
+#define ACL_PICO_BCAST		0x08
+#define ACL_AMP			0x03
+
+/* Baseband links */
+#define SCO_LINK	0x00
+#define ACL_LINK	0x01
+#define ESCO_LINK	0x02
+
+/* LMP features */
+#define LMP_3SLOT	0x01
+#define LMP_5SLOT	0x02
+#define LMP_ENCRYPT	0x04
+#define LMP_SOFFSET	0x08
+#define LMP_TACCURACY	0x10
+#define LMP_RSWITCH	0x20
+#define LMP_HOLD	0x40
+#define LMP_SNIFF	0x80
+
+#define LMP_PARK	0x01
+#define LMP_RSSI	0x02
+#define LMP_QUALITY	0x04
+#define LMP_SCO		0x08
+#define LMP_HV2		0x10
+#define LMP_HV3		0x20
+#define LMP_ULAW	0x40
+#define LMP_ALAW	0x80
+
+#define LMP_CVSD	0x01
+#define LMP_PSCHEME	0x02
+#define LMP_PCONTROL	0x04
+
+#define LMP_ESCO	0x80
+
+#define LMP_EV4		0x01
+#define LMP_EV5		0x02
+
+#define LMP_SNIFF_SUBR	0x02
+
+#define LMP_SIMPLE_PAIR	0x08
+
+/* Connection modes */
+#define HCI_CM_ACTIVE	0x0000
+#define HCI_CM_HOLD	0x0001
+#define HCI_CM_SNIFF	0x0002
+#define HCI_CM_PARK	0x0003
+
+/* Link policies */
+#define HCI_LP_RSWITCH	0x0001
+#define HCI_LP_HOLD	0x0002
+#define HCI_LP_SNIFF	0x0004
+#define HCI_LP_PARK	0x0008
+
+/* Link modes */
+#define HCI_LM_ACCEPT	0x8000
+#define HCI_LM_MASTER	0x0001
+#define HCI_LM_AUTH	0x0002
+#define HCI_LM_ENCRYPT	0x0004
+#define HCI_LM_TRUSTED	0x0008
+#define HCI_LM_RELIABLE	0x0010
+#define HCI_LM_SECURE	0x0020
+
+/* Authentication types */
+#define HCI_AT_NO_BONDING		0x00
+#define HCI_AT_NO_BONDING_MITM		0x01
+#define HCI_AT_DEDICATED_BONDING	0x02
+#define HCI_AT_DEDICATED_BONDING_MITM	0x03
+#define HCI_AT_GENERAL_BONDING		0x04
+#define HCI_AT_GENERAL_BONDING_MITM	0x05
+
+/* -----  HCI Commands ---- */
+#define HCI_OP_INQUIRY			0x0401
+struct hci_cp_inquiry {
+	__u8 lap[3];
+	__u8 length;
+	__u8 num_rsp;
+} __attribute__ ((packed));
+
+#define HCI_OP_INQUIRY_CANCEL		0x0402
+
+#define HCI_OP_EXIT_PERIODIC_INQ	0x0404
+
+#define HCI_OP_CREATE_CONN		0x0405
+struct hci_cp_create_conn {
+	bdaddr_t bdaddr;
+	__le16 pkt_type;
+	__u8 pscan_rep_mode;
+	__u8 pscan_mode;
+	__le16 clock_offset;
+	__u8 role_switch;
+} __attribute__ ((packed));
+
+#define HCI_OP_DISCONNECT		0x0406
+struct hci_cp_disconnect {
+	__le16 handle;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_OP_DISCONNECT_LOGIC          0x043A
+struct hci_cp_discon_logic {
+	__le16 handle;
+};
+
+#define HCI_OP_ADD_SCO			0x0407
+struct hci_cp_add_sco {
+	__le16 handle;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_CREATE_CONN_CANCEL	0x0408
+struct hci_cp_create_conn_cancel {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_ACCEPT_CONN_REQ		0x0409
+struct hci_cp_accept_conn_req {
+	bdaddr_t bdaddr;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_OP_REJECT_CONN_REQ		0x040a
+struct hci_cp_reject_conn_req {
+	bdaddr_t bdaddr;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_OP_LINK_KEY_REPLY		0x040b
+struct hci_cp_link_key_reply {
+	bdaddr_t bdaddr;
+	__u8 link_key[16];
+} __attribute__ ((packed));
+
+#define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
+struct hci_cp_link_key_neg_reply {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_PIN_CODE_REPLY		0x040d
+struct hci_cp_pin_code_reply {
+	bdaddr_t bdaddr;
+	__u8 pin_len;
+	__u8 pin_code[16];
+} __attribute__ ((packed));
+
+#define HCI_OP_PIN_CODE_NEG_REPLY	0x040e
+struct hci_cp_pin_code_neg_reply {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_CHANGE_CONN_PTYPE	0x040f
+struct hci_cp_change_conn_ptype {
+	__le16 handle;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_AUTH_REQUESTED		0x0411
+struct hci_cp_auth_requested {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_SET_CONN_ENCRYPT		0x0413
+struct hci_cp_set_conn_encrypt {
+	__le16 handle;
+	__u8 encrypt;
+} __attribute__ ((packed));
+
+#define HCI_OP_CHANGE_CONN_LINK_KEY	0x0415
+struct hci_cp_change_conn_link_key {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_REMOTE_NAME_REQ		0x0419
+struct hci_cp_remote_name_req {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_mode;
+	__le16 clock_offset;
+} __attribute__ ((packed));
+
+#define HCI_OP_REMOTE_NAME_REQ_CANCEL	0x041a
+struct hci_cp_remote_name_req_cancel {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_REMOTE_FEATURES	0x041b
+struct hci_cp_read_remote_features {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_REMOTE_EXT_FEATURES	0x041c
+struct hci_cp_read_remote_ext_features {
+	__le16 handle;
+	__u8 page;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_REMOTE_VERSION	0x041d
+struct hci_cp_read_remote_version {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_SETUP_SYNC_CONN		0x0428
+struct hci_cp_setup_sync_conn {
+	__le16 handle;
+	__le32 tx_bandwidth;
+	__le32 rx_bandwidth;
+	__le16 max_latency;
+	__le16 voice_setting;
+	__u8 retrans_effort;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_ACCEPT_SYNC_CONN_REQ	0x0429
+struct hci_cp_accept_sync_conn_req {
+	bdaddr_t bdaddr;
+	__le32 tx_bandwidth;
+	__le32 rx_bandwidth;
+	__le16 max_latency;
+	__le16 content_format;
+	__u8 retrans_effort;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_REJECT_SYNC_CONN_REQ	0x042a
+struct hci_cp_reject_sync_conn_req {
+	bdaddr_t bdaddr;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_OP_SNIFF_MODE		0x0803
+struct hci_cp_sniff_mode {
+	__le16 handle;
+	__le16 max_interval;
+	__le16 min_interval;
+	__le16 attempt;
+	__le16 timeout;
+} __attribute__ ((packed));
+
+#define HCI_OP_EXIT_SNIFF_MODE		0x0804
+struct hci_cp_exit_sniff_mode {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_ROLE_DISCOVERY		0x0809
+struct hci_cp_role_discovery {
+	__le16 handle;
+} __attribute__ ((packed));
+struct hci_rp_role_discovery {
+	__u8 status;
+	__le16 handle;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_OP_SWITCH_ROLE		0x080b
+struct hci_cp_switch_role {
+	bdaddr_t bdaddr;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LINK_POLICY		0x080c
+struct hci_cp_read_link_policy {
+	__le16 handle;
+} __attribute__ ((packed));
+struct hci_rp_read_link_policy {
+	__u8 status;
+	__le16 handle;
+	__le16 policy;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_LINK_POLICY	0x080d
+struct hci_cp_write_link_policy {
+	__le16 handle;
+	__le16 policy;
+} __attribute__ ((packed));
+struct hci_rp_write_link_policy {
+	__u8 status;
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_DEF_LINK_POLICY	0x080e
+struct hci_rp_read_def_link_policy {
+	__u8 status;
+	__le16 policy;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_DEF_LINK_POLICY	0x080f
+struct hci_cp_write_def_link_policy {
+	__le16 policy;
+} __attribute__ ((packed));
+
+#define HCI_OP_SNIFF_SUBRATE		0x0811
+struct hci_cp_sniff_subrate {
+	__le16 handle;
+	__le16 max_latency;
+	__le16 min_remote_timeout;
+	__le16 min_local_timeout;
+} __attribute__ ((packed));
+
+#define HCI_OP_SET_EVENT_MASK		0x0c01
+struct hci_cp_set_event_mask {
+	__u8 mask[8];
+} __attribute__ ((packed));
+
+#define HCI_OP_RESET			0x0c03
+
+#define HCI_OP_SET_EVENT_FLT		0x0c05
+struct hci_cp_set_event_flt {
+	__u8 flt_type;
+	__u8 cond_type;
+	__u8 condition[];
+} __attribute__ ((packed));
+
+/* Filter types */
+#define HCI_FLT_CLEAR_ALL	0x00
+#define HCI_FLT_INQ_RESULT	0x01
+#define HCI_FLT_CONN_SETUP	0x02
+
+/* CONN_SETUP Condition types */
+#define HCI_CONN_SETUP_ALLOW_ALL	0x00
+#define HCI_CONN_SETUP_ALLOW_CLASS	0x01
+#define HCI_CONN_SETUP_ALLOW_BDADDR	0x02
+
+/* CONN_SETUP Conditions */
+#define HCI_CONN_SETUP_AUTO_OFF	0x01
+#define HCI_CONN_SETUP_AUTO_ON	0x02
+
+#define HCI_OP_WRITE_LOCAL_NAME		0x0c13
+struct hci_cp_write_local_name {
+	__u8 name[248];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_NAME		0x0c14
+struct hci_rp_read_local_name {
+	__u8 status;
+	__u8 name[248];
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_CA_TIMEOUT		0x0c16
+
+#define HCI_OP_WRITE_PG_TIMEOUT		0x0c18
+
+#define HCI_OP_WRITE_SCAN_ENABLE 	0x0c1a
+#define SCAN_DISABLED		0x00
+#define SCAN_INQUIRY		0x01
+#define SCAN_PAGE		0x02
+
+#define HCI_OP_READ_AUTH_ENABLE		0x0c1f
+
+#define HCI_OP_WRITE_AUTH_ENABLE	0x0c20
+#define AUTH_DISABLED		0x00
+#define AUTH_ENABLED		0x01
+
+#define HCI_OP_READ_ENCRYPT_MODE	0x0c21
+
+#define HCI_OP_WRITE_ENCRYPT_MODE	0x0c22
+#define ENCRYPT_DISABLED	0x00
+#define ENCRYPT_P2P		0x01
+#define ENCRYPT_BOTH		0x02
+
+#define HCI_OP_READ_CLASS_OF_DEV	0x0c23
+struct hci_rp_read_class_of_dev {
+	__u8 status;
+	__u8 dev_class[3];
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_CLASS_OF_DEV	0x0c24
+struct hci_cp_write_class_of_dev {
+	__u8 dev_class[3];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_VOICE_SETTING	0x0c25
+struct hci_rp_read_voice_setting {
+	__u8 status;
+	__le16 voice_setting;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_VOICE_SETTING	0x0c26
+struct hci_cp_write_voice_setting {
+	__le16 voice_setting;
+} __attribute__ ((packed));
+
+#define HCI_OP_HOST_BUFFER_SIZE		0x0c33
+struct hci_cp_host_buffer_size {
+	__le16 acl_mtu;
+	__u8 sco_mtu;
+	__le16 acl_max_pkt;
+	__le16 sco_max_pkt;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_SSP_MODE		0x0c55
+struct hci_rp_read_ssp_mode {
+	__u8 status;
+	__u8 mode;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_SSP_MODE		0x0c56
+struct hci_cp_write_ssp_mode {
+	__u8 mode;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_VERSION	0x1001
+struct hci_rp_read_local_version {
+	__u8 status;
+	__u8 hci_ver;
+	__le16 hci_rev;
+	__u8 lmp_ver;
+	__le16 manufacturer;
+	__le16 lmp_subver;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_COMMANDS	0x1002
+struct hci_rp_read_local_commands {
+	__u8 status;
+	__u8 commands[64];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_FEATURES	0x1003
+struct hci_rp_read_local_features {
+	__u8 status;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_EXT_FEATURES	0x1004
+struct hci_rp_read_local_ext_features {
+	__u8 status;
+	__u8 page;
+	__u8 max_page;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_BUFFER_SIZE		0x1005
+struct hci_rp_read_buffer_size {
+	__u8 status;
+	__le16 acl_mtu;
+	__u8 sco_mtu;
+	__le16 acl_max_pkt;
+	__le16 sco_max_pkt;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_BD_ADDR		0x1009
+struct hci_rp_read_bd_addr {
+	__u8 status;
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_FLOW_CONTROL_MODE  0x0c66
+struct hci_rp_read_flow_control_mode {
+	__u8 status;
+	__u8 flow_ctrl_mode;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_DATA_BLOCK_SIZE     0x100A
+struct hci_rp_read_data_block_size {
+	__u8 status;
+	__le16 max_acl_pkt_len;
+	__le16 data_block_size;
+	__le16 total_block_num;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_AMP_INFO	0x1409
+struct hci_rp_read_local_amp_info {
+	__u8 status;
+	__u8 amp_status;
+	__le32 total_bandwidth;
+	__le32 max_gt_bandwidth;
+	__le32 min_latency;
+	__le32 max_pdu_size;
+	__u8 controller_type;
+	__le16 pal_capabilities;
+	__le16 amp_assoc_length;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_AMP_ASSOC	0x140A
+struct hci_cp_read_local_amp_assoc {
+	__u8 handle;
+	__le16 length_so_far;
+} __attribute__ ((packed));
+
+struct hci_rp_read_local_amp_assoc {
+	__u8 status;
+	__u8 phy_hndl;
+	__le16 remaining_length;
+	__u8 amp_assoc_buf[248];
+} __attribute__ ((packed));
+
+struct hci_cp_write_local_amp_assoc {
+	__u8 phy_hndl;
+	__le16 length_so_far;
+	__le16 remaining_length;
+	__u8 amp_assoc_buf[248];
+} __attribute__ ((packed));
+
+struct hci_tlv_hdr {
+	__u8 id;
+	__le16 length;
+} __attribute__ ((packed));
+
+#define HCI_TLV_MAC_ADDRESS	0x01
+
+#define HCI_OP_READ_REG_DATA     0x0c64
+struct hci_rp_read_reg_data {
+	__u8 status;
+	__u8 reg_domain_aware;
+	__le16 country_code;
+	__u8 non_country_entity;
+	__u8 reg_options;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_REG_DATA     0x0c65
+struct hci_rp_write_reg_data {
+	__u8 status;
+} __attribute__ ((packed));
+
+struct hci_cp_write_reg_data {
+	__u8 reg_domain_aware;
+	__le16 country_code;
+	__u8 non_country_entity;
+	__u8 reg_options;
+} __attribute__ ((packed));
+
+/* ---- HCI Events ---- */
+#define HCI_EV_INQUIRY_COMPLETE		0x01
+
+#define HCI_EV_INQUIRY_RESULT		0x02
+struct inquiry_info {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 pscan_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+} __attribute__ ((packed));
+
+#define HCI_EV_CONN_COMPLETE		0x03
+struct hci_ev_conn_complete {
+	__u8 status;
+	__le16 handle;
+	bdaddr_t bdaddr;
+	__u8 link_type;
+	__u8 encr_mode;
+} __attribute__ ((packed));
+
+#define HCI_EV_CONN_REQUEST		0x04
+struct hci_ev_conn_request {
+	bdaddr_t bdaddr;
+	__u8 dev_class[3];
+	__u8 link_type;
+} __attribute__ ((packed));
+
+#define HCI_EV_DISCONN_COMPLETE		0x05
+struct hci_ev_disconn_complete {
+	__u8 status;
+	__le16 handle;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_EV_AUTH_COMPLETE		0x06
+struct hci_ev_auth_complete {
+	__u8 status;
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_NAME		0x07
+struct hci_ev_remote_name {
+	__u8 status;
+	bdaddr_t bdaddr;
+	__u8 name[248];
+} __attribute__ ((packed));
+
+#define HCI_EV_ENCRYPT_CHANGE		0x08
+struct hci_ev_encrypt_change {
+	__u8 status;
+	__le16 handle;
+	__u8 encrypt;
+} __attribute__ ((packed));
+
+#define HCI_EV_CHANGE_LINK_KEY_COMPLETE	0x09
+struct hci_ev_change_link_key_complete {
+	__u8 status;
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_FEATURES		0x0b
+struct hci_ev_remote_features {
+	__u8 status;
+	__le16 handle;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_VERSION		0x0c
+struct hci_ev_remote_version {
+	__u8 status;
+	__le16 handle;
+	__u8 lmp_ver;
+	__le16 manufacturer;
+	__le16 lmp_subver;
+} __attribute__ ((packed));
+
+#define HCI_EV_QOS_SETUP_COMPLETE	0x0d
+struct hci_qos {
+	__u8 service_type;
+	__u32 token_rate;
+	__u32 peak_bandwidth;
+	__u32 latency;
+	__u32 delay_variation;
+} __attribute__ ((packed));
+struct hci_ev_qos_setup_complete {
+	__u8 status;
+	__le16 handle;
+	struct hci_qos qos;
+} __attribute__ ((packed));
+
+#define HCI_EV_CMD_COMPLETE		0x0e
+struct hci_ev_cmd_complete {
+	__u8 ncmd;
+	__le16 opcode;
+} __attribute__ ((packed));
+
+#define HCI_EV_CMD_STATUS		0x0f
+struct hci_ev_cmd_status {
+	__u8 status;
+	__u8 ncmd;
+	__le16 opcode;
+} __attribute__ ((packed));
+
+#define HCI_EV_ROLE_CHANGE		0x12
+struct hci_ev_role_change {
+	__u8 status;
+	bdaddr_t bdaddr;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_EV_NUM_COMP_PKTS		0x13
+struct hci_ev_num_comp_pkts {
+	__u8 num_hndl;
+	/* variable length part */
+} __attribute__ ((packed));
+
+#define HCI_EV_MODE_CHANGE		0x14
+struct hci_ev_mode_change {
+	__u8 status;
+	__le16 handle;
+	__u8 mode;
+	__le16 interval;
+} __attribute__ ((packed));
+
+#define HCI_EV_PIN_CODE_REQ		0x16
+struct hci_ev_pin_code_req {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_EV_LINK_KEY_REQ		0x17
+struct hci_ev_link_key_req {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_EV_LINK_KEY_NOTIFY		0x18
+struct hci_ev_link_key_notify {
+	bdaddr_t bdaddr;
+	__u8 link_key[16];
+	__u8 key_type;
+} __attribute__ ((packed));
+
+#define HCI_EV_CLOCK_OFFSET		0x1c
+struct hci_ev_clock_offset {
+	__u8 status;
+	__le16 handle;
+	__le16 clock_offset;
+} __attribute__ ((packed));
+
+#define HCI_EV_PKT_TYPE_CHANGE		0x1d
+struct hci_ev_pkt_type_change {
+	__u8 status;
+	__le16 handle;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_EV_PSCAN_REP_MODE		0x20
+struct hci_ev_pscan_rep_mode {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+} __attribute__ ((packed));
+
+#define HCI_EV_INQUIRY_RESULT_WITH_RSSI	0x22
+struct inquiry_info_with_rssi {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+} __attribute__ ((packed));
+struct inquiry_info_with_rssi_and_pscan_mode {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 pscan_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_EXT_FEATURES	0x23
+struct hci_ev_remote_ext_features {
+	__u8 status;
+	__le16 handle;
+	__u8 page;
+	__u8 max_page;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_EV_SYNC_CONN_COMPLETE	0x2c
+struct hci_ev_sync_conn_complete {
+	__u8 status;
+	__le16 handle;
+	bdaddr_t bdaddr;
+	__u8 link_type;
+	__u8 tx_interval;
+	__u8 retrans_window;
+	__le16 rx_pkt_len;
+	__le16 tx_pkt_len;
+	__u8 air_mode;
+} __attribute__ ((packed));
+
+#define HCI_EV_SYNC_CONN_CHANGED	0x2d
+struct hci_ev_sync_conn_changed {
+	__u8 status;
+	__le16 handle;
+	__u8 tx_interval;
+	__u8 retrans_window;
+	__le16 rx_pkt_len;
+	__le16 tx_pkt_len;
+} __attribute__ ((packed));
+
+#define HCI_EV_SNIFF_SUBRATE		0x2e
+struct hci_ev_sniff_subrate {
+	__u8 status;
+	__le16 handle;
+	__le16 max_tx_latency;
+	__le16 max_rx_latency;
+	__le16 max_remote_timeout;
+	__le16 max_local_timeout;
+} __attribute__ ((packed));
+
+#define HCI_EV_EXTENDED_INQUIRY_RESULT	0x2f
+struct extended_inquiry_info {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+	__u8 data[240];
+} __attribute__ ((packed));
+
+#define HCI_EV_IO_CAPA_REQUEST		0x31
+struct hci_ev_io_capa_request {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_EV_SIMPLE_PAIR_COMPLETE	0x36
+struct hci_ev_simple_pair_complete {
+	__u8 status;
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_HOST_FEATURES	0x3d
+struct hci_ev_remote_host_features {
+	bdaddr_t bdaddr;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_EV_PHY_LINK_COMPLETE   0x40
+struct hci_ev_phy_link_complete {
+	__u8 status;
+	__u8 phy_hndl;
+} __attribute__ ((packed));
+
+#define HCI_EV_DISCONNECT_PHY_LINK 0x42
+struct hci_ev_disconnect_phy_link {
+	__u8 status;
+	__u8 phy_hndl;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_EV_LOGIC_LINK_COMPLETE   0x45
+struct hci_ev_logic_link_complete {
+	__u8 status;
+	__le16 logic_hndl;
+	__u8 phy_hndl;
+	__u8 tx_fspec_id;
+} __attribute__ ((packed));
+
+#define HCI_EV_DISCONNECT_LOGIC_LINK  0x46
+struct hci_ev_disconnct_logic_link {
+	__u8 status;
+	__le16 logic_hndl;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_EV_NUM_COMP_BLOCKS	0x48
+struct hci_ev_num_comp_blks {
+	__le16 total_blks;
+	__u8 num_hndl;
+	/* variable length part */
+} __attribute__ ((packed));
+
+/* Internal events generated by Bluetooth stack */
+#define HCI_EV_STACK_INTERNAL	0xfd
+struct hci_ev_stack_internal {
+	__u16 type;
+	__u8 data[];
+} __attribute__ ((packed));
+
+#define HCI_EV_SI_DEVICE	0x01
+struct hci_ev_si_device {
+	__u16 event;
+	__u16 dev_id;
+} __attribute__ ((packed));
+
+#define HCI_EV_SI_SECURITY	0x02
+struct hci_ev_si_security {
+	__u16 event;
+	__u16 proto;
+	__u16 subproto;
+	__u8 incoming;
+} __attribute__ ((packed));
+
+/* ---- HCI Packet structures ---- */
+#define HCI_COMMAND_HDR_SIZE 3
+#define HCI_EVENT_HDR_SIZE   2
+#define HCI_ACL_HDR_SIZE     4
+#define HCI_SCO_HDR_SIZE     3
+
+struct hci_command_hdr {
+	__le16 opcode;		/* OCF & OGF */
+	__u8 plen;
+} __attribute__ ((packed));
+
+struct hci_event_hdr {
+	__u8 evt;
+	__u8 plen;
+} __attribute__ ((packed));
+
+struct hci_acl_hdr {
+	__le16 handle;		/* Handle & Flags(PB, BC) */
+	__le16 dlen;
+} __attribute__ ((packed));
+
+struct hci_sco_hdr {
+	__le16 handle;
+	__u8 dlen;
+} __attribute__ ((packed));
+
+#ifdef __KERNEL__
+#include <linux/skbuff.h>
+static inline struct hci_event_hdr *
+hci_event_hdr(const struct sk_buff *skb)
+{
+	return (struct hci_event_hdr *)skb->data;
+}
+
+static inline struct hci_acl_hdr *
+hci_acl_hdr(const struct sk_buff *skb)
+{
+	return (struct hci_acl_hdr *)skb->data;
+}
+
+static inline struct hci_sco_hdr *
+hci_sco_hdr(const struct sk_buff *skb)
+{
+	return (struct hci_sco_hdr *)skb->data;
+}
+#endif
+
+/* Command opcode pack/unpack */
+#define hci_opcode_pack(ogf, ocf)	(__u16) ((ocf & 0x03ff)|(ogf << 10))
+#define hci_opcode_ogf(op)		(op >> 10)
+#define hci_opcode_ocf(op)		(op & 0x03ff)
+
+/* ACL handle and flags pack/unpack */
+#define hci_handle_pack(h, f)	(__u16) ((h & 0x0fff)|(f << 12))
+#define hci_handle(h)		(h & 0x0fff)
+#define hci_flags(h)		(h >> 12)
+
+/* ---- HCI Sockets ---- */
+
+/* Socket options */
+#define HCI_DATA_DIR	1
+#define HCI_FILTER	2
+#define HCI_TIME_STAMP	3
+
+/* CMSG flags */
+#define HCI_CMSG_DIR	0x0001
+#define HCI_CMSG_TSTAMP	0x0002
+
+struct sockaddr_hci {
+	sa_family_t hci_family;
+	unsigned short hci_dev;
+};
+#define HCI_DEV_NONE	0xffff
+
+struct hci_filter {
+	unsigned long type_mask;
+	unsigned long event_mask[2];
+	__le16 opcode;
+};
+
+struct hci_ufilter {
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__le16 opcode;
+};
+
+#define HCI_FLT_TYPE_BITS	31
+#define HCI_FLT_EVENT_BITS	63
+#define HCI_FLT_OGF_BITS	63
+#define HCI_FLT_OCF_BITS	127
+
+/* ---- HCI Ioctl requests structures ---- */
+struct hci_dev_stats {
+	__u32 err_rx;
+	__u32 err_tx;
+	__u32 cmd_tx;
+	__u32 evt_rx;
+	__u32 acl_tx;
+	__u32 acl_rx;
+	__u32 sco_tx;
+	__u32 sco_rx;
+	__u32 byte_rx;
+	__u32 byte_tx;
+};
+
+struct hci_dev_info {
+	__u16 dev_id;
+	char name[8];
+
+	bdaddr_t bdaddr;
+
+	__u32 flags;
+	__u8 type;
+
+	__u8 features[8];
+
+	__u32 pkt_type;
+	__u32 link_policy;
+	__u32 link_mode;
+
+	__u16 acl_mtu;
+	__u16 acl_pkts;
+	__u16 sco_mtu;
+	__u16 sco_pkts;
+
+	struct hci_dev_stats stat;
+};
+
+struct hci_conn_info {
+	__u16 handle;
+	bdaddr_t bdaddr;
+	__u8 type;
+	__u8 out;
+	__u16 state;
+	__u32 link_mode;
+};
+
+struct hci_dev_req {
+	__u16 dev_id;
+	__u32 dev_opt;
+};
+
+struct hci_dev_list_req {
+	__u16 dev_num;
+	struct hci_dev_req dev_req[];	/* hci_dev_req structures */
+};
+
+struct hci_conn_list_req {
+	__u16 dev_id;
+	__u16 conn_num;
+	struct hci_conn_info conn_info[];
+};
+
+struct hci_conn_info_req {
+	bdaddr_t bdaddr;
+	__u8 type;
+	struct hci_conn_info conn_info[];
+};
+
+struct hci_auth_info_req {
+	bdaddr_t bdaddr;
+	__u8 type;
+};
+
+struct hci_inquiry_req {
+	__u16 dev_id;
+	__u16 flags;
+	__u8 lap[3];
+	__u8 length;
+	__u8 num_rsp;
+};
+#define IREQ_CACHE_FLUSH 0x0001
+
+struct hci_amp_info {
+	__u16 dev_id;
+	__u8 status;
+	__u8 amp_status;
+	__u32 total_bandwidth;
+	__u32 max_gt_bandwidth;
+	__u32 min_latency;
+	__u32 max_pdu_size;
+	__u8 controller_type;
+	__u16 pal_capabilities;
+	__u16 amp_assoc_length;
+	__u16 max_flush_tmout;
+	__u16 best_effort_flush_tmout;
+} __attribute__ ((packed));
+
+struct hci_amp_assoc {
+	__u16 dev_id;
+	__u16 length_so_far;
+	__u8 handle;
+	__u8 status;
+	__u16 remaining_length;
+	__u8 amp_assoc_buf[248];
+} __attribute__ ((packed));
+
+struct hci_reg_data {
+	__u16 dev_id;
+	__u8 status;
+	__u8 reg_domain_aware;
+	__u16 country_code;
+	__u8 non_country_entity;
+	__u8 reg_options;
+} __attribute__ ((packed));
+#endif /* __HCI_H */
diff --git a/88x9098/bt/muart_src/include/amp/bluetooth/hci_core.h b/88x9098/bt/muart_src/include/amp/bluetooth/hci_core.h
new file mode 100644
index 0000000..13c4660
--- /dev/null
+++ b/88x9098/bt/muart_src/include/amp/bluetooth/hci_core.h
@@ -0,0 +1,718 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_CORE_H
+#define __HCI_CORE_H
+
+#include <amp/bluetooth/hci.h>
+
+/* HCI upper protocols */
+#define HCI_PROTO_L2CAP	0
+#define HCI_PROTO_SCO	1
+
+/* HCI Core structures */
+struct inquiry_data {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 pscan_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+	__u8 ssp_mode;
+};
+
+struct inquiry_entry {
+	struct inquiry_entry *next;
+	__u32 timestamp;
+	struct inquiry_data data;
+};
+
+struct inquiry_cache {
+	spinlock_t lock;
+	__u32 timestamp;
+	struct inquiry_entry *list;
+};
+
+struct hci_conn_hash {
+	struct list_head list;
+	spinlock_t lock;
+	unsigned int acl_num;
+	unsigned int sco_num;
+};
+
+struct hci_dev {
+	struct list_head list;
+	spinlock_t lock;
+	atomic_t refcnt;
+
+	char name[8];
+	unsigned long flags;
+	__u16 id;
+	__u8 type;
+	bdaddr_t bdaddr;
+	__u8 dev_name[248];
+	__u8 dev_class[3];
+	__u8 features[8];
+	__u8 commands[64];
+	__u8 ssp_mode;
+	__u8 hci_ver;
+	__u16 hci_rev;
+	__u16 manufacturer;
+	__u16 voice_setting;
+
+	__u16 pkt_type;
+	__u16 esco_type;
+	__u16 link_policy;
+	__u16 link_mode;
+
+	__u32 idle_timeout;
+	__u16 sniff_min_interval;
+	__u16 sniff_max_interval;
+
+	unsigned long quirks;
+
+	atomic_t cmd_cnt;
+	unsigned int acl_cnt;
+	unsigned int sco_cnt;
+
+	unsigned int acl_mtu;
+	unsigned int sco_mtu;
+	unsigned int acl_pkts;
+	unsigned int sco_pkts;
+
+	unsigned long cmd_last_tx;
+	unsigned long acl_last_tx;
+	unsigned long sco_last_tx;
+
+	struct tasklet_struct cmd_task;
+	struct tasklet_struct rx_task;
+	struct tasklet_struct tx_task;
+
+	struct sk_buff_head rx_q;
+	struct sk_buff_head raw_q;
+	struct sk_buff_head cmd_q;
+
+	struct sk_buff *sent_cmd;
+	struct sk_buff *reassembly[3];
+
+	struct semaphore req_lock;
+	wait_queue_head_t req_wait_q;
+	__u32 req_status;
+	__u32 req_result;
+
+	struct inquiry_cache inq_cache;
+	struct hci_conn_hash conn_hash;
+
+	struct hci_dev_stats stat;
+
+	struct sk_buff_head driver_init;
+
+	void *driver_data;
+	void *core_data;
+
+	atomic_t promisc;
+
+	struct device *parent;
+	struct device dev;
+
+	struct module *owner;
+
+	int (*open) (struct hci_dev * hdev);
+	int (*close) (struct hci_dev * hdev);
+	int (*flush) (struct hci_dev * hdev);
+	int (*send) (struct sk_buff * skb);
+	void (*destruct) (struct hci_dev * hdev);
+	void (*notify) (struct hci_dev * hdev, unsigned int evt);
+	int (*ioctl) (struct hci_dev * hdev, unsigned int cmd,
+		      unsigned long arg);
+	__u8 flow_ctrl_mode;
+	__u16 data_block_size;
+	__u16 total_block_num;
+	__u16 block_cnt;
+	u8 *cmd_resp_buf;
+	__u16 cmd_len;
+	bdaddr_t dst;
+};
+
+struct hci_conn {
+	struct list_head list;
+
+	atomic_t refcnt;
+	spinlock_t lock;
+
+	bdaddr_t dst;
+	__u16 handle;
+	__u16 state;
+	__u8 mode;
+	__u8 type;
+	__u8 out;
+	__u8 attempt;
+	__u8 dev_class[3];
+	__u8 features[8];
+	__u8 ssp_mode;
+	__u16 interval;
+	__u16 pkt_type;
+	__u16 link_policy;
+	__u32 link_mode;
+	__u8 auth_type;
+	__u8 power_save;
+	__u8 phy_handle;
+	unsigned long pend;
+
+	unsigned int sent;
+
+	struct sk_buff_head data_q;
+
+	struct timer_list disc_timer;
+	struct timer_list idle_timer;
+
+	struct work_struct work;
+
+	struct device dev;
+
+	struct hci_dev *hdev;
+	void *l2cap_data;
+	void *sco_data;
+	void *priv;
+
+	struct hci_conn *link;
+};
+
+extern struct hci_proto *hci_proto[];
+extern struct list_head hci_dev_list;
+extern struct list_head hci_cb_list;
+extern rwlock_t hci_dev_list_lock;
+extern rwlock_t hci_cb_list_lock;
+
+/* ----- Inquiry cache ----- */
+#define INQUIRY_CACHE_AGE_MAX   (HZ*30)	// 30 seconds
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)	// 60 seconds
+
+#define inquiry_cache_lock(c)		spin_lock(&c->lock)
+#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
+#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
+#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
+
+static inline void
+inquiry_cache_init(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	spin_lock_init(&c->lock);
+	c->list = NULL;
+}
+
+static inline int
+inquiry_cache_empty(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return (c->list == NULL);
+}
+
+static inline long
+inquiry_cache_age(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return jiffies - c->timestamp;
+}
+
+static inline long
+inquiry_entry_age(struct inquiry_entry *e)
+{
+	return jiffies - e->timestamp;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
+					       bdaddr_t * bdaddr);
+void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
+
+/* ----- HCI Connections ----- */
+enum {
+	HCI_CONN_AUTH_PEND,
+	HCI_CONN_ENCRYPT_PEND,
+	HCI_CONN_RSWITCH_PEND,
+	HCI_CONN_MODE_CHANGE_PEND,
+};
+
+static inline void
+hci_conn_hash_init(struct hci_dev *hdev)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
+	h->acl_num = 0;
+	h->sco_num = 0;
+}
+
+static inline void
+hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	list_add(&c->list, &h->list);
+	if (c->type == ACL_LINK)
+		h->acl_num++;
+	else
+		h->sco_num++;
+}
+
+static inline void
+hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	list_del(&c->list);
+	if (c->type == ACL_LINK)
+		h->acl_num--;
+	else
+		h->sco_num--;
+}
+
+static inline struct hci_conn *
+hci_conn_hash_lookup_handle(struct hci_dev *hdev, __u16 handle)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if ((c->handle == handle) || (c->phy_handle == handle))
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_conn *
+hci_conn_hash_lookup_ba(struct hci_dev *hdev, __u8 type, bdaddr_t * ba)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && !bacmp(&c->dst, ba))
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_conn *
+hci_conn_hash_lookup_state(struct hci_dev *hdev, __u8 type, __u16 state)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && c->state == state)
+			return c;
+	}
+	return NULL;
+}
+
+void hci_acl_connect(struct hci_conn *conn);
+void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
+void hci_add_sco(struct hci_conn *conn, __u16 handle);
+void hci_setup_sync(struct hci_conn *conn, __u16 handle);
+
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t * dst);
+int hci_conn_del(struct hci_conn *conn);
+void hci_conn_hash_flush(struct hci_dev *hdev);
+void hci_conn_check_pending(struct hci_dev *hdev);
+
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t * dst,
+			     __u8 auth_type);
+int hci_conn_check_link_mode(struct hci_conn *conn);
+int hci_conn_auth(struct hci_conn *conn);
+int hci_conn_encrypt(struct hci_conn *conn);
+int hci_conn_change_link_key(struct hci_conn *conn);
+int hci_conn_switch_role(struct hci_conn *conn, uint8_t role);
+
+void hci_conn_enter_active_mode(struct hci_conn *conn);
+void hci_conn_enter_sniff_mode(struct hci_conn *conn);
+void hci_logy_disconn(struct hci_conn *conn);
+
+static inline void
+hci_conn_hold(struct hci_conn *conn)
+{
+	atomic_inc(&conn->refcnt);
+	del_timer(&conn->disc_timer);
+}
+
+static inline void
+hci_conn_put(struct hci_conn *conn)
+{
+	if (atomic_dec_and_test(&conn->refcnt)) {
+		unsigned long timeo;
+		if (conn->type == ACL_LINK) {
+			del_timer(&conn->idle_timer);
+			if (conn->state == BT_CONNECTED) {
+				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
+				if (!conn->out)
+					timeo *= 2;
+			} else
+				timeo = msecs_to_jiffies(10);
+		} else
+			timeo = msecs_to_jiffies(10);
+		mod_timer(&conn->disc_timer, jiffies + timeo);
+	}
+}
+
+/* ----- HCI tasks ----- */
+static inline void
+hci_sched_cmd(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->cmd_task);
+}
+
+static inline void
+hci_sched_rx(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->rx_task);
+}
+
+static inline void
+hci_sched_tx(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->tx_task);
+}
+
+/* ----- HCI Devices ----- */
+static inline void
+__hci_dev_put(struct hci_dev *d)
+{
+	if (atomic_dec_and_test(&d->refcnt))
+		d->destruct(d);
+}
+
+static inline void
+hci_dev_put(struct hci_dev *d)
+{
+	__hci_dev_put(d);
+	module_put(d->owner);
+}
+
+static inline struct hci_dev *
+__hci_dev_hold(struct hci_dev *d)
+{
+	atomic_inc(&d->refcnt);
+	return d;
+}
+
+static inline struct hci_dev *
+hci_dev_hold(struct hci_dev *d)
+{
+	if (try_module_get(d->owner))
+		return __hci_dev_hold(d);
+	return NULL;
+}
+
+#define hci_dev_lock(d)		spin_lock(&d->lock)
+#define hci_dev_unlock(d)	spin_unlock(&d->lock)
+#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
+#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
+
+struct hci_dev *hci_dev_get(int index);
+struct hci_dev *hci_get_route(bdaddr_t * src, bdaddr_t * dst);
+
+struct hci_dev *hci_alloc_dev(void);
+void hci_free_dev(struct hci_dev *hdev);
+int hci_register_dev(struct hci_dev *hdev);
+int hci_unregister_dev(struct hci_dev *hdev);
+int hci_suspend_dev(struct hci_dev *hdev);
+int hci_resume_dev(struct hci_dev *hdev);
+int hci_dev_open(__u16 dev);
+int hci_dev_close(__u16 dev);
+int hci_dev_reset(__u16 dev);
+int hci_dev_reset_stat(__u16 dev);
+int hci_dev_cmd(unsigned int cmd, void __user * arg);
+int hci_get_dev_list(void __user * arg);
+int hci_get_dev_info(void __user * arg);
+int hci_get_conn_list(void __user * arg);
+int hci_get_conn_info(struct hci_dev *hdev, void __user * arg);
+int hci_get_auth_info(struct hci_dev *hdev, void __user * arg);
+int hci_inquiry(void __user * arg);
+int hci_get_amp_info(void __user * arg);
+int hci_get_amp_assoc(void __user * arg);
+int hci_get_reg_data(void __user * arg);
+int hci_set_reg_data(void __user * arg);
+
+void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
+
+/* Receive frame from HCI drivers */
+static inline int
+hci_recv_frame(struct sk_buff *skb)
+{
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+	if (!hdev || (!test_bit(HCI_UP, &hdev->flags)
+		      && !test_bit(HCI_INIT, &hdev->flags))) {
+		kfree_skb(skb);
+		return -ENXIO;
+	}
+
+	/* Incomming skb */
+	bt_cb(skb)->incoming = 1;
+
+	/* Time stamp */
+	__net_timestamp(skb);
+
+	/* Queue frame for rx task */
+	skb_queue_tail(&hdev->rx_q, skb);
+	hci_sched_rx(hdev);
+	return 0;
+}
+
+int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
+
+int hci_register_sysfs(struct hci_dev *hdev);
+void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_conn_add_sysfs(struct hci_conn *conn);
+void hci_conn_del_sysfs(struct hci_conn *conn);
+
+#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
+
+/* ----- LMP capabilities ----- */
+#define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)
+#define lmp_encrypt_capable(dev)   ((dev)->features[0] & LMP_ENCRYPT)
+#define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
+#define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
+#define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
+#define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
+
+/* ----- HCI protocols ----- */
+struct hci_proto {
+	char *name;
+	unsigned int id;
+	unsigned long flags;
+
+	void *priv;
+
+	int (*connect_ind) (struct hci_dev * hdev, bdaddr_t * bdaddr,
+			    __u8 type);
+	int (*connect_cfm) (struct hci_conn * conn, __u8 status);
+	int (*disconn_ind) (struct hci_conn * conn, __u8 reason);
+	int (*recv_acldata) (struct hci_conn * conn, struct sk_buff * skb,
+			     __u16 flags);
+	int (*recv_scodata) (struct hci_conn * conn, struct sk_buff * skb);
+	int (*auth_cfm) (struct hci_conn * conn, __u8 status);
+	int (*encrypt_cfm) (struct hci_conn * conn, __u8 status, __u8 encrypt);
+};
+
+static inline int
+hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t * bdaddr, __u8 type)
+{
+	register struct hci_proto *hp;
+	int mask = 0;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	return mask;
+}
+
+static inline void
+hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
+}
+
+static inline void
+hci_proto_disconn_ind(struct hci_conn *conn, __u8 reason)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_ind)
+		hp->disconn_ind(conn, reason);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_ind)
+		hp->disconn_ind(conn, reason);
+}
+
+static inline void
+hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->auth_cfm)
+		hp->auth_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->auth_cfm)
+		hp->auth_cfm(conn, status);
+}
+
+static inline void
+hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->encrypt_cfm)
+		hp->encrypt_cfm(conn, status, encrypt);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->encrypt_cfm)
+		hp->encrypt_cfm(conn, status, encrypt);
+}
+
+int hci_register_proto(struct hci_proto *hproto);
+int hci_unregister_proto(struct hci_proto *hproto);
+
+/* ----- HCI callbacks ----- */
+struct hci_cb {
+	struct list_head list;
+
+	char *name;
+
+	void (*auth_cfm) (struct hci_conn * conn, __u8 status);
+	void (*encrypt_cfm) (struct hci_conn * conn, __u8 status, __u8 encrypt);
+	void (*key_change_cfm) (struct hci_conn * conn, __u8 status);
+	void (*role_switch_cfm) (struct hci_conn * conn, __u8 status,
+				 __u8 role);
+};
+
+static inline void
+hci_auth_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct list_head *p;
+
+	hci_proto_auth_cfm(conn, status);
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->auth_cfm)
+			cb->auth_cfm(conn, status);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void
+hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+{
+	struct list_head *p;
+
+	hci_proto_encrypt_cfm(conn, status, encrypt);
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->encrypt_cfm)
+			cb->encrypt_cfm(conn, status, encrypt);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void
+hci_key_change_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct list_head *p;
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->key_change_cfm)
+			cb->key_change_cfm(conn, status);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void
+hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
+{
+	struct list_head *p;
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->role_switch_cfm)
+			cb->role_switch_cfm(conn, status, role);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+int hci_register_cb(struct hci_cb *hcb);
+int hci_unregister_cb(struct hci_cb *hcb);
+
+int hci_register_notifier(struct notifier_block *nb);
+int hci_unregister_notifier(struct notifier_block *nb);
+
+int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
+int hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+int hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
+
+void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
+
+void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
+
+/* ----- HCI Sockets ----- */
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+
+/* HCI info for socket */
+#define hci_pi(sk) ((struct hci_pinfo *) sk)
+
+struct hci_pinfo {
+	struct bt_sock bt;
+	struct hci_dev *hdev;
+	struct hci_filter filter;
+	__u32 cmsg_mask;
+};
+
+/* HCI security filter */
+#define HCI_SFLT_MAX_OGF  5
+
+struct hci_sec_filter {
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
+};
+
+/* ----- HCI requests ----- */
+#define HCI_REQ_DONE	  0
+#define HCI_REQ_PEND	  1
+#define HCI_REQ_CANCELED  2
+
+#define hci_req_lock(d)		down(&d->req_lock)
+#define hci_req_unlock(d)	up(&d->req_lock)
+
+void hci_req_complete(struct hci_dev *hdev, int result);
+
+#endif /* __HCI_CORE_H */
diff --git a/88x9098/bt/muart_src/include/bluetooth.h b/88x9098/bt/muart_src/include/bluetooth.h
new file mode 100644
index 0000000..3a786ac
--- /dev/null
+++ b/88x9098/bt/muart_src/include/bluetooth.h
@@ -0,0 +1,187 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __BLUETOOTH_H
+#define __BLUETOOTH_H
+
+#include <asm/types.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+#include <linux/poll.h>
+#include <net/sock.h>
+
+#ifndef AF_BLUETOOTH
+#define AF_BLUETOOTH	31
+#define PF_BLUETOOTH	AF_BLUETOOTH
+#endif
+
+/* Reserv for core and drivers use */
+#define BT_SKB_RESERVE	8
+
+#define BTPROTO_L2CAP	0
+#define BTPROTO_HCI	1
+#define BTPROTO_SCO	2
+#define BTPROTO_RFCOMM	3
+#define BTPROTO_BNEP	4
+#define BTPROTO_CMTP	5
+#define BTPROTO_HIDP	6
+#define BTPROTO_AVDTP	7
+
+#define SOL_HCI		0
+#define SOL_L2CAP	6
+#define SOL_SCO		17
+#define SOL_RFCOMM	18
+
+#define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
+#define BT_DBG(fmt, arg...)  printk(KERN_INFO "%s: " fmt "\n" , __FUNCTION__ , ## arg)
+#define BT_ERR(fmt, arg...)  printk(KERN_ERR  "%s: " fmt "\n" , __FUNCTION__ , ## arg)
+
+/* Connection and socket states */
+enum {
+	BT_CONNECTED = 1,	/* Equal to TCP_ESTABLISHED to make net code
+				   happy */
+	BT_OPEN,
+	BT_BOUND,
+	BT_LISTEN,
+	BT_CONNECT,
+	BT_CONNECT2,
+	BT_CONFIG,
+	BT_DISCONN,
+	BT_CLOSED
+};
+
+/* Endianness conversions */
+#define htobs(a)	__cpu_to_le16(a)
+#define htobl(a)	__cpu_to_le32(a)
+#define btohs(a)	__le16_to_cpu(a)
+#define btohl(a)	__le32_to_cpu(a)
+
+/* BD Address */
+typedef struct {
+	__u8 b[6];
+} __attribute__ ((packed)) bdaddr_t;
+
+#define BDADDR_ANY   (&(bdaddr_t) {{0, 0, 0, 0, 0, 0}})
+#define BDADDR_LOCAL (&(bdaddr_t) {{0, 0, 0, 0xff, 0xff, 0xff}})
+
+/* Copy, swap, convert BD Address */
+static inline int
+bacmp(bdaddr_t * ba1, bdaddr_t * ba2)
+{
+	return memcmp(ba1, ba2, sizeof(bdaddr_t));
+}
+
+static inline void
+bacpy(bdaddr_t * dst, bdaddr_t * src)
+{
+	memcpy(dst, src, sizeof(bdaddr_t));
+}
+
+void baswap(bdaddr_t * dst, bdaddr_t * src);
+char *batostr(bdaddr_t * ba);
+bdaddr_t *strtoba(char *str);
+
+/* Common socket structures and functions */
+
+#define bt_sk(__sk) ((struct bt_sock *) __sk)
+
+struct bt_sock {
+	struct sock sk;
+	bdaddr_t src;
+	bdaddr_t dst;
+	struct list_head accept_q;
+	struct sock *parent;
+};
+
+struct bt_sock_list {
+	struct hlist_head head;
+	rwlock_t lock;
+};
+
+int bt_sock_register(int proto, struct net_proto_family *ops);
+int bt_sock_unregister(int proto);
+void bt_sock_link(struct bt_sock_list *l, struct sock *s);
+void bt_sock_unlink(struct bt_sock_list *l, struct sock *s);
+int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
+		    size_t len, int flags);
+uint bt_sock_poll(struct file *file, struct socket *sock, poll_table * wait);
+int bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
+
+void bt_accept_enqueue(struct sock *parent, struct sock *sk);
+void bt_accept_unlink(struct sock *sk);
+struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);
+
+/* Skb helpers */
+struct bt_skb_cb {
+	__u8 pkt_type;
+	__u8 incoming;
+};
+#define bt_cb(skb) ((struct bt_skb_cb *)(skb->cb))
+
+static inline struct sk_buff *
+bt_skb_alloc(unsigned int len, gfp_t how)
+{
+	struct sk_buff *skb;
+
+	if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
+		skb_reserve(skb, BT_SKB_RESERVE);
+		bt_cb(skb)->incoming = 0;
+	}
+	return skb;
+}
+
+static inline struct sk_buff *
+bt_skb_send_alloc(struct sock *sk, unsigned long len, int nb, int *err)
+{
+	struct sk_buff *skb;
+
+	if ((skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err))) {
+		skb_reserve(skb, BT_SKB_RESERVE);
+		bt_cb(skb)->incoming = 0;
+	}
+
+	return skb;
+}
+
+static inline int
+skb_frags_no(struct sk_buff *skb)
+{
+	register struct sk_buff *frag = skb_shinfo(skb)->frag_list;
+	register int n = 1;
+
+	for (; frag; frag = frag->next, n++) ;
+	return n;
+}
+
+int bt_err(__u16 code);
+
+extern int hci_sock_init(void);
+extern int hci_sock_cleanup(void);
+
+extern int bt_sysfs_init(void);
+extern void bt_sysfs_cleanup(void);
+
+extern struct class *bt_class;
+
+#endif /* __BLUETOOTH_H */
diff --git a/88x9098/bt/muart_src/include/hci.h b/88x9098/bt/muart_src/include/hci.h
new file mode 100644
index 0000000..d4c32bf
--- /dev/null
+++ b/88x9098/bt/muart_src/include/hci.h
@@ -0,0 +1,969 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_H
+#define __HCI_H
+
+#define HCI_MAX_ACL_SIZE	1024
+#define HCI_MAX_SCO_SIZE	255
+#define HCI_MAX_EVENT_SIZE	260
+#define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
+
+/* HCI dev events */
+#define HCI_DEV_REG			1
+#define HCI_DEV_UNREG			2
+#define HCI_DEV_UP			3
+#define HCI_DEV_DOWN			4
+#define HCI_DEV_SUSPEND			5
+#define HCI_DEV_RESUME			6
+
+/* HCI notify events */
+#define HCI_NOTIFY_CONN_ADD		1
+#define HCI_NOTIFY_CONN_DEL		2
+#define HCI_NOTIFY_VOICE_SETTING	3
+
+/* HCI device types */
+#define HCI_VIRTUAL	0
+#define HCI_USB		1
+#define HCI_PCCARD	2
+#define HCI_UART	3
+#define HCI_RS232	4
+#define HCI_PCI		5
+#define HCI_SDIO	6
+
+/* HCI device quirks */
+enum {
+	HCI_QUIRK_RESET_ON_INIT,
+	HCI_QUIRK_RAW_DEVICE,
+	HCI_QUIRK_FIXUP_BUFFER_SIZE
+};
+
+/* HCI device flags */
+enum {
+	HCI_UP,
+	HCI_INIT,
+	HCI_RUNNING,
+
+	HCI_PSCAN,
+	HCI_ISCAN,
+	HCI_AUTH,
+	HCI_ENCRYPT,
+	HCI_INQUIRY,
+
+	HCI_RAW,
+
+	HCI_SECMGR
+};
+
+/* HCI ioctl defines */
+#define HCIDEVUP	_IOW('H', 201, int)
+#define HCIDEVDOWN	_IOW('H', 202, int)
+#define HCIDEVRESET	_IOW('H', 203, int)
+#define HCIDEVRESTAT	_IOW('H', 204, int)
+
+#define HCIGETDEVLIST	_IOR('H', 210, int)
+#define HCIGETDEVINFO	_IOR('H', 211, int)
+#define HCIGETCONNLIST	_IOR('H', 212, int)
+#define HCIGETCONNINFO	_IOR('H', 213, int)
+
+#define HCIHOLDCONN	_IOR('H', 214, int)
+#define HCIPUTCONN	_IOR('H', 215, int)
+
+#define HCISETRAW	_IOW('H', 220, int)
+#define HCISETSCAN	_IOW('H', 221, int)
+#define HCISETAUTH	_IOW('H', 222, int)
+#define HCISETENCRYPT	_IOW('H', 223, int)
+#define HCISETPTYPE	_IOW('H', 224, int)
+#define HCISETLINKPOL	_IOW('H', 225, int)
+#define HCISETLINKMODE	_IOW('H', 226, int)
+#define HCISETACLMTU	_IOW('H', 227, int)
+#define HCISETSCOMTU	_IOW('H', 228, int)
+
+#define HCISETSECMGR	_IOW('H', 230, int)
+
+#define HCIINQUIRY	_IOR('H', 240, int)
+
+/* HCI timeouts */
+#define HCI_CONNECT_TIMEOUT	(40000)	/* 40 seconds */
+#define HCI_DISCONN_TIMEOUT	(20000)	/* 20 seconds */
+#define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
+#define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
+
+/* HCI data types */
+#define HCI_COMMAND_PKT		0x01
+#define HCI_ACLDATA_PKT		0x02
+#define HCI_SCODATA_PKT		0x03
+#define HCI_EVENT_PKT		0x04
+#define HCI_VENDOR_PKT		0xff
+
+/* HCI packet types */
+#define HCI_DM1		0x0008
+#define HCI_DM3		0x0400
+#define HCI_DM5		0x4000
+#define HCI_DH1		0x0010
+#define HCI_DH3		0x0800
+#define HCI_DH5		0x8000
+
+#define HCI_HV1		0x0020
+#define HCI_HV2		0x0040
+#define HCI_HV3		0x0080
+
+#define SCO_PTYPE_MASK	(HCI_HV1 | HCI_HV2 | HCI_HV3)
+#define ACL_PTYPE_MASK	(~SCO_PTYPE_MASK)
+
+/* eSCO packet types */
+#define ESCO_HV1	0x0001
+#define ESCO_HV2	0x0002
+#define ESCO_HV3	0x0004
+#define ESCO_EV3	0x0008
+#define ESCO_EV4	0x0010
+#define ESCO_EV5	0x0020
+
+/* ACL flags */
+#define ACL_CONT		0x01
+#define ACL_START		0x02
+#define ACL_ACTIVE_BCAST	0x04
+#define ACL_PICO_BCAST		0x08
+
+/* Baseband links */
+#define SCO_LINK	0x00
+#define ACL_LINK	0x01
+#define ESCO_LINK	0x02
+
+/* LMP features */
+#define LMP_3SLOT	0x01
+#define LMP_5SLOT	0x02
+#define LMP_ENCRYPT	0x04
+#define LMP_SOFFSET	0x08
+#define LMP_TACCURACY	0x10
+#define LMP_RSWITCH	0x20
+#define LMP_HOLD	0x40
+#define LMP_SNIFF	0x80
+
+#define LMP_PARK	0x01
+#define LMP_RSSI	0x02
+#define LMP_QUALITY	0x04
+#define LMP_SCO		0x08
+#define LMP_HV2		0x10
+#define LMP_HV3		0x20
+#define LMP_ULAW	0x40
+#define LMP_ALAW	0x80
+
+#define LMP_CVSD	0x01
+#define LMP_PSCHEME	0x02
+#define LMP_PCONTROL	0x04
+
+#define LMP_ESCO	0x80
+
+#define LMP_EV4		0x01
+#define LMP_EV5		0x02
+
+#define LMP_SNIFF_SUBR	0x02
+
+/* Connection modes */
+#define HCI_CM_ACTIVE	0x0000
+#define HCI_CM_HOLD	0x0001
+#define HCI_CM_SNIFF	0x0002
+#define HCI_CM_PARK	0x0003
+
+/* Link policies */
+#define HCI_LP_RSWITCH	0x0001
+#define HCI_LP_HOLD	0x0002
+#define HCI_LP_SNIFF	0x0004
+#define HCI_LP_PARK	0x0008
+
+/* Link modes */
+#define HCI_LM_ACCEPT	0x8000
+#define HCI_LM_MASTER	0x0001
+#define HCI_LM_AUTH	0x0002
+#define HCI_LM_ENCRYPT	0x0004
+#define HCI_LM_TRUSTED	0x0008
+#define HCI_LM_RELIABLE	0x0010
+#define HCI_LM_SECURE	0x0020
+
+/* -----  HCI Commands ---- */
+#define HCI_OP_INQUIRY			0x0401
+struct hci_cp_inquiry {
+	__u8 lap[3];
+	__u8 length;
+	__u8 num_rsp;
+} __attribute__ ((packed));
+
+#define HCI_OP_INQUIRY_CANCEL		0x0402
+
+#define HCI_OP_EXIT_PERIODIC_INQ	0x0404
+
+#define HCI_OP_CREATE_CONN		0x0405
+struct hci_cp_create_conn {
+	bdaddr_t bdaddr;
+	__le16 pkt_type;
+	__u8 pscan_rep_mode;
+	__u8 pscan_mode;
+	__le16 clock_offset;
+	__u8 role_switch;
+} __attribute__ ((packed));
+
+#define HCI_OP_DISCONNECT		0x0406
+struct hci_cp_disconnect {
+	__le16 handle;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_OP_ADD_SCO			0x0407
+struct hci_cp_add_sco {
+	__le16 handle;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_CREATE_CONN_CANCEL	0x0408
+struct hci_cp_create_conn_cancel {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_ACCEPT_CONN_REQ		0x0409
+struct hci_cp_accept_conn_req {
+	bdaddr_t bdaddr;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_OP_REJECT_CONN_REQ		0x040a
+struct hci_cp_reject_conn_req {
+	bdaddr_t bdaddr;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_OP_LINK_KEY_REPLY		0x040b
+struct hci_cp_link_key_reply {
+	bdaddr_t bdaddr;
+	__u8 link_key[16];
+} __attribute__ ((packed));
+
+#define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
+struct hci_cp_link_key_neg_reply {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_PIN_CODE_REPLY		0x040d
+struct hci_cp_pin_code_reply {
+	bdaddr_t bdaddr;
+	__u8 pin_len;
+	__u8 pin_code[16];
+} __attribute__ ((packed));
+
+#define HCI_OP_PIN_CODE_NEG_REPLY	0x040e
+struct hci_cp_pin_code_neg_reply {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_CHANGE_CONN_PTYPE	0x040f
+struct hci_cp_change_conn_ptype {
+	__le16 handle;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_AUTH_REQUESTED		0x0411
+struct hci_cp_auth_requested {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_SET_CONN_ENCRYPT		0x0413
+struct hci_cp_set_conn_encrypt {
+	__le16 handle;
+	__u8 encrypt;
+} __attribute__ ((packed));
+
+#define HCI_OP_CHANGE_CONN_LINK_KEY	0x0415
+struct hci_cp_change_conn_link_key {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_REMOTE_NAME_REQ		0x0419
+struct hci_cp_remote_name_req {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_mode;
+	__le16 clock_offset;
+} __attribute__ ((packed));
+
+#define HCI_OP_REMOTE_NAME_REQ_CANCEL	0x041a
+struct hci_cp_remote_name_req_cancel {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_REMOTE_FEATURES	0x041b
+struct hci_cp_read_remote_features {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_REMOTE_EXT_FEATURES	0x041c
+struct hci_cp_read_remote_ext_features {
+	__le16 handle;
+	__u8 page;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_REMOTE_VERSION	0x041d
+struct hci_cp_read_remote_version {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_SETUP_SYNC_CONN		0x0428
+struct hci_cp_setup_sync_conn {
+	__le16 handle;
+	__le32 tx_bandwidth;
+	__le32 rx_bandwidth;
+	__le16 max_latency;
+	__le16 voice_setting;
+	__u8 retrans_effort;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_ACCEPT_SYNC_CONN_REQ	0x0429
+struct hci_cp_accept_sync_conn_req {
+	bdaddr_t bdaddr;
+	__le32 tx_bandwidth;
+	__le32 rx_bandwidth;
+	__le16 max_latency;
+	__le16 content_format;
+	__u8 retrans_effort;
+	__le16 pkt_type;
+} __attribute__ ((packed));
+
+#define HCI_OP_REJECT_SYNC_CONN_REQ	0x042a
+struct hci_cp_reject_sync_conn_req {
+	bdaddr_t bdaddr;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_OP_SNIFF_MODE		0x0803
+struct hci_cp_sniff_mode {
+	__le16 handle;
+	__le16 max_interval;
+	__le16 min_interval;
+	__le16 attempt;
+	__le16 timeout;
+} __attribute__ ((packed));
+
+#define HCI_OP_EXIT_SNIFF_MODE		0x0804
+struct hci_cp_exit_sniff_mode {
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_ROLE_DISCOVERY		0x0809
+struct hci_cp_role_discovery {
+	__le16 handle;
+} __attribute__ ((packed));
+struct hci_rp_role_discovery {
+	__u8 status;
+	__le16 handle;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_OP_SWITCH_ROLE		0x080b
+struct hci_cp_switch_role {
+	bdaddr_t bdaddr;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LINK_POLICY		0x080c
+struct hci_cp_read_link_policy {
+	__le16 handle;
+} __attribute__ ((packed));
+struct hci_rp_read_link_policy {
+	__u8 status;
+	__le16 handle;
+	__le16 policy;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_LINK_POLICY	0x080d
+struct hci_cp_write_link_policy {
+	__le16 handle;
+	__le16 policy;
+} __attribute__ ((packed));
+struct hci_rp_write_link_policy {
+	__u8 status;
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_OP_SNIFF_SUBRATE		0x0811
+struct hci_cp_sniff_subrate {
+	__le16 handle;
+	__le16 max_latency;
+	__le16 min_remote_timeout;
+	__le16 min_local_timeout;
+} __attribute__ ((packed));
+
+#define HCI_OP_SET_EVENT_MASK		0x0c01
+struct hci_cp_set_event_mask {
+	__u8 mask[8];
+} __attribute__ ((packed));
+
+#define HCI_OP_RESET			0x0c03
+
+#define HCI_OP_SET_EVENT_FLT		0x0c05
+struct hci_cp_set_event_flt {
+	__u8 flt_type;
+	__u8 cond_type;
+	__u8 condition[];
+} __attribute__ ((packed));
+
+/* Filter types */
+#define HCI_FLT_CLEAR_ALL	0x00
+#define HCI_FLT_INQ_RESULT	0x01
+#define HCI_FLT_CONN_SETUP	0x02
+
+/* CONN_SETUP Condition types */
+#define HCI_CONN_SETUP_ALLOW_ALL	0x00
+#define HCI_CONN_SETUP_ALLOW_CLASS	0x01
+#define HCI_CONN_SETUP_ALLOW_BDADDR	0x02
+
+/* CONN_SETUP Conditions */
+#define HCI_CONN_SETUP_AUTO_OFF	0x01
+#define HCI_CONN_SETUP_AUTO_ON	0x02
+
+#define HCI_OP_WRITE_LOCAL_NAME		0x0c13
+struct hci_cp_write_local_name {
+	__u8 name[248];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_NAME		0x0c14
+struct hci_rp_read_local_name {
+	__u8 status;
+	__u8 name[248];
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_CA_TIMEOUT		0x0c16
+
+#define HCI_OP_WRITE_PG_TIMEOUT		0x0c18
+
+#define HCI_OP_WRITE_SCAN_ENABLE 	0x0c1a
+#define SCAN_DISABLED		0x00
+#define SCAN_INQUIRY		0x01
+#define SCAN_PAGE		0x02
+
+#define HCI_OP_READ_AUTH_ENABLE		0x0c1f
+
+#define HCI_OP_WRITE_AUTH_ENABLE	0x0c20
+#define AUTH_DISABLED		0x00
+#define AUTH_ENABLED		0x01
+
+#define HCI_OP_READ_ENCRYPT_MODE	0x0c21
+
+#define HCI_OP_WRITE_ENCRYPT_MODE	0x0c22
+#define ENCRYPT_DISABLED	0x00
+#define ENCRYPT_P2P		0x01
+#define ENCRYPT_BOTH		0x02
+
+#define HCI_OP_READ_CLASS_OF_DEV	0x0c23
+struct hci_rp_read_class_of_dev {
+	__u8 status;
+	__u8 dev_class[3];
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_CLASS_OF_DEV	0x0c24
+struct hci_cp_write_class_of_dev {
+	__u8 dev_class[3];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_VOICE_SETTING	0x0c25
+struct hci_rp_read_voice_setting {
+	__u8 status;
+	__le16 voice_setting;
+} __attribute__ ((packed));
+
+#define HCI_OP_WRITE_VOICE_SETTING	0x0c26
+struct hci_cp_write_voice_setting {
+	__le16 voice_setting;
+} __attribute__ ((packed));
+
+#define HCI_OP_HOST_BUFFER_SIZE		0x0c33
+struct hci_cp_host_buffer_size {
+	__le16 acl_mtu;
+	__u8 sco_mtu;
+	__le16 acl_max_pkt;
+	__le16 sco_max_pkt;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_VERSION	0x1001
+struct hci_rp_read_local_version {
+	__u8 status;
+	__u8 hci_ver;
+	__le16 hci_rev;
+	__u8 lmp_ver;
+	__le16 manufacturer;
+	__le16 lmp_subver;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_COMMANDS	0x1002
+struct hci_rp_read_local_commands {
+	__u8 status;
+	__u8 commands[64];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_FEATURES	0x1003
+struct hci_rp_read_local_features {
+	__u8 status;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_LOCAL_EXT_FEATURES	0x1004
+struct hci_rp_read_local_ext_features {
+	__u8 status;
+	__u8 page;
+	__u8 max_page;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_BUFFER_SIZE		0x1005
+struct hci_rp_read_buffer_size {
+	__u8 status;
+	__le16 acl_mtu;
+	__u8 sco_mtu;
+	__le16 acl_max_pkt;
+	__le16 sco_max_pkt;
+} __attribute__ ((packed));
+
+#define HCI_OP_READ_BD_ADDR		0x1009
+struct hci_rp_read_bd_addr {
+	__u8 status;
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+/* ---- HCI Events ---- */
+#define HCI_EV_INQUIRY_COMPLETE		0x01
+
+#define HCI_EV_INQUIRY_RESULT		0x02
+struct inquiry_info {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 pscan_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+} __attribute__ ((packed));
+
+#define HCI_EV_CONN_COMPLETE		0x03
+struct hci_ev_conn_complete {
+	__u8 status;
+	__le16 handle;
+	bdaddr_t bdaddr;
+	__u8 link_type;
+	__u8 encr_mode;
+} __attribute__ ((packed));
+
+#define HCI_EV_CONN_REQUEST		0x04
+struct hci_ev_conn_request {
+	bdaddr_t bdaddr;
+	__u8 dev_class[3];
+	__u8 link_type;
+} __attribute__ ((packed));
+
+#define HCI_EV_DISCONN_COMPLETE		0x05
+struct hci_ev_disconn_complete {
+	__u8 status;
+	__le16 handle;
+	__u8 reason;
+} __attribute__ ((packed));
+
+#define HCI_EV_AUTH_COMPLETE		0x06
+struct hci_ev_auth_complete {
+	__u8 status;
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_NAME		0x07
+struct hci_ev_remote_name {
+	__u8 status;
+	bdaddr_t bdaddr;
+	__u8 name[248];
+} __attribute__ ((packed));
+
+#define HCI_EV_ENCRYPT_CHANGE		0x08
+struct hci_ev_encrypt_change {
+	__u8 status;
+	__le16 handle;
+	__u8 encrypt;
+} __attribute__ ((packed));
+
+#define HCI_EV_CHANGE_LINK_KEY_COMPLETE	0x09
+struct hci_ev_change_link_key_complete {
+	__u8 status;
+	__le16 handle;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_FEATURES		0x0b
+struct hci_ev_remote_features {
+	__u8 status;
+	__le16 handle;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_VERSION		0x0c
+struct hci_ev_remote_version {
+	__u8 status;
+	__le16 handle;
+	__u8 lmp_ver;
+	__le16 manufacturer;
+	__le16 lmp_subver;
+} __attribute__ ((packed));
+
+#define HCI_EV_QOS_SETUP_COMPLETE	0x0d
+struct hci_qos {
+	__u8 service_type;
+	__u32 token_rate;
+	__u32 peak_bandwidth;
+	__u32 latency;
+	__u32 delay_variation;
+} __attribute__ ((packed));
+struct hci_ev_qos_setup_complete {
+	__u8 status;
+	__le16 handle;
+	struct hci_qos qos;
+} __attribute__ ((packed));
+
+#define HCI_EV_CMD_COMPLETE		0x0e
+struct hci_ev_cmd_complete {
+	__u8 ncmd;
+	__le16 opcode;
+} __attribute__ ((packed));
+
+#define HCI_EV_CMD_STATUS		0x0f
+struct hci_ev_cmd_status {
+	__u8 status;
+	__u8 ncmd;
+	__le16 opcode;
+} __attribute__ ((packed));
+
+#define HCI_EV_ROLE_CHANGE		0x12
+struct hci_ev_role_change {
+	__u8 status;
+	bdaddr_t bdaddr;
+	__u8 role;
+} __attribute__ ((packed));
+
+#define HCI_EV_NUM_COMP_PKTS		0x13
+struct hci_ev_num_comp_pkts {
+	__u8 num_hndl;
+	/* variable length part */
+} __attribute__ ((packed));
+
+#define HCI_EV_MODE_CHANGE		0x14
+struct hci_ev_mode_change {
+	__u8 status;
+	__le16 handle;
+	__u8 mode;
+	__le16 interval;
+} __attribute__ ((packed));
+
+#define HCI_EV_PIN_CODE_REQ		0x16
+struct hci_ev_pin_code_req {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_EV_LINK_KEY_REQ		0x17
+struct hci_ev_link_key_req {
+	bdaddr_t bdaddr;
+} __attribute__ ((packed));
+
+#define HCI_EV_LINK_KEY_NOTIFY		0x18
+struct hci_ev_link_key_notify {
+	bdaddr_t bdaddr;
+	__u8 link_key[16];
+	__u8 key_type;
+} __attribute__ ((packed));
+
+#define HCI_EV_CLOCK_OFFSET		0x1c
+struct hci_ev_clock_offset {
+	__u8 status;
+	__le16 handle;
+	__le16 clock_offset;
+} __attribute__ ((packed));
+
+#define HCI_EV_PSCAN_REP_MODE		0x20
+struct hci_ev_pscan_rep_mode {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+} __attribute__ ((packed));
+
+#define HCI_EV_INQUIRY_RESULT_WITH_RSSI	0x22
+struct inquiry_info_with_rssi {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+} __attribute__ ((packed));
+struct inquiry_info_with_rssi_and_pscan_mode {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 pscan_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+} __attribute__ ((packed));
+
+#define HCI_EV_REMOTE_EXT_FEATURES	0x23
+struct hci_ev_remote_ext_features {
+	__u8 status;
+	__le16 handle;
+	__u8 page;
+	__u8 max_page;
+	__u8 features[8];
+} __attribute__ ((packed));
+
+#define HCI_EV_SYNC_CONN_COMPLETE	0x2c
+struct hci_ev_sync_conn_complete {
+	__u8 status;
+	__le16 handle;
+	bdaddr_t bdaddr;
+	__u8 link_type;
+	__u8 tx_interval;
+	__u8 retrans_window;
+	__le16 rx_pkt_len;
+	__le16 tx_pkt_len;
+	__u8 air_mode;
+} __attribute__ ((packed));
+
+#define HCI_EV_SYNC_CONN_CHANGED	0x2d
+struct hci_ev_sync_conn_changed {
+	__u8 status;
+	__le16 handle;
+	__u8 tx_interval;
+	__u8 retrans_window;
+	__le16 rx_pkt_len;
+	__le16 tx_pkt_len;
+} __attribute__ ((packed));
+
+#define HCI_EV_SNIFF_SUBRATE		0x2e
+struct hci_ev_sniff_subrate {
+	__u8 status;
+	__le16 handle;
+	__le16 max_tx_latency;
+	__le16 max_rx_latency;
+	__le16 max_remote_timeout;
+	__le16 max_local_timeout;
+} __attribute__ ((packed));
+
+#define HCI_EV_EXTENDED_INQUIRY_RESULT	0x2f
+struct extended_inquiry_info {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+	__u8 data[240];
+} __attribute__ ((packed));
+
+/* Internal events generated by Bluetooth stack */
+#define HCI_EV_STACK_INTERNAL	0xfd
+struct hci_ev_stack_internal {
+	__u16 type;
+	__u8 data[];
+} __attribute__ ((packed));
+
+#define HCI_EV_SI_DEVICE	0x01
+struct hci_ev_si_device {
+	__u16 event;
+	__u16 dev_id;
+} __attribute__ ((packed));
+
+#define HCI_EV_SI_SECURITY	0x02
+struct hci_ev_si_security {
+	__u16 event;
+	__u16 proto;
+	__u16 subproto;
+	__u8 incoming;
+} __attribute__ ((packed));
+
+/* ---- HCI Packet structures ---- */
+#define HCI_COMMAND_HDR_SIZE 3
+#define HCI_EVENT_HDR_SIZE   2
+#define HCI_ACL_HDR_SIZE     4
+#define HCI_SCO_HDR_SIZE     3
+
+struct hci_command_hdr {
+	__le16 opcode;		/* OCF & OGF */
+	__u8 plen;
+} __attribute__ ((packed));
+
+struct hci_event_hdr {
+	__u8 evt;
+	__u8 plen;
+} __attribute__ ((packed));
+
+struct hci_acl_hdr {
+	__le16 handle;		/* Handle & Flags(PB, BC) */
+	__le16 dlen;
+} __attribute__ ((packed));
+
+struct hci_sco_hdr {
+	__le16 handle;
+	__u8 dlen;
+} __attribute__ ((packed));
+
+#ifdef __KERNEL__
+#include <linux/skbuff.h>
+static inline struct hci_event_hdr *
+hci_event_hdr(const struct sk_buff *skb)
+{
+	return (struct hci_event_hdr *)skb->data;
+}
+
+static inline struct hci_acl_hdr *
+hci_acl_hdr(const struct sk_buff *skb)
+{
+	return (struct hci_acl_hdr *)skb->data;
+}
+
+static inline struct hci_sco_hdr *
+hci_sco_hdr(const struct sk_buff *skb)
+{
+	return (struct hci_sco_hdr *)skb->data;
+}
+#endif
+
+/* Command opcode pack/unpack */
+#define hci_opcode_pack(ogf, ocf)	(__u16) ((ocf & 0x03ff)|(ogf << 10))
+#define hci_opcode_ogf(op)		(op >> 10)
+#define hci_opcode_ocf(op)		(op & 0x03ff)
+
+/* ACL handle and flags pack/unpack */
+#define hci_handle_pack(h, f)	(__u16) ((h & 0x0fff)|(f << 12))
+#define hci_handle(h)		(h & 0x0fff)
+#define hci_flags(h)		(h >> 12)
+
+/* ---- HCI Sockets ---- */
+
+/* Socket options */
+#define HCI_DATA_DIR	1
+#define HCI_FILTER	2
+#define HCI_TIME_STAMP	3
+
+/* CMSG flags */
+#define HCI_CMSG_DIR	0x0001
+#define HCI_CMSG_TSTAMP	0x0002
+
+struct sockaddr_hci {
+	sa_family_t hci_family;
+	unsigned short hci_dev;
+};
+#define HCI_DEV_NONE	0xffff
+
+struct hci_filter {
+	unsigned long type_mask;
+	unsigned long event_mask[2];
+	__le16 opcode;
+};
+
+struct hci_ufilter {
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__le16 opcode;
+};
+
+#define HCI_FLT_TYPE_BITS	31
+#define HCI_FLT_EVENT_BITS	63
+#define HCI_FLT_OGF_BITS	63
+#define HCI_FLT_OCF_BITS	127
+
+/* ---- HCI Ioctl requests structures ---- */
+struct hci_dev_stats {
+	__u32 err_rx;
+	__u32 err_tx;
+	__u32 cmd_tx;
+	__u32 evt_rx;
+	__u32 acl_tx;
+	__u32 acl_rx;
+	__u32 sco_tx;
+	__u32 sco_rx;
+	__u32 byte_rx;
+	__u32 byte_tx;
+};
+
+struct hci_dev_info {
+	__u16 dev_id;
+	char name[8];
+
+	bdaddr_t bdaddr;
+
+	__u32 flags;
+	__u8 type;
+
+	__u8 features[8];
+
+	__u32 pkt_type;
+	__u32 link_policy;
+	__u32 link_mode;
+
+	__u16 acl_mtu;
+	__u16 acl_pkts;
+	__u16 sco_mtu;
+	__u16 sco_pkts;
+
+	struct hci_dev_stats stat;
+};
+
+struct hci_conn_info {
+	__u16 handle;
+	bdaddr_t bdaddr;
+	__u8 type;
+	__u8 out;
+	__u16 state;
+	__u32 link_mode;
+};
+
+struct hci_dev_req {
+	__u16 dev_id;
+	__u32 dev_opt;
+};
+
+struct hci_dev_list_req {
+	__u16 dev_num;
+	struct hci_dev_req dev_req[];	/* hci_dev_req structures */
+};
+
+struct hci_conn_list_req {
+	__u16 dev_id;
+	__u16 conn_num;
+	struct hci_conn_info conn_info[];
+};
+
+struct hci_conn_info_req {
+	bdaddr_t bdaddr;
+	__u8 type;
+	struct hci_conn_info conn_info[];
+};
+
+struct hci_inquiry_req {
+	__u16 dev_id;
+	__u16 flags;
+	__u8 lap[3];
+	__u8 length;
+	__u8 num_rsp;
+};
+#define IREQ_CACHE_FLUSH 0x0001
+
+#endif /* __HCI_H */
diff --git a/88x9098/bt/muart_src/include/hci_core.h b/88x9098/bt/muart_src/include/hci_core.h
new file mode 100644
index 0000000..102bd3e
--- /dev/null
+++ b/88x9098/bt/muart_src/include/hci_core.h
@@ -0,0 +1,710 @@
+/*
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright 2010-2020, NXP
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_CORE_H
+#define __HCI_CORE_H
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)
+#include <linux/interrupt.h>
+#endif
+#include "hci.h"
+
+/* HCI upper protocols */
+#define HCI_PROTO_L2CAP	0
+#define HCI_PROTO_SCO	1
+
+/* HCI Core structures */
+struct inquiry_data {
+	bdaddr_t bdaddr;
+	__u8 pscan_rep_mode;
+	__u8 pscan_period_mode;
+	__u8 pscan_mode;
+	__u8 dev_class[3];
+	__le16 clock_offset;
+	__s8 rssi;
+};
+
+struct inquiry_entry {
+	struct inquiry_entry *next;
+	__u32 timestamp;
+	struct inquiry_data data;
+};
+
+struct inquiry_cache {
+	spinlock_t lock;
+	__u32 timestamp;
+	struct inquiry_entry *list;
+};
+
+struct hci_conn_hash {
+	struct list_head list;
+	spinlock_t lock;
+	unsigned int acl_num;
+	unsigned int sco_num;
+};
+
+struct hci_dev {
+	struct list_head list;
+	spinlock_t lock;
+	atomic_t refcnt;
+
+	char name[10];
+	unsigned long flags;
+	__u16 id;
+	__u8 type;
+	bdaddr_t bdaddr;
+	__u8 dev_name[248];
+	__u8 dev_class[3];
+	__u8 features[8];
+	__u8 commands[64];
+	__u8 hci_ver;
+	__u16 hci_rev;
+	__u16 manufacturer;
+	__u16 voice_setting;
+
+	__u16 pkt_type;
+	__u16 esco_type;
+	__u16 link_policy;
+	__u16 link_mode;
+
+	__u32 idle_timeout;
+	__u16 sniff_min_interval;
+	__u16 sniff_max_interval;
+
+	unsigned long quirks;
+
+	atomic_t cmd_cnt;
+	unsigned int acl_cnt;
+	unsigned int sco_cnt;
+
+	unsigned int acl_mtu;
+	unsigned int sco_mtu;
+	unsigned int acl_pkts;
+	unsigned int sco_pkts;
+
+	unsigned long cmd_last_tx;
+	unsigned long acl_last_tx;
+	unsigned long sco_last_tx;
+
+	struct tasklet_struct cmd_task;
+	struct tasklet_struct rx_task;
+	struct tasklet_struct tx_task;
+
+	struct sk_buff_head rx_q;
+	struct sk_buff_head raw_q;
+	struct sk_buff_head cmd_q;
+
+	struct sk_buff *sent_cmd;
+	struct sk_buff *reassembly[3];
+
+	struct semaphore req_lock;
+	wait_queue_head_t req_wait_q;
+	__u32 req_status;
+	__u32 req_result;
+
+	struct inquiry_cache inq_cache;
+	struct hci_conn_hash conn_hash;
+
+	struct hci_dev_stats stat;
+
+	struct sk_buff_head driver_init;
+
+	void *driver_data;
+	void *core_data;
+
+	atomic_t promisc;
+
+	struct device *parent;
+	struct device dev;
+
+	struct module *owner;
+
+	int (*open) (struct hci_dev * hdev);
+	int (*close) (struct hci_dev * hdev);
+	int (*flush) (struct hci_dev * hdev);
+	int (*send) (struct sk_buff * skb);
+	void (*destruct) (struct hci_dev * hdev);
+	void (*notify) (struct hci_dev * hdev, unsigned int evt);
+	int (*ioctl) (struct hci_dev * hdev, unsigned int cmd,
+		      unsigned long arg);
+};
+
+struct hci_conn {
+	struct list_head list;
+
+	atomic_t refcnt;
+	spinlock_t lock;
+
+	bdaddr_t dst;
+	__u16 handle;
+	__u16 state;
+	__u8 mode;
+	__u8 type;
+	__u8 out;
+	__u8 attempt;
+	__u8 dev_class[3];
+	__u8 features[8];
+	__u16 interval;
+	__u16 link_policy;
+	__u32 link_mode;
+	__u8 power_save;
+	unsigned long pend;
+
+	unsigned int sent;
+
+	struct sk_buff_head data_q;
+
+	struct timer_list disc_timer;
+	struct timer_list idle_timer;
+
+	struct work_struct work;
+
+	struct device dev;
+
+	struct hci_dev *hdev;
+	void *l2cap_data;
+	void *sco_data;
+	void *priv;
+
+	struct hci_conn *link;
+};
+
+extern struct hci_proto *hci_proto[];
+extern struct list_head hci_dev_list;
+extern struct list_head hci_cb_list;
+//extern rwlock_t hci_dev_list_lock;
+extern rwlock_t hci_cb_list_lock;
+
+/* ----- Inquiry cache ----- */
+#define INQUIRY_CACHE_AGE_MAX   (HZ*30)	// 30 seconds
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)	// 60 seconds
+
+#define inquiry_cache_lock(c)		spin_lock(&c->lock)
+#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
+#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
+#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
+
+static inline void
+inquiry_cache_init(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	spin_lock_init(&c->lock);
+	c->list = NULL;
+}
+
+static inline int
+inquiry_cache_empty(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return (c->list == NULL);
+}
+
+static inline long
+inquiry_cache_age(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return jiffies - c->timestamp;
+}
+
+static inline long
+inquiry_entry_age(struct inquiry_entry *e)
+{
+	return jiffies - e->timestamp;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
+					       bdaddr_t * bdaddr);
+void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
+
+/* ----- HCI Connections ----- */
+enum {
+	HCI_CONN_AUTH_PEND,
+	HCI_CONN_ENCRYPT_PEND,
+	HCI_CONN_RSWITCH_PEND,
+	HCI_CONN_MODE_CHANGE_PEND,
+};
+
+static inline void
+hci_conn_hash_init(struct hci_dev *hdev)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
+	h->acl_num = 0;
+	h->sco_num = 0;
+}
+
+static inline void
+hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	list_add(&c->list, &h->list);
+	if (c->type == ACL_LINK)
+		h->acl_num++;
+	else
+		h->sco_num++;
+}
+
+static inline void
+hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	list_del(&c->list);
+	if (c->type == ACL_LINK)
+		h->acl_num--;
+	else
+		h->sco_num--;
+}
+
+static inline struct hci_conn *
+hci_conn_hash_lookup_handle(struct hci_dev *hdev, __u16 handle)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->handle == handle)
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_conn *
+hci_conn_hash_lookup_ba(struct hci_dev *hdev, __u8 type, bdaddr_t * ba)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && !bacmp(&c->dst, ba))
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_conn *
+hci_conn_hash_lookup_state(struct hci_dev *hdev, __u8 type, __u16 state)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && c->state == state)
+			return c;
+	}
+	return NULL;
+}
+
+void hci_acl_connect(struct hci_conn *conn);
+void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
+void hci_add_sco(struct hci_conn *conn, __u16 handle);
+void hci_setup_sync(struct hci_conn *conn, __u16 handle);
+
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t * dst);
+int hci_conn_del(struct hci_conn *conn);
+void hci_conn_hash_flush(struct hci_dev *hdev);
+void hci_conn_check_pending(struct hci_dev *hdev);
+
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t * src);
+int hci_conn_auth(struct hci_conn *conn);
+int hci_conn_encrypt(struct hci_conn *conn);
+int hci_conn_change_link_key(struct hci_conn *conn);
+int hci_conn_switch_role(struct hci_conn *conn, uint8_t role);
+
+void hci_conn_enter_active_mode(struct hci_conn *conn);
+void hci_conn_enter_sniff_mode(struct hci_conn *conn);
+
+static inline void
+hci_conn_hold(struct hci_conn *conn)
+{
+	atomic_inc(&conn->refcnt);
+	del_timer(&conn->disc_timer);
+}
+
+static inline void
+hci_conn_put(struct hci_conn *conn)
+{
+	if (atomic_dec_and_test(&conn->refcnt)) {
+		unsigned long timeo;
+		if (conn->type == ACL_LINK) {
+			del_timer(&conn->idle_timer);
+			if (conn->state == BT_CONNECTED) {
+				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
+				if (!conn->out)
+					timeo *= 2;
+			} else
+				timeo = msecs_to_jiffies(10);
+		} else
+			timeo = msecs_to_jiffies(10);
+		mod_timer(&conn->disc_timer, jiffies + timeo);
+	}
+}
+
+/* ----- HCI tasks ----- */
+static inline void
+hci_sched_cmd(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->cmd_task);
+}
+
+static inline void
+hci_sched_rx(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->rx_task);
+}
+
+static inline void
+hci_sched_tx(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->tx_task);
+}
+
+/* ----- HCI Devices ----- */
+static inline void
+__hci_dev_put(struct hci_dev *d)
+{
+	if (atomic_dec_and_test(&d->refcnt))
+		d->destruct(d);
+}
+
+static inline void
+hci_dev_put(struct hci_dev *d)
+{
+	__hci_dev_put(d);
+	module_put(d->owner);
+}
+
+static inline struct hci_dev *
+__hci_dev_hold(struct hci_dev *d)
+{
+	atomic_inc(&d->refcnt);
+	return d;
+}
+
+static inline struct hci_dev *
+hci_dev_hold(struct hci_dev *d)
+{
+	if (try_module_get(d->owner))
+		return __hci_dev_hold(d);
+	return NULL;
+}
+
+#define hci_dev_lock(d)		spin_lock(&d->lock)
+#define hci_dev_unlock(d)	spin_unlock(&d->lock)
+#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
+#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
+
+struct hci_dev *hci_dev_get(int index);
+struct hci_dev *hci_get_route(bdaddr_t * src, bdaddr_t * dst);
+
+#if 0
+struct hci_dev *mbt_hci_alloc_dev(void);
+void mbt_hci_free_dev(struct hci_dev *hdev);
+int mbt_hci_register_dev(struct hci_dev *hdev);
+int mbt_hci_unregister_dev(struct hci_dev *hdev);
+int mbt_hci_suspend_dev(struct hci_dev *hdev);
+int mbt_hci_resume_dev(struct hci_dev *hdev);
+#endif
+int hci_dev_open(__u16 dev);
+int hci_dev_close(__u16 dev);
+int hci_dev_reset(__u16 dev);
+int hci_dev_reset_stat(__u16 dev);
+int hci_dev_cmd(unsigned int cmd, void __user * arg);
+int hci_get_dev_list(void __user * arg);
+int hci_get_dev_info(void __user * arg);
+int hci_get_conn_list(void __user * arg);
+int hci_get_conn_info(struct hci_dev *hdev, void __user * arg);
+int hci_inquiry(void __user * arg);
+int hci_hold_conn_cmd(struct hci_dev *hdev, void __user * arg);
+int hci_put_conn_cmd(struct hci_dev *hdev, void __user * arg);
+void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
+
+/* Receive frame from HCI drivers */
+static inline int
+hci_recv_frame(struct sk_buff *skb)
+{
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+	if (!hdev || (!test_bit(HCI_UP, &hdev->flags)
+		      && !test_bit(HCI_INIT, &hdev->flags))) {
+		kfree_skb(skb);
+		return -ENXIO;
+	}
+
+	/* Incomming skb */
+	bt_cb(skb)->incoming = 1;
+
+	/* Time stamp */
+	__net_timestamp(skb);
+
+	/* Queue frame for rx task */
+	skb_queue_tail(&hdev->rx_q, skb);
+
+	// hci_sched_rx(hdev);
+
+	/* Wakeup rx thread */
+	wake_up_interruptible(&hdev->req_wait_q);
+
+	return 0;
+}
+
+int mbt_hci_recv_fragment(struct hci_dev *hdev, int type, void *data,
+			  int count);
+
+int hci_register_sysfs(struct hci_dev *hdev);
+void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_conn_add_sysfs(struct hci_conn *conn);
+void hci_conn_del_sysfs(struct hci_conn *conn);
+
+#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
+
+/* ----- LMP capabilities ----- */
+#define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)
+#define lmp_encrypt_capable(dev)   ((dev)->features[0] & LMP_ENCRYPT)
+#define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
+#define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
+#define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
+
+/* ----- HCI protocols ----- */
+struct hci_proto {
+	char *name;
+	unsigned int id;
+	unsigned long flags;
+
+	void *priv;
+
+	int (*connect_ind) (struct hci_dev * hdev, bdaddr_t * bdaddr,
+			    __u8 type);
+	int (*connect_cfm) (struct hci_conn * conn, __u8 status);
+	int (*disconn_ind) (struct hci_conn * conn, __u8 reason);
+	int (*recv_acldata) (struct hci_conn * conn, struct sk_buff * skb,
+			     __u16 flags);
+	int (*recv_scodata) (struct hci_conn * conn, struct sk_buff * skb);
+	int (*auth_cfm) (struct hci_conn * conn, __u8 status);
+	int (*encrypt_cfm) (struct hci_conn * conn, __u8 status);
+};
+
+static inline int
+hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t * bdaddr, __u8 type)
+{
+	register struct hci_proto *hp;
+	int mask = 0;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	return mask;
+}
+
+static inline void
+hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
+}
+
+static inline void
+hci_proto_disconn_ind(struct hci_conn *conn, __u8 reason)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_ind)
+		hp->disconn_ind(conn, reason);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_ind)
+		hp->disconn_ind(conn, reason);
+}
+
+static inline void
+hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->auth_cfm)
+		hp->auth_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->auth_cfm)
+		hp->auth_cfm(conn, status);
+}
+
+static inline void
+hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->encrypt_cfm)
+		hp->encrypt_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->encrypt_cfm)
+		hp->encrypt_cfm(conn, status);
+}
+
+int hci_register_proto(struct hci_proto *hproto);
+int hci_unregister_proto(struct hci_proto *hproto);
+
+/* ----- HCI callbacks ----- */
+struct hci_cb {
+	struct list_head list;
+
+	char *name;
+
+	void (*auth_cfm) (struct hci_conn * conn, __u8 status);
+	void (*encrypt_cfm) (struct hci_conn * conn, __u8 status, __u8 encrypt);
+	void (*key_change_cfm) (struct hci_conn * conn, __u8 status);
+	void (*role_switch_cfm) (struct hci_conn * conn, __u8 status,
+				 __u8 role);
+};
+
+static inline void
+hci_auth_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct list_head *p;
+
+	hci_proto_auth_cfm(conn, status);
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->auth_cfm)
+			cb->auth_cfm(conn, status);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void
+hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+{
+	struct list_head *p;
+
+	hci_proto_encrypt_cfm(conn, status);
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->encrypt_cfm)
+			cb->encrypt_cfm(conn, status, encrypt);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void
+hci_key_change_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct list_head *p;
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->key_change_cfm)
+			cb->key_change_cfm(conn, status);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void
+hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
+{
+	struct list_head *p;
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->role_switch_cfm)
+			cb->role_switch_cfm(conn, status, role);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+int hci_register_cb(struct hci_cb *hcb);
+int hci_unregister_cb(struct hci_cb *hcb);
+
+int hci_register_notifier(struct notifier_block *nb);
+int hci_unregister_notifier(struct notifier_block *nb);
+
+int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
+int hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+int hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
+
+void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
+
+void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
+
+/* ----- HCI Sockets ----- */
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+
+/* HCI info for socket */
+#define hci_pi(sk) ((struct hci_pinfo *) sk)
+
+struct hci_pinfo {
+	struct bt_sock bt;
+	struct hci_dev *hdev;
+	struct hci_filter filter;
+	__u32 cmsg_mask;
+};
+
+/* HCI security filter */
+#define HCI_SFLT_MAX_OGF  5
+
+struct hci_sec_filter {
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
+};
+
+/* ----- HCI requests ----- */
+#define HCI_REQ_DONE	  0
+#define HCI_REQ_PEND	  1
+#define HCI_REQ_CANCELED  2
+
+#define hci_req_lock(d)		down(&d->req_lock)
+#define hci_req_unlock(d)	up(&d->req_lock)
+
+void hci_req_complete(struct hci_dev *hdev, int result);
+
+#endif /* __HCI_CORE_H */
diff --git a/88x9098/bt/muart_src/mbt_char.c b/88x9098/bt/muart_src/mbt_char.c
new file mode 100644
index 0000000..f951706
--- /dev/null
+++ b/88x9098/bt/muart_src/mbt_char.c
@@ -0,0 +1,699 @@
+/** @file mbt_char.c
+  *
+  * @brief This file contains the char device function calls
+  *
+  * Copyright 2018-2021 NXP
+  *
+  * This software file (the File) is distributed by NXP
+  * under the terms of the GNU General Public License Version 2, June 1991
+  * (the License).  You may use, redistribute and/or modify the File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available by writing to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+  * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+
+#define _INCLUDE_H_
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/proc_fs.h>
+
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+
+#include <linux/path.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#endif
+
+#if defined(BT_AMP) && !defined(MBT_EXT)
+#include "amp/bluetooth/bluetooth.h"
+#include "amp/bluetooth/hci_core.h"
+#else
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#endif
+
+#include "hci_wrapper.h"
+#include "hci_uart.h"
+
+#include  <linux/version.h>
+
+#include "bt_drv.h"
+#include "mbt_char.h"
+
+LIST_HEAD(char_dev_list);
+
+static DEFINE_SPINLOCK(char_dev_list_lock);
+static int mbtchar_major = MBTCHAR_MAJOR_NUM;
+
+/**
+ *	@brief Changes permissions of the dev
+ *
+ *	@param name 	pointer to character
+ *	@param mode		mode_t type data
+ *	@return			0--success otherwise failure
+ */
+int
+mbtchar_chmod(char *name, mode_t mode)
+{
+	struct path path;
+	struct inode *inode;
+	struct iattr newattrs;
+	int ret;
+
+	ENTER();
+	mdelay(30);
+	ret = kern_path(name, LOOKUP_FOLLOW, &path);
+	if (ret)
+		goto out;
+	inode = path.dentry->d_inode;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	mutex_lock(&inode->i_mutex);
+#else
+	inode_lock(inode);
+#endif
+
+	ret = mnt_want_write(path.mnt);
+	if (ret)
+		goto out_unlock;
+	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
+	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+	if (inode->i_op->setattr)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		ret = inode->i_op->setattr(inode->i_sb->s_user_ns, path.dentry,
+					   &newattrs);
+#else
+		ret = inode->i_op->setattr(path.dentry, &newattrs);
+#endif
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		ret = simple_setattr(inode->i_sb->s_user_ns, path.dentry,
+				     &newattrs);
+#else
+		ret = simple_setattr(path.dentry, &newattrs);
+#endif
+#else
+		ret = inode_setattr(inode, &newattrs);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	mutex_unlock(&inode->i_mutex);
+#else
+	inode_unlock(inode);
+#endif
+	mnt_drop_write(path.mnt);
+
+	path_put(&path);
+	LEAVE();
+	return ret;
+out_unlock:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	mutex_unlock(&inode->i_mutex);
+#else
+	inode_unlock(inode);
+#endif
+	mnt_drop_write(path.mnt);
+out:
+	path_put(&path);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief Changes ownership of the dev
+ *
+ *	@param name 	pointer to character
+ *	@param user		uid_t type data
+ *	@param group	gid_t type data
+ *	@return			0--success otherwise failure
+ */
+int
+mbtchar_chown(char *name, uid_t user, gid_t group)
+{
+	struct path path;
+	struct inode *inode = NULL;
+	struct iattr newattrs;
+	int ret = 0;
+
+	ENTER();
+	mdelay(30);
+	ret = kern_path(name, LOOKUP_FOLLOW, &path);
+	if (ret)
+		goto out;
+	inode = path.dentry->d_inode;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	mutex_lock(&inode->i_mutex);
+#else
+	inode_lock(inode);
+#endif
+	ret = mnt_want_write(path.mnt);
+	if (ret)
+		goto out_unlock;
+	newattrs.ia_valid = ATTR_CTIME;
+	if (user != (uid_t) (-1)) {
+		newattrs.ia_valid |= ATTR_UID;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+		newattrs.ia_uid = user;
+#else
+		newattrs.ia_uid = KUIDT_INIT(user);
+#endif
+	}
+	if (group != (gid_t) (-1)) {
+		newattrs.ia_valid |= ATTR_GID;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+		newattrs.ia_gid = group;
+#else
+		newattrs.ia_gid = KGIDT_INIT(group);
+#endif
+	}
+	if (!S_ISDIR(inode->i_mode))
+		newattrs.ia_valid |=
+			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
+	if (inode->i_op->setattr)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		ret = inode->i_op->setattr(inode->i_sb->s_user_ns, path.dentry,
+					   &newattrs);
+#else
+		ret = inode->i_op->setattr(path.dentry, &newattrs);
+#endif
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		ret = simple_setattr(inode->i_sb->s_user_ns, path.dentry,
+				     &newattrs);
+#else
+		ret = simple_setattr(path.dentry, &newattrs);
+#endif
+#else
+		ret = inode_setattr(inode, &newattrs);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	mutex_unlock(&inode->i_mutex);
+#else
+	inode_unlock(inode);
+#endif
+	mnt_drop_write(path.mnt);
+
+	path_put(&path);
+	LEAVE();
+	return ret;
+out_unlock:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	mutex_unlock(&inode->i_mutex);
+#else
+	inode_unlock(inode);
+#endif
+	mnt_drop_write(path.mnt);
+out:
+	path_put(&path);
+	return ret;
+}
+
+/**
+ *	@brief write handler for char dev
+ *
+ *	@param filp 	pointer to structure file
+ *	@param buf		pointer to char buffer
+ *	@param count	size of receive buffer
+ *	@param f_pos	pointer to loff_t type data
+ *	@return			number of bytes written
+ */
+ssize_t
+chardev_write(struct file * filp, const char *buf, size_t count, loff_t * f_pos)
+{
+	int nwrite = 0;
+	struct sk_buff *skb;
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+	ENTER();
+
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+	nwrite = count;
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
+	if (!skb) {
+		PRINTM(ERROR, "mbtchar_write(): fail to alloc skb\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	if (copy_from_user((void *)skb_put(skb, count), buf, count)) {
+		PRINTM(ERROR, "mbtchar_write(): cp_from_user failed\n");
+		kfree_skb(skb);
+		nwrite = -EFAULT;
+		goto exit;
+	}
+	skb->dev = (void *)m_dev;
+	bt_cb(skb)->pkt_type = *((unsigned char *)skb->data);
+	skb_pull(skb, 1);
+
+	PRINTM(DATA, "Write: pkt_type: 0x%x, len=%d @%lu\n",
+	       bt_cb(skb)->pkt_type, skb->len, jiffies);
+	DBG_HEXDUMP(ERROR, "chardev_write", skb->data, skb->len);
+
+	/* Send skb to the hci wrapper layer */
+	if (m_dev->send(m_dev, skb)) {
+		PRINTM(ERROR, "Write: Fail\n");
+		nwrite = 0;
+		/* Send failed */
+		kfree_skb(skb);
+	}
+exit:
+	LEAVE();
+	return nwrite;
+}
+
+/**
+ *	@brief read handler for BT char dev
+ *
+ *	@param filp 	pointer to structure file
+ *	@param buf		pointer to char buffer
+ *	@param count	size of receive buffer
+ *	@param f_pos	pointer to loff_t type data
+ *	@return			number of bytes read
+ */
+ssize_t
+chardev_read(struct file * filp, char *buf, size_t count, loff_t * f_pos)
+{
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = dev->m_dev;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t ret = 0;
+	struct sk_buff *skb = NULL;
+
+	ENTER();
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	/* Wait for rx data */
+	add_wait_queue(&m_dev->req_wait_q, &wait);
+	while (1) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		skb = skb_dequeue(&m_dev->rx_q);
+		if (skb)
+			break;
+		if (!test_bit(HCI_UP, &m_dev->flags)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		if (filp->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			break;
+		}
+		if (signal_pending(current)) {
+			ret = -EINTR;
+			break;
+		}
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&m_dev->req_wait_q, &wait);
+
+	if (!skb)
+		goto out;
+
+	if (skb->len > count) {
+		ret = -EOVERFLOW;
+		goto outf;
+	}
+	/* Put type byte before the data */
+	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
+	PRINTM(DATA, "Read: pkt_type: 0x%x, len=%d @%lu\n",
+	       bt_cb(skb)->pkt_type, skb->len, jiffies);
+	DBG_HEXDUMP(DAT_D, "chardev_read", skb->data, skb->len);
+	if (copy_to_user(buf, skb->data, skb->len)) {
+		ret = -EFAULT;
+		goto outf;
+	}
+	ret = skb->len;
+outf:
+	kfree_skb(skb);
+out:
+	LEAVE();
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+/**
+ *	@brief ioctl handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp 	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_ioctl(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
+#else
+/**
+ *	@brief ioctl handler for char dev
+ *
+ *	@param filp 	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+long
+chardev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+	ENTER();
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+	PRINTM(INFO, "IOCTL: cmd=%d\n", cmd);
+	switch (cmd) {
+	case MBTCHAR_IOCTL_RELEASE:
+		m_dev->close(m_dev);
+		break;
+	case MBTCHAR_IOCTL_QUERY_TYPE:
+		m_dev->query(m_dev, arg);
+		break;
+	default:
+		break;
+	}
+	LEAVE();
+	return 0;
+}
+
+/**
+ *	@brief open handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp 	pointer to structure file
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	struct char_dev *dev = NULL;
+	struct m_dev *m_dev = NULL;
+	ENTER();
+
+	dev = container_of(inode->i_cdev, struct char_dev, cdev);
+	if (!dev->m_dev) {
+		ret = -ENXIO;
+		goto done;
+	}
+	filp->private_data = dev;	/* for other methods */
+	m_dev = dev->m_dev;
+	mdev_req_lock(m_dev);
+	if (test_bit(HCI_UP, &m_dev->flags)) {
+		PRINTM(INFO, "Already UP\n");
+		ret = -EALREADY;
+		goto done;
+	}
+	if (m_dev->open(m_dev)) {
+		ret = -EIO;
+		goto done;
+	}
+	set_bit(HCI_UP, &m_dev->flags);
+
+done:
+	mdev_req_unlock(m_dev);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief release handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp 	pointer to structure file
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_release(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	struct m_dev *m_dev = NULL;
+	struct char_dev *dev = NULL;
+
+	ENTER();
+
+	dev = (struct char_dev *)filp->private_data;
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+	ret = m_dev->close(m_dev);
+	filp->private_data = NULL;
+	clear_bit(HCI_UP, &m_dev->flags);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief poll handler for char dev
+ *
+ *	@param filp 	pointer to structure file
+ *	@param wait		pointer to poll_table structure
+ *	@return			mask
+ */
+static unsigned int
+chardev_poll(struct file *filp, poll_table * wait)
+{
+	unsigned int mask;
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+
+	ENTER();
+
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+
+	m_dev = dev->m_dev;
+	poll_wait(filp, &m_dev->req_wait_q, wait);
+	mask = POLLOUT | POLLWRNORM;
+	if (skb_peek(&m_dev->rx_q))
+		mask |= POLLIN | POLLRDNORM;
+	if (!test_bit(HCI_UP, &(m_dev->flags)))
+		mask |= POLLHUP;
+	PRINTM(INFO, "poll mask=0x%x\n", mask);
+
+	LEAVE();
+	return mask;
+}
+
+/* File ops for the Char driver */
+struct file_operations chardev_fops = {
+	.read = chardev_read,
+	.write = chardev_write,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	.ioctl = chardev_ioctl,
+#else
+	.unlocked_ioctl = chardev_ioctl,
+#endif
+	.open = chardev_open,
+	.release = chardev_release,
+	.poll = chardev_poll,
+};
+
+/**
+ *	@brief This function creates the char dev
+ *
+ *	@param dev	 		A pointer to structure char_dev
+ *  @param char_class	A pointer to class struct
+ *  @param mod_name		A pointer to char
+ *  @param dev_name		A pointer to char
+ *	@return				0--success otherwise failure
+ */
+int
+register_char_dev(struct char_dev *dev, struct class *char_class,
+		  char *mod_name, char *dev_name)
+{
+	int ret = 0, dev_num;
+	unsigned long flags;
+	ENTER();
+	/* create the chrdev region */
+	if (mbtchar_major) {
+		dev_num = MKDEV(mbtchar_major, dev->minor);
+		ret = register_chrdev_region(dev_num, 1, mod_name);
+	} else {
+		PRINTM(INFO, "chardev: no major # yet\n");
+		ret = alloc_chrdev_region(&dev_num, dev->minor, 1, mod_name);
+	}
+
+	if (ret) {
+		PRINTM(ERROR, "chardev: create chrdev_region failed\n");
+		LEAVE();
+		return ret;
+	}
+	if (!mbtchar_major) {
+		/* Store the allocated dev major # */
+		mbtchar_major = MAJOR(dev_num);
+	}
+	cdev_init(&dev->cdev, &chardev_fops);
+	dev->cdev.owner = THIS_MODULE;
+	dev->cdev.ops = &chardev_fops;
+	dev_num = MKDEV(mbtchar_major, dev->minor);
+
+	if (cdev_add(&dev->cdev, dev_num, 1)) {
+		PRINTM(ERROR, "chardev: cdev_add failed\n");
+		ret = -EFAULT;
+		goto free_cdev_region;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	if ((dev->dev_type == BT_TYPE) || (dev->dev_type == BT_AMP_TYPE)) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), NULL, dev_name);
+	}
+	if (dev->dev_type == FM_TYPE) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), NULL, dev_name);
+	}
+	if (dev->dev_type == NFC_TYPE) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), NULL, dev_name);
+	}
+#else
+	if ((dev->dev_type == BT_TYPE) || (dev->dev_type == BT_AMP_TYPE)) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), dev_name);
+	}
+	if (dev->dev_type == FM_TYPE) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), dev_name);
+	}
+	if (dev->dev_type == NFC_TYPE) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), dev_name);
+	}
+#endif
+	PRINTM(INFO, "register char dev=%s \n", dev_name);
+
+	/** modify later */
+
+	spin_lock_irqsave(&char_dev_list_lock, flags);
+	list_add_tail(&dev->list, &char_dev_list);
+	spin_unlock_irqrestore(&char_dev_list_lock, flags);
+
+	LEAVE();
+	return ret;
+free_cdev_region:
+	unregister_chrdev_region(MKDEV(mbtchar_major, dev->minor), 1);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief This function deletes the char dev
+ *
+ *	@param dev	 		A pointer to structure char_dev
+ *  @param char_class	A pointer to class struct
+ *  @param dev_name		A pointer to char
+ *	@return				0--success otherwise failure
+ */
+int
+unregister_char_dev(struct char_dev *dev, struct class *char_class,
+		    char *dev_name)
+{
+	ENTER();
+
+	device_destroy(char_class, MKDEV(mbtchar_major, dev->minor));
+	cdev_del(&dev->cdev);
+	unregister_chrdev_region(MKDEV(mbtchar_major, dev->minor), 1);
+	PRINTM(INFO, "unregister char dev=%s \n", dev_name);
+
+	LEAVE();
+	return 0;
+}
+
+/**
+ *	@brief This function cleans module
+ *
+ *  @param char_class	A pointer to class struct
+ *	@return				N/A
+ */
+void
+chardev_cleanup(struct class *char_class)
+{
+	unsigned long flags;
+	struct list_head *p = NULL;
+	struct char_dev *dev = NULL;
+	ENTER();
+	spin_lock_irqsave(&char_dev_list_lock, flags);
+	do {
+		dev = NULL;
+		list_for_each(p, &char_dev_list) {
+			dev = list_entry(p, struct char_dev, list);
+			list_del(p);
+			spin_unlock_irqrestore(&char_dev_list_lock, flags);
+			unregister_char_dev(dev, char_class, dev->m_dev->name);
+			kfree(dev);
+			spin_lock_irqsave(&char_dev_list_lock, flags);
+			break;
+		}
+	} while (dev);
+	spin_unlock_irqrestore(&char_dev_list_lock, flags);
+	class_destroy(char_class);
+	LEAVE();
+}
+
+/**
+ *	@brief This function cleans module
+ *
+ *  @param m_dev		A pointer to m_dev struct
+ *  @param char_class	A pointer to class struct
+ *	@return 			N/A
+ */
+void
+chardev_cleanup_one(struct m_dev *m_dev, struct class *char_class)
+{
+	unsigned long flags;
+	struct list_head *p = NULL;
+	struct char_dev *dev = NULL;
+	ENTER();
+	spin_lock_irqsave(&char_dev_list_lock, flags);
+	list_for_each(p, &char_dev_list) {
+		dev = list_entry(p, struct char_dev, list);
+		if (dev->minor == m_dev->index) {
+			list_del(p);
+			spin_unlock_irqrestore(&char_dev_list_lock, flags);
+			dev->m_dev = NULL;
+			unregister_char_dev(dev, char_class, m_dev->name);
+			kfree(dev);
+			spin_lock_irqsave(&char_dev_list_lock, flags);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&char_dev_list_lock, flags);
+	LEAVE();
+}
diff --git a/88x9098/bt/muart_src/mbt_char.h b/88x9098/bt/muart_src/mbt_char.h
new file mode 100644
index 0000000..eaed56d
--- /dev/null
+++ b/88x9098/bt/muart_src/mbt_char.h
@@ -0,0 +1,64 @@
+/** @file mbt_char.h
+  *
+  * @brief This file contains mbtchar driver specific defines etc
+  *
+  * Copyright 2018-2020 NXP
+  *
+  * This software file (the File) is distributed by NXP
+  * under the terms of the GNU General Public License Version 2, June 1991
+  * (the License).  You may use, redistribute and/or modify the File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available by writing to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+  * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+
+#ifndef __MBT_CHAR_H__
+#define __MBT_CHAR_H__
+
+/** Define ioctl */
+#define MBTCHAR_IOCTL_RELEASE       _IO('M', 1)
+#define MBTCHAR_IOCTL_QUERY_TYPE    _IO('M', 2)
+
+/** Interface specific macros */
+#define FMCHAR_MINOR_BASE            (10)
+#define NFCCHAR_MINOR_BASE           (20)
+
+/** Declaration of char_dev struct */
+struct char_dev {
+	struct list_head list;
+	int minor;
+	int dev_type;
+	struct cdev cdev;
+	struct m_dev *m_dev;
+};
+
+/** Changes permissions of the dev */
+int mbtchar_chmod(char *name, mode_t mode);
+
+/** Changes ownership of the dev */
+int mbtchar_chown(char *name, uid_t user, gid_t group);
+
+/**	This function creates the char dev */
+int register_char_dev(struct char_dev *dev, struct class *char_class,
+		      char *mod_name, char *dev_name);
+
+/**	This function deletes the char dev */
+int unregister_char_dev(struct char_dev *dev, struct class *char_class,
+			char *dev_name);
+
+/**	This function cleans module */
+void chardev_cleanup(struct class *char_class);
+
+/**	This function cleans module */
+void chardev_cleanup_one(struct m_dev *m_dev, struct class *char_class);
+
+int mbtchar_unregister_dev(struct m_dev *m_dev);
+
+#endif /*__MBT_CHAR_H__*/
diff --git a/88x9098/wlan/Android.mk b/88x9098/wlan/Android.mk
new file mode 100644
index 0000000..e453ea1
--- /dev/null
+++ b/88x9098/wlan/Android.mk
@@ -0,0 +1,17 @@
+# Copyright 2018-2020 NXP
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/88x9098/wlan/hal/Android.mk b/88x9098/wlan/hal/Android.mk
new file mode 100644
index 0000000..e453ea1
--- /dev/null
+++ b/88x9098/wlan/hal/Android.mk
@@ -0,0 +1,17 @@
+# Copyright 2018-2020 NXP
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/88x9098/wlan/hal/wifi_hal/APACHE_LICENSE-2.0.txt b/88x9098/wlan/hal/wifi_hal/APACHE_LICENSE-2.0.txt
new file mode 100644
index 0000000..75b5248
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/APACHE_LICENSE-2.0.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/88x9098/wlan/hal/wifi_hal/Android.mk b/88x9098/wlan/hal/wifi_hal/Android.mk
new file mode 100644
index 0000000..35fbf89
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/Android.mk
@@ -0,0 +1,64 @@
+# Copyright 2012-2020 NXP
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+# Make the HAL library
+# ============================================================
+include $(CLEAR_VARS)
+
+LOCAL_REQUIRED_MODULES :=
+
+LOCAL_CFLAGS += -Wno-unused-parameter -Wno-int-to-pointer-cast
+LOCAL_CFLAGS += -Wno-maybe-uninitialized -Wno-parentheses
+LOCAL_CFLAGS += -Werror
+LOCAL_CPPFLAGS += -Wno-conversion-null
+
+LOCAL_CFLAGS += -DPLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)
+LOCAL_CPPFLAGS += -DPLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)
+
+ifneq ($(filter %64,$(LINUX_ARCH)),)
+LOCAL_CFLAGS += -DMLAN_64BIT
+endif
+
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH) \
+	$(LOCAL_PATH)/include \
+	external/libnl/include \
+	system/core/liblog/include \
+	system/core/libcutils/include \
+	system/core/libutils/include \
+	$(call include-path-for, libhardware_legacy)/hardware_legacy \
+	external/wpa_supplicant_8/src/drivers \
+	$(TARGET_OUT_HEADERS)/libwpa_client \
+	$(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+
+LOCAL_SRC_FILES := \
+	wifi_hal.cpp \
+	common.cpp \
+	cpp_bindings.cpp \
+	link_layer_stats.cpp \
+	rtt.cpp \
+	wifi_logger.cpp \
+	roam.cpp \
+	wifi_nan.cpp \
+	wifi_offload.cpp
+
+LOCAL_SHARED_LIBRARIES += libnetutils libnl liblog libcutils libutils libwpa_client
+LOCAL_PROPRIETARY_MODULE := true
+
+LOCAL_MODULE := libwifi-hal-nxp
+
+include $(BUILD_STATIC_LIBRARY)
+
diff --git a/88x9098/wlan/hal/wifi_hal/README b/88x9098/wlan/hal/wifi_hal/README
new file mode 100644
index 0000000..30bc441
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/README
@@ -0,0 +1 @@
+This vendor hal is compatible with Android Q only.
diff --git a/88x9098/wlan/hal/wifi_hal/common.cpp b/88x9098/wlan/hal/wifi_hal/common.cpp
new file mode 100644
index 0000000..faac7d1
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/common.cpp
@@ -0,0 +1,285 @@
+/*
+* Copyright (C) 2017 The Android Open Source Project
+* Portions copyright (C) 2017 Broadcom Limited
+* Portions copyright 2015-2020 NXP
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+
+interface_info *getIfaceInfo(wifi_interface_handle handle)
+{
+    return (interface_info *)handle;
+}
+
+wifi_handle getWifiHandle(wifi_interface_handle handle)
+{
+    return getIfaceInfo(handle)->handle;
+}
+
+hal_info *getHalInfo(wifi_handle handle)
+{
+    return (hal_info *)handle;
+}
+
+hal_info *getHalInfo(wifi_interface_handle handle)
+{
+    return getHalInfo(getWifiHandle(handle));
+}
+
+wifi_handle getWifiHandle(hal_info *info)
+{
+    return (wifi_handle)info;
+}
+
+wifi_interface_handle getIfaceHandle(interface_info *info)
+{
+    return (wifi_interface_handle)info;
+}
+
+wifi_error wifi_register_handler(wifi_handle handle, int cmd, nl_recvmsg_msg_cb_t func, void *arg)
+{
+    hal_info *info = (hal_info *)handle;
+
+    /* TODO: check for multiple handlers? */
+    pthread_mutex_lock(&info->cb_lock);
+
+    wifi_error result = WIFI_ERROR_OUT_OF_MEMORY;
+
+    if (info->num_event_cb < info->alloc_event_cb) {
+        info->event_cb[info->num_event_cb].nl_cmd  = cmd;
+        info->event_cb[info->num_event_cb].vendor_id  = 0;
+        info->event_cb[info->num_event_cb].vendor_subcmd  = 0;
+        info->event_cb[info->num_event_cb].cb_func = func;
+        info->event_cb[info->num_event_cb].cb_arg  = arg;
+        ALOGV("Successfully added event handler %p:%p for command %d at %d",
+                arg, func, cmd, info->num_event_cb);
+        info->num_event_cb++;
+        result = WIFI_SUCCESS;
+    }
+
+    pthread_mutex_unlock(&info->cb_lock);
+    return result;
+}
+
+wifi_error wifi_register_vendor_handler(wifi_handle handle,
+        uint32_t id, int subcmd, nl_recvmsg_msg_cb_t func, void *arg)
+{
+    hal_info *info = (hal_info *)handle;
+
+    /* TODO: check for multiple handlers? */
+    pthread_mutex_lock(&info->cb_lock);
+
+    wifi_error result = WIFI_ERROR_OUT_OF_MEMORY;
+
+    if (info->num_event_cb < info->alloc_event_cb) {
+        info->event_cb[info->num_event_cb].nl_cmd  = NL80211_CMD_VENDOR;
+        info->event_cb[info->num_event_cb].vendor_id  = id;
+        info->event_cb[info->num_event_cb].vendor_subcmd  = subcmd;
+        info->event_cb[info->num_event_cb].cb_func = func;
+        info->event_cb[info->num_event_cb].cb_arg  = arg;
+        ALOGV("Added event handler %p:%p for vendor 0x%0x and subcmd 0x%0x at %d",
+                arg, func, id, subcmd, info->num_event_cb);
+        info->num_event_cb++;
+        result = WIFI_SUCCESS;
+    }
+
+    pthread_mutex_unlock(&info->cb_lock);
+    return result;
+}
+
+void wifi_unregister_handler(wifi_handle handle, int cmd)
+{
+    hal_info *info = (hal_info *)handle;
+
+    if (cmd == NL80211_CMD_VENDOR) {
+        ALOGE("Must use wifi_unregister_vendor_handler to remove vendor handlers");
+        return;
+    }
+
+    pthread_mutex_lock(&info->cb_lock);
+
+    for (int i = 0; i < info->num_event_cb; i++) {
+        if (info->event_cb[i].nl_cmd == cmd) {
+            ALOGV("Successfully removed event handler %p:%p for cmd = 0x%0x from %d",
+                    info->event_cb[i].cb_arg, info->event_cb[i].cb_func, cmd, i);
+
+            memmove(&info->event_cb[i], &info->event_cb[i+1],
+                (info->num_event_cb - i - 1) * sizeof(cb_info));
+            info->num_event_cb--;
+            break;
+        }
+    }
+
+    pthread_mutex_unlock(&info->cb_lock);
+}
+
+void wifi_unregister_vendor_handler(wifi_handle handle, uint32_t id, int subcmd)
+{
+    hal_info *info = (hal_info *)handle;
+
+    pthread_mutex_lock(&info->cb_lock);
+
+    for (int i = 0; i < info->num_event_cb; i++) {
+
+        if (info->event_cb[i].nl_cmd == NL80211_CMD_VENDOR
+                && info->event_cb[i].vendor_id == id
+                && info->event_cb[i].vendor_subcmd == subcmd) {
+            ALOGV("Successfully removed event handler %p:%p for vendor 0x%0x, subcmd 0x%0x from %d",
+                    info->event_cb[i].cb_arg, info->event_cb[i].cb_func, id, subcmd, i);
+            memmove(&info->event_cb[i], &info->event_cb[i+1],
+                (info->num_event_cb - i - 1) * sizeof(cb_info));
+            info->num_event_cb--;
+            break;
+        }
+    }
+
+    pthread_mutex_unlock(&info->cb_lock);
+}
+
+
+wifi_error wifi_register_cmd(wifi_handle handle, int id, WifiCommand *cmd)
+{
+    hal_info *info = (hal_info *)handle;
+
+    ALOGI("registering command %d", id);
+
+    wifi_error result = WIFI_ERROR_OUT_OF_MEMORY;
+
+    ALOGV("%s()::%d::Reached!!\n", __func__, __LINE__);	
+    if (info->num_cmd < info->alloc_cmd) {
+        info->cmd[info->num_cmd].id   = id;
+        info->cmd[info->num_cmd].cmd  = cmd;
+        ALOGV("Successfully added command %d: %p at %d", id, cmd, info->num_cmd);
+        ALOGV("%s()::%d::Reached!!\n", __func__, __LINE__);
+        info->num_cmd++;
+        result = WIFI_SUCCESS;
+    }
+
+    return result;
+}
+
+WifiCommand *wifi_unregister_cmd(wifi_handle handle, int id)
+{
+    hal_info *info = (hal_info *)handle;
+
+    ALOGV("un-registering command %d", id);
+
+    WifiCommand *cmd = NULL;
+
+    for (int i = 0; i < info->num_cmd; i++) {
+        if (info->cmd[i].id == id) {
+            cmd = info->cmd[i].cmd;
+            memmove(&info->cmd[i], &info->cmd[i+1], (info->num_cmd - i - 1) * sizeof(cmd_info));
+            info->num_cmd--;
+            ALOGV("Successfully removed command %d: %p from %d", id, cmd, i);
+            break;
+        }
+    }
+
+    return cmd;
+}
+
+WifiCommand *wifi_get_cmd(wifi_handle handle, int id)
+{
+    hal_info *info = (hal_info *)handle;
+
+    WifiCommand *cmd = NULL;
+
+    for (int i = 0; i < info->num_cmd; i++) {
+        if (info->cmd[i].id == id) {
+            cmd = info->cmd[i].cmd;
+            break;
+        }
+    }
+
+    return cmd;
+}
+
+void wifi_unregister_cmd(wifi_handle handle, WifiCommand *cmd)
+{
+    hal_info *info = (hal_info *)handle;
+
+    for (int i = 0; i < info->num_cmd; i++) {
+        if (info->cmd[i].cmd == cmd) {
+            int id = info->cmd[i].id;
+            memmove(&info->cmd[i], &info->cmd[i+1], (info->num_cmd - i - 1) * sizeof(cmd_info));
+            info->num_cmd--;
+            ALOGV("Successfully removed command %d: %p from %d", id, cmd, i);
+            break;
+        }
+    }
+}
+
+wifi_error wifi_cancel_cmd(wifi_request_id id, wifi_interface_handle iface)
+{
+    wifi_handle handle = getWifiHandle(iface);
+
+    WifiCommand *cmd = wifi_unregister_cmd(handle, id);
+    ALOGV("Cancel WifiCommand = %p", cmd);
+    if (cmd) {
+        cmd->cancel();
+        cmd->releaseRef();
+        return WIFI_SUCCESS;
+    }
+
+    return WIFI_ERROR_INVALID_ARGS;
+}
+
+void hexdump(void *buf, byte len)
+{
+    int i=0;
+    char *bytes = (char *)buf;
+
+    if (len) {
+        ALOGV("******HexDump len:%d*********", len);
+        for (i = 0; ((i + 7) < len); i+=8) {
+            ALOGV("%02x %02x %02x %02x   %02x %02x %02x %02x",
+                bytes[i], bytes[i+1],
+                bytes[i+2], bytes[i+3],
+                bytes[i+4], bytes[i+5],
+                bytes[i+6], bytes[i+7]);
+        }
+        if ((len - i) >= 4) {
+            ALOGV("%02x %02x %02x %02x",
+                bytes[i], bytes[i+1],
+                bytes[i+2], bytes[i+3]);
+            i+=4;
+        }
+        for (;i < len;i++) {
+            ALOGV("%02x", bytes[i]);
+        }
+        ALOGV("******HexDump End***********");
+    } else {
+        return;
+    }
+}
+
diff --git a/88x9098/wlan/hal/wifi_hal/common.h b/88x9098/wlan/hal/wifi_hal/common.h
new file mode 100644
index 0000000..7d864dc
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/common.h
@@ -0,0 +1,348 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2021 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "wifi_hal.h"
+
+#ifndef __WIFI_HAL_COMMON_H__
+#define __WIFI_HAL_COMMON_H__
+
+#define LOG_TAG  "WifiHAL"
+
+#include <pthread.h>
+#include "nl80211_copy.h"
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+#include <utils/Log.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+#include <netlink-private/object-api.h>
+#include <netlink-private/types.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/time.h>
+#include <iostream>
+#include <new>
+#include <stdarg.h>
+#include "pkt_stats.h"
+
+#define WIFI_HAL_VERSION      "008.002"
+
+// some common macros
+#define min(x, y)       ((x) < (y) ? (x) : (y))
+#define max(x, y)       ((x) > (y) ? (x) : (y))
+
+/*
+  Mutest define
+*/
+class Mutex
+{
+private:
+    pthread_mutex_t mMutex;
+public:
+    Mutex() {
+        pthread_mutex_init(&mMutex, NULL);
+    }
+    ~Mutex() {
+        pthread_mutex_destroy(&mMutex);
+    }
+    int tryLock() {
+        return pthread_mutex_trylock(&mMutex);
+    }
+    int lock() {
+        return pthread_mutex_lock(&mMutex);
+    }
+    void unlock() {
+        pthread_mutex_unlock(&mMutex);
+    }
+};
+
+/*
+  Define Condition
+*/
+class Condition
+{
+private:
+    pthread_cond_t mCondition;
+    pthread_mutex_t mMutex;
+
+public:
+    Condition() {
+        pthread_mutex_init(&mMutex, NULL);
+        pthread_cond_init(&mCondition, NULL);
+    }
+    ~Condition() {
+        pthread_cond_destroy(&mCondition);
+        pthread_mutex_destroy(&mMutex);
+    }
+
+    int wait() {
+        return pthread_cond_wait(&mCondition, &mMutex);
+    }
+
+    void signal() {
+        pthread_cond_signal(&mCondition);
+    }
+};
+
+#define SOCKET_BUFFER_SIZE      (32768U)
+#define RECV_BUF_SIZE           (4096)
+#define DEFAULT_EVENT_CB_SIZE   (64)
+#define DEFAULT_CMD_SIZE        (64)
+#define MAC_OUI_LEN             3
+
+
+/* libnl 2.0 compatibility code */
+#define nl_handle nl_sock
+#define nl80211_handle_alloc nl_socket_alloc_cb
+#define nl80211_handle_destroy nl_socket_free
+
+const uint32_t MARVELL_OUI = 0x005043;
+
+/* vendor commands define */
+typedef enum {
+    /* don't use 0 as a valid subcommand */
+    VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+
+    /* define all vendor startup commands between 0x0 and 0x0FFF */
+    VENDOR_NL80211_SUBCMD_RANGE_START  = 0x0001,
+    VENDOR_NL80211_SUBCMD_RANGE_END    = 0x0FFF,
+    NXP_OFFLOAD_START_SENDING_PACKET  = 0x0003,
+    NXP_OFFLOAD_STOP_SENDING_PACKET   = 0x0004,
+    NXP_SUBCMD_SCAN_MAC_OUI           = 0x0007,
+    NXP_SUBCMD_SET_PACKET_FILTER      = 0x0011,
+    NXP_SUBCMD_GET_PACKET_FILTER_CAPA = 0x0012,
+    NXP_SUBCMD_CONFIGURE_ND_OFFLOAD   = 0x0100,
+
+    /* define all GScan related commands between 0x1000 and 0x10FF */
+    NXP_SUBCMD_GSCAN_RANGE_START      = 0x1000,
+    GSCAN_SUBCMD_GET_CAPABILITIES      = NXP_SUBCMD_GSCAN_RANGE_START,
+    GSCAN_SUBCMD_SET_CONFIG,                            /* 0x1001 */
+    GSCAN_SUBCMD_SET_SCAN_CONFIG,                       /* 0x1002 */
+    GSCAN_SUBCMD_ENABLE_GSCAN,                          /* 0x1003 */
+    GSCAN_SUBCMD_GET_SCAN_RESULTS,                      /* 0x1004 */
+    GSCAN_SUBCMD_SCAN_RESULTS,                          /* 0x1005 */
+    GSCAN_SUBCMD_SET_HOTLIST,                           /* 0x1006 */
+    GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,         /* 0x1007 */
+    GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,              /* 0x1008 */
+    NXP_SUBCMD_GET_VALID_CHANNELS,                     /* 0x1009 */
+    NXP_SUBCMD_GET_SUPPORTED_FEATURE_SET,               /* 0x100A */
+    NXP_SUBCMD_GET_CONCURRENCY_MATRIX,                  /* 0x100B */
+    NXP_SUBCMD_SET_NODFS_FLAG,                          /* 0x100C */
+    NXP_SUBCMD_SET_COUNTRY_CODE,                        /* 0x100D */
+    GSCAN_SUBCMD_SET_EPNO_SSID,                          /* 0x100E */
+    WIFI_SUBCMD_SET_SSID_WHITE_LIST,                    /* 0x100F */
+    WIFI_SUBCMD_SET_ROAM_PARAMS,                        /* 0x1010 */
+    WIFI_SUBCMD_ENABLE_LAZY_ROAM,                       /* 0x1011 */
+    WIFI_SUBCMD_SET_BSSID_PREF,                         /* 0x1012 */
+    WIFI_SUBCMD_SET_BSSID_BLACKLIST,                     /* 0x1013 */
+    GSCAN_SUBCMD_ANQPO_CONFIG,                          /* 0x1014 */
+    /* Add more sub commands here */
+    GSCAN_SUBCMD_MAX,
+    
+    /* define all RTT related commands between 0x1100 and 0x11FF */
+    NXP_SUBCMD_RTT_GET_CAPA = 0x1100,
+    NXP_SUBCMD_RTT_RANGE_REQUEST,
+    NXP_SUBCMD_RTT_RANGE_CANCEL,
+    NXP_SUBCMD_RTT_GET_RESPONDER_INFO,
+    NXP_SUBCMD_RTT_ENABLE_RESPONDER,
+    NXP_SUBCMD_RTT_DISABLE_RESPONDER,
+    NXP_SUBCMD_RTT_SET_LCI,
+    NXP_SUBCMD_RTT_SET_LCR,
+    
+    /* define all link layer related commands between 0x1200 and 0x12FF */
+    NXP_SUBCMD_LL_STATS_SET = 0x1200,
+    NXP_SUBCMD_LL_STATS_GET,
+    NXP_SUBCMD_LL_STATS_CLR,
+    
+    /* define all Logger related commands between 0x1400 and 0x14FF */
+    NXP_SUBCMD_START_LOGGING = 0x1400,
+    NXP_SUBCMD_GET_LOGGER_FEATURE_SET,
+    NXP_SUBCMD_GET_RING_DATA,
+    NXP_SUBCMD_GET_RING_STATUS,
+    NXP_SUBCMD_GET_FW_VERSION,
+    NXP_SUBCMD_GET_FW_MEM_DUMP,
+    NXP_SUBCMD_GET_DRIVER_VERSION,
+    NXP_SUBCMD_GET_DRIVER_MEM_DUMP,
+    NXP_SUBCMD_START_PKT_FATE_MONITORING,
+    
+    /* define all RSSI related commands between 0x1500 and 0x15FF */
+    NXP_SUBCMD_RSSI_MONITOR = 0x1500,
+    NXP_EVENT_RSSI_MONITOR,
+    
+    /* define all roaming control commands between 0x1700 and 0x17FF */
+    NXP_SUBCMD_GET_ROAMING_CAPA = 0x1700,
+    NXP_SUBCMD_ENABLE_FW_ROAMING,
+    NXP_SUBCMD_ROAMING_CONFIG,
+
+    /* define all nan related commands between 0x1800 and 0x18FF */
+    NXP_SUBCMD_NAN_ENABLE_REQ = 0x1800,
+    NXP_SUBCMD_NAN_DISABLE_REQ,
+    NXP_SUBCMD_NAN_PUBLISH_REQ,
+    NXP_SUBCMD_NAN_PUBLISH_CANCEL,
+    NXP_SUBCMD_NAN_SUBSCRIBE_REQ,
+    NXP_SUBCMD_NAN_SUBSCRIBE_CANCEL,
+    NXP_SUBCMD_NAN_TRANSMIT_FOLLOWUP,
+    NXP_SUBCMD_NAN_STATS_REQ,
+    NXP_SUBCMD_NAN_CONFIG_REQ,
+    NXP_SUBCMD_NAN_TCA_REQ,
+    NXP_SUBCMD_NAN_BEACON_SDF_PAYLOAD,
+    NXP_SUBCMD_NAN_GET_CAPA,
+    NXP_SUBCMD_NAN_DATA_IF_CREATE,
+    NXP_SUBCMD_NAN_DATA_IF_DELETE,
+    NXP_SUBCMD_NAN_DATA_REQ_INITOR,
+    NXP_SUBCMD_NAN_DATA_INDI_RESP,
+    NXP_SUBCMD_NAN_DATA_END,
+    
+    /* This is reserved for future usage */
+} ANDROID_VENDOR_SUB_COMMAND;
+
+typedef enum {
+    RESERVED1,
+    RESERVED2,
+    GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS ,
+    GSCAN_EVENT_HOTLIST_RESULTS_FOUND,
+    GSCAN_EVENT_SCAN_RESULTS_AVAILABLE,
+    GSCAN_EVENT_FULL_SCAN_RESULTS,
+    RTT_EVENT_COMPLETE,
+    NXP_EVENT_RTT_RANGE_RESULT,
+    GSCAN_EVENT_COMPLETE_SCAN,
+    GSCAN_EVENT_HOTLIST_RESULTS_LOST,
+    GSCAN_EVENT_EPNO_EVENT,
+    GSCAN_EVENT_ANQPO_HOTSPOT_MATCH,
+    GOOGLE_RSSI_MONITOR_EVENT
+} WIFI_EVENT;
+
+typedef void (*wifi_internal_event_handler) (wifi_handle handle, int events);
+
+class WifiCommand;
+
+typedef struct {
+    int nl_cmd;
+    uint32_t vendor_id;
+    int vendor_subcmd;
+    nl_recvmsg_msg_cb_t cb_func;
+    void *cb_arg;
+} cb_info;
+
+typedef struct {
+    wifi_request_id id;
+    WifiCommand *cmd;
+} cmd_info;
+
+typedef struct {
+    wifi_handle handle;                             // handle to wifi data
+    char name[8+1];                                 // interface name + trailing null
+    int  id;                                        // id to use when talking to driver
+} interface_info;
+
+typedef struct {
+
+    struct nl_sock *cmd_sock;                       // command socket object
+    struct nl_sock *event_sock;                     // event socket object
+    int nl80211_family_id;                          // family id for 80211 driver
+    int cleanup_socks[2];                           // sockets used to implement wifi_cleanup
+
+    bool in_event_loop;                             // Indicates that event loop is active
+    bool clean_up;                                  // Indication to clean up the socket
+
+    wifi_internal_event_handler event_handler;      // default event handler
+    wifi_cleaned_up_handler cleaned_up_handler;     // socket cleaned up handler
+
+    cb_info *event_cb;                              // event callbacks
+    int num_event_cb;                               // number of event callbacks
+    int alloc_event_cb;                             // number of allocated callback objects
+    pthread_mutex_t cb_lock;                        // mutex for the event_cb access
+
+    cmd_info *cmd;                                  // Outstanding commands
+    int num_cmd;                                    // number of commands
+    int alloc_cmd;                                  // number of commands allocated
+
+    bool fate_monitoring_enabled;
+    packet_fate_monitor_info *pkt_fate_stats;
+    pthread_mutex_t pkt_fate_stats_lock;
+
+    interface_info **interfaces;                    // array of interfaces
+    int num_interfaces;                             // number of interfaces
+    WLAN_DRIVER_WAKE_REASON_CNT *wifi_wake_reason_cnt;
+} hal_info;
+
+//#define PNO_SSID_FOUND  0x1
+//#define PNO_SSID_LOST    0x2
+
+/*typedef struct wifi_pno_result {
+    unsigned char ssid[32];
+    unsigned char ssid_len;
+    signed char rssi;
+    u16 channel;
+    u16 flags;
+    mac_addr  bssid;
+} wifi_pno_result_t;*/
+
+wifi_error wifi_register_handler(wifi_handle handle, int cmd, nl_recvmsg_msg_cb_t func, void *arg);
+wifi_error wifi_register_vendor_handler(wifi_handle handle,
+            uint32_t id, int subcmd, nl_recvmsg_msg_cb_t func, void *arg);
+void wifi_unregister_handler(wifi_handle handle, int cmd);
+void wifi_unregister_vendor_handler(wifi_handle handle, uint32_t id, int subcmd);
+wifi_error wifi_register_cmd(wifi_handle handle, int id, WifiCommand *cmd);
+WifiCommand *wifi_unregister_cmd(wifi_handle handle, int id);
+WifiCommand *wifi_get_cmd(wifi_handle handle, int id);
+void wifi_unregister_cmd(wifi_handle handle, WifiCommand *cmd);
+interface_info *getIfaceInfo(wifi_interface_handle);
+wifi_handle getWifiHandle(wifi_interface_handle handle);
+hal_info *getHalInfo(wifi_handle handle);
+hal_info *getHalInfo(wifi_interface_handle handle);
+wifi_handle getWifiHandle(hal_info *info);
+wifi_interface_handle getIfaceHandle(interface_info *info);
+wifi_error wifi_cancel_cmd(wifi_request_id id, wifi_interface_handle iface);
+extern wifi_error wifi_configure_nd_offload(wifi_interface_handle iface, u8 enable);
+extern wifi_error wifi_start_rssi_monitoring(wifi_request_id id, wifi_interface_handle
+                        iface, s8 max_rssi, s8 min_rssi, wifi_rssi_event_handler eh);
+extern wifi_error wifi_stop_rssi_monitoring(wifi_request_id id, wifi_interface_handle iface);
+/**
+* API to set packe filter
+* @param program        pointer to the program byte-code
+* @param len               length of the program byte_code 
+*/
+extern wifi_error wifi_set_packet_filter(wifi_interface_handle iface, const u8* program, u32 len);
+
+/**
+* API to get packet filter capabilities. Returns the chipset's hardware filtering capabilities
+* @param version         pointer to version of the packet filter interpreter supported, filled in upon return. 0 indicates no support
+* @param max_len       pointer to maximum size of the filter bytecode, filled in upon return
+*/
+extern wifi_error wifi_get_packet_filter_capabilities(wifi_interface_handle handle, u32* version, u32* max_len);
+extern wifi_error wifi_get_wake_reason_stats(wifi_interface_handle iface, 
+                                            WLAN_DRIVER_WAKE_REASON_CNT *wifi_wake_reason_cnt);
+
+void hexdump(void *bytes, byte len);
+
+#endif
+
diff --git a/88x9098/wlan/hal/wifi_hal/cpp_bindings.cpp b/88x9098/wlan/hal/wifi_hal/cpp_bindings.cpp
new file mode 100644
index 0000000..89d0703
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/cpp_bindings.cpp
@@ -0,0 +1,743 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include <ctype.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+
+void appendFmt(char *buf, int &offset, const char *fmt, ...)
+{
+    va_list params;
+    va_start(params, fmt);
+    offset += vsprintf(buf + offset, fmt, params);
+    va_end(params);
+}
+
+#define C2S(x)  case x: return #x;
+
+static const char *cmdToString(int cmd)
+{
+	switch (cmd) {
+	C2S(NL80211_CMD_UNSPEC)
+	C2S(NL80211_CMD_GET_WIPHY)
+	C2S(NL80211_CMD_SET_WIPHY)
+	C2S(NL80211_CMD_NEW_WIPHY)
+	C2S(NL80211_CMD_DEL_WIPHY)
+	C2S(NL80211_CMD_GET_INTERFACE)
+	C2S(NL80211_CMD_SET_INTERFACE)
+	C2S(NL80211_CMD_NEW_INTERFACE)
+	C2S(NL80211_CMD_DEL_INTERFACE)
+	C2S(NL80211_CMD_GET_KEY)
+	C2S(NL80211_CMD_SET_KEY)
+	C2S(NL80211_CMD_NEW_KEY)
+	C2S(NL80211_CMD_DEL_KEY)
+	C2S(NL80211_CMD_GET_BEACON)
+	C2S(NL80211_CMD_SET_BEACON)
+	C2S(NL80211_CMD_START_AP)
+	C2S(NL80211_CMD_STOP_AP)
+	C2S(NL80211_CMD_GET_STATION)
+	C2S(NL80211_CMD_SET_STATION)
+	C2S(NL80211_CMD_NEW_STATION)
+	C2S(NL80211_CMD_DEL_STATION)
+	C2S(NL80211_CMD_GET_MPATH)
+	C2S(NL80211_CMD_SET_MPATH)
+	C2S(NL80211_CMD_NEW_MPATH)
+	C2S(NL80211_CMD_DEL_MPATH)
+	C2S(NL80211_CMD_SET_BSS)
+	C2S(NL80211_CMD_SET_REG)
+	C2S(NL80211_CMD_REQ_SET_REG)
+	C2S(NL80211_CMD_GET_MESH_CONFIG)
+	C2S(NL80211_CMD_SET_MESH_CONFIG)
+	C2S(NL80211_CMD_SET_MGMT_EXTRA_IE)
+	C2S(NL80211_CMD_GET_REG)
+	C2S(NL80211_CMD_GET_SCAN)
+	C2S(NL80211_CMD_TRIGGER_SCAN)
+	C2S(NL80211_CMD_NEW_SCAN_RESULTS)
+	C2S(NL80211_CMD_SCAN_ABORTED)
+	C2S(NL80211_CMD_REG_CHANGE)
+	C2S(NL80211_CMD_AUTHENTICATE)
+	C2S(NL80211_CMD_ASSOCIATE)
+	C2S(NL80211_CMD_DEAUTHENTICATE)
+	C2S(NL80211_CMD_DISASSOCIATE)
+	C2S(NL80211_CMD_MICHAEL_MIC_FAILURE)
+	C2S(NL80211_CMD_REG_BEACON_HINT)
+	C2S(NL80211_CMD_JOIN_IBSS)
+	C2S(NL80211_CMD_LEAVE_IBSS)
+	C2S(NL80211_CMD_TESTMODE)
+	C2S(NL80211_CMD_CONNECT)
+	C2S(NL80211_CMD_ROAM)
+	C2S(NL80211_CMD_DISCONNECT)
+	C2S(NL80211_CMD_SET_WIPHY_NETNS)
+	C2S(NL80211_CMD_GET_SURVEY)
+	C2S(NL80211_CMD_NEW_SURVEY_RESULTS)
+	C2S(NL80211_CMD_SET_PMKSA)
+	C2S(NL80211_CMD_DEL_PMKSA)
+	C2S(NL80211_CMD_FLUSH_PMKSA)
+	C2S(NL80211_CMD_REMAIN_ON_CHANNEL)
+	C2S(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL)
+	C2S(NL80211_CMD_SET_TX_BITRATE_MASK)
+	C2S(NL80211_CMD_REGISTER_FRAME)
+	C2S(NL80211_CMD_FRAME)
+	C2S(NL80211_CMD_FRAME_TX_STATUS)
+	C2S(NL80211_CMD_SET_POWER_SAVE)
+	C2S(NL80211_CMD_GET_POWER_SAVE)
+	C2S(NL80211_CMD_SET_CQM)
+	C2S(NL80211_CMD_NOTIFY_CQM)
+	C2S(NL80211_CMD_SET_CHANNEL)
+	C2S(NL80211_CMD_SET_WDS_PEER)
+	C2S(NL80211_CMD_FRAME_WAIT_CANCEL)
+	C2S(NL80211_CMD_JOIN_MESH)
+	C2S(NL80211_CMD_LEAVE_MESH)
+	C2S(NL80211_CMD_UNPROT_DEAUTHENTICATE)
+	C2S(NL80211_CMD_UNPROT_DISASSOCIATE)
+	C2S(NL80211_CMD_NEW_PEER_CANDIDATE)
+	C2S(NL80211_CMD_GET_WOWLAN)
+	C2S(NL80211_CMD_SET_WOWLAN)
+	C2S(NL80211_CMD_START_SCHED_SCAN)
+	C2S(NL80211_CMD_STOP_SCHED_SCAN)
+	C2S(NL80211_CMD_SCHED_SCAN_RESULTS)
+	C2S(NL80211_CMD_SCHED_SCAN_STOPPED)
+	C2S(NL80211_CMD_SET_REKEY_OFFLOAD)
+	C2S(NL80211_CMD_PMKSA_CANDIDATE)
+	C2S(NL80211_CMD_TDLS_OPER)
+	C2S(NL80211_CMD_TDLS_MGMT)
+	C2S(NL80211_CMD_UNEXPECTED_FRAME)
+	C2S(NL80211_CMD_PROBE_CLIENT)
+	C2S(NL80211_CMD_REGISTER_BEACONS)
+	C2S(NL80211_CMD_UNEXPECTED_4ADDR_FRAME)
+	C2S(NL80211_CMD_SET_NOACK_MAP)
+	C2S(NL80211_CMD_CH_SWITCH_NOTIFY)
+	C2S(NL80211_CMD_START_P2P_DEVICE)
+	C2S(NL80211_CMD_STOP_P2P_DEVICE)
+	C2S(NL80211_CMD_CONN_FAILED)
+	C2S(NL80211_CMD_SET_MCAST_RATE)
+	C2S(NL80211_CMD_SET_MAC_ACL)
+	C2S(NL80211_CMD_RADAR_DETECT)
+	C2S(NL80211_CMD_GET_PROTOCOL_FEATURES)
+	C2S(NL80211_CMD_UPDATE_FT_IES)
+	C2S(NL80211_CMD_FT_EVENT)
+	C2S(NL80211_CMD_CRIT_PROTOCOL_START)
+	C2S(NL80211_CMD_CRIT_PROTOCOL_STOP)
+	C2S(NL80211_CMD_GET_COALESCE)
+	C2S(NL80211_CMD_SET_COALESCE)
+	C2S(NL80211_CMD_CHANNEL_SWITCH)
+	C2S(NL80211_CMD_VENDOR)
+	C2S(NL80211_CMD_SET_QOS_MAP)
+	default:
+		return "NL80211_CMD_UNKNOWN";
+	}
+}
+
+const char *attributeToString(int attribute)
+{
+    switch (attribute) {
+	C2S(NL80211_ATTR_UNSPEC)
+
+	C2S(NL80211_ATTR_WIPHY)
+	C2S(NL80211_ATTR_WIPHY_NAME)
+
+	C2S(NL80211_ATTR_IFINDEX)
+	C2S(NL80211_ATTR_IFNAME)
+	C2S(NL80211_ATTR_IFTYPE)
+
+	C2S(NL80211_ATTR_MAC)
+
+	C2S(NL80211_ATTR_KEY_DATA)
+	C2S(NL80211_ATTR_KEY_IDX)
+	C2S(NL80211_ATTR_KEY_CIPHER)
+	C2S(NL80211_ATTR_KEY_SEQ)
+	C2S(NL80211_ATTR_KEY_DEFAULT)
+
+	C2S(NL80211_ATTR_BEACON_INTERVAL)
+	C2S(NL80211_ATTR_DTIM_PERIOD)
+	C2S(NL80211_ATTR_BEACON_HEAD)
+	C2S(NL80211_ATTR_BEACON_TAIL)
+
+	C2S(NL80211_ATTR_STA_AID)
+	C2S(NL80211_ATTR_STA_FLAGS)
+	C2S(NL80211_ATTR_STA_LISTEN_INTERVAL)
+	C2S(NL80211_ATTR_STA_SUPPORTED_RATES)
+	C2S(NL80211_ATTR_STA_VLAN)
+	C2S(NL80211_ATTR_STA_INFO)
+
+	C2S(NL80211_ATTR_WIPHY_BANDS)
+
+	C2S(NL80211_ATTR_MNTR_FLAGS)
+
+	C2S(NL80211_ATTR_MESH_ID)
+	C2S(NL80211_ATTR_STA_PLINK_ACTION)
+	C2S(NL80211_ATTR_MPATH_NEXT_HOP)
+	C2S(NL80211_ATTR_MPATH_INFO)
+
+	C2S(NL80211_ATTR_BSS_CTS_PROT)
+	C2S(NL80211_ATTR_BSS_SHORT_PREAMBLE)
+	C2S(NL80211_ATTR_BSS_SHORT_SLOT_TIME)
+
+	C2S(NL80211_ATTR_HT_CAPABILITY)
+
+	C2S(NL80211_ATTR_SUPPORTED_IFTYPES)
+
+	C2S(NL80211_ATTR_REG_ALPHA2)
+	C2S(NL80211_ATTR_REG_RULES)
+
+	C2S(NL80211_ATTR_MESH_CONFIG)
+
+	C2S(NL80211_ATTR_BSS_BASIC_RATES)
+
+	C2S(NL80211_ATTR_WIPHY_TXQ_PARAMS)
+	C2S(NL80211_ATTR_WIPHY_FREQ)
+	C2S(NL80211_ATTR_WIPHY_CHANNEL_TYPE)
+
+	C2S(NL80211_ATTR_KEY_DEFAULT_MGMT)
+
+	C2S(NL80211_ATTR_MGMT_SUBTYPE)
+	C2S(NL80211_ATTR_IE)
+
+	C2S(NL80211_ATTR_MAX_NUM_SCAN_SSIDS)
+
+	C2S(NL80211_ATTR_SCAN_FREQUENCIES)
+	C2S(NL80211_ATTR_SCAN_SSIDS)
+	C2S(NL80211_ATTR_GENERATION) /* replaces old SCAN_GENERATION */
+	C2S(NL80211_ATTR_BSS)
+
+	C2S(NL80211_ATTR_REG_INITIATOR)
+	C2S(NL80211_ATTR_REG_TYPE)
+
+	C2S(NL80211_ATTR_SUPPORTED_COMMANDS)
+
+	C2S(NL80211_ATTR_FRAME)
+	C2S(NL80211_ATTR_SSID)
+	C2S(NL80211_ATTR_AUTH_TYPE)
+	C2S(NL80211_ATTR_REASON_CODE)
+
+	C2S(NL80211_ATTR_KEY_TYPE)
+
+	C2S(NL80211_ATTR_MAX_SCAN_IE_LEN)
+	C2S(NL80211_ATTR_CIPHER_SUITES)
+
+	C2S(NL80211_ATTR_FREQ_BEFORE)
+	C2S(NL80211_ATTR_FREQ_AFTER)
+
+	C2S(NL80211_ATTR_FREQ_FIXED)
+
+
+	C2S(NL80211_ATTR_WIPHY_RETRY_SHORT)
+	C2S(NL80211_ATTR_WIPHY_RETRY_LONG)
+	C2S(NL80211_ATTR_WIPHY_FRAG_THRESHOLD)
+	C2S(NL80211_ATTR_WIPHY_RTS_THRESHOLD)
+
+	C2S(NL80211_ATTR_TIMED_OUT)
+
+	C2S(NL80211_ATTR_USE_MFP)
+
+	C2S(NL80211_ATTR_STA_FLAGS2)
+
+	C2S(NL80211_ATTR_CONTROL_PORT)
+
+	C2S(NL80211_ATTR_TESTDATA)
+
+	C2S(NL80211_ATTR_PRIVACY)
+
+	C2S(NL80211_ATTR_DISCONNECTED_BY_AP)
+	C2S(NL80211_ATTR_STATUS_CODE)
+
+	C2S(NL80211_ATTR_CIPHER_SUITES_PAIRWISE)
+	C2S(NL80211_ATTR_CIPHER_SUITE_GROUP)
+	C2S(NL80211_ATTR_WPA_VERSIONS)
+	C2S(NL80211_ATTR_AKM_SUITES)
+
+	C2S(NL80211_ATTR_REQ_IE)
+	C2S(NL80211_ATTR_RESP_IE)
+
+	C2S(NL80211_ATTR_PREV_BSSID)
+
+	C2S(NL80211_ATTR_KEY)
+	C2S(NL80211_ATTR_KEYS)
+
+	C2S(NL80211_ATTR_PID)
+
+	C2S(NL80211_ATTR_4ADDR)
+
+	C2S(NL80211_ATTR_SURVEY_INFO)
+
+	C2S(NL80211_ATTR_PMKID)
+	C2S(NL80211_ATTR_MAX_NUM_PMKIDS)
+
+	C2S(NL80211_ATTR_DURATION)
+
+	C2S(NL80211_ATTR_COOKIE)
+
+	C2S(NL80211_ATTR_WIPHY_COVERAGE_CLASS)
+
+	C2S(NL80211_ATTR_TX_RATES)
+
+	C2S(NL80211_ATTR_FRAME_MATCH)
+
+	C2S(NL80211_ATTR_ACK)
+
+	C2S(NL80211_ATTR_PS_STATE)
+
+	C2S(NL80211_ATTR_CQM)
+
+	C2S(NL80211_ATTR_LOCAL_STATE_CHANGE)
+
+	C2S(NL80211_ATTR_AP_ISOLATE)
+
+	C2S(NL80211_ATTR_WIPHY_TX_POWER_SETTING)
+	C2S(NL80211_ATTR_WIPHY_TX_POWER_LEVEL)
+
+	C2S(NL80211_ATTR_TX_FRAME_TYPES)
+	C2S(NL80211_ATTR_RX_FRAME_TYPES)
+	C2S(NL80211_ATTR_FRAME_TYPE)
+
+	C2S(NL80211_ATTR_CONTROL_PORT_ETHERTYPE)
+	C2S(NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT)
+
+	C2S(NL80211_ATTR_SUPPORT_IBSS_RSN)
+
+	C2S(NL80211_ATTR_WIPHY_ANTENNA_TX)
+	C2S(NL80211_ATTR_WIPHY_ANTENNA_RX)
+
+	C2S(NL80211_ATTR_MCAST_RATE)
+
+	C2S(NL80211_ATTR_OFFCHANNEL_TX_OK)
+
+	C2S(NL80211_ATTR_BSS_HT_OPMODE)
+
+	C2S(NL80211_ATTR_KEY_DEFAULT_TYPES)
+
+	C2S(NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION)
+
+	C2S(NL80211_ATTR_MESH_SETUP)
+
+	C2S(NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX)
+	C2S(NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX)
+
+	C2S(NL80211_ATTR_SUPPORT_MESH_AUTH)
+	C2S(NL80211_ATTR_STA_PLINK_STATE)
+
+	C2S(NL80211_ATTR_WOWLAN_TRIGGERS)
+	C2S(NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED)
+
+	C2S(NL80211_ATTR_SCHED_SCAN_INTERVAL)
+
+	C2S(NL80211_ATTR_INTERFACE_COMBINATIONS)
+	C2S(NL80211_ATTR_SOFTWARE_IFTYPES)
+
+	C2S(NL80211_ATTR_REKEY_DATA)
+
+	C2S(NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS)
+	C2S(NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN)
+
+	C2S(NL80211_ATTR_SCAN_SUPP_RATES)
+
+	C2S(NL80211_ATTR_HIDDEN_SSID)
+
+	C2S(NL80211_ATTR_IE_PROBE_RESP)
+	C2S(NL80211_ATTR_IE_ASSOC_RESP)
+
+	C2S(NL80211_ATTR_STA_WME)
+	C2S(NL80211_ATTR_SUPPORT_AP_UAPSD)
+
+	C2S(NL80211_ATTR_ROAM_SUPPORT)
+
+	C2S(NL80211_ATTR_SCHED_SCAN_MATCH)
+	C2S(NL80211_ATTR_MAX_MATCH_SETS)
+
+	C2S(NL80211_ATTR_PMKSA_CANDIDATE)
+
+	C2S(NL80211_ATTR_TX_NO_CCK_RATE)
+
+	C2S(NL80211_ATTR_TDLS_ACTION)
+	C2S(NL80211_ATTR_TDLS_DIALOG_TOKEN)
+	C2S(NL80211_ATTR_TDLS_OPERATION)
+	C2S(NL80211_ATTR_TDLS_SUPPORT)
+	C2S(NL80211_ATTR_TDLS_EXTERNAL_SETUP)
+
+	C2S(NL80211_ATTR_DEVICE_AP_SME)
+
+	C2S(NL80211_ATTR_DONT_WAIT_FOR_ACK)
+
+	C2S(NL80211_ATTR_FEATURE_FLAGS)
+
+	C2S(NL80211_ATTR_PROBE_RESP_OFFLOAD)
+
+	C2S(NL80211_ATTR_PROBE_RESP)
+
+	C2S(NL80211_ATTR_DFS_REGION)
+
+	C2S(NL80211_ATTR_DISABLE_HT)
+	C2S(NL80211_ATTR_HT_CAPABILITY_MASK)
+
+	C2S(NL80211_ATTR_NOACK_MAP)
+
+	C2S(NL80211_ATTR_INACTIVITY_TIMEOUT)
+
+	C2S(NL80211_ATTR_RX_SIGNAL_DBM)
+
+	C2S(NL80211_ATTR_BG_SCAN_PERIOD)
+
+	C2S(NL80211_ATTR_WDEV)
+
+	C2S(NL80211_ATTR_USER_REG_HINT_TYPE)
+
+	C2S(NL80211_ATTR_CONN_FAILED_REASON)
+
+	C2S(NL80211_ATTR_SAE_DATA)
+
+	C2S(NL80211_ATTR_VHT_CAPABILITY)
+
+	C2S(NL80211_ATTR_SCAN_FLAGS)
+
+	C2S(NL80211_ATTR_CHANNEL_WIDTH)
+	C2S(NL80211_ATTR_CENTER_FREQ1)
+	C2S(NL80211_ATTR_CENTER_FREQ2)
+
+	C2S(NL80211_ATTR_P2P_CTWINDOW)
+	C2S(NL80211_ATTR_P2P_OPPPS)
+
+	C2S(NL80211_ATTR_LOCAL_MESH_POWER_MODE)
+
+	C2S(NL80211_ATTR_ACL_POLICY)
+
+	C2S(NL80211_ATTR_MAC_ADDRS)
+
+	C2S(NL80211_ATTR_MAC_ACL_MAX)
+
+	C2S(NL80211_ATTR_RADAR_EVENT)
+
+	C2S(NL80211_ATTR_EXT_CAPA)
+	C2S(NL80211_ATTR_EXT_CAPA_MASK)
+
+	C2S(NL80211_ATTR_STA_CAPABILITY)
+	C2S(NL80211_ATTR_STA_EXT_CAPABILITY)
+
+	C2S(NL80211_ATTR_PROTOCOL_FEATURES)
+	C2S(NL80211_ATTR_SPLIT_WIPHY_DUMP)
+
+	C2S(NL80211_ATTR_DISABLE_VHT)
+	C2S(NL80211_ATTR_VHT_CAPABILITY_MASK)
+
+	C2S(NL80211_ATTR_MDID)
+	C2S(NL80211_ATTR_IE_RIC)
+
+	C2S(NL80211_ATTR_CRIT_PROT_ID)
+	C2S(NL80211_ATTR_MAX_CRIT_PROT_DURATION)
+
+	C2S(NL80211_ATTR_PEER_AID)
+
+	C2S(NL80211_ATTR_COALESCE_RULE)
+
+	C2S(NL80211_ATTR_CH_SWITCH_COUNT)
+	C2S(NL80211_ATTR_CH_SWITCH_BLOCK_TX)
+	C2S(NL80211_ATTR_CSA_IES)
+	C2S(NL80211_ATTR_CSA_C_OFF_BEACON)
+	C2S(NL80211_ATTR_CSA_C_OFF_PRESP)
+
+	C2S(NL80211_ATTR_RXMGMT_FLAGS)
+
+	C2S(NL80211_ATTR_STA_SUPPORTED_CHANNELS)
+
+	C2S(NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES)
+
+	C2S(NL80211_ATTR_HANDLE_DFS)
+
+	C2S(NL80211_ATTR_SUPPORT_5_MHZ)
+	C2S(NL80211_ATTR_SUPPORT_10_MHZ)
+
+	C2S(NL80211_ATTR_OPMODE_NOTIF)
+
+	C2S(NL80211_ATTR_VENDOR_ID)
+	C2S(NL80211_ATTR_VENDOR_SUBCMD)
+	C2S(NL80211_ATTR_VENDOR_DATA)
+	C2S(NL80211_ATTR_VENDOR_EVENTS)
+
+	C2S(NL80211_ATTR_QOS_MAP)
+    default:
+        return "NL80211_ATTR_UNKNOWN";
+    }
+}
+
+void WifiEvent::log() {
+    parse();
+
+    byte *data = (byte *)genlmsg_attrdata(mHeader, 0);
+    int len = genlmsg_attrlen(mHeader, 0);
+    ALOGV("cmd = %s, len = %d", get_cmdString(), len);
+    ALOGV("vendor_id = %04x, vendor_subcmd = %d", get_vendor_id(), get_vendor_subcmd());
+
+    for (int i = 0; i < len; i += 16) {
+        char line[81];
+        int linelen = min(16, len - i);
+        int offset = 0;
+        appendFmt(line, offset, "%02x", data[i]);
+        for (int j = 1; j < linelen; j++) {
+            appendFmt(line, offset, " %02x", data[i+j]);
+        }
+
+        for (int j = linelen; j < 16; j++) {
+            appendFmt(line, offset, "   ");
+        }
+
+        line[23] = '-';
+
+        appendFmt(line, offset, "  ");
+
+        for (int j = 0; j < linelen; j++) {
+            if (isprint(data[i+j])) {
+                appendFmt(line, offset, "%c", data[i+j]);
+            } else {
+                appendFmt(line, offset, "-");
+            }
+        }
+    }
+
+    for (unsigned i = 0; i < NL80211_ATTR_MAX_INTERNAL; i++) {
+        if (mAttributes[i] != NULL) {
+            ALOGD("found attribute %s", attributeToString(i));
+        }
+    }
+
+    ALOGV("-- End of message --");
+}
+
+const char *WifiEvent::get_cmdString() {
+    return cmdToString(get_cmd());
+}
+
+
+int WifiEvent::parse() {
+    if (mHeader != NULL) {
+        return WIFI_SUCCESS;
+    }
+    mHeader = (genlmsghdr *)nlmsg_data(nlmsg_hdr(mMsg));
+    int result = nla_parse(mAttributes, NL80211_ATTR_MAX_INTERNAL, genlmsg_attrdata(mHeader, 0),
+          genlmsg_attrlen(mHeader, 0), NULL);
+    return result;
+}
+
+int WifiRequest::create(int family, uint8_t cmd, int flags, int hdrlen) {
+    mMsg = nlmsg_alloc();
+    if (mMsg != NULL) {
+        genlmsg_put(mMsg, /* pid = */ 0, /* seq = */ 0, family,
+                hdrlen, flags, cmd, /* version = */ 0);
+        return WIFI_SUCCESS;
+    } else {
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+}
+
+int WifiRequest::create(uint32_t id, int subcmd) {
+    int res = create(NL80211_CMD_VENDOR);
+    if (res < 0) {
+        return res;
+    }
+
+    res = put_u32(NL80211_ATTR_VENDOR_ID, id);
+    if (res < 0) {
+        return res;
+    }
+
+    res = put_u32(NL80211_ATTR_VENDOR_SUBCMD, subcmd);
+    if (res < 0) {
+        return res;
+    }
+
+    if (mIface != -1) {
+        res = set_iface_id(mIface);
+    }
+
+    return res;
+}
+
+
+static int no_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+int WifiCommand::requestResponse() {
+    int err = create();                 /* create the message */
+    if (err < 0) {
+        return err;
+    }
+
+    return requestResponse(mMsg);
+}
+
+int WifiCommand::requestResponse(WifiRequest& request) {
+    int err = 0;
+
+    ALOGV("Wifi command request response");
+    struct nl_cb *cb = nl_cb_alloc(NL_CB_DEFAULT);
+    if (!cb)
+        goto out;
+
+    ALOGV("%s()::%d::Reached!!\n", __func__, __LINE__);	
+    err = nl_send_auto_complete(mInfo->cmd_sock, request.getMessage());    /* send message */
+    //err = nl_send_auto_complete(mInfo->cmd_handle, request.getMessage());    /* send message */
+    if (err < 0)
+        goto out;
+	ALOGV("%s()::%d::Reached!!\n", __func__, __LINE__);	
+
+    err = 1;
+
+    nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, no_seq_check, NULL);
+    nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &err);
+    nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &err);
+    nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &err);
+    nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, response_handler, this);
+
+    ALOGV("wifi nl_cb_set err = %d\n", err);
+    while (err > 0) {                   /* wait for reply */
+        int res = nl_recvmsgs(mInfo->cmd_sock, cb);
+        //int res = nl_recvmsgs(mInfo->cmd_handle, cb);
+        if (res) {
+            ALOGE("nl80211: %s->nl_recvmsgs failed: %d", __func__, res);
+        }
+    }
+out:
+    ALOGV("%s()::%d::Reached!! return value = %d\n", __func__, __LINE__, err);
+    nl_cb_put(cb);
+    return err;
+}
+
+int WifiCommand::requestEvent(int cmd) {
+
+    ALOGV("requesting event %d", cmd);
+    int res = wifi_register_handler(wifiHandle(), cmd, event_handler, this);
+    if (res < 0) {
+        return res;
+    }
+
+    res = create();                                                 /* create the message */
+    if (res < 0)
+        goto out;
+
+    ALOGV("waiting for response %d", cmd);
+    res = nl_send_auto_complete(mInfo->cmd_sock, mMsg.getMessage());    /* send message */
+    //res = nl_send_auto_complete(mInfo->cmd_handle, mMsg.getMessage());    /* send message */
+    if (res < 0)
+        goto out;
+
+    ALOGV("waiting for event %d", cmd);
+    res = mCondition.wait();
+    if (res < 0)
+        goto out;
+
+out:
+    wifi_unregister_handler(wifiHandle(), cmd);
+    return res;
+}
+
+int WifiCommand::requestVendorEvent(uint32_t id, int subcmd) {
+
+    int res = wifi_register_vendor_handler(wifiHandle(), id, subcmd, event_handler, this);
+    if (res < 0) {
+        return res;
+    }
+
+    res = create();                                                 /* create the message */
+    if (res < 0)
+        goto out;
+
+    res = nl_send_auto_complete(mInfo->cmd_sock, mMsg.getMessage());    /* send message */
+    //res = nl_send_auto_complete(mInfo->cmd_handle, mMsg.getMessage());    /* send message */
+    if (res < 0)
+        goto out;
+
+    res = mCondition.wait();
+    if (res < 0)
+        goto out;
+
+out:
+    wifi_unregister_vendor_handler(wifiHandle(), id, subcmd);
+    return res;
+}
+
+/* Event handlers */
+int WifiCommand::response_handler(struct nl_msg *msg, void *arg) {
+    WifiCommand *cmd = (WifiCommand *)arg;
+    WifiEvent reply(msg);
+    int res = reply.parse();
+    if (res < 0) {
+        ALOGE("Failed to parse reply message = %d", res);
+        return NL_SKIP;
+    } else {
+        return cmd->handleResponse(reply);
+    }
+}
+
+int WifiCommand::event_handler(struct nl_msg *msg, void *arg) {
+    WifiCommand *cmd = (WifiCommand *)arg;
+    WifiEvent event(msg);
+    int res = event.parse();
+    if (res < 0) {
+        ALOGE("Failed to parse event = %d", res);
+        res = NL_SKIP;
+    } else {
+        res = cmd->handleEvent(event);
+    }
+
+    cmd->mCondition.signal();
+    return res;
+}
+
+/* Other event handlers */
+int WifiCommand::valid_handler(struct nl_msg *msg, void *arg) {
+    int *err = (int *)arg;
+    *err = 0;
+    return NL_SKIP;
+}
+
+int WifiCommand::ack_handler(struct nl_msg *msg, void *arg) {
+    int *err = (int *)arg;
+    *err = 0;
+    return NL_STOP;
+}
+
+int WifiCommand::finish_handler(struct nl_msg *msg, void *arg) {
+    int *ret = (int *)arg;
+    *ret = 0;
+    return NL_SKIP;
+}
+
+int WifiCommand::error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err, void *arg) {
+    int *ret = (int *)arg;
+    *ret = err->error;
+
+    return NL_SKIP;
+}
diff --git a/88x9098/wlan/hal/wifi_hal/cpp_bindings.h b/88x9098/wlan/hal/wifi_hal/cpp_bindings.h
new file mode 100644
index 0000000..debf7ae
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/cpp_bindings.h
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "wifi_hal.h"
+#include "common.h"
+
+class WifiEvent
+{
+    /* TODO: remove this when nl headers are updated */
+    static const unsigned NL80211_ATTR_MAX_INTERNAL = 256;
+private:
+    struct nl_msg *mMsg;
+    struct genlmsghdr *mHeader;
+    struct nlattr *mAttributes[NL80211_ATTR_MAX_INTERNAL + 1];
+
+public:
+    WifiEvent(nl_msg *msg) {
+        mMsg = msg;
+        mHeader = NULL;
+        memset(mAttributes, 0, sizeof(mAttributes));
+    }
+    ~WifiEvent() {
+        /* don't destroy mMsg; it doesn't belong to us */
+    }
+
+    void log();
+
+    int parse();
+
+    genlmsghdr *header() {
+        return mHeader;
+    }
+
+    int get_cmd() {
+        return mHeader->cmd;
+    }
+
+    int get_vendor_id() {
+        return get_u32(NL80211_ATTR_VENDOR_ID);
+    }
+
+    int get_vendor_subcmd() {
+        return get_u32(NL80211_ATTR_VENDOR_SUBCMD);
+    }
+
+    void *get_vendor_data() {
+        return get_data(NL80211_ATTR_VENDOR_DATA);
+    }
+
+    int get_vendor_data_len() {
+        return get_len(NL80211_ATTR_VENDOR_DATA);
+    }
+
+    const char *get_cmdString();
+
+    nlattr ** attributes() {
+        return mAttributes;
+    }
+
+    nlattr *get_attribute(int attribute) {
+        return mAttributes[attribute];
+    }
+
+    uint8_t get_u8(int attribute) {
+        return mAttributes[attribute] ? nla_get_u8(mAttributes[attribute]) : 0;
+    }
+
+    uint16_t get_u16(int attribute) {
+        return mAttributes[attribute] ? nla_get_u16(mAttributes[attribute]) : 0;
+    }
+
+    uint32_t get_u32(int attribute) {
+        return mAttributes[attribute] ? nla_get_u32(mAttributes[attribute]) : 0;
+    }
+
+    uint64_t get_u64(int attribute) {
+        return mAttributes[attribute] ? nla_get_u64(mAttributes[attribute]) : 0;
+    }
+
+    int get_len(int attribute) {
+        return mAttributes[attribute] ? nla_len(mAttributes[attribute]) : 0;
+    }
+
+    void *get_data(int attribute) {
+        return mAttributes[attribute] ? nla_data(mAttributes[attribute]) : NULL;
+    }
+
+private:
+    WifiEvent(const WifiEvent&);        // hide copy constructor to prevent copies
+};
+
+class nl_iterator {
+    struct nlattr *pos;
+    int rem;
+public:
+    nl_iterator(struct nlattr *attr) {
+        pos = (struct nlattr *)nla_data(attr);
+        rem = nla_len(attr);
+    }
+    bool has_next() {
+        return nla_ok(pos, rem);
+    }
+    void next() {
+        pos = (struct nlattr *)nla_next(pos, &(rem));
+    }
+    struct nlattr *get() {
+        return pos;
+    }
+    uint16_t get_type() {
+        return pos->nla_type;
+    }
+    uint8_t get_u8() {
+        return nla_get_u8(pos);
+    }
+    uint16_t get_u16() {
+        return nla_get_u16(pos);
+    }
+    uint32_t get_u32() {
+        return nla_get_u32(pos);
+    }
+    uint64_t get_u64() {
+        return nla_get_u64(pos);
+    }
+    void* get_data() {
+        return nla_data(pos);
+    }
+    int get_len() {
+        return nla_len(pos);
+    }
+private:
+    nl_iterator(const nl_iterator&);    // hide copy constructor to prevent copies
+};
+
+class WifiRequest
+{
+private:
+    int mFamily;
+    int mIface;
+    struct nl_msg *mMsg;
+
+public:
+    WifiRequest(int family) {
+        mMsg = NULL;
+        mFamily = family;
+        mIface = -1;
+    }
+
+    WifiRequest(int family, int iface) {
+        mMsg = NULL;
+        mFamily = family;
+        mIface = iface;
+    }
+
+    ~WifiRequest() {
+        destroy();
+    }
+
+    void destroy() {
+        if (mMsg) {
+            nlmsg_free(mMsg);
+            mMsg = NULL;
+        }
+    }
+
+    nl_msg *getMessage() {
+        return mMsg;
+    }
+
+    /* Command assembly helpers */
+    int create(int family, uint8_t cmd, int flags, int hdrlen);
+    int create(uint8_t cmd) {
+        return create(mFamily, cmd, 0, 0);
+    }
+
+    int create(uint32_t id, int subcmd);
+
+    int put(int attribute, void *ptr, unsigned len) {
+        return nla_put(mMsg, attribute, len, ptr);
+    }
+    int put_u8(int attribute, uint8_t value) {
+        return nla_put(mMsg, attribute, sizeof(value), &value);
+    }
+    int put_s8(int attribute, s8 value) {
+        s8 tmp = value;
+        return nla_put(mMsg, attribute, sizeof(s8), &tmp);
+    }
+    int put_u16(int attribute, uint16_t value) {
+        return nla_put(mMsg, attribute, sizeof(value), &value);
+    }
+    int put_u32(int attribute, uint32_t value) {
+        return nla_put(mMsg, attribute, sizeof(value), &value);
+    }
+    int put_u64(int attribute, uint64_t value) {
+        return nla_put(mMsg, attribute, sizeof(value), &value);
+    }
+    int put_string(int attribute, const char *value) {
+        return nla_put(mMsg, attribute, strlen(value) + 1, value);
+    }
+    int put_addr(int attribute, mac_addr value) {
+        return nla_put(mMsg, attribute, sizeof(mac_addr), value);
+    }
+
+    struct nlattr * attr_start(int attribute) {
+        return nla_nest_start(mMsg, attribute | NLA_F_NESTED);
+    }
+    void attr_end(struct nlattr *attr) {
+        nla_nest_end(mMsg, attr);
+    }
+
+    int set_iface_id(int ifindex) {
+        return put_u32(NL80211_ATTR_IFINDEX, ifindex);
+    }
+private:
+    WifiRequest(const WifiRequest&);        // hide copy constructor to prevent copies
+
+};
+
+class WifiCommand
+{
+protected:
+    const char *mType;
+    hal_info *mInfo;
+    WifiRequest mMsg;
+    Condition mCondition;
+    wifi_request_id mId;
+    interface_info *mIfaceInfo;
+    int mRefs;
+public:
+    WifiCommand(const char *type, wifi_handle handle, wifi_request_id id)
+            : mType(type), mMsg(getHalInfo(handle)->nl80211_family_id), mId(id), mRefs(1)
+    {
+        mIfaceInfo = NULL;
+        mInfo = getHalInfo(handle);
+        // ALOGD("WifiCommand %p created, mInfo = %p, mIfaceInfo = %p", this, mInfo, mIfaceInfo);
+    }
+
+    WifiCommand(const char *type, wifi_interface_handle iface, wifi_request_id id)
+            : mType(type), mMsg(getHalInfo(iface)->nl80211_family_id, getIfaceInfo(iface)->id),
+            mId(id), mRefs(1)
+    {
+        mIfaceInfo = getIfaceInfo(iface);
+        mInfo = getHalInfo(iface);
+        // ALOGD("WifiCommand %p created, mInfo = %p, mIfaceInfo = %p", this, mInfo, mIfaceInfo);
+    }
+
+    virtual ~WifiCommand() {
+        // ALOGD("WifiCommand %p destroyed", this);
+    }
+
+    wifi_request_id id() {
+        return mId;
+    }
+
+    const char *getType() {
+        return mType;
+    }
+
+    virtual void addRef() {
+        __sync_add_and_fetch(&mRefs, 1);
+        // ALOGD("addRef: WifiCommand %p has %d references", this, refs);
+    }
+
+    virtual void releaseRef() {
+        int refs = __sync_sub_and_fetch(&mRefs, 1);
+        if (refs == 0) {
+            delete this;
+        } else {
+            // ALOGD("releaseRef: WifiCommand %p has %d references", this, refs);
+        }
+    }
+
+    virtual int create() {
+        /* by default there is no way to cancel */
+        ALOGD("WifiCommand %p can't be created", this);
+        return WIFI_ERROR_NOT_SUPPORTED;
+    }
+
+    virtual int cancel() {
+        /* by default there is no way to cancel */
+        return WIFI_ERROR_NOT_SUPPORTED;
+    }
+
+    int requestResponse();
+    int requestEvent(int cmd);
+    int requestVendorEvent(uint32_t id, int subcmd);
+    int requestResponse(WifiRequest& request);
+
+protected:
+    wifi_handle wifiHandle() {
+        return getWifiHandle(mInfo);
+    }
+
+    wifi_interface_handle ifaceHandle() {
+        return getIfaceHandle(mIfaceInfo);
+    }
+
+    int familyId() {
+        return mInfo->nl80211_family_id;
+    }
+
+    int ifaceId() {
+        return mIfaceInfo->id;
+    }
+
+    /* Override this method to parse reply and dig out data; save it in the object */
+    virtual int handleResponse(WifiEvent& reply) {
+        ALOGI("skipping a response");
+        return NL_SKIP;
+    }
+
+    /* Override this method to parse event and dig out data; save it in the object */
+    virtual int handleEvent(WifiEvent& event) {
+        ALOGI("skipping an event");
+        return NL_SKIP;
+    }
+
+    int registerHandler(int cmd) {
+        return wifi_register_handler(wifiHandle(), cmd, &event_handler, this);
+    }
+
+    void unregisterHandler(int cmd) {
+        wifi_unregister_handler(wifiHandle(), cmd);
+    }
+
+    int registerVendorHandler(uint32_t id, int subcmd) {
+        return wifi_register_vendor_handler(wifiHandle(), id, subcmd, &event_handler, this);
+    }
+
+    void unregisterVendorHandler(uint32_t id, int subcmd) {
+        wifi_unregister_vendor_handler(wifiHandle(), id, subcmd);
+    }
+
+private:
+    WifiCommand(const WifiCommand& );           // hide copy constructor to prevent copies
+
+    /* Event handling */
+    static int response_handler(struct nl_msg *msg, void *arg);
+
+    static int event_handler(struct nl_msg *msg, void *arg);
+
+    /* Other event handlers */
+    static int valid_handler(struct nl_msg *msg, void *arg);
+
+    static int ack_handler(struct nl_msg *msg, void *arg);
+
+    static int finish_handler(struct nl_msg *msg, void *arg);
+
+    static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err, void *arg);
+};
+
+/* nl message processing macros (required to pass C++ type checks) */
+
+#define for_each_attr(pos, nla, rem) \
+    for (pos = (nlattr *)nla_data(nla), rem = nla_len(nla); \
+        nla_ok(pos, rem); \
+        pos = (nlattr *)nla_next(pos, &(rem)))
+
diff --git a/88x9098/wlan/hal/wifi_hal/gscan.cpp b/88x9098/wlan/hal/wifi_hal/gscan.cpp
new file mode 100644
index 0000000..a4928b1
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/gscan.cpp
@@ -0,0 +1,1852 @@
+/*
+* Copyright (C) 2017 The Android Open Source Project
+* Portions copyright (C) 2017 Broadcom Limited
+* Portions copyright 2015-2020 NXP
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include "common.h"
+
+#define LOG_TAG  "WifiHAL"
+//#define LOG_NDEBUG 0         //uncomment to enable verbose logging
+
+#include <utils/Log.h>
+
+#include "wifi_hal.h"
+#include "cpp_bindings.h"
+
+typedef enum {
+
+    GSCAN_ATTRIBUTE_NUM_BUCKETS = 10,
+    GSCAN_ATTRIBUTE_BASE_PERIOD,
+    GSCAN_ATTRIBUTE_BUCKETS_BAND,
+    GSCAN_ATTRIBUTE_BUCKET_ID,
+    GSCAN_ATTRIBUTE_BUCKET_PERIOD,
+    GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS,
+    GSCAN_ATTRIBUTE_BUCKET_CHANNELS,
+    GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN,
+    GSCAN_ATTRIBUTE_REPORT_THRESHOLD,
+    GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE,
+    GSCAN_ATTRIBUTE_BAND = GSCAN_ATTRIBUTE_BUCKETS_BAND,
+
+    GSCAN_ATTRIBUTE_ENABLE_FEATURE = 20,
+    GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE,              /* indicates no more results */
+    GSCAN_ATTRIBUTE_FLUSH_FEATURE,                      /* Flush all the configs */
+    GSCAN_ENABLE_FULL_SCAN_RESULTS,
+    GSCAN_ATTRIBUTE_REPORT_EVENTS,
+
+    /* remaining reserved for additional attributes */
+    GSCAN_ATTRIBUTE_NUM_OF_RESULTS = 30,
+    GSCAN_ATTRIBUTE_FLUSH_RESULTS,
+    GSCAN_ATTRIBUTE_SCAN_RESULTS,                       /* flat array of wifi_scan_result */
+    GSCAN_ATTRIBUTE_SCAN_ID,                            /* indicates scan number */
+    GSCAN_ATTRIBUTE_SCAN_FLAGS,                         /* indicates if scan was aborted */
+    GSCAN_ATTRIBUTE_AP_FLAGS,                           /* flags on significant change event */
+    GSCAN_ATTRIBUTE_NUM_CHANNELS,
+    GSCAN_ATTRIBUTE_CHANNEL_LIST,
+    GSCAN_ATTRIBUTE_CH_BUCKET_BITMASK,
+    /* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_SSID = 40,
+    GSCAN_ATTRIBUTE_BSSID,
+    GSCAN_ATTRIBUTE_CHANNEL,
+    GSCAN_ATTRIBUTE_RSSI,
+    GSCAN_ATTRIBUTE_TIMESTAMP,
+    GSCAN_ATTRIBUTE_RTT,
+    GSCAN_ATTRIBUTE_RTTSD,
+
+    /* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_HOTLIST_BSSIDS = 50,
+    GSCAN_ATTRIBUTE_RSSI_LOW,
+    GSCAN_ATTRIBUTE_RSSI_HIGH,
+    GSCAN_ATTRIBUTE_HOTLIST_ELEM,
+    GSCAN_ATTRIBUTE_HOTLIST_FLUSH,
+    GSCAN_ATTRIBUTE_HOTLIST_BSSID_COUNT,
+
+    /* remaining reserved for additional attributes */
+    GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE = 60,
+    GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE,
+    GSCAN_ATTRIBUTE_MIN_BREACHING,
+    GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS,
+    GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH,
+
+    /* EPNO */
+    GSCAN_ATTRIBUTE_EPNO_SSID_LIST = 70,
+    GSCAN_ATTRIBUTE_EPNO_SSID,
+    GSCAN_ATTRIBUTE_EPNO_SSID_LEN,
+    GSCAN_ATTRIBUTE_EPNO_RSSI,
+    GSCAN_ATTRIBUTE_EPNO_FLAGS,
+    GSCAN_ATTRIBUTE_EPNO_AUTH,
+    GSCAN_ATTRIBUTE_EPNO_SSID_NUM,
+    GSCAN_ATTRIBUTE_EPNO_FLUSH,
+
+    /* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_WHITELIST_SSID = 80,
+    GSCAN_ATTRIBUTE_NUM_WL_SSID,
+    GSCAN_ATTRIBUTE_WL_SSID_LEN,
+    GSCAN_ATTRIBUTE_WL_SSID_FLUSH,
+    GSCAN_ATTRIBUTE_WHITELIST_SSID_ELEM,
+    GSCAN_ATTRIBUTE_NUM_BSSID,
+    GSCAN_ATTRIBUTE_BSSID_PREF_LIST,
+    GSCAN_ATTRIBUTE_BSSID_PREF_FLUSH,
+    GSCAN_ATTRIBUTE_BSSID_PREF,
+    GSCAN_ATTRIBUTE_RSSI_MODIFIER,
+
+    /* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_A_BAND_BOOST_THRESHOLD = 90,
+    GSCAN_ATTRIBUTE_A_BAND_PENALTY_THRESHOLD,
+    GSCAN_ATTRIBUTE_A_BAND_BOOST_FACTOR,
+    GSCAN_ATTRIBUTE_A_BAND_PENALTY_FACTOR,
+    GSCAN_ATTRIBUTE_A_BAND_MAX_BOOST,
+    GSCAN_ATTRIBUTE_LAZY_ROAM_HYSTERESIS,
+    GSCAN_ATTRIBUTE_ALERT_ROAM_RSSI_TRIGGER,
+    GSCAN_ATTRIBUTE_LAZY_ROAM_ENABLE,
+
+    /* BSSID blacklist */
+    GSCAN_ATTRIBUTE_BSSID_BLACKLIST_FLUSH = 100,
+    GSCAN_ATTRIBUTE_BLACKLIST_BSSID,
+
+    /* ANQPO */
+    GSCAN_ATTRIBUTE_ANQPO_HS_LIST = 110,
+    GSCAN_ATTRIBUTE_ANQPO_HS_LIST_SIZE,
+    GSCAN_ATTRIBUTE_ANQPO_HS_NETWORK_ID,
+    GSCAN_ATTRIBUTE_ANQPO_HS_NAI_REALM,
+    GSCAN_ATTRIBUTE_ANQPO_HS_ROAM_CONSORTIUM_ID,
+    GSCAN_ATTRIBUTE_ANQPO_HS_PLMN,
+
+    /* Adaptive scan attributes */
+    GSCAN_ATTRIBUTE_BUCKET_STEP_COUNT = 120,
+    GSCAN_ATTRIBUTE_BUCKET_MAX_PERIOD,
+
+    /* ePNO cfg */
+    GSCAN_ATTRIBUTE_EPNO_5G_RSSI_THR = 130,
+    GSCAN_ATTRIBUTE_EPNO_2G_RSSI_THR,
+    GSCAN_ATTRIBUTE_EPNO_INIT_SCORE_MAX,
+    GSCAN_ATTRIBUTE_EPNO_CUR_CONN_BONUS,
+    GSCAN_ATTRIBUTE_EPNO_SAME_NETWORK_BONUS,
+    GSCAN_ATTRIBUTE_EPNO_SECURE_BONUS,
+    GSCAN_ATTRIBUTE_EPNO_5G_BONUS,
+
+    GSCAN_ATTRIBUTE_MAX
+
+} GSCAN_ATTRIBUTE;
+
+
+// helper methods
+wifi_error wifi_enable_full_scan_results(wifi_request_id id, wifi_interface_handle iface,
+         wifi_scan_result_handler handler);
+wifi_error wifi_disable_full_scan_results(wifi_request_id id, wifi_interface_handle iface);
+int wifi_handle_full_scan_event(wifi_request_id id, WifiEvent& event,
+         wifi_scan_result_handler handler);
+void convert_to_hal_result(wifi_scan_result *to, wifi_gscan_result_t *from);
+
+
+void convert_to_hal_result(wifi_scan_result *to, wifi_gscan_result_t *from)
+{
+    to->ts = from->ts;
+    to->channel = from->channel;
+    to->rssi = from->rssi;
+    to->rtt = from->rtt;
+    to->rtt_sd = from->rtt_sd;
+    to->beacon_period = from->beacon_period;
+    to->capability = from->capability;
+    memcpy(to->ssid, from->ssid, (DOT11_MAX_SSID_LEN+1));
+    memcpy(&to->bssid, &from->bssid, sizeof(mac_addr));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+class GetCapabilitiesCommand : public WifiCommand
+{
+    wifi_gscan_capabilities *mCapabilities;
+public:
+    GetCapabilitiesCommand(wifi_interface_handle iface, wifi_gscan_capabilities *capabitlites)
+        : WifiCommand("GetGscanCapabilitiesCommand", iface, 0), mCapabilities(capabitlites)
+    {
+        memset(mCapabilities, 0, sizeof(*mCapabilities));
+    }
+
+    virtual int create() {
+        ALOGV("Creating message to get scan capablities; iface = %d", mIfaceInfo->id);
+
+        int ret = mMsg.create(GOOGLE_OUI, GSCAN_SUBCMD_GET_CAPABILITIES);
+        if (ret < 0) {
+            return ret;
+        }
+
+        return ret;
+    }
+
+protected:
+    virtual int handleResponse(WifiEvent& reply) {
+
+        ALOGV("In GetCapabilities::handleResponse");
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGD("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        int id = reply.get_vendor_id();
+        int subcmd = reply.get_vendor_subcmd();
+
+        void *data = reply.get_vendor_data();
+        int len = reply.get_vendor_data_len();
+
+        ALOGV("Id = %0x, subcmd = %d, len = %d, expected len = %d", id, subcmd, len,
+                    sizeof(*mCapabilities));
+
+        memcpy(mCapabilities, data, min(len, (int) sizeof(*mCapabilities)));
+
+        return NL_OK;
+    }
+};
+
+
+wifi_error wifi_get_gscan_capabilities(wifi_interface_handle handle,
+        wifi_gscan_capabilities *capabilities)
+{
+    GetCapabilitiesCommand command(handle, capabilities);
+    return (wifi_error) command.requestResponse();
+}
+
+class GetChannelListCommand : public WifiCommand
+{
+    wifi_channel *channels;
+    int max_channels;
+    int *num_channels;
+    int band;
+public:
+    GetChannelListCommand(wifi_interface_handle iface, wifi_channel *channel_buf, int *ch_num,
+        int num_max_ch, int band)
+        : WifiCommand("GetChannelListCommand", iface, 0), channels(channel_buf),
+            max_channels(num_max_ch), num_channels(ch_num), band(band)
+    {
+        memset(channels, 0, sizeof(wifi_channel) * max_channels);
+    }
+    virtual int create() {
+        ALOGV("Creating message to get channel list; iface = %d", mIfaceInfo->id);
+
+        int ret = mMsg.create(GOOGLE_OUI, GSCAN_SUBCMD_GET_CHANNEL_LIST);
+        if (ret < 0) {
+            return ret;
+        }
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(GSCAN_ATTRIBUTE_BAND, band);
+        if (ret < 0) {
+            return ret;
+        }
+
+        mMsg.attr_end(data);
+
+        return ret;
+    }
+
+protected:
+    virtual int handleResponse(WifiEvent& reply) {
+
+        ALOGV("In GetChannelList::handleResponse");
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGD("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        int id = reply.get_vendor_id();
+        int subcmd = reply.get_vendor_subcmd();
+        int num_channels_to_copy = 0;
+
+        nlattr *vendor_data = reply.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        int len = reply.get_vendor_data_len();
+
+        ALOGV("Id = %0x, subcmd = %d, len = %d", id, subcmd, len);
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("no vendor data in GetChannelList response; ignoring it");
+            return NL_SKIP;
+        }
+
+        for (nl_iterator it(vendor_data); it.has_next(); it.next()) {
+            if (it.get_type() == GSCAN_ATTRIBUTE_NUM_CHANNELS) {
+                num_channels_to_copy = it.get_u32();
+                ALOGI("Got channel list with %d channels", num_channels_to_copy);
+                if(num_channels_to_copy > max_channels)
+                    num_channels_to_copy = max_channels;
+                *num_channels = num_channels_to_copy;
+            } else if (it.get_type() == GSCAN_ATTRIBUTE_CHANNEL_LIST && num_channels_to_copy) {
+                memcpy(channels, it.get_data(), sizeof(int) * num_channels_to_copy);
+            } else {
+                ALOGW("Ignoring invalid attribute type = %d, size = %d",
+                        it.get_type(), it.get_len());
+            }
+        }
+
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_get_valid_channels(wifi_interface_handle handle,
+        int band, int max_channels, wifi_channel *channels, int *num_channels)
+{
+    GetChannelListCommand command(handle, channels, num_channels,
+                                        max_channels, band);
+    return (wifi_error) command.requestResponse();
+}
+/////////////////////////////////////////////////////////////////////////////
+
+/* helper functions */
+
+static int parseScanResults(wifi_scan_result *results, int num, nlattr *attr)
+{
+    memset(results, 0, sizeof(wifi_scan_result) * num);
+
+    int i = 0;
+    for (nl_iterator it(attr); it.has_next() && i < num; it.next(), i++) {
+
+        int index = it.get_type();
+        ALOGI("retrieved scan result %d", index);
+        nlattr *sc_data = (nlattr *) it.get_data();
+        wifi_scan_result *result = results + i;
+
+        for (nl_iterator it2(sc_data); it2.has_next(); it2.next()) {
+            int type = it2.get_type();
+            if (type == GSCAN_ATTRIBUTE_SSID) {
+                strncpy(result->ssid, (char *) it2.get_data(), it2.get_len());
+                result->ssid[it2.get_len()] = 0;
+            } else if (type == GSCAN_ATTRIBUTE_BSSID) {
+                memcpy(result->bssid, (byte *) it2.get_data(), sizeof(mac_addr));
+            } else if (type == GSCAN_ATTRIBUTE_TIMESTAMP) {
+                result->ts = it2.get_u64();
+            } else if (type == GSCAN_ATTRIBUTE_CHANNEL) {
+                result->ts = it2.get_u16();
+            } else if (type == GSCAN_ATTRIBUTE_RSSI) {
+                result->rssi = it2.get_u8();
+            } else if (type == GSCAN_ATTRIBUTE_RTT) {
+                result->rtt = it2.get_u64();
+            } else if (type == GSCAN_ATTRIBUTE_RTTSD) {
+                result->rtt_sd = it2.get_u64();
+            }
+        }
+
+    }
+
+    if (i >= num) {
+        ALOGE("Got too many results; skipping some");
+    }
+
+    return i;
+}
+
+int createFeatureRequest(WifiRequest& request, int subcmd, int enable) {
+
+    int result = request.create(GOOGLE_OUI, subcmd);
+    if (result < 0) {
+        return result;
+    }
+
+    nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+    result = request.put_u32(GSCAN_ATTRIBUTE_ENABLE_FEATURE, enable);
+    if (result < 0) {
+        return result;
+    }
+
+    request.attr_end(data);
+    return WIFI_SUCCESS;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+class FullScanResultsCommand : public WifiCommand
+{
+    int *mParams;
+    wifi_scan_result_handler mHandler;
+public:
+    FullScanResultsCommand(wifi_interface_handle iface, int id, int *params,
+                wifi_scan_result_handler handler)
+        : WifiCommand("FullScanResultsCommand", iface, id), mParams(params), mHandler(handler)
+    { }
+
+    int createRequest(WifiRequest& request, int subcmd, int enable) {
+        int result = request.create(GOOGLE_OUI, subcmd);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u32(GSCAN_ENABLE_FULL_SCAN_RESULTS, enable);
+        if (result < 0) {
+            return result;
+        }
+
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+
+    }
+
+    int start() {
+        ALOGV("Enabling Full scan results");
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request, GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS, 1);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+            return result;
+        }
+
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_FULL_SCAN_RESULTS);
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to enable full scan results; result = %d", result);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_FULL_SCAN_RESULTS);
+            return result;
+        }
+
+        return result;
+    }
+
+    virtual int cancel() {
+        ALOGV("Disabling Full scan results");
+
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request, GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS, 0);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to disable full scan results;result = %d", result);
+            }
+        }
+
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_FULL_SCAN_RESULTS);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+         ALOGD("Request complete!");
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        ALOGV("Full scan results:  Got an event");
+        return wifi_handle_full_scan_event(id(), event, mHandler);
+    }
+
+};
+/////////////////////////////////////////////////////////////////////////////
+
+class ScanCommand : public WifiCommand
+{
+    wifi_scan_cmd_params *mParams;
+    wifi_scan_result_handler mHandler;
+public:
+    ScanCommand(wifi_interface_handle iface, int id, wifi_scan_cmd_params *params,
+                wifi_scan_result_handler handler)
+        : WifiCommand("ScanCommand", iface, id), mParams(params), mHandler(handler)
+    { }
+
+    int createSetupRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_CONFIG);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u32(GSCAN_ATTRIBUTE_BASE_PERIOD, mParams->base_period);
+        if (result < 0) {
+            return result;
+        }
+
+        result = request.put_u32(GSCAN_ATTRIBUTE_NUM_BUCKETS, mParams->num_buckets);
+        if (result < 0) {
+            return result;
+        }
+
+        for (int i = 0; i < mParams->num_buckets; i++) {
+            nlattr * bucket = request.attr_start(i);    // next bucket
+            result = request.put_u32(GSCAN_ATTRIBUTE_BUCKET_ID, mParams->buckets[i].bucket);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_BUCKET_PERIOD, mParams->buckets[i].period);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_BUCKETS_BAND,
+                    mParams->buckets[i].band);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_BUCKET_STEP_COUNT,
+                    mParams->buckets[i].step_count);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_BUCKET_MAX_PERIOD,
+                    mParams->buckets[i].max_period);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_REPORT_EVENTS,
+                    mParams->buckets[i].report_events);
+            if (result < 0) {
+                return result;
+            }
+
+            result = request.put_u32(GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS,
+                    mParams->buckets[i].num_channels);
+            if (result < 0) {
+                return result;
+            }
+
+            if (mParams->buckets[i].num_channels) {
+                nlattr *channels = request.attr_start(GSCAN_ATTRIBUTE_BUCKET_CHANNELS);
+                ALOGV(" channels: ");
+                for (int j = 0; j < mParams->buckets[i].num_channels; j++) {
+                    result = request.put_u32(j, mParams->buckets[i].channels[j].channel);
+                    ALOGV(" %u", mParams->buckets[i].channels[j].channel);
+
+                    if (result < 0) {
+                        return result;
+                    }
+                }
+                request.attr_end(channels);
+            }
+
+            request.attr_end(bucket);
+        }
+
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int createScanConfigRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_SCAN_CONFIG);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u32(GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN, mParams->max_ap_per_scan);
+        if (result < 0) {
+            return result;
+        }
+
+        result = request.put_u32(GSCAN_ATTRIBUTE_REPORT_THRESHOLD,
+                mParams->report_threshold_percent);
+        if (result < 0) {
+            return result;
+        }
+
+        int num_scans = mParams->report_threshold_num_scans;
+
+        result = request.put_u32(GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE, num_scans);
+        if (result < 0) {
+            return result;
+        }
+
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int createStartRequest(WifiRequest& request) {
+        return createFeatureRequest(request, GSCAN_SUBCMD_ENABLE_GSCAN, 1);
+    }
+
+    int createStopRequest(WifiRequest& request) {
+        return createFeatureRequest(request, GSCAN_SUBCMD_ENABLE_GSCAN, 0);
+    }
+
+    int start() {
+        ALOGV("GSCAN start");
+        WifiRequest request(familyId(), ifaceId());
+        int result = createSetupRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create setup request; result = %d", result);
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to configure setup; result = %d", result);
+            return result;
+        }
+
+        request.destroy();
+
+        result = createScanConfigRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create scan config request; result = %d", result);
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to configure scan; result = %d", result);
+            return result;
+        }
+
+        ALOGV(" ....starting scan");
+
+        result = createStartRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create start request; result = %d", result);
+            return result;
+        }
+
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_SCAN_RESULTS_AVAILABLE);
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_COMPLETE_SCAN);
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_FULL_SCAN_RESULTS);
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to start scan; result = %d", result);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_COMPLETE_SCAN);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_SCAN_RESULTS_AVAILABLE);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_FULL_SCAN_RESULTS);
+            return result;
+        }
+        return result;
+    }
+
+    virtual int cancel() {
+        ALOGV("Stopping scan");
+
+        WifiRequest request(familyId(), ifaceId());
+        int result = createStopRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create stop request; result = %d", result);
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to stop scan; result = %d", result);
+            }
+        }
+
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_COMPLETE_SCAN);
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_SCAN_RESULTS_AVAILABLE);
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_FULL_SCAN_RESULTS);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        ALOGV("Got a scan results event");
+        //event.log();
+
+        nlattr *vendor_data = event.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+        int event_id = event.get_vendor_subcmd();
+
+        if ((event_id == GSCAN_EVENT_COMPLETE_SCAN) ||
+            (event_id == GSCAN_EVENT_SCAN_RESULTS_AVAILABLE)) {
+            if (vendor_data == NULL || len != 4) {
+                ALOGI("Bad event data!");
+                return NL_SKIP;
+            }
+            wifi_scan_event evt_type;
+            evt_type = (wifi_scan_event) event.get_u32(NL80211_ATTR_VENDOR_DATA);
+            ALOGV("Received event type %d", evt_type);
+            if(*mHandler.on_scan_event)
+                (*mHandler.on_scan_event)(id(), evt_type);
+        } else if (event_id == GSCAN_EVENT_FULL_SCAN_RESULTS) {
+            wifi_handle_full_scan_event(id(), event, mHandler);
+        }
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_start_gscan(
+        wifi_request_id id,
+        wifi_interface_handle iface,
+        wifi_scan_cmd_params params,
+        wifi_scan_result_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+
+    ALOGV("Starting GScan, halHandle = %p", handle);
+
+    ScanCommand *cmd = new ScanCommand(iface, id, &params, handler);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error result = wifi_register_cmd(handle, id, cmd);
+    if (result != WIFI_SUCCESS) {
+        cmd->releaseRef();
+        return result;
+    }
+    result = (wifi_error)cmd->start();
+    if (result != WIFI_SUCCESS) {
+        wifi_unregister_cmd(handle, id);
+        cmd->releaseRef();
+        return result;
+    }
+    return result;
+}
+
+wifi_error wifi_stop_gscan(wifi_request_id id, wifi_interface_handle iface)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    ALOGV("Stopping GScan, wifi_request_id = %d, halHandle = %p", id, handle);
+
+    if (id == -1) {
+        wifi_scan_result_handler handler;
+        wifi_scan_cmd_params dummy_params;
+        wifi_handle handle = getWifiHandle(iface);
+        memset(&handler, 0, sizeof(handler));
+
+        ScanCommand *cmd = new ScanCommand(iface, id, &dummy_params, handler);
+        NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+        cmd->cancel();
+        cmd->releaseRef();
+        return WIFI_SUCCESS;
+    }
+
+    return wifi_cancel_cmd(id, iface);
+}
+
+wifi_error wifi_enable_full_scan_results(
+        wifi_request_id id,
+        wifi_interface_handle iface,
+        wifi_scan_result_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    int params_dummy;
+
+    ALOGV("Enabling full scan results, halHandle = %p", handle);
+
+    FullScanResultsCommand *cmd = new FullScanResultsCommand(iface, id, &params_dummy, handler);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error result = wifi_register_cmd(handle, id, cmd);
+    if (result != WIFI_SUCCESS) {
+        cmd->releaseRef();
+        return result;
+    }
+    result = (wifi_error)cmd->start();
+    if (result != WIFI_SUCCESS) {
+        wifi_unregister_cmd(handle, id);
+        cmd->releaseRef();
+        return result;
+    }
+    return result;
+}
+
+int wifi_handle_full_scan_event(
+        wifi_request_id id,
+        WifiEvent& event,
+        wifi_scan_result_handler handler)
+{
+    nlattr *vendor_data = event.get_attribute(NL80211_ATTR_VENDOR_DATA);
+    unsigned int len = event.get_vendor_data_len();
+
+    if (vendor_data == NULL || len < sizeof(wifi_gscan_full_result_t)) {
+        ALOGI("Full scan results: No scan results found");
+        return NL_SKIP;
+    }
+
+    wifi_gscan_full_result_t *drv_res = (wifi_gscan_full_result_t *)event.get_vendor_data();
+    /* To protect against corrupted data, put a ceiling */
+    int ie_len = min(MAX_PROBE_RESP_IE_LEN, drv_res->ie_length);
+    wifi_scan_result *full_scan_result;
+    wifi_gscan_result_t *fixed = &drv_res->fixed;
+
+    if ((ie_len + offsetof(wifi_gscan_full_result_t, ie_data)) > len) {
+        ALOGE("BAD event data, len %d ie_len %d fixed length %d!\n", len,
+            ie_len, offsetof(wifi_gscan_full_result_t, ie_data));
+        return NL_SKIP;
+    }
+    full_scan_result = (wifi_scan_result *) malloc((ie_len + offsetof(wifi_scan_result, ie_data)));
+    if (!full_scan_result) {
+        ALOGE("Full scan results: Can't malloc!\n");
+        return NL_SKIP;
+    }
+    convert_to_hal_result(full_scan_result, fixed);
+    full_scan_result->ie_length = ie_len;
+    memcpy(full_scan_result->ie_data, drv_res->ie_data, ie_len);
+    if(handler.on_full_scan_result)
+        handler.on_full_scan_result(id, full_scan_result, drv_res->scan_ch_bucket);
+
+    ALOGV("Full scan result: %-32s %02x:%02x:%02x:%02x:%02x:%02x %d %d %lld %lld %lld %x %d\n",
+        fixed->ssid, fixed->bssid[0], fixed->bssid[1], fixed->bssid[2], fixed->bssid[3],
+        fixed->bssid[4], fixed->bssid[5], fixed->rssi, fixed->channel, fixed->ts,
+        fixed->rtt, fixed->rtt_sd, drv_res->scan_ch_bucket, drv_res->ie_length);
+    free(full_scan_result);
+    return NL_SKIP;
+}
+
+
+wifi_error wifi_disable_full_scan_results(wifi_request_id id, wifi_interface_handle iface)
+{
+    ALOGV("Disabling full scan results");
+    wifi_handle handle = getWifiHandle(iface);
+
+    if(id == -1) {
+        wifi_scan_result_handler handler;
+        wifi_handle handle = getWifiHandle(iface);
+        int params_dummy;
+
+        memset(&handler, 0, sizeof(handler));
+        FullScanResultsCommand *cmd = new FullScanResultsCommand(iface, 0, &params_dummy, handler);
+        NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+        cmd->cancel();
+        cmd->releaseRef();
+        return WIFI_SUCCESS;
+    }
+
+    return wifi_cancel_cmd(id, iface);
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+class GetScanResultsCommand : public WifiCommand {
+    wifi_cached_scan_results *mScans;
+    int mMax;
+    int *mNum;
+    int mRetrieved;
+    byte mFlush;
+    int mCompleted;
+public:
+    GetScanResultsCommand(wifi_interface_handle iface, byte flush,
+            wifi_cached_scan_results *results, int max, int *num)
+        : WifiCommand("GetScanResultsCommand", iface, -1), mScans(results), mMax(max), mNum(num),
+                mRetrieved(0), mFlush(flush), mCompleted(0)
+    { }
+
+    int createRequest(WifiRequest& request, int num, byte flush) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_GET_SCAN_RESULTS);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u32(GSCAN_ATTRIBUTE_NUM_OF_RESULTS, num);
+        if (result < 0) {
+            return result;
+        }
+
+        result = request.put_u8(GSCAN_ATTRIBUTE_FLUSH_RESULTS, flush);
+        if (result < 0) {
+            return result;
+        }
+
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int execute() {
+        WifiRequest request(familyId(), ifaceId());
+        ALOGV("retrieving %d scan results", mMax);
+
+        for (int i = 0; i < 10 && mRetrieved < mMax; i++) {
+            int num_to_retrieve = mMax - mRetrieved;
+            // ALOGI("retrieving %d scan results in one shot", num_to_retrieve);
+            int result = createRequest(request, num_to_retrieve, mFlush);
+            if (result < 0) {
+                ALOGE("failed to create request");
+                return result;
+            }
+
+            int prev_retrieved = mRetrieved;
+
+            result = requestResponse(request);
+
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to retrieve scan results; result = %d", result);
+                return result;
+            }
+
+            if (mRetrieved == prev_retrieved || mCompleted) {
+                /* no more items left to retrieve */
+                break;
+            }
+
+            request.destroy();
+        }
+
+        ALOGV("GetScanResults read %d results", mRetrieved);
+        *mNum = mRetrieved;
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        ALOGV("In GetScanResultsCommand::handleResponse");
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGD("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        int id = reply.get_vendor_id();
+        int subcmd = reply.get_vendor_subcmd();
+
+        ALOGV("Id = %0x, subcmd = %d", id, subcmd);
+
+        /*
+        if (subcmd != GSCAN_SUBCMD_SCAN_RESULTS) {
+            ALOGE("Invalid response to GetScanResultsCommand; ignoring it");
+            return NL_SKIP;
+        }
+        */
+
+        nlattr *vendor_data = reply.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        int len = reply.get_vendor_data_len();
+
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("no vendor data in GetScanResults response; ignoring it");
+            return NL_SKIP;
+        }
+
+        for (nl_iterator it(vendor_data); it.has_next(); it.next()) {
+            if (it.get_type() == GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE) {
+                mCompleted = it.get_u8();
+                ALOGV("retrieved mCompleted flag : %d", mCompleted);
+            } else if (it.get_type() == GSCAN_ATTRIBUTE_SCAN_RESULTS || it.get_type() == 0) {
+                int scan_id = 0, flags = 0, num = 0, scan_ch_bucket_mask = 0;
+                for (nl_iterator it2(it.get()); it2.has_next(); it2.next()) {
+                    if (it2.get_type() == GSCAN_ATTRIBUTE_SCAN_ID) {
+                        scan_id = it2.get_u32();
+                        ALOGV("retrieved scan_id : 0x%0x", scan_id);
+                    } else if (it2.get_type() == GSCAN_ATTRIBUTE_SCAN_FLAGS) {
+                        flags = it2.get_u8();
+                        ALOGV("retrieved scan_flags : 0x%0x", flags);
+                    } else if (it2.get_type() == GSCAN_ATTRIBUTE_NUM_OF_RESULTS) {
+                        num = it2.get_u32();
+                        ALOGV("retrieved num_results: %d", num);
+                    } else if (it2.get_type() == GSCAN_ATTRIBUTE_CH_BUCKET_BITMASK) {
+                        scan_ch_bucket_mask = it2.get_u32();
+                        ALOGD("retrieved scan_ch_bucket_mask: %x", scan_ch_bucket_mask);
+                    } else if (it2.get_type() == GSCAN_ATTRIBUTE_SCAN_RESULTS && num) {
+                        if (mRetrieved >= mMax) {
+                            ALOGW("Stored %d scans, ignoring excess results", mRetrieved);
+                            break;
+                        }
+                        num = min(num, (int)(it2.get_len()/sizeof(wifi_gscan_result)));
+                        num = min(num, (int)MAX_AP_CACHE_PER_SCAN);
+                        ALOGV("Copying %d scan results", num);
+                        wifi_gscan_result_t *results = (wifi_gscan_result_t *)it2.get_data();
+                        wifi_scan_result *mScanResults = mScans[mRetrieved].results;
+
+                        for (int i = 0; i < num; i++) {
+                            wifi_gscan_result_t *result = &results[i];
+                            convert_to_hal_result(&mScanResults[i], result);
+                            mScanResults[i].ie_length = 0;
+                            ALOGV("%02d  %-32s  %02x:%02x:%02x:%02x:%02x:%02x  %04d", i,
+                                result->ssid, result->bssid[0], result->bssid[1], result->bssid[2],
+                                result->bssid[3], result->bssid[4], result->bssid[5],
+                                result->rssi);
+                        }
+                        mScans[mRetrieved].scan_id = scan_id;
+                        mScans[mRetrieved].flags = flags;
+                        mScans[mRetrieved].num_results = num;
+                        mScans[mRetrieved].buckets_scanned = scan_ch_bucket_mask;
+                        ALOGV("Setting result of scan_id : 0x%0x", mScans[mRetrieved].scan_id);
+                        mRetrieved++;
+                    } else {
+                        ALOGW("Ignoring invalid attribute type = %d, size = %d",
+                                it.get_type(), it.get_len());
+                    }
+                }
+            } else {
+                ALOGW("Ignoring invalid attribute type = %d, size = %d",
+                        it.get_type(), it.get_len());
+            }
+        }
+        ALOGV("GetScanResults read %d results", mRetrieved);
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_get_cached_gscan_results(wifi_interface_handle iface, byte flush,
+        int max, wifi_cached_scan_results *results, int *num) {
+    ALOGV("Getting cached scan results, iface handle = %p, num = %d", iface, *num);
+
+    GetScanResultsCommand *cmd = new GetScanResultsCommand(iface, flush, results, max, num);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error err = (wifi_error)cmd->execute();
+    cmd->releaseRef();
+    return err;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+class BssidHotlistCommand : public WifiCommand
+{
+private:
+    wifi_bssid_hotlist_params mParams;
+    wifi_hotlist_ap_found_handler mHandler;
+    static const int MAX_RESULTS = 64;
+    wifi_scan_result mResults[MAX_RESULTS];
+public:
+    BssidHotlistCommand(wifi_interface_handle handle, int id,
+            wifi_bssid_hotlist_params params, wifi_hotlist_ap_found_handler handler)
+        : WifiCommand("BssidHotlistCommand", handle, id), mParams(params), mHandler(handler)
+    { }
+
+    int createSetupRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_HOTLIST);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(GSCAN_ATTRIBUTE_HOTLIST_FLUSH, 1);
+        if (result < 0) {
+            return result;
+        }
+
+        result = request.put_u32(GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE, mParams.lost_ap_sample_size);
+        if (result < 0) {
+            return result;
+        }
+
+        result = request.put_u32(GSCAN_ATTRIBUTE_HOTLIST_BSSID_COUNT, mParams.num_bssid);
+        if (result < 0) {
+            return result;
+        }
+
+        struct nlattr * attr = request.attr_start(GSCAN_ATTRIBUTE_HOTLIST_BSSIDS);
+        for (int i = 0; i < mParams.num_bssid; i++) {
+            nlattr *attr2 = request.attr_start(GSCAN_ATTRIBUTE_HOTLIST_ELEM);
+            if (attr2 == NULL) {
+                return WIFI_ERROR_OUT_OF_MEMORY;
+            }
+            result = request.put_addr(GSCAN_ATTRIBUTE_BSSID, mParams.ap[i].bssid);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u8(GSCAN_ATTRIBUTE_RSSI_HIGH, mParams.ap[i].high);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u8(GSCAN_ATTRIBUTE_RSSI_LOW, mParams.ap[i].low);
+            if (result < 0) {
+                return result;
+            }
+            request.attr_end(attr2);
+        }
+
+        request.attr_end(attr);
+        request.attr_end(data);
+        return result;
+    }
+
+    int createTeardownRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_HOTLIST);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(GSCAN_ATTRIBUTE_HOTLIST_FLUSH, 1);
+        if (result < 0) {
+            return result;
+        }
+
+        struct nlattr * attr = request.attr_start(GSCAN_ATTRIBUTE_HOTLIST_BSSIDS);
+        request.attr_end(attr);
+        request.attr_end(data);
+        return result;
+    }
+
+    int start() {
+        ALOGI("Executing hotlist setup request, num = %d", mParams.num_bssid);
+        WifiRequest request(familyId(), ifaceId());
+        int result = createSetupRequest(request);
+        if (result < 0) {
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGI("Failed to execute hotlist setup request, result = %d", result);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_FOUND);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_LOST);
+            return result;
+        }
+
+        ALOGI("Successfully set %d APs in the hotlist ", mParams.num_bssid);
+        result = createFeatureRequest(request, GSCAN_SUBCMD_ENABLE_GSCAN, 1);
+        if (result < 0) {
+            return result;
+        }
+
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_FOUND);
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_LOST);
+
+        result = requestResponse(request);
+        if (result < 0) {
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_FOUND);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_LOST);
+            return result;
+        }
+
+        ALOGI("successfully restarted the scan");
+        return result;
+    }
+
+    virtual int cancel() {
+        /* unregister event handler */
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_FOUND);
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_HOTLIST_RESULTS_LOST);
+        /* create set hotlist message with empty hotlist */
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request);
+        if (result < 0) {
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            return result;
+        }
+
+        ALOGI("Successfully reset APs in current hotlist");
+        return result;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        ALOGI("Hotlist AP event");
+        int event_id = event.get_vendor_subcmd();
+        // event.log();
+
+        nlattr *vendor_data = event.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+
+        if (vendor_data == NULL || len == 0) {
+            ALOGI("No scan results found");
+            return NL_SKIP;
+        }
+
+        memset(mResults, 0, sizeof(wifi_scan_result) * MAX_RESULTS);
+
+        int num = len / sizeof(wifi_gscan_result_t);
+        wifi_gscan_result_t *inp = (wifi_gscan_result_t *)event.get_vendor_data();
+        num = min(MAX_RESULTS, num);
+        for (int i = 0; i < num; i++, inp++) {
+            convert_to_hal_result(&(mResults[i]), inp);
+        }
+
+        if (event_id == GSCAN_EVENT_HOTLIST_RESULTS_FOUND) {
+            ALOGI("FOUND %d hotlist APs", num);
+            if (*mHandler.on_hotlist_ap_found)
+                (*mHandler.on_hotlist_ap_found)(id(), num, mResults);
+        } else if (event_id == GSCAN_EVENT_HOTLIST_RESULTS_LOST) {
+            ALOGI("LOST %d hotlist APs", num);
+            if (*mHandler.on_hotlist_ap_lost)
+                (*mHandler.on_hotlist_ap_lost)(id(), num, mResults);
+        }
+        return NL_SKIP;
+    }
+};
+
+class ePNOCommand : public WifiCommand
+{
+private:
+    wifi_epno_params epno_params;
+    wifi_epno_handler mHandler;
+    wifi_scan_result mResults[MAX_EPNO_NETWORKS];
+public:
+    ePNOCommand(wifi_interface_handle handle, int id,
+            const wifi_epno_params *params, wifi_epno_handler handler)
+        : WifiCommand("ePNOCommand", handle, id), mHandler(handler)
+    {
+        if (params != NULL) {
+            memcpy(&epno_params, params, sizeof(wifi_epno_params));
+        } else {
+            memset(&epno_params, 0, sizeof(wifi_epno_params));
+        }
+    }
+    int createSetupRequest(WifiRequest& request) {
+        if (epno_params.num_networks > MAX_EPNO_NETWORKS) {
+            ALOGE("wrong epno num_networks:%d", epno_params.num_networks);
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_EPNO_SSID);
+        if (result < 0) {
+            return result;
+        }
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(GSCAN_ATTRIBUTE_EPNO_FLUSH, 1);
+        if (result < 0) {
+            return result;
+        }
+
+        result = request.put_u8(GSCAN_ATTRIBUTE_EPNO_5G_RSSI_THR,
+                            (u8)epno_params.min5GHz_rssi);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u8(GSCAN_ATTRIBUTE_EPNO_2G_RSSI_THR,
+                            (u8)epno_params.min24GHz_rssi);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_EPNO_INIT_SCORE_MAX,
+                            epno_params.initial_score_max);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_EPNO_CUR_CONN_BONUS,
+                            epno_params.current_connection_bonus);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_EPNO_SAME_NETWORK_BONUS,
+                            epno_params.same_network_bonus);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_EPNO_SECURE_BONUS,
+                            epno_params.secure_bonus);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_EPNO_5G_BONUS,
+                            epno_params.band5GHz_bonus);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u8(GSCAN_ATTRIBUTE_EPNO_SSID_NUM,
+                        epno_params.num_networks);
+        if (result < 0) {
+            return result;
+        }
+        struct nlattr * attr = request.attr_start(GSCAN_ATTRIBUTE_EPNO_SSID_LIST);
+        wifi_epno_network *ssid_list = epno_params.networks;
+        for (int i = 0; i < epno_params.num_networks; i++) {
+            nlattr *attr2 = request.attr_start(i);
+            if (attr2 == NULL) {
+                return WIFI_ERROR_OUT_OF_MEMORY;
+            }
+            result = request.put(GSCAN_ATTRIBUTE_EPNO_SSID, ssid_list[i].ssid, DOT11_MAX_SSID_LEN);
+            ALOGI("PNO network: SSID %s flags %x auth %x", ssid_list[i].ssid,
+                ssid_list[i].flags,
+                ssid_list[i].auth_bit_field);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_EPNO_SSID_LEN, strlen(ssid_list[i].ssid));
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_EPNO_FLAGS, ssid_list[i].flags);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_EPNO_AUTH, ssid_list[i].auth_bit_field);
+            if (result < 0) {
+                return result;
+            }
+            request.attr_end(attr2);
+        }
+        request.attr_end(attr);
+        request.attr_end(data);
+        return result;
+    }
+
+    int createTeardownRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_EPNO_SSID);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(GSCAN_ATTRIBUTE_EPNO_FLUSH, 1);
+        if (result < 0) {
+            return result;
+        }
+        request.attr_end(data);
+        return result;
+    }
+
+    int start() {
+        ALOGI("Executing ePNO setup request, num = %d", epno_params.num_networks);
+        WifiRequest request(familyId(), ifaceId());
+        int result = createSetupRequest(request);
+        if (result < 0) {
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGI("Failed to execute ePNO setup request, result = %d", result);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_EPNO_EVENT);
+            return result;
+        }
+
+        ALOGI("Successfully set %d SSIDs for ePNO", epno_params.num_networks);
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_EPNO_EVENT);
+        ALOGI("successfully restarted the scan");
+        return result;
+    }
+
+    virtual int cancel() {
+        /* unregister event handler */
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_EPNO_EVENT);
+        /* create set hotlist message with empty hotlist */
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request);
+        if (result < 0) {
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            return result;
+        }
+
+        ALOGI("Successfully reset APs in current hotlist");
+        return result;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        ALOGI("ePNO event");
+        int event_id = event.get_vendor_subcmd();
+        // event.log();
+
+        nlattr *vendor_data = event.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+
+        if (vendor_data == NULL || len == 0) {
+            ALOGI("No scan results found");
+            return NL_SKIP;
+        }
+
+        memset(mResults, 0, sizeof(wifi_scan_result) * MAX_EPNO_NETWORKS);
+
+        unsigned int num = len / sizeof(wifi_pno_result_t);
+        unsigned int i;
+        num = min(MAX_EPNO_NETWORKS, num);
+        wifi_pno_result_t *res = (wifi_pno_result_t *) event.get_vendor_data();
+        for (i = 0; i < num; i++) {
+            if (res[i].flags == PNO_SSID_FOUND) {
+                memcpy(mResults[i].ssid, res[i].ssid, res[i].ssid_len);
+                memcpy(mResults[i].bssid, res[i].bssid, sizeof(mac_addr));
+
+                mResults[i].ssid[res[i].ssid_len] = '\0';
+                mResults[i].channel = res[i].channel;
+                mResults[i].rssi = res[i].rssi;
+            }
+        }
+        if (*mHandler.on_network_found)
+            (*mHandler.on_network_found)(id(), num, mResults);
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_set_bssid_hotlist(wifi_request_id id, wifi_interface_handle iface,
+        wifi_bssid_hotlist_params params, wifi_hotlist_ap_found_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+
+    BssidHotlistCommand *cmd = new BssidHotlistCommand(iface, id, params, handler);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error result = wifi_register_cmd(handle, id, cmd);
+    if (result != WIFI_SUCCESS) {
+        cmd->releaseRef();
+        return result;
+    }
+    result = (wifi_error)cmd->start();
+    if (result != WIFI_SUCCESS) {
+        wifi_unregister_cmd(handle, id);
+        cmd->releaseRef();
+        return result;
+    }
+    return result;
+}
+
+wifi_error wifi_reset_bssid_hotlist(wifi_request_id id, wifi_interface_handle iface)
+{
+    return wifi_cancel_cmd(id, iface);
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+class SignificantWifiChangeCommand : public WifiCommand
+{
+    typedef struct {
+        mac_addr bssid;                     // BSSID
+        wifi_channel channel;               // channel frequency in MHz
+        int num_rssi;                       // number of rssi samples
+        wifi_rssi rssi[8];                   // RSSI history in db
+    } wifi_significant_change_result_internal;
+
+private:
+    wifi_significant_change_params mParams;
+    wifi_significant_change_handler mHandler;
+    static const int MAX_RESULTS = 64;
+    wifi_significant_change_result_internal mResultsBuffer[MAX_RESULTS];
+    wifi_significant_change_result *mResults[MAX_RESULTS];
+public:
+    SignificantWifiChangeCommand(wifi_interface_handle handle, int id,
+            wifi_significant_change_params params, wifi_significant_change_handler handler)
+        : WifiCommand("SignificantWifiChangeCommand", handle, id), mParams(params),
+            mHandler(handler)
+    { }
+
+    int createSetupRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH, 1);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE, mParams.rssi_sample_size);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE, mParams.lost_ap_sample_size);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_MIN_BREACHING, mParams.min_breaching);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u16(GSCAN_ATTRIBUTE_NUM_BSSID, mParams.num_bssid);
+        if (result < 0) {
+            return result;
+        }
+        if (mParams.num_bssid != 0) {
+            nlattr* attr = request.attr_start(GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS);
+            if (attr == NULL) {
+                return WIFI_ERROR_OUT_OF_MEMORY;
+            }
+
+            for (int i = 0; i < mParams.num_bssid; i++) {
+                nlattr* attr2 = request.attr_start(i);
+                if (attr2 == NULL) {
+                    return WIFI_ERROR_OUT_OF_MEMORY;
+                }
+                result = request.put_addr(GSCAN_ATTRIBUTE_BSSID, mParams.ap[i].bssid);
+                if (result < 0) {
+                    return result;
+                }
+                result = request.put_u8(GSCAN_ATTRIBUTE_RSSI_HIGH, mParams.ap[i].high);
+                if (result < 0) {
+                    return result;
+                }
+                result = request.put_u8(GSCAN_ATTRIBUTE_RSSI_LOW, mParams.ap[i].low);
+                if (result < 0) {
+                    return result;
+                }
+                request.attr_end(attr2);
+            }
+
+            request.attr_end(attr);
+        }
+        request.attr_end(data);
+
+        return result;
+    }
+
+    int createTeardownRequest(WifiRequest& request) {
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u16(GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH, 1);
+        if (result < 0) {
+            return result;
+        }
+
+        request.attr_end(data);
+        return result;
+    }
+
+    int start() {
+        ALOGI("Set significant wifi change config");
+        WifiRequest request(familyId(), ifaceId());
+
+        int result = createSetupRequest(request);
+        if (result < 0) {
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGI("failed to set significant wifi change config %d", result);
+            return result;
+        }
+
+        ALOGI("successfully set significant wifi change config");
+
+        result = createFeatureRequest(request, GSCAN_SUBCMD_ENABLE_GSCAN, 1);
+        if (result < 0) {
+            return result;
+        }
+
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS);
+
+        result = requestResponse(request);
+        if (result < 0) {
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS);
+            return result;
+        }
+
+        ALOGI("successfully restarted the scan");
+        return result;
+    }
+
+    virtual int cancel() {
+        /* unregister event handler */
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS);
+
+        /* create set significant change monitor message with empty hotlist */
+        WifiRequest request(familyId(), ifaceId());
+
+        int result = createTeardownRequest(request);
+        if (result < 0) {
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            return result;
+        }
+
+        ALOGI("successfully reset significant wifi change config");
+        return result;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        ALOGV("Got a significant wifi change event");
+
+        nlattr *vendor_data = event.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+
+        if (vendor_data == NULL || len == 0) {
+            ALOGI("No scan results found");
+            return NL_SKIP;
+        }
+
+        typedef struct {
+            uint16_t flags;
+            uint16_t channel;
+            mac_addr bssid;
+            s8 rssi_history[8];
+        } ChangeInfo;
+
+        int num = min(len / sizeof(ChangeInfo), MAX_RESULTS);
+        ChangeInfo *ci = (ChangeInfo *)event.get_vendor_data();
+
+        for (int i = 0; i < num; i++) {
+            memcpy(mResultsBuffer[i].bssid, ci[i].bssid, sizeof(mac_addr));
+            mResultsBuffer[i].channel = ci[i].channel;
+            mResultsBuffer[i].num_rssi = 8;
+            for (int j = 0; j < mResultsBuffer[i].num_rssi; j++)
+                mResultsBuffer[i].rssi[j] = (int) ci[i].rssi_history[j];
+            mResults[i] = reinterpret_cast<wifi_significant_change_result *>(&(mResultsBuffer[i]));
+        }
+
+        ALOGV("Retrieved %d scan results", num);
+
+        if (num != 0) {
+            (*mHandler.on_significant_change)(id(), num, mResults);
+        } else {
+            ALOGW("No significant change reported");
+        }
+
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_set_significant_change_handler(wifi_request_id id, wifi_interface_handle iface,
+        wifi_significant_change_params params, wifi_significant_change_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+
+    SignificantWifiChangeCommand *cmd = new SignificantWifiChangeCommand(
+            iface, id, params, handler);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error result = wifi_register_cmd(handle, id, cmd);
+    if (result != WIFI_SUCCESS) {
+        cmd->releaseRef();
+        return result;
+    }
+    result = (wifi_error)cmd->start();
+    if (result != WIFI_SUCCESS) {
+        wifi_unregister_cmd(handle, id);
+        cmd->releaseRef();
+        return result;
+    }
+    return result;
+}
+
+wifi_error wifi_reset_significant_change_handler(wifi_request_id id, wifi_interface_handle iface)
+{
+    return wifi_cancel_cmd(id, iface);
+}
+
+wifi_error wifi_reset_epno_list(wifi_request_id id, wifi_interface_handle iface)
+{
+    if (id == -1) {
+        wifi_epno_handler handler;
+        wifi_handle handle = getWifiHandle(iface);
+
+        memset(&handler, 0, sizeof(handler));
+        ePNOCommand *cmd = new ePNOCommand(iface, id, NULL, handler);
+        NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+        cmd->cancel();
+        cmd->releaseRef();
+        return WIFI_SUCCESS;
+    }
+    return wifi_cancel_cmd(id, iface);
+}
+
+wifi_error wifi_set_epno_list(wifi_request_id id, wifi_interface_handle iface,
+        const wifi_epno_params *params, wifi_epno_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+
+    ePNOCommand *cmd = new ePNOCommand(iface, id, params, handler);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error result = wifi_register_cmd(handle, id, cmd);
+    if (result != WIFI_SUCCESS) {
+        cmd->releaseRef();
+        return result;
+    }
+    result = (wifi_error)cmd->start();
+    if (result != WIFI_SUCCESS) {
+        wifi_unregister_cmd(handle, id);
+        cmd->releaseRef();
+        return result;
+    }
+    return result;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+
+class AnqpoConfigureCommand : public WifiCommand
+{
+    int num_hs;
+    wifi_passpoint_network *mNetworks;
+    wifi_passpoint_event_handler mHandler;
+    wifi_scan_result *mResult;
+public:
+    AnqpoConfigureCommand(wifi_request_id id, wifi_interface_handle iface,
+        int num, wifi_passpoint_network *hs_list, wifi_passpoint_event_handler handler)
+        : WifiCommand("AnqpoConfigureCommand", iface, id), num_hs(num), mNetworks(hs_list),
+            mHandler(handler)
+    {
+        mResult = NULL;
+    }
+
+    int createRequest(WifiRequest& request, int val) {
+
+        int result = request.create(GOOGLE_OUI, GSCAN_SUBCMD_ANQPO_CONFIG);
+        result = request.put_u32(GSCAN_ATTRIBUTE_ANQPO_HS_LIST_SIZE, num_hs);
+        if (result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+
+        struct nlattr * attr = request.attr_start(GSCAN_ATTRIBUTE_ANQPO_HS_LIST);
+        for (int i = 0; i < num_hs; i++) {
+            nlattr *attr2 = request.attr_start(i);
+            if (attr2 == NULL) {
+                return WIFI_ERROR_OUT_OF_MEMORY;
+            }
+            result = request.put_u32(GSCAN_ATTRIBUTE_ANQPO_HS_NETWORK_ID, mNetworks[i].id);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put(GSCAN_ATTRIBUTE_ANQPO_HS_NAI_REALM, mNetworks[i].realm, 256);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put(GSCAN_ATTRIBUTE_ANQPO_HS_ROAM_CONSORTIUM_ID,
+                         mNetworks[i].roamingConsortiumIds, 128);
+            if (result < 0) {
+                return result;
+            }
+            result = request.put(GSCAN_ATTRIBUTE_ANQPO_HS_PLMN, mNetworks[i].plmn, 3);
+            if (result < 0) {
+                return result;
+            }
+
+            request.attr_end(attr2);
+        }
+
+        request.attr_end(attr);
+        request.attr_end(data);
+
+        return WIFI_SUCCESS;
+    }
+
+    int start() {
+
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request, num_hs);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+            return result;
+        }
+
+        registerVendorHandler(GOOGLE_OUI, GSCAN_EVENT_ANQPO_HOTSPOT_MATCH);
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to set ANQPO networks; result = %d", result);
+            unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_ANQPO_HOTSPOT_MATCH);
+            return result;
+        }
+
+        return result;
+    }
+
+    virtual int cancel() {
+
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request, 0);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to reset ANQPO networks;result = %d", result);
+            }
+        }
+
+        unregisterVendorHandler(GOOGLE_OUI, GSCAN_EVENT_ANQPO_HOTSPOT_MATCH);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+         ALOGD("Request complete!");
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        typedef struct {
+            u16 channel;        /* channel of GAS protocol */
+            u8  dialog_token;   /* GAS dialog token */
+            u8  fragment_id;    /* fragment id */
+            u16 status_code;    /* status code on GAS completion */
+            u16 data_len;       /* length of data to follow */
+            u8  data[1];        /* variable length specified by data_len */
+        } wifi_anqp_gas_resp;
+
+        ALOGI("ANQPO hotspot matched event!");
+
+        nlattr *vendor_data = event.get_attribute(NL80211_ATTR_VENDOR_DATA);
+        unsigned int len = event.get_vendor_data_len();
+
+        if (vendor_data == NULL || len < sizeof(wifi_scan_result)) {
+            ALOGI("No scan results found");
+            return NL_SKIP;
+        }
+        mResult = (wifi_scan_result *)malloc(sizeof(wifi_scan_result));
+        if (!mResult) {
+            return NL_SKIP;
+        }
+        wifi_gscan_full_result_t *drv_res = (wifi_gscan_full_result_t *)event.get_vendor_data();
+        wifi_gscan_result_t *fixed = &drv_res->fixed;
+        convert_to_hal_result(mResult, fixed);
+
+        byte *anqp = (byte *)drv_res + offsetof(wifi_gscan_full_result_t, ie_data) + drv_res->ie_length;
+        wifi_anqp_gas_resp *gas = (wifi_anqp_gas_resp *)anqp;
+        int anqp_len = offsetof(wifi_anqp_gas_resp, data) + gas->data_len;
+        int networkId = *(int *)((byte *)anqp + anqp_len);
+
+        ALOGI("%-32s\t", mResult->ssid);
+
+        ALOGI("%02x:%02x:%02x:%02x:%02x:%02x ", mResult->bssid[0], mResult->bssid[1],
+                mResult->bssid[2], mResult->bssid[3], mResult->bssid[4], mResult->bssid[5]);
+
+        ALOGI("%d\t", mResult->rssi);
+        ALOGI("%d\t", mResult->channel);
+        ALOGI("%lld\t", mResult->ts);
+        ALOGI("%lld\t", mResult->rtt);
+        ALOGI("%lld\n", mResult->rtt_sd);
+
+        if(*mHandler.on_passpoint_network_found)
+            (*mHandler.on_passpoint_network_found)(id(), networkId, mResult, anqp_len, anqp);
+        free(mResult);
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_set_passpoint_list(wifi_request_id id, wifi_interface_handle iface, int num,
+        wifi_passpoint_network *networks, wifi_passpoint_event_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+
+    AnqpoConfigureCommand *cmd = new AnqpoConfigureCommand(id, iface, num, networks, handler);
+    NULL_CHECK_RETURN(cmd, "memory allocation failure", WIFI_ERROR_OUT_OF_MEMORY);
+    wifi_error result = wifi_register_cmd(handle, id, cmd);
+    if (result != WIFI_SUCCESS) {
+        cmd->releaseRef();
+        return result;
+    }
+    result = (wifi_error)cmd->start();
+    if (result != WIFI_SUCCESS) {
+        wifi_unregister_cmd(handle, id);
+        cmd->releaseRef();
+        return result;
+    }
+    return result;
+}
+
+wifi_error wifi_reset_passpoint_list(wifi_request_id id, wifi_interface_handle iface)
+{
+    return wifi_cancel_cmd(id, iface);
+}
diff --git a/88x9098/wlan/hal/wifi_hal/link_layer_stats.cpp b/88x9098/wlan/hal/wifi_hal/link_layer_stats.cpp
new file mode 100644
index 0000000..3f6878c
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/link_layer_stats.cpp
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+
+typedef enum {
+    NXP_ATTR_LL_STATS_INVALID = 0,
+    NXP_ATTR_MPDU_SIZE_THRESHOLD,
+    NXP_ATTR_AGGRESSIVE_STATS_GATHERING,
+    NXP_ATTR_LL_STATS_IFACE,
+    NXP_ATTR_LL_STATS_NUM_RADIOS,
+    NXP_ATTR_LL_STATS_RADIO,
+    NXP_ATTR_LL_STATS_CLEAR_REQ_MASK,
+    NXP_ATTR_LL_STATS_STOP_REQ,
+    NXP_ATTR_LL_STATS_CLEAR_RSP_MASK,
+    NXP_ATTR_LL_STATS_STOP_RSP,
+
+    /* keep last */
+    NXP_ATTR_LL_STATS_AFTER_LAST,
+    NXP_ATTR_LL_STATS_MAX = 
+    NXP_ATTR_LL_STATS_AFTER_LAST - 1
+
+} LINK_LAYER_ATTRIBUTE;
+
+/* radio statistics */
+typedef struct {
+   wifi_radio radio;                      // wifi radio (if multiple radio supported)
+   u32 on_time;                           // msecs the radio is awake (32 bits number accruing over time)
+   u32 tx_time;                           // msecs the radio is transmitting (32 bits number accruing over time)
+   u32 num_tx_levels;                     // number of radio transmit power levels
+   //u32 *tx_time_per_levels;               // pointer to an array of radio transmit per power levels in
+                                          // msecs accured over time
+   u32 rx_time;                           // msecs the radio is in active receive (32 bits number accruing over time)
+   u32 on_time_scan;                      // msecs the radio is awake due to all scan (32 bits number accruing over time)
+   u32 on_time_nbd;                       // msecs the radio is awake due to NAN (32 bits number accruing over time)
+   u32 on_time_gscan;                     // msecs the radio is awake due to G?scan (32 bits number accruing over time)
+   u32 on_time_roam_scan;                 // msecs the radio is awake due to roam?scan (32 bits number accruing over time)
+   u32 on_time_pno_scan;                  // msecs the radio is awake due to PNO scan (32 bits number accruing over time)
+   u32 on_time_hs20;                      // msecs the radio is awake due to HS2.0 scans and GAS exchange (32 bits number accruing over time)
+   u32 num_channels;                      // number of channels
+   wifi_channel_stat channels[];          // channel statistics
+} wifi_radio_stat_nxp;
+
+/* interface statistics */
+typedef struct {
+   //wifi_interface_handle iface;          // wifi interface
+   wifi_interface_link_layer_info info;  // current state of the interface
+   u32 beacon_rx;                        // access point beacon received count from connected AP
+   u64 average_tsf_offset;               // average beacon offset encountered (beacon_TSF - TBTT)
+                                         // The average_tsf_offset field is used so as to calculate the
+                                         // typical beacon contention time on the channel as well may be
+                                         // used to debug beacon synchronization and related power consumption issue
+   u32 leaky_ap_detected;                // indicate that this AP typically leaks packets beyond the driver guard time.
+   u32 leaky_ap_avg_num_frames_leaked;  // average number of frame leaked by AP after frame with PM bit set was ACK'ed by AP
+   u32 leaky_ap_guard_time;              // guard time currently in force (when implementing IEEE power management based on
+                                         // frame control PM bit), How long driver waits before shutting down the radio and
+                                         // after receiving an ACK for a data frame with PM bit set)
+   u32 mgmt_rx;                          // access point mgmt frames received count from connected AP (including Beacon)
+   u32 mgmt_action_rx;                   // action frames received count
+   u32 mgmt_action_tx;                   // action frames transmit count
+   wifi_rssi rssi_mgmt;                  // access Point Beacon and Management frames RSSI (averaged)
+   wifi_rssi rssi_data;                  // access Point Data Frames RSSI (averaged) from connected AP
+   wifi_rssi rssi_ack;                   // access Point ACK RSSI (averaged) from connected AP
+   wifi_wmm_ac_stat ac[WIFI_AC_MAX];     // per ac data packet statistics
+   u32 num_peers;                        // number of peers
+   wifi_peer_info peer_info[];           // per peer statistics
+} wifi_iface_stat_nxp;
+
+class GetLinkStats : public WifiCommand
+{
+private:
+    wifi_stats_result_handler Handler;
+
+public:
+    GetLinkStats(wifi_interface_handle iface, wifi_stats_result_handler handler)
+    : WifiCommand("GetLinkStats", iface, 0)
+    {
+        Handler = handler;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_LL_STATS_GET);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get link layer stats - %d", ret);
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        struct nlattr *tb_vendor[NXP_ATTR_LL_STATS_MAX + 1];
+        struct nlattr *vendor_data = NULL;
+        u32 num_radios = 0;
+        wifi_iface_stat *iface_stat = NULL;
+        wifi_radio_stat *radio_stat = NULL;
+        int id = 0, len = 0;
+        u32 i = 0;
+        wifi_iface_stat_nxp *iface_stat_nxp = NULL;
+        u32 iface_len = 0;
+        wifi_radio_stat *radio_stat_tmp = NULL;
+        u32 radio_stat_len = 0;
+        wifi_radio_stat_nxp *radio_stat_nxp = NULL;
+        wifi_radio_stat_nxp *radio_stat_nxp_tmp = NULL;
+        u32 each_len = 0;
+        u32 total_len = 0;
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+        vendor_data = (nlattr *)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        len = reply.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in command response\n");
+            return NL_SKIP;
+        }
+        id = reply.get_vendor_id();
+        nla_parse(tb_vendor, NXP_ATTR_LL_STATS_MAX, vendor_data, len, NULL);
+
+        /** Process IFACE */
+        if(!tb_vendor[NXP_ATTR_LL_STATS_IFACE]){
+            ALOGE("NXP_ATTR_LL_STATS_IFACE not found\n");
+            return NL_SKIP;
+        }
+        iface_stat_nxp = (wifi_iface_stat_nxp *)nla_data(tb_vendor[NXP_ATTR_LL_STATS_IFACE]);
+        iface_len = nla_len(tb_vendor[NXP_ATTR_LL_STATS_IFACE]) + sizeof(wifi_interface_handle);
+        iface_stat = (wifi_iface_stat *)malloc(iface_len);
+        if (iface_stat == NULL) {
+            ALOGE("Could not allocate iface_stat");
+            return NL_SKIP;
+        }
+        memset(iface_stat, 0, iface_len);
+        iface_stat->iface = NULL;
+        memcpy((u8 *)iface_stat + sizeof(wifi_interface_handle), iface_stat_nxp, nla_len(tb_vendor[NXP_ATTR_LL_STATS_IFACE]));
+
+        /** Process Num of RADIO */
+        if(!tb_vendor[NXP_ATTR_LL_STATS_NUM_RADIOS]){
+            ALOGE("NXP_ATTR_LL_STATS_NUM_RADIOS not found\n");
+            free(iface_stat);
+            return NL_SKIP;
+        }
+        num_radios = nla_get_u32(tb_vendor[NXP_ATTR_LL_STATS_NUM_RADIOS]);
+
+        /** Process RADIO */
+        if(!tb_vendor[NXP_ATTR_LL_STATS_RADIO]){
+            ALOGE("NXP_ATTR_LL_STATS_RADIO not found\n");
+            free(iface_stat);
+            return NL_SKIP;
+        }
+        radio_stat_nxp = (wifi_radio_stat_nxp *)nla_data(tb_vendor[NXP_ATTR_LL_STATS_RADIO]);
+        /* Check len and Count total len need to malloc */
+        radio_stat_nxp_tmp = radio_stat_nxp;
+        for (i=0; i<num_radios; i++) {
+            each_len = sizeof(wifi_radio_stat_nxp) + radio_stat_nxp_tmp->num_channels * sizeof(wifi_channel_stat);
+            total_len += each_len;
+            radio_stat_len += sizeof(wifi_radio_stat) + radio_stat_nxp_tmp->num_channels * sizeof(wifi_channel_stat);
+            radio_stat_nxp_tmp = (wifi_radio_stat_nxp *)((u8 *)radio_stat_nxp_tmp + each_len);
+        }
+        if (!radio_stat_len || !total_len || total_len != (u32)nla_len(tb_vendor[NXP_ATTR_LL_STATS_RADIO])) {
+            ALOGE("NXP_ATTR_LL_STATS_RADIO len not right: radio_stat_len=%d total_len=%d attrlen=%d\n",
+                radio_stat_len, total_len, nla_len(tb_vendor[NXP_ATTR_LL_STATS_RADIO]));
+            free(iface_stat);
+            return NL_SKIP;
+        }
+        /* malloc radio stat and copy the data from driver to HAL */
+        radio_stat = (wifi_radio_stat *)malloc(radio_stat_len);
+        if (radio_stat == NULL) {
+            ALOGE("Could not allocate radio_stat");
+            free(iface_stat);
+            return NL_SKIP;
+        }
+        memset(radio_stat, 0, radio_stat_len);
+        radio_stat_tmp= radio_stat;
+        radio_stat_nxp_tmp = radio_stat_nxp;
+        for (i=0; i<num_radios; i++) {
+            radio_stat_tmp->radio = radio_stat_nxp_tmp->radio;
+            radio_stat_tmp->on_time = radio_stat_nxp_tmp->on_time;
+            radio_stat_tmp->tx_time = radio_stat_nxp_tmp->tx_time;
+            radio_stat_tmp->num_tx_levels = radio_stat_nxp_tmp->num_tx_levels;
+            radio_stat_tmp->tx_time_per_levels = NULL;
+            radio_stat_tmp->rx_time = radio_stat_nxp_tmp->rx_time;
+            radio_stat_tmp->on_time_scan = radio_stat_nxp_tmp->on_time_scan;
+            radio_stat_tmp->on_time_nbd = radio_stat_nxp_tmp->on_time_nbd;
+            radio_stat_tmp->on_time_gscan = radio_stat_nxp_tmp->on_time_gscan;
+            radio_stat_tmp->on_time_roam_scan = radio_stat_nxp_tmp->on_time_roam_scan;
+            radio_stat_tmp->on_time_pno_scan = radio_stat_nxp_tmp->on_time_pno_scan;
+            radio_stat_tmp->on_time_hs20 = radio_stat_nxp_tmp->on_time_hs20;
+            radio_stat_tmp->num_channels = radio_stat_nxp_tmp->num_channels;
+            memcpy(radio_stat_tmp->channels, radio_stat_nxp_tmp->channels, radio_stat_nxp_tmp->num_channels * sizeof(wifi_channel_stat));
+            radio_stat_tmp = (wifi_radio_stat *)((u8 *)radio_stat_tmp + sizeof(wifi_radio_stat) + radio_stat_nxp_tmp->num_channels * sizeof(wifi_channel_stat));
+            radio_stat_nxp_tmp = (wifi_radio_stat_nxp *)((u8 *)radio_stat_nxp_tmp +sizeof(wifi_radio_stat_nxp) + radio_stat_nxp_tmp->num_channels * sizeof(wifi_channel_stat));
+        }
+
+        if (Handler.on_link_stats_results) {
+            (Handler.on_link_stats_results)(id, iface_stat, num_radios, radio_stat);
+        } else {
+            ALOGW("No linklayer stats handler registered");
+        }
+        free(iface_stat);
+        free(radio_stat);
+        return NL_OK;
+    }
+};
+
+class SetLinkStats : public WifiCommand
+{
+private:
+    wifi_link_layer_params Params;
+
+public:
+    SetLinkStats(wifi_interface_handle iface, wifi_link_layer_params params)
+    :WifiCommand("SetLinkStats", iface, 0)
+    {
+        Params = params;
+    }
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_LL_STATS_SET);
+        if (ret < 0) {
+            ALOGE("Failed to create message to set link layer stats - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_MPDU_SIZE_THRESHOLD, Params.mpdu_size_threshold);
+        if (ret < 0)
+            return ret;
+        ret = mMsg.put_u32(NXP_ATTR_AGGRESSIVE_STATS_GATHERING,Params.aggressive_statistics_gathering);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_get_link_stats(wifi_request_id id, wifi_interface_handle iface, 
+                                  wifi_stats_result_handler handler)
+{
+    int ret = 0;
+    GetLinkStats GetStats(iface, handler);
+    ret = GetStats.requestResponse();
+    return (wifi_error) ret;
+}
+
+wifi_error wifi_set_link_stats(wifi_interface_handle iface, wifi_link_layer_params params)
+{
+    int ret = 0;
+    SetLinkStats SetStats(iface, params);
+    ret = SetStats.requestResponse();
+    return (wifi_error)ret;
+}
+
+class ClearLinkStats : public WifiCommand
+{
+private:
+    u32 clearReqMask;
+    u32 *clearRspMask;
+    u8 stopReq;
+    u8 *stopRsp;
+
+public:
+    ClearLinkStats (wifi_interface_handle iface, u32 stats_clear_req_mask,
+                        u32 *stats_clear_rsp_mask, u8 stop_req, u8 *stop_rsp)
+    : WifiCommand("ClearLinkStats", iface, 0)
+    {
+        clearReqMask = stats_clear_req_mask;
+        clearRspMask = stats_clear_rsp_mask;
+        stopReq = stop_req;
+        stopRsp = stop_rsp;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_LL_STATS_CLR);
+        if(ret < 0){
+            ALOGE("Failed to create message to clear link stats - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_LL_STATS_CLEAR_REQ_MASK, clearReqMask);
+        if (ret < 0)
+            return ret;
+        ret = mMsg.put_u8(NXP_ATTR_LL_STATS_STOP_REQ, stopReq);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply){
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+        nlattr *vendor_data =(nlattr *)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in command response");
+            return NL_SKIP;
+        }
+        struct nlattr *tb_vendor[NXP_ATTR_LL_STATS_MAX + 1];
+        nla_parse(tb_vendor, NXP_ATTR_LL_STATS_MAX, vendor_data, len, NULL);
+        if(!tb_vendor[NXP_ATTR_LL_STATS_CLEAR_RSP_MASK]){
+            ALOGE("NXP_ATTR_LL_STATS_CLEAR_RSP_MASK not found\n");
+            return NL_SKIP;
+        }
+        clearRspMask = (u32 *)nla_data(tb_vendor[NXP_ATTR_LL_STATS_CLEAR_RSP_MASK]);
+        if(!tb_vendor[NXP_ATTR_LL_STATS_STOP_RSP]){
+            ALOGE("NXP_ATTR_LL_STATS_STOP_RSP not found\n");
+            return NL_SKIP;
+        }
+        stopRsp = (u8 *)nla_data(tb_vendor[NXP_ATTR_LL_STATS_STOP_RSP]);
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_clear_link_stats(wifi_interface_handle iface, u32 stats_clear_req_mask, 
+                                     u32 *stats_clear_rsp_mask, u8 stop_req, u8 *stop_rsp)
+{
+    int ret = 0;
+    ClearLinkStats ClearStats(iface, stats_clear_req_mask, stats_clear_rsp_mask, 
+                              stop_req, stop_rsp);
+    ret = ClearStats.requestResponse();
+    return (wifi_error) ret;
+}
diff --git a/88x9098/wlan/hal/wifi_hal/nan_nxp.h b/88x9098/wlan/hal/wifi_hal/nan_nxp.h
new file mode 100644
index 0000000..5b1c794
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/nan_nxp.h
@@ -0,0 +1,178 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+* Portion copyright 2017-2020 NXP
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#ifndef __NAN_NXP_H__
+#define __NAN_NXP_H__
+
+/*
+  NAN Status codes exchanged between firmware
+  and WifiHal.
+*/
+typedef enum {
+    /* NAN Protocol Response Codes */
+    NAN_I_STATUS_SUCCESS = 0,
+    NAN_I_STATUS_TIMEOUT = 1,
+    NAN_I_STATUS_DE_FAILURE = 2,
+    NAN_I_STATUS_INVALID_MSG_VERSION = 3,
+    NAN_I_STATUS_INVALID_MSG_LEN = 4,
+    NAN_I_STATUS_INVALID_MSG_ID = 5,
+    NAN_I_STATUS_INVALID_HANDLE = 6,
+    NAN_I_STATUS_NO_SPACE_AVAILABLE = 7,
+    NAN_I_STATUS_INVALID_PUBLISH_TYPE = 8,
+    NAN_I_STATUS_INVALID_TX_TYPE = 9,
+    NAN_I_STATUS_INVALID_MATCH_ALGORITHM = 10,
+    NAN_I_STATUS_DISABLE_IN_PROGRESS = 11,
+    NAN_I_STATUS_INVALID_TLV_LEN = 12,
+    NAN_I_STATUS_INVALID_TLV_TYPE = 13,
+    NAN_I_STATUS_MISSING_TLV_TYPE = 14,
+    NAN_I_STATUS_INVALID_TOTAL_TLVS_LEN = 15,
+    NAN_I_STATUS_INVALID_REQUESTER_INSTANCE_ID= 16,
+    NAN_I_STATUS_INVALID_TLV_VALUE = 17,
+    NAN_I_STATUS_INVALID_TX_PRIORITY = 18,
+    NAN_I_STATUS_INVALID_CONNECTION_MAP = 19,
+    NAN_I_STATUS_INVALID_THRESHOLD_CROSSING_ALERT_ID = 20,
+    NAN_I_STATUS_INVALID_STATS_ID = 21,
+    NAN_I_STATUS_NAN_NOT_ALLOWED = 22,
+    NAN_I_STATUS_NO_OTA_ACK = 23,
+    NAN_I_STATUS_TX_FAIL = 24,
+    NAN_I_STATUS_NAN_ALREADY_ENABLED = 25,
+    NAN_I_STATUS_FOLLOWUP_QUEUE_FULL = 26,
+    /* 27-4095 Reserved */
+    /* NAN Configuration Response codes */
+    NAN_I_STATUS_INVALID_RSSI_CLOSE_VALUE = 4096,
+    NAN_I_STATUS_INVALID_RSSI_MIDDLE_VALUE = 4097,
+    NAN_I_STATUS_INVALID_HOP_COUNT_LIMIT = 4098,
+    NAN_I_STATUS_INVALID_MASTER_PREFERENCE_VALUE = 4099,
+    NAN_I_STATUS_INVALID_LOW_CLUSTER_ID_VALUE = 4100,
+    NAN_I_STATUS_INVALID_HIGH_CLUSTER_ID_VALUE = 4101,
+    NAN_I_STATUS_INVALID_BACKGROUND_SCAN_PERIOD = 4102,
+    NAN_I_STATUS_INVALID_RSSI_PROXIMITY_VALUE = 4103,
+    NAN_I_STATUS_INVALID_SCAN_CHANNEL = 4104,
+    NAN_I_STATUS_INVALID_POST_NAN_CONNECTIVITY_CAPABILITIES_BITMAP = 4105,
+    NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_NUMCHAN_VALUE = 4106,
+    NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_DURATION_VALUE = 4107,
+    NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_CLASS_VALUE = 4108,
+    NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_CHANNEL_VALUE = 4109,
+    NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_AVAILABILITY_INTERVAL_BITMAP_VALUE = 4110,
+    NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_MAP_ID = 4111,
+    NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_CONN_TYPE_VALUE = 4112,
+    NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_DEVICE_ROLE_VALUE = 4113,
+    NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_DURATION_VALUE = 4114,
+    NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_BITMAP_VALUE = 4115,
+    NAN_I_STATUS_MISSING_FUTHER_AVAILABILITY_MAP = 4116,
+    NAN_I_STATUS_INVALID_BAND_CONFIG_FLAGS = 4117,
+    NAN_I_STATUS_INVALID_RANDOM_FACTOR_UPDATE_TIME_VALUE = 4118,
+    NAN_I_STATUS_INVALID_ONGOING_SCAN_PERIOD = 4119,
+    NAN_I_STATUS_INVALID_DW_INTERVAL_VALUE = 4120,
+    NAN_I_STATUS_INVALID_DB_INTERVAL_VALUE = 4121,
+    /* 4122-8191 RESERVED */
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_INVALID = 8192,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_TIMEOUT = 8193,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_USER_REQUEST = 8194,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_FAILURE = 8195,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_COUNT_REACHED = 8196,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_DE_SHUTDOWN = 8197,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_DISABLE_IN_PROGRESS = 8198,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_POST_DISC_ATTR_EXPIRED = 8199,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_POST_DISC_LEN_EXCEEDED = 8200,
+    NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_FURTHER_AVAIL_MAP_EMPTY = 8201,
+    /* 9000-9500 NDP Status type */
+    NDP_I_UNSUPPORTED_CONCURRENCY = 9000,
+    NDP_I_NAN_DATA_IFACE_CREATE_FAILED = 9001,
+    NDP_I_NAN_DATA_IFACE_DELETE_FAILED = 9002,
+    NDP_I_DATA_INITIATOR_REQUEST_FAILED = 9003,
+    NDP_I_DATA_RESPONDER_REQUEST_FAILED = 9004,
+    NDP_I_INVALID_SERVICE_INSTANCE_ID = 9005,
+    NDP_I_INVALID_NDP_INSTANCE_ID = 9006,
+    NDP_I_INVALID_RESPONSE_CODE = 9007,
+    NDP_I_INVALID_APP_INFO_LEN = 9008,
+    /* OTA failures and timeouts during negotiation */
+    NDP_I_MGMT_FRAME_REQUEST_FAILED = 9009,
+    NDP_I_MGMT_FRAME_RESPONSE_FAILED = 9010,
+    NDP_I_MGMT_FRAME_CONFIRM_FAILED = 9011,
+    NDP_I_END_FAILED = 9012,
+    NDP_I_MGMT_FRAME_END_REQUEST_FAILED = 9013,
+
+    /* 9500 onwards vendor specific error codes */
+    NDP_I_VENDOR_SPECIFIC_ERROR = 9500
+} NanInternalStatusType;
+
+/*
+  Definition of various NanResponseType
+*/
+typedef enum {
+    NAN_REQUEST_ENABLED = 0x3000,
+    NAN_REQUEST_DISABLED,
+    NAN_REQUEST_PUBLISH,
+    NAN_REQUEST_PUBLISH_CANCEL,
+    NAN_REQUEST_TRANSMIT_FOLLOWUP,
+    NAN_REQUEST_SUBSCRIBE,
+    NAN_REQUEST_SUBSCRIBE_CANCEL,
+    NAN_REQUEST_STATS,
+    NAN_REQUEST_CONFIG,
+    NAN_REQUEST_TCA,
+    NAN_REQUEST_ERROR,
+    NAN_REQUEST_BEACON_SDF_PAYLOAD,
+    NAN_GET_CAPABILITIES_REQUEST,
+    NAN_DP_INTERFACE_CREATE_REQUEST,
+    NAN_DP_INTERFACE_DELETE_REQUEST,
+    NAN_DP_INITIATOR_RESPONSE_REQUEST,
+    NAN_DP_RESPONDER_RESPONSE_REQUES,
+    NAN_DP_END_REQUEST,
+    NAN_REQUEST_MAX
+} NanNxpRequestType;
+
+typedef enum {
+    NAN_MSG_ID_ERROR_RSP                    = 0,
+    NAN_MSG_ID_ENABLE,
+    NAN_MSG_ID_DISABLE,
+    NAN_MSG_ID_PUBLISH_SERVICE,
+    NAN_MSG_ID_PUBLISH_SERVICE_CANCEL,
+    NAN_MSG_ID_PUBLISH_REPLIED_IND,
+    NAN_MSG_ID_PUBLISH_TERMINATED_IND,
+    NAN_MSG_ID_SUBSCRIBE_SERVICE,
+    NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL,
+    NAN_MSG_ID_SUBSCRIBE_TERMINATED_IND,
+    NAN_MSG_ID_TRANSMIT_FOLLOWUP,
+    NAN_MSG_ID_FOLLOWUP_IND,
+    NAN_MSG_ID_STATS,
+    NAN_MSG_ID_CONFIGURATION,
+    NAN_MSG_ID_TCA,
+    NAN_MSG_ID_TCA_IND,
+    NAN_MSG_ID_BEACON_SDF,
+    NAN_MSG_ID_BEACON_SDF_IND,
+    NAN_MSG_ID_CAPABILITIES ,
+    NAN_MSG_ID_NDP_IF_CREATE,
+    NAN_MSG_ID_NDP_IF_DELETE,
+    NAN_MSG_ID_NDP_REQ_INITIATOR,
+    NAN_MSG_ID_NDP_IND_RESP,
+    NAN_MSG_ID_NDP_END,
+    NAN_MSG_ID_MATCH_IND,
+    NAN_MSG_ID_MATCH_EXPIRED_IND,
+    NAN_MSG_ID_DE_EVENT_IND,
+    NAN_MSG_ID_DISABLE_IND,
+    NAN_MSG_ID_SELF_TRANSMIT_FOLLOWUP_IND,
+    NAN_MSG_ID_RANGING_REQUEST_RECEVD_IND,
+    NAN_MSG_ID_RANGING_RESULT_IND,
+} NanMsgIdType;
+
+typedef enum {
+    NAN_DE_MAC_ADDR = 10,
+    NAN_DE_START_CLUSTER,
+    NAN_DE_JOIN_CLUSTER,
+} NanDEtype;
+
+#endif
diff --git a/88x9098/wlan/hal/wifi_hal/nl80211_copy.h b/88x9098/wlan/hal/wifi_hal/nl80211_copy.h
new file mode 100644
index 0000000..712b751
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/nl80211_copy.h
@@ -0,0 +1,4588 @@
+#ifndef __LINUX_NL80211_H
+#define __LINUX_NL80211_H
+/*
+ * 802.11 netlink interface public header
+ *
+ * Copyright 2006-2010 Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
+ * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
+ * Copyright 2008 Michael Buesch <m@bues.ch>
+ * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
+ * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
+ * Copyright 2008 Colin McCabe <colin@cozybit.com>
+ * Copyright 2015-2020 NXP
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * This header file defines the userspace API to the wireless stack. Please
+ * be careful not to break things - i.e. don't move anything around or so
+ * unless you can demonstrate that it breaks neither API nor ABI.
+ *
+ * Additions to the API should be accompanied by actual implementations in
+ * an upstream driver, so that example implementations exist in case there
+ * are ever concerns about the precise semantics of the API or changes are
+ * needed, and to ensure that code for dead (no longer implemented) API
+ * can actually be identified and removed.
+ * Nonetheless, semantics should also be documented carefully in this file.
+ */
+
+#include <linux/types.h>
+
+#define NL80211_GENL_NAME "nl80211"
+
+#define NL80211_MULTICAST_GROUP_CONFIG		"config"
+#define NL80211_MULTICAST_GROUP_SCAN		"scan"
+#define NL80211_MULTICAST_GROUP_REG		"regulatory"
+#define NL80211_MULTICAST_GROUP_MLME		"mlme"
+#define NL80211_MULTICAST_GROUP_VENDOR		"vendor"
+#define NL80211_MULTICAST_GROUP_TESTMODE	"testmode"
+
+/**
+ * DOC: Station handling
+ *
+ * Stations are added per interface, but a special case exists with VLAN
+ * interfaces. When a station is bound to an AP interface, it may be moved
+ * into a VLAN identified by a VLAN interface index (%NL80211_ATTR_STA_VLAN).
+ * The station is still assumed to belong to the AP interface it was added
+ * to.
+ *
+ * Station handling varies per interface type and depending on the driver's
+ * capabilities.
+ *
+ * For drivers supporting TDLS with external setup (WIPHY_FLAG_SUPPORTS_TDLS
+ * and WIPHY_FLAG_TDLS_EXTERNAL_SETUP), the station lifetime is as follows:
+ *  - a setup station entry is added, not yet authorized, without any rate
+ *    or capability information, this just exists to avoid race conditions
+ *  - when the TDLS setup is done, a single NL80211_CMD_SET_STATION is valid
+ *    to add rate and capability information to the station and at the same
+ *    time mark it authorized.
+ *  - %NL80211_TDLS_ENABLE_LINK is then used
+ *  - after this, the only valid operation is to remove it by tearing down
+ *    the TDLS link (%NL80211_TDLS_DISABLE_LINK)
+ *
+ * TODO: need more info for other interface types
+ */
+
+/**
+ * DOC: Frame transmission/registration support
+ *
+ * Frame transmission and registration support exists to allow userspace
+ * management entities such as wpa_supplicant react to management frames
+ * that are not being handled by the kernel. This includes, for example,
+ * certain classes of action frames that cannot be handled in the kernel
+ * for various reasons.
+ *
+ * Frame registration is done on a per-interface basis and registrations
+ * cannot be removed other than by closing the socket. It is possible to
+ * specify a registration filter to register, for example, only for a
+ * certain type of action frame. In particular with action frames, those
+ * that userspace registers for will not be returned as unhandled by the
+ * driver, so that the registered application has to take responsibility
+ * for doing that.
+ *
+ * The type of frame that can be registered for is also dependent on the
+ * driver and interface type. The frame types are advertised in wiphy
+ * attributes so applications know what to expect.
+ *
+ * NOTE: When an interface changes type while registrations are active,
+ *       these registrations are ignored until the interface type is
+ *       changed again. This means that changing the interface type can
+ *       lead to a situation that couldn't otherwise be produced, but
+ *       any such registrations will be dormant in the sense that they
+ *       will not be serviced, i.e. they will not receive any frames.
+ *
+ * Frame transmission allows userspace to send for example the required
+ * responses to action frames. It is subject to some sanity checking,
+ * but many frames can be transmitted. When a frame was transmitted, its
+ * status is indicated to the sending socket.
+ *
+ * For more technical details, see the corresponding command descriptions
+ * below.
+ */
+
+/**
+ * DOC: Virtual interface / concurrency capabilities
+ *
+ * Some devices are able to operate with virtual MACs, they can have
+ * more than one virtual interface. The capability handling for this
+ * is a bit complex though, as there may be a number of restrictions
+ * on the types of concurrency that are supported.
+ *
+ * To start with, each device supports the interface types listed in
+ * the %NL80211_ATTR_SUPPORTED_IFTYPES attribute, but by listing the
+ * types there no concurrency is implied.
+ *
+ * Once concurrency is desired, more attributes must be observed:
+ * To start with, since some interface types are purely managed in
+ * software, like the AP-VLAN type in mac80211 for example, there's
+ * an additional list of these, they can be added at any time and
+ * are only restricted by some semantic restrictions (e.g. AP-VLAN
+ * cannot be added without a corresponding AP interface). This list
+ * is exported in the %NL80211_ATTR_SOFTWARE_IFTYPES attribute.
+ *
+ * Further, the list of supported combinations is exported. This is
+ * in the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute. Basically,
+ * it exports a list of "groups", and at any point in time the
+ * interfaces that are currently active must fall into any one of
+ * the advertised groups. Within each group, there are restrictions
+ * on the number of interfaces of different types that are supported
+ * and also the number of different channels, along with potentially
+ * some other restrictions. See &enum nl80211_if_combination_attrs.
+ *
+ * All together, these attributes define the concurrency of virtual
+ * interfaces that a given device supports.
+ */
+
+/**
+ * DOC: packet coalesce support
+ *
+ * In most cases, host that receives IPv4 and IPv6 multicast/broadcast
+ * packets does not do anything with these packets. Therefore the
+ * reception of these unwanted packets causes unnecessary processing
+ * and power consumption.
+ *
+ * Packet coalesce feature helps to reduce number of received interrupts
+ * to host by buffering these packets in firmware/hardware for some
+ * predefined time. Received interrupt will be generated when one of the
+ * following events occur.
+ * a) Expiration of hardware timer whose expiration time is set to maximum
+ * coalescing delay of matching coalesce rule.
+ * b) Coalescing buffer in hardware reaches it's limit.
+ * c) Packet doesn't match any of the configured coalesce rules.
+ *
+ * User needs to configure following parameters for creating a coalesce
+ * rule.
+ * a) Maximum coalescing delay
+ * b) List of packet patterns which needs to be matched
+ * c) Condition for coalescence. pattern 'match' or 'no match'
+ * Multiple such rules can be created.
+ */
+
+/**
+ * enum nl80211_commands - supported nl80211 commands
+ *
+ * @NL80211_CMD_UNSPEC: unspecified command to catch errors
+ *
+ * @NL80211_CMD_GET_WIPHY: request information about a wiphy or dump request
+ *	to get a list of all present wiphys.
+ * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
+ *	%NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
+ *	%NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ (and the
+ *	attributes determining the channel width; this is used for setting
+ *	monitor mode channel),  %NL80211_ATTR_WIPHY_RETRY_SHORT,
+ *	%NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+ *	and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
+ *	However, for setting the channel, see %NL80211_CMD_SET_CHANNEL
+ *	instead, the support here is for backward compatibility only.
+ * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
+ *	or rename notification. Has attributes %NL80211_ATTR_WIPHY and
+ *	%NL80211_ATTR_WIPHY_NAME.
+ * @NL80211_CMD_DEL_WIPHY: Wiphy deleted. Has attributes
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_WIPHY_NAME.
+ *
+ * @NL80211_CMD_GET_INTERFACE: Request an interface's configuration;
+ *	either a dump request for all interfaces or a specific get with a
+ *	single %NL80211_ATTR_IFINDEX is supported.
+ * @NL80211_CMD_SET_INTERFACE: Set type of a virtual interface, requires
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_IFTYPE.
+ * @NL80211_CMD_NEW_INTERFACE: Newly created virtual interface or response
+ *	to %NL80211_CMD_GET_INTERFACE. Has %NL80211_ATTR_IFINDEX,
+ *	%NL80211_ATTR_WIPHY and %NL80211_ATTR_IFTYPE attributes. Can also
+ *	be sent from userspace to request creation of a new virtual interface,
+ *	then requires attributes %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFTYPE and
+ *	%NL80211_ATTR_IFNAME.
+ * @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from
+ *	userspace to request deletion of a virtual interface, then requires
+ *	attribute %NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified
+ *	by %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC.
+ * @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,
+ *	%NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD.
+ * @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,
+ *	%NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,
+ *	and %NL80211_ATTR_KEY_SEQ attributes.
+ * @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX
+ *	or %NL80211_ATTR_MAC.
+ *
+ * @NL80211_CMD_GET_BEACON: (not used)
+ * @NL80211_CMD_SET_BEACON: change the beacon on an access point interface
+ *	using the %NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL
+ *	attributes. For drivers that generate the beacon and probe responses
+ *	internally, the following attributes must be provided: %NL80211_ATTR_IE,
+ *	%NL80211_ATTR_IE_PROBE_RESP and %NL80211_ATTR_IE_ASSOC_RESP.
+ * @NL80211_CMD_START_AP: Start AP operation on an AP interface, parameters
+ *	are like for %NL80211_CMD_SET_BEACON, and additionally parameters that
+ *	do not change are used, these include %NL80211_ATTR_BEACON_INTERVAL,
+ *	%NL80211_ATTR_DTIM_PERIOD, %NL80211_ATTR_SSID,
+ *	%NL80211_ATTR_HIDDEN_SSID, %NL80211_ATTR_CIPHERS_PAIRWISE,
+ *	%NL80211_ATTR_CIPHER_GROUP, %NL80211_ATTR_WPA_VERSIONS,
+ *	%NL80211_ATTR_AKM_SUITES, %NL80211_ATTR_PRIVACY,
+ *	%NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_INACTIVITY_TIMEOUT,
+ *	%NL80211_ATTR_ACL_POLICY and %NL80211_ATTR_MAC_ADDRS.
+ *	The channel to use can be set on the interface or be given using the
+ *	%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel width.
+ * @NL80211_CMD_NEW_BEACON: old alias for %NL80211_CMD_START_AP
+ * @NL80211_CMD_STOP_AP: Stop AP operation on the given interface
+ * @NL80211_CMD_DEL_BEACON: old alias for %NL80211_CMD_STOP_AP
+ *
+ * @NL80211_CMD_GET_STATION: Get station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_STATION: Set station attributes for station identified by
+ *	%NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_STATION: Add a station with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all stations, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX. %NL80211_ATTR_MGMT_SUBTYPE and
+ *	%NL80211_ATTR_REASON_CODE can optionally be used to specify which type
+ *	of disconnection indication should be sent to the station
+ *	(Deauthentication or Disassociation frame and reason code for that
+ *	frame).
+ *
+ * @NL80211_CMD_GET_MPATH: Get mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to
+ * 	destination %NL80211_ATTR_MAC on the interface identified by
+ * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_MPATH: Create a new mesh path for the destination given by
+ *	%NL80211_ATTR_MAC via %NL80211_ATTR_MPATH_NEXT_HOP.
+ * @NL80211_CMD_DEL_MPATH: Delete a mesh path to the destination given by
+ *	%NL80211_ATTR_MAC.
+ * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
+ *	the interface identified by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
+ *	or, if no MAC address given, all mesh paths, on the interface identified
+ *	by %NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_SET_BSS: Set BSS attributes for BSS identified by
+ *	%NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set
+ *	regulatory domain. If %NL80211_ATTR_WIPHY is specified and the device
+ *	has a private regulatory domain, it will be returned. Otherwise, the
+ *	global regdomain will be returned.
+ *	A device will have a private regulatory domain if it uses the
+ *	regulatory_hint() API. Even when a private regdomain is used the channel
+ *	information will still be mended according to further hints from
+ *	the regulatory core to help with compliance. A dump version of this API
+ *	is now available which will returns the global regdomain as well as
+ *	all private regdomains of present wiphys (for those that have it).
+ *	If a wiphy is self-managed (%NL80211_ATTR_WIPHY_SELF_MANAGED_REG), then
+ *	its private regdomain is the only valid one for it. The regulatory
+ *	core is not used to help with compliance in this case.
+ * @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command
+ *	after being queried by the kernel. CRDA replies by sending a regulatory
+ *	domain structure which consists of %NL80211_ATTR_REG_ALPHA set to our
+ *	current alpha2 if it found a match. It also provides
+ * 	NL80211_ATTR_REG_RULE_FLAGS, and a set of regulatory rules. Each
+ * 	regulatory rule is a nested set of attributes  given by
+ * 	%NL80211_ATTR_REG_RULE_FREQ_[START|END] and
+ * 	%NL80211_ATTR_FREQ_RANGE_MAX_BW with an attached power rule given by
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_ANT_GAIN and
+ * 	%NL80211_ATTR_REG_RULE_POWER_MAX_EIRP.
+ * @NL80211_CMD_REQ_SET_REG: ask the wireless core to set the regulatory domain
+ * 	to the specified ISO/IEC 3166-1 alpha2 country code. The core will
+ * 	store this as a valid request and then query userspace for it.
+ *
+ * @NL80211_CMD_GET_MESH_CONFIG: Get mesh networking properties for the
+ *	interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MESH_CONFIG: Set mesh networking properties for the
+ *      interface identified by %NL80211_ATTR_IFINDEX
+ *
+ * @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The
+ *	interface is identified with %NL80211_ATTR_IFINDEX and the management
+ *	frame subtype with %NL80211_ATTR_MGMT_SUBTYPE. The extra IE data to be
+ *	added to the end of the specified management frame is specified with
+ *	%NL80211_ATTR_IE. If the command succeeds, the requested data will be
+ *	added to all specified management frames generated by
+ *	kernel/firmware/driver.
+ *	Note: This command has been removed and it is only reserved at this
+ *	point to avoid re-using existing command number. The functionality this
+ *	command was planned for has been provided with cleaner design with the
+ *	option to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,
+ *	NL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_CMD_GET_SCAN: get scan results
+ * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	probe requests at CCK rate or not.
+ * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
+ *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
+ * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
+ *	partial scan results may be available
+ *
+ * @NL80211_CMD_START_SCHED_SCAN: start a scheduled scan at certain
+ *	intervals, as specified by %NL80211_ATTR_SCHED_SCAN_INTERVAL.
+ *	Like with normal scans, if SSIDs (%NL80211_ATTR_SCAN_SSIDS)
+ *	are passed, they are used in the probe requests.  For
+ *	broadcast, a broadcast SSID must be passed (ie. an empty
+ *	string).  If no SSID is passed, no probe requests are sent and
+ *	a passive scan is performed.  %NL80211_ATTR_SCAN_FREQUENCIES,
+ *	if passed, define which channels should be scanned; if not
+ *	passed, all channels allowed for the current regulatory domain
+ *	are used.  Extra IEs can also be passed from the userspace by
+ *	using the %NL80211_ATTR_IE attribute.  The first cycle of the
+ *	scheduled scan can be delayed by %NL80211_ATTR_SCHED_SCAN_DELAY
+ *	is supplied.
+ * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan. Returns -ENOENT if
+ *	scheduled scan is not running. The caller may assume that as soon
+ *	as the call returns, it is safe to start a new scheduled scan again.
+ * @NL80211_CMD_SCHED_SCAN_RESULTS: indicates that there are scheduled scan
+ *	results available.
+ * @NL80211_CMD_SCHED_SCAN_STOPPED: indicates that the scheduled scan has
+ *	stopped.  The driver may issue this event at any time during a
+ *	scheduled scan.  One reason for stopping the scan is if the hardware
+ *	does not support starting an association or a normal scan while running
+ *	a scheduled scan.  This event is also sent when the
+ *	%NL80211_CMD_STOP_SCHED_SCAN command is received or when the interface
+ *	is brought down while a scheduled scan was running.
+ *
+ * @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation
+ *      or noise level
+ * @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to
+ *	NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
+ *
+ * @NL80211_CMD_SET_PMKSA: Add a PMKSA cache entry, using %NL80211_ATTR_MAC
+ *	(for the BSSID) and %NL80211_ATTR_PMKID.
+ * @NL80211_CMD_DEL_PMKSA: Delete a PMKSA cache entry, using %NL80211_ATTR_MAC
+ *	(for the BSSID) and %NL80211_ATTR_PMKID.
+ * @NL80211_CMD_FLUSH_PMKSA: Flush all PMKSA cache entries.
+ *
+ * @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain
+ * 	has been changed and provides details of the request information
+ * 	that caused the change such as who initiated the regulatory request
+ * 	(%NL80211_ATTR_REG_INITIATOR), the wiphy_idx
+ * 	(%NL80211_ATTR_REG_ALPHA2) on which the request was made from if
+ * 	the initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or
+ * 	%NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain
+ * 	set (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is
+ * 	%NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on
+ * 	to (%NL80211_ATTR_REG_ALPHA2).
+ * @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon
+ * 	has been found while world roaming thus enabling active scan or
+ * 	any mode of operation that initiates TX (beacons) on a channel
+ * 	where we would not have been able to do either before. As an example
+ * 	if you are world roaming (regulatory domain set to world or if your
+ * 	driver is using a custom world roaming regulatory domain) and while
+ * 	doing a passive scan on the 5 GHz band you find an AP there (if not
+ * 	on a DFS channel) you will now be able to actively scan for that AP
+ * 	or use AP mode on your card on that same channel. Note that this will
+ * 	never be used for channels 1-11 on the 2 GHz band as they are always
+ * 	enabled world wide. This beacon hint is only sent if your device had
+ * 	either disabled active scanning or beaconing on a channel. We send to
+ * 	userspace the wiphy on which we removed a restriction from
+ * 	(%NL80211_ATTR_WIPHY) and the channel on which this occurred
+ * 	before (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)
+ * 	the beacon hint was processed.
+ *
+ * @NL80211_CMD_AUTHENTICATE: authentication request and notification.
+ *	This command is used both as a command (request to authenticate) and
+ *	as an event on the "mlme" multicast group indicating completion of the
+ *	authentication process.
+ *	When used as a command, %NL80211_ATTR_IFINDEX is used to identify the
+ *	interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
+ *	BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
+ *	the SSID (mainly for association, but is included in authentication
+ *	request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
+ *	to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
+ *	is used to specify the authentication type. %NL80211_ATTR_IE is used to
+ *	define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
+ *	to be added to the frame.
+ *	When used as an event, this reports reception of an Authentication
+ *	frame in station and IBSS modes when the local MLME processed the
+ *	frame, i.e., it was for the local STA and was received in correct
+ *	state. This is similar to MLME-AUTHENTICATE.confirm primitive in the
+ *	MLME SAP interface (kernel providing MLME, userspace SME). The
+ *	included %NL80211_ATTR_FRAME attribute contains the management frame
+ *	(including both the header and frame body, but not FCS). This event is
+ *	also used to indicate if the authentication attempt timed out. In that
+ *	case the %NL80211_ATTR_FRAME attribute is replaced with a
+ *	%NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which
+ *	pending authentication timed out).
+ * @NL80211_CMD_ASSOCIATE: association request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Association and Reassociation
+ *	(similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,
+ *	MLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives).
+ * @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to
+ *	MLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication
+ *	primitives).
+ * @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like
+ *	NL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to
+ *	MLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives).
+ *
+ * @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael
+ *	MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
+ *	event includes %NL80211_ATTR_MAC to describe the source MAC address of
+ *	the frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key
+ *	type, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and
+ *	%NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this
+ *	event matches with MLME-MICHAELMICFAILURE.indication() primitive
+ *
+ * @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a
+ *	FREQ attribute (for the initial frequency if no peer can be found)
+ *	and optionally a MAC (as BSSID) and FREQ_FIXED attribute if those
+ *	should be fixed rather than automatically determined. Can only be
+ *	executed on a network interface that is UP, and fixed BSSID/FREQ
+ *	may be rejected. Another optional parameter is the beacon interval,
+ *	given in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not
+ *	given defaults to 100 TU (102.4ms).
+ * @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is
+ *	determined by the network interface.
+ *
+ * @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute
+ *	to identify the device, and the TESTDATA blob attribute to pass through
+ *	to the driver.
+ *
+ * @NL80211_CMD_CONNECT: connection request and notification; this command
+ *	requests to connect to a specified network but without separating
+ *	auth and assoc steps. For this, you need to specify the SSID in a
+ *	%NL80211_ATTR_SSID attribute, and can optionally specify the association
+ *	IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_USE_MFP,
+ *	%NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+ *	%NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT, %NL80211_ATTR_MAC_HINT, and
+ *	%NL80211_ATTR_WIPHY_FREQ_HINT.
+ *	If included, %NL80211_ATTR_MAC and %NL80211_ATTR_WIPHY_FREQ are
+ *	restrictions on BSS selection, i.e., they effectively prevent roaming
+ *	within the ESS. %NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT
+ *	can be included to provide a recommendation of the initial BSS while
+ *	allowing the driver to roam to other BSSes within the ESS and also to
+ *	ignore this recommendation if the indicated BSS is not ideal. Only one
+ *	set of BSSID,frequency parameters is used (i.e., either the enforcing
+ *	%NL80211_ATTR_MAC,%NL80211_ATTR_WIPHY_FREQ or the less strict
+ *	%NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT).
+ *	Background scan period can optionally be
+ *	specified in %NL80211_ATTR_BG_SCAN_PERIOD,
+ *	if not specified default background scan configuration
+ *	in driver is used and if period value is 0, bg scan will be disabled.
+ *	This attribute is ignored if driver does not support roam scan.
+ *	It is also sent as an event, with the BSSID and response IEs when the
+ *	connection is established or failed to be established. This can be
+ *	determined by the STATUS_CODE attribute.
+ * @NL80211_CMD_ROAM: request that the card roam (currently not implemented),
+ *	sent as an event when the card/driver roamed by itself.
+ * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
+ *	userspace that a connection was dropped by the AP or due to other
+ *	reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
+ *	%NL80211_ATTR_REASON_CODE attributes are used.
+ *
+ * @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices
+ *	associated with this wiphy must be down and will follow.
+ *
+ * @NL80211_CMD_REMAIN_ON_CHANNEL: Request to remain awake on the specified
+ *	channel for the specified amount of time. This can be used to do
+ *	off-channel operations like transmit a Public Action frame and wait for
+ *	a response while being associated to an AP on another channel.
+ *	%NL80211_ATTR_IFINDEX is used to specify which interface (and thus
+ *	radio) is used. %NL80211_ATTR_WIPHY_FREQ is used to specify the
+ *	frequency for the operation.
+ *	%NL80211_ATTR_DURATION is used to specify the duration in milliseconds
+ *	to remain on the channel. This command is also used as an event to
+ *	notify when the requested duration starts (it may take a while for the
+ *	driver to schedule this time due to other concurrent needs for the
+ *	radio).
+ *	When called, this operation returns a cookie (%NL80211_ATTR_COOKIE)
+ *	that will be included with any events pertaining to this request;
+ *	the cookie is also used to cancel the request.
+ * @NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL: This command can be used to cancel a
+ *	pending remain-on-channel duration if the desired operation has been
+ *	completed prior to expiration of the originally requested duration.
+ *	%NL80211_ATTR_WIPHY or %NL80211_ATTR_IFINDEX is used to specify the
+ *	radio. The %NL80211_ATTR_COOKIE attribute must be given as well to
+ *	uniquely identify the request.
+ *	This command is also used as an event to notify when a requested
+ *	remain-on-channel duration has expired.
+ *
+ * @NL80211_CMD_SET_TX_BITRATE_MASK: Set the mask of rates to be used in TX
+ *	rate selection. %NL80211_ATTR_IFINDEX is used to specify the interface
+ *	and @NL80211_ATTR_TX_RATES the set of allowed rates.
+ *
+ * @NL80211_CMD_REGISTER_FRAME: Register for receiving certain mgmt frames
+ *	(via @NL80211_CMD_FRAME) for processing in userspace. This command
+ *	requires an interface index, a frame type attribute (optional for
+ *	backward compatibility reasons, if not given assumes action frames)
+ *	and a match attribute containing the first few bytes of the frame
+ *	that should match, e.g. a single byte for only a category match or
+ *	four bytes for vendor frames including the OUI. The registration
+ *	cannot be dropped, but is removed automatically when the netlink
+ *	socket is closed. Multiple registrations can be made.
+ * @NL80211_CMD_REGISTER_ACTION: Alias for @NL80211_CMD_REGISTER_FRAME for
+ *	backward compatibility
+ * @NL80211_CMD_FRAME: Management frame TX request and RX notification. This
+ *	command is used both as a request to transmit a management frame and
+ *	as an event indicating reception of a frame that was not processed in
+ *	kernel code, but is for us (i.e., which may need to be processed in a
+ *	user space application). %NL80211_ATTR_FRAME is used to specify the
+ *	frame contents (including header). %NL80211_ATTR_WIPHY_FREQ is used
+ *	to indicate on which channel the frame is to be transmitted or was
+ *	received. If this channel is not the current channel (remain-on-channel
+ *	or the operational channel) the device will switch to the given channel
+ *	and transmit the frame, optionally waiting for a response for the time
+ *	specified using %NL80211_ATTR_DURATION. When called, this operation
+ *	returns a cookie (%NL80211_ATTR_COOKIE) that will be included with the
+ *	TX status event pertaining to the TX request.
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	management frames at CCK rate or not in 2GHz band.
+ *	%NL80211_ATTR_CSA_C_OFFSETS_TX is an array of offsets to CSA
+ *	counters which will be updated to the current value. This attribute
+ *	is used during CSA period.
+ * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
+ *	command may be used with the corresponding cookie to cancel the wait
+ *	time if it is known that it is no longer necessary.
+ * @NL80211_CMD_ACTION: Alias for @NL80211_CMD_FRAME for backward compatibility.
+ * @NL80211_CMD_FRAME_TX_STATUS: Report TX status of a management frame
+ *	transmitted with %NL80211_CMD_FRAME. %NL80211_ATTR_COOKIE identifies
+ *	the TX command and %NL80211_ATTR_FRAME includes the contents of the
+ *	frame. %NL80211_ATTR_ACK flag is included if the recipient acknowledged
+ *	the frame.
+ * @NL80211_CMD_ACTION_TX_STATUS: Alias for @NL80211_CMD_FRAME_TX_STATUS for
+ *	backward compatibility.
+ *
+ * @NL80211_CMD_SET_POWER_SAVE: Set powersave, using %NL80211_ATTR_PS_STATE
+ * @NL80211_CMD_GET_POWER_SAVE: Get powersave status in %NL80211_ATTR_PS_STATE
+ *
+ * @NL80211_CMD_SET_CQM: Connection quality monitor configuration. This command
+ *	is used to configure connection quality monitoring notification trigger
+ *	levels.
+ * @NL80211_CMD_NOTIFY_CQM: Connection quality monitor notification. This
+ *	command is used as an event to indicate the that a trigger level was
+ *	reached.
+ * @NL80211_CMD_SET_CHANNEL: Set the channel (using %NL80211_ATTR_WIPHY_FREQ
+ *	and the attributes determining channel width) the given interface
+ *	(identifed by %NL80211_ATTR_IFINDEX) shall operate on.
+ *	In case multiple channels are supported by the device, the mechanism
+ *	with which it switches channels is implementation-defined.
+ *	When a monitor interface is given, it can only switch channel while
+ *	no other interfaces are operating to avoid disturbing the operation
+ *	of any other interfaces, and other interfaces will again take
+ *	precedence when they are used.
+ *
+ * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface.
+ *
+ * @NL80211_CMD_JOIN_MESH: Join a mesh. The mesh ID must be given, and initial
+ *	mesh config parameters may be given.
+ * @NL80211_CMD_LEAVE_MESH: Leave the mesh network -- no special arguments, the
+ *	network is determined by the network interface.
+ *
+ * @NL80211_CMD_UNPROT_DEAUTHENTICATE: Unprotected deauthentication frame
+ *	notification. This event is used to indicate that an unprotected
+ *	deauthentication frame was dropped when MFP is in use.
+ * @NL80211_CMD_UNPROT_DISASSOCIATE: Unprotected disassociation frame
+ *	notification. This event is used to indicate that an unprotected
+ *	disassociation frame was dropped when MFP is in use.
+ *
+ * @NL80211_CMD_NEW_PEER_CANDIDATE: Notification on the reception of a
+ *      beacon or probe response from a compatible mesh peer.  This is only
+ *      sent while no station information (sta_info) exists for the new peer
+ *      candidate and when @NL80211_MESH_SETUP_USERSPACE_AUTH,
+ *      @NL80211_MESH_SETUP_USERSPACE_AMPE, or
+ *      @NL80211_MESH_SETUP_USERSPACE_MPM is set.  On reception of this
+ *      notification, userspace may decide to create a new station
+ *      (@NL80211_CMD_NEW_STATION).  To stop this notification from
+ *      reoccurring, the userspace authentication daemon may want to create the
+ *      new station with the AUTHENTICATED flag unset and maybe change it later
+ *      depending on the authentication result.
+ *
+ * @NL80211_CMD_GET_WOWLAN: get Wake-on-Wireless-LAN (WoWLAN) settings.
+ * @NL80211_CMD_SET_WOWLAN: set Wake-on-Wireless-LAN (WoWLAN) settings.
+ *	Since wireless is more complex than wired ethernet, it supports
+ *	various triggers. These triggers can be configured through this
+ *	command with the %NL80211_ATTR_WOWLAN_TRIGGERS attribute. For
+ *	more background information, see
+ *	http://wireless.kernel.org/en/users/Documentation/WoWLAN.
+ *	The @NL80211_CMD_SET_WOWLAN command can also be used as a notification
+ *	from the driver reporting the wakeup reason. In this case, the
+ *	@NL80211_ATTR_WOWLAN_TRIGGERS attribute will contain the reason
+ *	for the wakeup, if it was caused by wireless. If it is not present
+ *	in the wakeup notification, the wireless device didn't cause the
+ *	wakeup but reports that it was woken up.
+ *
+ * @NL80211_CMD_SET_REKEY_OFFLOAD: This command is used give the driver
+ *	the necessary information for supporting GTK rekey offload. This
+ *	feature is typically used during WoWLAN. The configuration data
+ *	is contained in %NL80211_ATTR_REKEY_DATA (which is nested and
+ *	contains the data in sub-attributes). After rekeying happened,
+ *	this command may also be sent by the driver as an MLME event to
+ *	inform userspace of the new replay counter.
+ *
+ * @NL80211_CMD_PMKSA_CANDIDATE: This is used as an event to inform userspace
+ *	of PMKSA caching dandidates.
+ *
+ * @NL80211_CMD_TDLS_OPER: Perform a high-level TDLS command (e.g. link setup).
+ *	In addition, this can be used as an event to request userspace to take
+ *	actions on TDLS links (set up a new link or tear down an existing one).
+ *	In such events, %NL80211_ATTR_TDLS_OPERATION indicates the requested
+ *	operation, %NL80211_ATTR_MAC contains the peer MAC address, and
+ *	%NL80211_ATTR_REASON_CODE the reason code to be used (only with
+ *	%NL80211_TDLS_TEARDOWN).
+ * @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame. The
+ *	%NL80211_ATTR_TDLS_ACTION attribute determines the type of frame to be
+ *	sent. Public Action codes (802.11-2012 8.1.5.1) will be sent as
+ *	802.11 management frames, while TDLS action codes (802.11-2012
+ *	8.5.13.1) will be encapsulated and sent as data frames. The currently
+ *	supported Public Action code is %WLAN_PUB_ACTION_TDLS_DISCOVER_RES
+ *	and the currently supported TDLS actions codes are given in
+ *	&enum ieee80211_tdls_actioncode.
+ *
+ * @NL80211_CMD_UNEXPECTED_FRAME: Used by an application controlling an AP
+ *	(or GO) interface (i.e. hostapd) to ask for unexpected frames to
+ *	implement sending deauth to stations that send unexpected class 3
+ *	frames. Also used as the event sent by the kernel when such a frame
+ *	is received.
+ *	For the event, the %NL80211_ATTR_MAC attribute carries the TA and
+ *	other attributes like the interface index are present.
+ *	If used as the command it must have an interface index and you can
+ *	only unsubscribe from the event by closing the socket. Subscription
+ *	is also for %NL80211_CMD_UNEXPECTED_4ADDR_FRAME events.
+ *
+ * @NL80211_CMD_UNEXPECTED_4ADDR_FRAME: Sent as an event indicating that the
+ *	associated station identified by %NL80211_ATTR_MAC sent a 4addr frame
+ *	and wasn't already in a 4-addr VLAN. The event will be sent similarly
+ *	to the %NL80211_CMD_UNEXPECTED_FRAME event, to the same listener.
+ *
+ * @NL80211_CMD_PROBE_CLIENT: Probe an associated station on an AP interface
+ *	by sending a null data frame to it and reporting when the frame is
+ *	acknowleged. This is used to allow timing out inactive clients. Uses
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_MAC. The command returns a
+ *	direct reply with an %NL80211_ATTR_COOKIE that is later used to match
+ *	up the event with the request. The event includes the same data and
+ *	has %NL80211_ATTR_ACK set if the frame was ACKed.
+ *
+ * @NL80211_CMD_REGISTER_BEACONS: Register this socket to receive beacons from
+ *	other BSSes when any interfaces are in AP mode. This helps implement
+ *	OLBC handling in hostapd. Beacons are reported in %NL80211_CMD_FRAME
+ *	messages. Note that per PHY only one application may register.
+ *
+ * @NL80211_CMD_SET_NOACK_MAP: sets a bitmap for the individual TIDs whether
+ *      No Acknowledgement Policy should be applied.
+ *
+ * @NL80211_CMD_CH_SWITCH_NOTIFY: An AP or GO may decide to switch channels
+ *	independently of the userspace SME, send this event indicating
+ *	%NL80211_ATTR_IFINDEX is now on %NL80211_ATTR_WIPHY_FREQ and the
+ *	attributes determining channel width.  This indication may also be
+ *	sent when a remotely-initiated switch (e.g., when a STA receives a CSA
+ *	from the remote AP) is completed;
+ *
+ * @NL80211_CMD_CH_SWITCH_STARTED_NOTIFY: Notify that a channel switch
+ *	has been started on an interface, regardless of the initiator
+ *	(ie. whether it was requested from a remote device or
+ *	initiated on our own).  It indicates that
+ *	%NL80211_ATTR_IFINDEX will be on %NL80211_ATTR_WIPHY_FREQ
+ *	after %NL80211_ATTR_CH_SWITCH_COUNT TBTT's.  The userspace may
+ *	decide to react to this indication by requesting other
+ *	interfaces to change channel as well.
+ *
+ * @NL80211_CMD_START_P2P_DEVICE: Start the given P2P Device, identified by
+ *	its %NL80211_ATTR_WDEV identifier. It must have been created with
+ *	%NL80211_CMD_NEW_INTERFACE previously. After it has been started, the
+ *	P2P Device can be used for P2P operations, e.g. remain-on-channel and
+ *	public action frame TX.
+ * @NL80211_CMD_STOP_P2P_DEVICE: Stop the given P2P Device, identified by
+ *	its %NL80211_ATTR_WDEV identifier.
+ *
+ * @NL80211_CMD_CONN_FAILED: connection request to an AP failed; used to
+ *	notify userspace that AP has rejected the connection request from a
+ *	station, due to particular reason. %NL80211_ATTR_CONN_FAILED_REASON
+ *	is used for this.
+ *
+ * @NL80211_CMD_SET_MCAST_RATE: Change the rate used to send multicast frames
+ *	for IBSS or MESH vif.
+ *
+ * @NL80211_CMD_SET_MAC_ACL: sets ACL for MAC address based access control.
+ *	This is to be used with the drivers advertising the support of MAC
+ *	address based access control. List of MAC addresses is passed in
+ *	%NL80211_ATTR_MAC_ADDRS and ACL policy is passed in
+ *	%NL80211_ATTR_ACL_POLICY. Driver will enable ACL with this list, if it
+ *	is not already done. The new list will replace any existing list. Driver
+ *	will clear its ACL when the list of MAC addresses passed is empty. This
+ *	command is used in AP/P2P GO mode. Driver has to make sure to clear its
+ *	ACL list during %NL80211_CMD_STOP_AP.
+ *
+ * @NL80211_CMD_RADAR_DETECT: Start a Channel availability check (CAC). Once
+ *	a radar is detected or the channel availability scan (CAC) has finished
+ *	or was aborted, or a radar was detected, usermode will be notified with
+ *	this event. This command is also used to notify userspace about radars
+ *	while operating on this channel.
+ *	%NL80211_ATTR_RADAR_EVENT is used to inform about the type of the
+ *	event.
+ *
+ * @NL80211_CMD_GET_PROTOCOL_FEATURES: Get global nl80211 protocol features,
+ *	i.e. features for the nl80211 protocol rather than device features.
+ *	Returns the features in the %NL80211_ATTR_PROTOCOL_FEATURES bitmap.
+ *
+ * @NL80211_CMD_UPDATE_FT_IES: Pass down the most up-to-date Fast Transition
+ *	Information Element to the WLAN driver
+ *
+ * @NL80211_CMD_FT_EVENT: Send a Fast transition event from the WLAN driver
+ *	to the supplicant. This will carry the target AP's MAC address along
+ *	with the relevant Information Elements. This event is used to report
+ *	received FT IEs (MDIE, FTIE, RSN IE, TIE, RICIE).
+ *
+ * @NL80211_CMD_CRIT_PROTOCOL_START: Indicates user-space will start running
+ *	a critical protocol that needs more reliability in the connection to
+ *	complete.
+ *
+ * @NL80211_CMD_CRIT_PROTOCOL_STOP: Indicates the connection reliability can
+ *	return back to normal.
+ *
+ * @NL80211_CMD_GET_COALESCE: Get currently supported coalesce rules.
+ * @NL80211_CMD_SET_COALESCE: Configure coalesce rules or clear existing rules.
+ *
+ * @NL80211_CMD_CHANNEL_SWITCH: Perform a channel switch by announcing the
+ *	the new channel information (Channel Switch Announcement - CSA)
+ *	in the beacon for some time (as defined in the
+ *	%NL80211_ATTR_CH_SWITCH_COUNT parameter) and then change to the
+ *	new channel. Userspace provides the new channel information (using
+ *	%NL80211_ATTR_WIPHY_FREQ and the attributes determining channel
+ *	width). %NL80211_ATTR_CH_SWITCH_BLOCK_TX may be supplied to inform
+ *	other station that transmission must be blocked until the channel
+ *	switch is complete.
+ *
+ * @NL80211_CMD_VENDOR: Vendor-specified command/event. The command is specified
+ *	by the %NL80211_ATTR_VENDOR_ID attribute and a sub-command in
+ *	%NL80211_ATTR_VENDOR_SUBCMD. Parameter(s) can be transported in
+ *	%NL80211_ATTR_VENDOR_DATA.
+ *	For feature advertisement, the %NL80211_ATTR_VENDOR_DATA attribute is
+ *	used in the wiphy data as a nested attribute containing descriptions
+ *	(&struct nl80211_vendor_cmd_info) of the supported vendor commands.
+ *	This may also be sent as an event with the same attributes.
+ *
+ * @NL80211_CMD_SET_QOS_MAP: Set Interworking QoS mapping for IP DSCP values.
+ *	The QoS mapping information is included in %NL80211_ATTR_QOS_MAP. If
+ *	that attribute is not included, QoS mapping is disabled. Since this
+ *	QoS mapping is relevant for IP packets, it is only valid during an
+ *	association. This is cleared on disassociation and AP restart.
+ *
+ * @NL80211_CMD_ADD_TX_TS: Ask the kernel to add a traffic stream for the given
+ *	%NL80211_ATTR_TSID and %NL80211_ATTR_MAC with %NL80211_ATTR_USER_PRIO
+ *	and %NL80211_ATTR_ADMITTED_TIME parameters.
+ *	Note that the action frame handshake with the AP shall be handled by
+ *	userspace via the normal management RX/TX framework, this only sets
+ *	up the TX TS in the driver/device.
+ *	If the admitted time attribute is not added then the request just checks
+ *	if a subsequent setup could be successful, the intent is to use this to
+ *	avoid setting up a session with the AP when local restrictions would
+ *	make that impossible. However, the subsequent "real" setup may still
+ *	fail even if the check was successful.
+ * @NL80211_CMD_DEL_TX_TS: Remove an existing TS with the %NL80211_ATTR_TSID
+ *	and %NL80211_ATTR_MAC parameters. It isn't necessary to call this
+ *	before removing a station entry entirely, or before disassociating
+ *	or similar, cleanup will happen in the driver/device in this case.
+ *
+ * @NL80211_CMD_GET_MPP: Get mesh path attributes for mesh proxy path to
+ *	destination %NL80211_ATTR_MAC on the interface identified by
+ *	%NL80211_ATTR_IFINDEX.
+ *
+ * @NL80211_CMD_JOIN_OCB: Join the OCB network. The center frequency and
+ *	bandwidth of a channel must be given.
+ * @NL80211_CMD_LEAVE_OCB: Leave the OCB network -- no special arguments, the
+ *	network is determined by the network interface.
+ *
+ * @NL80211_CMD_TDLS_CHANNEL_SWITCH: Start channel-switching with a TDLS peer,
+ *	identified by the %NL80211_ATTR_MAC parameter. A target channel is
+ *	provided via %NL80211_ATTR_WIPHY_FREQ and other attributes determining
+ *	channel width/type. The target operating class is given via
+ *	%NL80211_ATTR_OPER_CLASS.
+ *	The driver is responsible for continually initiating channel-switching
+ *	operations and returning to the base channel for communication with the
+ *	AP.
+ * @NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH: Stop channel-switching with a TDLS
+ *	peer given by %NL80211_ATTR_MAC. Both peers must be on the base channel
+ *	when this command completes.
+ *
+ * @NL80211_CMD_WIPHY_REG_CHANGE: Similar to %NL80211_CMD_REG_CHANGE, but used
+ *	as an event to indicate changes for devices with wiphy-specific regdom
+ *	management.
+ *
+ * @NL80211_CMD_MAX: highest used command number
+ * @__NL80211_CMD_AFTER_LAST: internal use
+ */
+enum nl80211_commands {
+/* don't change the order or add anything between, this is ABI! */
+	NL80211_CMD_UNSPEC,
+
+	NL80211_CMD_GET_WIPHY,		/* can dump */
+	NL80211_CMD_SET_WIPHY,
+	NL80211_CMD_NEW_WIPHY,
+	NL80211_CMD_DEL_WIPHY,
+
+	NL80211_CMD_GET_INTERFACE,	/* can dump */
+	NL80211_CMD_SET_INTERFACE,
+	NL80211_CMD_NEW_INTERFACE,
+	NL80211_CMD_DEL_INTERFACE,
+
+	NL80211_CMD_GET_KEY,
+	NL80211_CMD_SET_KEY,
+	NL80211_CMD_NEW_KEY,
+	NL80211_CMD_DEL_KEY,
+
+	NL80211_CMD_GET_BEACON,
+	NL80211_CMD_SET_BEACON,
+	NL80211_CMD_START_AP,
+	NL80211_CMD_NEW_BEACON = NL80211_CMD_START_AP,
+	NL80211_CMD_STOP_AP,
+	NL80211_CMD_DEL_BEACON = NL80211_CMD_STOP_AP,
+
+	NL80211_CMD_GET_STATION,
+	NL80211_CMD_SET_STATION,
+	NL80211_CMD_NEW_STATION,
+	NL80211_CMD_DEL_STATION,
+
+	NL80211_CMD_GET_MPATH,
+	NL80211_CMD_SET_MPATH,
+	NL80211_CMD_NEW_MPATH,
+	NL80211_CMD_DEL_MPATH,
+
+	NL80211_CMD_SET_BSS,
+
+	NL80211_CMD_SET_REG,
+	NL80211_CMD_REQ_SET_REG,
+
+	NL80211_CMD_GET_MESH_CONFIG,
+	NL80211_CMD_SET_MESH_CONFIG,
+
+	NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
+
+	NL80211_CMD_GET_REG,
+
+	NL80211_CMD_GET_SCAN,
+	NL80211_CMD_TRIGGER_SCAN,
+	NL80211_CMD_NEW_SCAN_RESULTS,
+	NL80211_CMD_SCAN_ABORTED,
+
+	NL80211_CMD_REG_CHANGE,
+
+	NL80211_CMD_AUTHENTICATE,
+	NL80211_CMD_ASSOCIATE,
+	NL80211_CMD_DEAUTHENTICATE,
+	NL80211_CMD_DISASSOCIATE,
+
+	NL80211_CMD_MICHAEL_MIC_FAILURE,
+
+	NL80211_CMD_REG_BEACON_HINT,
+
+	NL80211_CMD_JOIN_IBSS,
+	NL80211_CMD_LEAVE_IBSS,
+
+	NL80211_CMD_TESTMODE,
+
+	NL80211_CMD_CONNECT,
+	NL80211_CMD_ROAM,
+	NL80211_CMD_DISCONNECT,
+
+	NL80211_CMD_SET_WIPHY_NETNS,
+
+	NL80211_CMD_GET_SURVEY,
+	NL80211_CMD_NEW_SURVEY_RESULTS,
+
+	NL80211_CMD_SET_PMKSA,
+	NL80211_CMD_DEL_PMKSA,
+	NL80211_CMD_FLUSH_PMKSA,
+
+	NL80211_CMD_REMAIN_ON_CHANNEL,
+	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,
+
+	NL80211_CMD_SET_TX_BITRATE_MASK,
+
+	NL80211_CMD_REGISTER_FRAME,
+	NL80211_CMD_REGISTER_ACTION = NL80211_CMD_REGISTER_FRAME,
+	NL80211_CMD_FRAME,
+	NL80211_CMD_ACTION = NL80211_CMD_FRAME,
+	NL80211_CMD_FRAME_TX_STATUS,
+	NL80211_CMD_ACTION_TX_STATUS = NL80211_CMD_FRAME_TX_STATUS,
+
+	NL80211_CMD_SET_POWER_SAVE,
+	NL80211_CMD_GET_POWER_SAVE,
+
+	NL80211_CMD_SET_CQM,
+	NL80211_CMD_NOTIFY_CQM,
+
+	NL80211_CMD_SET_CHANNEL,
+	NL80211_CMD_SET_WDS_PEER,
+
+	NL80211_CMD_FRAME_WAIT_CANCEL,
+
+	NL80211_CMD_JOIN_MESH,
+	NL80211_CMD_LEAVE_MESH,
+
+	NL80211_CMD_UNPROT_DEAUTHENTICATE,
+	NL80211_CMD_UNPROT_DISASSOCIATE,
+
+	NL80211_CMD_NEW_PEER_CANDIDATE,
+
+	NL80211_CMD_GET_WOWLAN,
+	NL80211_CMD_SET_WOWLAN,
+
+	NL80211_CMD_START_SCHED_SCAN,
+	NL80211_CMD_STOP_SCHED_SCAN,
+	NL80211_CMD_SCHED_SCAN_RESULTS,
+	NL80211_CMD_SCHED_SCAN_STOPPED,
+
+	NL80211_CMD_SET_REKEY_OFFLOAD,
+
+	NL80211_CMD_PMKSA_CANDIDATE,
+
+	NL80211_CMD_TDLS_OPER,
+	NL80211_CMD_TDLS_MGMT,
+
+	NL80211_CMD_UNEXPECTED_FRAME,
+
+	NL80211_CMD_PROBE_CLIENT,
+
+	NL80211_CMD_REGISTER_BEACONS,
+
+	NL80211_CMD_UNEXPECTED_4ADDR_FRAME,
+
+	NL80211_CMD_SET_NOACK_MAP,
+
+	NL80211_CMD_CH_SWITCH_NOTIFY,
+
+	NL80211_CMD_START_P2P_DEVICE,
+	NL80211_CMD_STOP_P2P_DEVICE,
+
+	NL80211_CMD_CONN_FAILED,
+
+	NL80211_CMD_SET_MCAST_RATE,
+
+	NL80211_CMD_SET_MAC_ACL,
+
+	NL80211_CMD_RADAR_DETECT,
+
+	NL80211_CMD_GET_PROTOCOL_FEATURES,
+
+	NL80211_CMD_UPDATE_FT_IES,
+	NL80211_CMD_FT_EVENT,
+
+	NL80211_CMD_CRIT_PROTOCOL_START,
+	NL80211_CMD_CRIT_PROTOCOL_STOP,
+
+	NL80211_CMD_GET_COALESCE,
+	NL80211_CMD_SET_COALESCE,
+
+	NL80211_CMD_CHANNEL_SWITCH,
+
+	NL80211_CMD_VENDOR,
+
+	NL80211_CMD_SET_QOS_MAP,
+
+	NL80211_CMD_ADD_TX_TS,
+	NL80211_CMD_DEL_TX_TS,
+
+	NL80211_CMD_GET_MPP,
+
+	NL80211_CMD_JOIN_OCB,
+	NL80211_CMD_LEAVE_OCB,
+
+	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY,
+
+	NL80211_CMD_TDLS_CHANNEL_SWITCH,
+	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,
+
+	NL80211_CMD_WIPHY_REG_CHANGE,
+
+	/* add new commands above here */
+
+	/* used to define NL80211_CMD_MAX below */
+	__NL80211_CMD_AFTER_LAST,
+	NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
+};
+
+/*
+ * Allow user space programs to use #ifdef on new commands by defining them
+ * here
+ */
+#define NL80211_CMD_SET_BSS NL80211_CMD_SET_BSS
+#define NL80211_CMD_SET_MGMT_EXTRA_IE NL80211_CMD_SET_MGMT_EXTRA_IE
+#define NL80211_CMD_REG_CHANGE NL80211_CMD_REG_CHANGE
+#define NL80211_CMD_AUTHENTICATE NL80211_CMD_AUTHENTICATE
+#define NL80211_CMD_ASSOCIATE NL80211_CMD_ASSOCIATE
+#define NL80211_CMD_DEAUTHENTICATE NL80211_CMD_DEAUTHENTICATE
+#define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
+#define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
+
+#define NL80211_ATTR_FEATURE_FLAGS NL80211_ATTR_FEATURE_FLAGS
+
+/* source-level API compatibility */
+#define NL80211_CMD_GET_MESH_PARAMS NL80211_CMD_GET_MESH_CONFIG
+#define NL80211_CMD_SET_MESH_PARAMS NL80211_CMD_SET_MESH_CONFIG
+#define NL80211_MESH_SETUP_VENDOR_PATH_SEL_IE NL80211_MESH_SETUP_IE
+
+/**
+ * enum nl80211_attrs - nl80211 netlink attributes
+ *
+ * @NL80211_ATTR_UNSPEC: unspecified attribute to catch errors
+ *
+ * @NL80211_ATTR_WIPHY: index of wiphy to operate on, cf.
+ *	/sys/class/ieee80211/<phyname>/index
+ * @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)
+ * @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters
+ * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz,
+ *	defines the channel together with the (deprecated)
+ *	%NL80211_ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes
+ *	%NL80211_ATTR_CHANNEL_WIDTH and if needed %NL80211_ATTR_CENTER_FREQ1
+ *	and %NL80211_ATTR_CENTER_FREQ2
+ * @NL80211_ATTR_CHANNEL_WIDTH: u32 attribute containing one of the values
+ *	of &enum nl80211_chan_width, describing the channel width. See the
+ *	documentation of the enum for more information.
+ * @NL80211_ATTR_CENTER_FREQ1: Center frequency of the first part of the
+ *	channel, used for anything but 20 MHz bandwidth
+ * @NL80211_ATTR_CENTER_FREQ2: Center frequency of the second part of the
+ *	channel, used only for 80+80 MHz bandwidth
+ * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
+ *	if HT20 or HT40 are to be used (i.e., HT disabled if not included):
+ *	NL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including
+ *		this attribute)
+ *	NL80211_CHAN_HT20 = HT20 only
+ *	NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
+ *	NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
+ *	This attribute is now deprecated.
+ * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
+ *	less than or equal to the RTS threshold; allowed range: 1..255;
+ *	dot11ShortRetryLimit; u8
+ * @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is
+ *	greater than the RTS threshold; allowed range: 1..255;
+ *	dot11ShortLongLimit; u8
+ * @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum
+ *	length in octets for frames; allowed range: 256..8000, disable
+ *	fragmentation with (u32)-1; dot11FragmentationThreshold; u32
+ * @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length
+ *	larger than or equal to this use RTS/CTS handshake); allowed range:
+ *	0..65536, disable with (u32)-1; dot11RTSThreshold; u32
+ * @NL80211_ATTR_WIPHY_COVERAGE_CLASS: Coverage Class as defined by IEEE 802.11
+ *	section 7.3.2.9; dot11CoverageClass; u8
+ *
+ * @NL80211_ATTR_IFINDEX: network interface index of the device to operate on
+ * @NL80211_ATTR_IFNAME: network interface name
+ * @NL80211_ATTR_IFTYPE: type of virtual interface, see &enum nl80211_iftype
+ *
+ * @NL80211_ATTR_WDEV: wireless device identifier, used for pseudo-devices
+ *	that don't have a netdev (u64)
+ *
+ * @NL80211_ATTR_MAC: MAC address (various uses)
+ *
+ * @NL80211_ATTR_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_ATTR_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_ATTR_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_ATTR_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ * @NL80211_ATTR_KEY_DEFAULT: Flag attribute indicating the key is default key
+ * @NL80211_ATTR_KEY_DEFAULT_MGMT: Flag attribute indicating the key is the
+ *	default management key
+ * @NL80211_ATTR_CIPHER_SUITES_PAIRWISE: For crypto settings for connect or
+ *	other commands, indicates which pairwise cipher suites are used
+ * @NL80211_ATTR_CIPHER_SUITE_GROUP: For crypto settings for connect or
+ *	other commands, indicates which group cipher suite is used
+ *
+ * @NL80211_ATTR_BEACON_INTERVAL: beacon interval in TU
+ * @NL80211_ATTR_DTIM_PERIOD: DTIM period for beaconing
+ * @NL80211_ATTR_BEACON_HEAD: portion of the beacon before the TIM IE
+ * @NL80211_ATTR_BEACON_TAIL: portion of the beacon after the TIM IE
+ *
+ * @NL80211_ATTR_STA_AID: Association ID for the station (u16)
+ * @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *	&enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)
+ * @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by
+ *	IEEE 802.11 7.3.1.6 (u16).
+ * @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported
+ *	rates as defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ * @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station
+ *	to, or the AP interface the station was originally added to to.
+ * @NL80211_ATTR_STA_INFO: information about a station, part of station info
+ *	given for %NL80211_CMD_GET_STATION, nested attribute containing
+ *	info as possible, see &enum nl80211_sta_info.
+ *
+ * @NL80211_ATTR_WIPHY_BANDS: Information about an operating bands,
+ *	consisting of a nested array.
+ *
+ * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
+ * @NL80211_ATTR_STA_PLINK_ACTION: action to perform on the mesh peer link
+ *	(see &enum nl80211_plink_action).
+ * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
+ * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
+ * 	info given for %NL80211_CMD_GET_MPATH, nested attribute described at
+ *	&enum nl80211_mpath_info.
+ *
+ * @NL80211_ATTR_MNTR_FLAGS: flags, nested element with NLA_FLAG attributes of
+ *      &enum nl80211_mntr_flags.
+ *
+ * @NL80211_ATTR_REG_ALPHA2: an ISO-3166-alpha2 country code for which the
+ * 	current regulatory domain should be set to or is already set to.
+ * 	For example, 'CR', for Costa Rica. This attribute is used by the kernel
+ * 	to query the CRDA to retrieve one regulatory domain. This attribute can
+ * 	also be used by userspace to query the kernel for the currently set
+ * 	regulatory domain. We chose an alpha2 as that is also used by the
+ * 	IEEE-802.11 country information element to identify a country.
+ * 	Users can also simply ask the wireless core to set regulatory domain
+ * 	to a specific alpha2.
+ * @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory
+ *	rules.
+ *
+ * @NL80211_ATTR_BSS_CTS_PROT: whether CTS protection is enabled (u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_PREAMBLE: whether short preamble is enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_SHORT_SLOT_TIME: whether short slot time enabled
+ *	(u8, 0 or 1)
+ * @NL80211_ATTR_BSS_BASIC_RATES: basic rates, array of basic
+ *	rates in format defined by IEEE 802.11 7.3.2.2 but without the length
+ *	restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HT_CAPABILITY: HT Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ *
+ * @NL80211_ATTR_SUPPORTED_IFTYPES: nested attribute containing all
+ *	supported interface types, each a flag attribute with the number
+ *	of the interface mode.
+ *
+ * @NL80211_ATTR_MGMT_SUBTYPE: Management frame subtype for
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE.
+ *
+ * @NL80211_ATTR_IE: Information element(s) data (used, e.g., with
+ *	%NL80211_CMD_SET_MGMT_EXTRA_IE).
+ *
+ * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
+ *	a single scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS: number of SSIDs you can
+ *	scan with a single scheduled scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
+ *	that can be added to a scan request
+ * @NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN: maximum length of information
+ *	elements that can be added to a scheduled scan request
+ * @NL80211_ATTR_MAX_MATCH_SETS: maximum number of sets that can be
+ *	used with @NL80211_ATTR_SCHED_SCAN_MATCH, a wiphy attribute.
+ *
+ * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
+ * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
+ *	scanning and include a zero-length SSID (wildcard) for wildcard scan
+ * @NL80211_ATTR_BSS: scan result BSS
+ *
+ * @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain
+ * 	currently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*
+ * @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently
+ * 	set. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)
+ *
+ * @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies
+ *	an array of command numbers (i.e. a mapping index to command number)
+ *	that the driver for the given wiphy supports.
+ *
+ * @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header
+ *	and body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and
+ *	NL80211_CMD_ASSOCIATE events
+ * @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)
+ * @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,
+ *	represented as a u32
+ * @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and
+ *	%NL80211_CMD_DISASSOCIATE, u16
+ *
+ * @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as
+ *	a u32
+ *
+ * @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _before_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ * @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change
+ * 	due to considerations from a beacon hint. This attribute reflects
+ * 	the state of the channel _after_ the beacon hint processing. This
+ * 	attributes consists of a nested attribute containing
+ * 	NL80211_FREQUENCY_ATTR_*
+ *
+ * @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported
+ *	cipher suites
+ *
+ * @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look
+ *	for other networks on different channels
+ *
+ * @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this
+ *	is used, e.g., with %NL80211_CMD_AUTHENTICATE event
+ *
+ * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
+ *	used for the association (&enum nl80211_mfp, represented as a u32);
+ *	this attribute can be used
+ *	with %NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests
+ *
+ * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
+ *	&struct nl80211_sta_flag_update.
+ *
+ * @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls
+ *	IEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in
+ *	station mode. If the flag is included in %NL80211_CMD_ASSOCIATE
+ *	request, the driver will assume that the port is unauthorized until
+ *	authorized by user space. Otherwise, port is marked authorized by
+ *	default in station mode.
+ * @NL80211_ATTR_CONTROL_PORT_ETHERTYPE: A 16-bit value indicating the
+ *	ethertype that will be used for key negotiation. It can be
+ *	specified with the associate and connect commands. If it is not
+ *	specified, the value defaults to 0x888E (PAE, 802.1X). This
+ *	attribute is also used as a flag in the wiphy information to
+ *	indicate that protocols other than PAE are supported.
+ * @NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT: When included along with
+ *	%NL80211_ATTR_CONTROL_PORT_ETHERTYPE, indicates that the custom
+ *	ethertype frames used for key negotiation must not be encrypted.
+ *
+ * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
+ *	We recommend using nested, driver-specific attributes within this.
+ *
+ * @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT
+ *	event was due to the AP disconnecting the station, and not due to
+ *	a local disconnect request.
+ * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
+ *	event (u16)
+ * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
+ *	that protected APs should be used. This is also used with NEW_BEACON to
+ *	indicate that the BSS is to use protection.
+ *
+ * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT, ASSOCIATE, and NEW_BEACON
+ *	to indicate which unicast key ciphers will be used with the connection
+ *	(an array of u32).
+ * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which group key cipher will be used with the connection (a
+ *	u32).
+ * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which WPA version(s) the AP we want to associate with is using
+ *	(a u32 with flags from &enum nl80211_wpa_versions).
+ * @NL80211_ATTR_AKM_SUITES: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which key management algorithm(s) to use (an array of u32).
+ *
+ * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
+ *	sent out by the card, for ROAM and successful CONNECT events.
+ * @NL80211_ATTR_RESP_IE: (Re)association response information elements as
+ *	sent by peer, for ROAM and successful CONNECT events.
+ *
+ * @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used by in ASSOCIATE
+ *	commands to specify using a reassociate frame
+ *
+ * @NL80211_ATTR_KEY: key information in a nested attribute with
+ *	%NL80211_KEY_* sub-attributes
+ * @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()
+ *	and join_ibss(), key information is in a nested attribute each
+ *	with %NL80211_KEY_* sub-attributes
+ *
+ * @NL80211_ATTR_PID: Process ID of a network namespace.
+ *
+ * @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for
+ *	dumps. This number increases whenever the object list being
+ *	dumped changes, and as such userspace can verify that it has
+ *	obtained a complete and consistent snapshot by verifying that
+ *	all dump messages contain the same generation number. If it
+ *	changed then the list changed and the dump should be repeated
+ *	completely from scratch.
+ *
+ * @NL80211_ATTR_4ADDR: Use 4-address frames on a virtual interface
+ *
+ * @NL80211_ATTR_SURVEY_INFO: survey information about a channel, part of
+ *      the survey response for %NL80211_CMD_GET_SURVEY, nested attribute
+ *      containing info as possible, see &enum survey_info.
+ *
+ * @NL80211_ATTR_PMKID: PMK material for PMKSA caching.
+ * @NL80211_ATTR_MAX_NUM_PMKIDS: maximum number of PMKIDs a firmware can
+ *	cache, a wiphy attribute.
+ *
+ * @NL80211_ATTR_DURATION: Duration of an operation in milliseconds, u32.
+ * @NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION: Device attribute that
+ *	specifies the maximum duration that can be requested with the
+ *	remain-on-channel operation, in milliseconds, u32.
+ *
+ * @NL80211_ATTR_COOKIE: Generic 64-bit cookie to identify objects.
+ *
+ * @NL80211_ATTR_TX_RATES: Nested set of attributes
+ *	(enum nl80211_tx_rate_attributes) describing TX rates per band. The
+ *	enum nl80211_band value is used as the index (nla_type() of the nested
+ *	data. If a band is not included, it will be configured to allow all
+ *	rates based on negotiated supported rates information. This attribute
+ *	is used with %NL80211_CMD_SET_TX_BITRATE_MASK.
+ *
+ * @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain
+ *	at least one byte, currently used with @NL80211_CMD_REGISTER_FRAME.
+ * @NL80211_ATTR_FRAME_TYPE: A u16 indicating the frame type/subtype for the
+ *	@NL80211_CMD_REGISTER_FRAME command.
+ * @NL80211_ATTR_TX_FRAME_TYPES: wiphy capability attribute, which is a
+ *	nested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing
+ *	information about which frame types can be transmitted with
+ *	%NL80211_CMD_FRAME.
+ * @NL80211_ATTR_RX_FRAME_TYPES: wiphy capability attribute, which is a
+ *	nested attribute of %NL80211_ATTR_FRAME_TYPE attributes, containing
+ *	information about which frame types can be registered for RX.
+ *
+ * @NL80211_ATTR_ACK: Flag attribute indicating that the frame was
+ *	acknowledged by the recipient.
+ *
+ * @NL80211_ATTR_PS_STATE: powersave state, using &enum nl80211_ps_state values.
+ *
+ * @NL80211_ATTR_CQM: connection quality monitor configuration in a
+ *	nested attribute with %NL80211_ATTR_CQM_* sub-attributes.
+ *
+ * @NL80211_ATTR_LOCAL_STATE_CHANGE: Flag attribute to indicate that a command
+ *	is requesting a local authentication/association state change without
+ *	invoking actual management frame exchange. This can be used with
+ *	NL80211_CMD_AUTHENTICATE, NL80211_CMD_DEAUTHENTICATE,
+ *	NL80211_CMD_DISASSOCIATE.
+ *
+ * @NL80211_ATTR_AP_ISOLATE: (AP mode) Do not forward traffic between stations
+ *	connected to this BSS.
+ *
+ * @NL80211_ATTR_WIPHY_TX_POWER_SETTING: Transmit power setting type. See
+ *      &enum nl80211_tx_power_setting for possible values.
+ * @NL80211_ATTR_WIPHY_TX_POWER_LEVEL: Transmit power level in signed mBm units.
+ *      This is used in association with @NL80211_ATTR_WIPHY_TX_POWER_SETTING
+ *      for non-automatic settings.
+ *
+ * @NL80211_ATTR_SUPPORT_IBSS_RSN: The device supports IBSS RSN, which mostly
+ *	means support for per-station GTKs.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_TX: Bitmap of allowed antennas for transmitting.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for transmitting. If an antenna is not selected in this
+ *	bitmap the hardware is not allowed to transmit on this antenna.
+ *
+ *	Each bit represents one antenna, starting with antenna 1 at the first
+ *	bit. Depending on which antennas are selected in the bitmap, 802.11n
+ *	drivers can derive which chainmasks to use (if all antennas belonging to
+ *	a particular chain are disabled this chain should be disabled) and if
+ *	a chain has diversity antennas wether diversity should be used or not.
+ *	HT capabilities (STBC, TX Beamforming, Antenna selection) can be
+ *	derived from the available chains after applying the antenna mask.
+ *	Non-802.11n drivers can derive wether to use diversity or not.
+ *	Drivers may reject configurations or RX/TX mask combinations they cannot
+ *	support by returning -EINVAL.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_RX: Bitmap of allowed antennas for receiving.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for receiving. If an antenna is not selected in this bitmap
+ *	the hardware should not be configured to receive on this antenna.
+ *	For a more detailed description see @NL80211_ATTR_WIPHY_ANTENNA_TX.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX: Bitmap of antennas which are available
+ *	for configuration as TX antennas via the above parameters.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX: Bitmap of antennas which are available
+ *	for configuration as RX antennas via the above parameters.
+ *
+ * @NL80211_ATTR_MCAST_RATE: Multicast tx rate (in 100 kbps) for IBSS
+ *
+ * @NL80211_ATTR_OFFCHANNEL_TX_OK: For management frame TX, the frame may be
+ *	transmitted on another channel when the channel given doesn't match
+ *	the current channel. If the current channel doesn't match and this
+ *	flag isn't set, the frame will be rejected. This is also used as an
+ *	nl80211 capability flag.
+ *
+ * @NL80211_ATTR_BSS_HT_OPMODE: HT operation mode (u16)
+ *
+ * @NL80211_ATTR_KEY_DEFAULT_TYPES: A nested attribute containing flags
+ *	attributes, specifying what a key should be set as default as.
+ *	See &enum nl80211_key_default_types.
+ *
+ * @NL80211_ATTR_MESH_SETUP: Optional mesh setup parameters.  These cannot be
+ *	changed once the mesh is active.
+ * @NL80211_ATTR_MESH_CONFIG: Mesh configuration parameters, a nested attribute
+ *	containing attributes from &enum nl80211_meshconf_params.
+ * @NL80211_ATTR_SUPPORT_MESH_AUTH: Currently, this means the underlying driver
+ *	allows auth frames in a mesh to be passed to userspace for processing via
+ *	the @NL80211_MESH_SETUP_USERSPACE_AUTH flag.
+ * @NL80211_ATTR_STA_PLINK_STATE: The state of a mesh peer link as defined in
+ *	&enum nl80211_plink_state. Used when userspace is driving the peer link
+ *	management state machine.  @NL80211_MESH_SETUP_USERSPACE_AMPE or
+ *	@NL80211_MESH_SETUP_USERSPACE_MPM must be enabled.
+ *
+ * @NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: indicates, as part of the wiphy
+ *	capabilities, the supported WoWLAN triggers
+ * @NL80211_ATTR_WOWLAN_TRIGGERS: used by %NL80211_CMD_SET_WOWLAN to
+ *	indicate which WoW triggers should be enabled. This is also
+ *	used by %NL80211_CMD_GET_WOWLAN to get the currently enabled WoWLAN
+ *	triggers.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_INTERVAL: Interval between scheduled scan
+ *	cycles, in msecs.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_MATCH: Nested attribute with one or more
+ *	sets of attributes to match during scheduled scans.  Only BSSs
+ *	that match any of the sets will be reported.  These are
+ *	pass-thru filter rules.
+ *	For a match to succeed, the BSS must match all attributes of a
+ *	set.  Since not every hardware supports matching all types of
+ *	attributes, there is no guarantee that the reported BSSs are
+ *	fully complying with the match sets and userspace needs to be
+ *	able to ignore them by itself.
+ *	Thus, the implementation is somewhat hardware-dependent, but
+ *	this is only an optimization and the userspace application
+ *	needs to handle all the non-filtered results anyway.
+ *	If the match attributes don't make sense when combined with
+ *	the values passed in @NL80211_ATTR_SCAN_SSIDS (eg. if an SSID
+ *	is included in the probe request, but the match attributes
+ *	will never let it go through), -EINVAL may be returned.
+ *	If ommited, no filtering is done.
+ *
+ * @NL80211_ATTR_INTERFACE_COMBINATIONS: Nested attribute listing the supported
+ *	interface combinations. In each nested item, it contains attributes
+ *	defined in &enum nl80211_if_combination_attrs.
+ * @NL80211_ATTR_SOFTWARE_IFTYPES: Nested attribute (just like
+ *	%NL80211_ATTR_SUPPORTED_IFTYPES) containing the interface types that
+ *	are managed in software: interfaces of these types aren't subject to
+ *	any restrictions in their number or combinations.
+ *
+ * @NL80211_ATTR_REKEY_DATA: nested attribute containing the information
+ *	necessary for GTK rekeying in the device, see &enum nl80211_rekey_data.
+ *
+ * @NL80211_ATTR_SCAN_SUPP_RATES: rates per to be advertised as supported in scan,
+ *	nested array attribute containing an entry for each band, with the entry
+ *	being a list of supported rates as defined by IEEE 802.11 7.3.2.2 but
+ *	without the length restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HIDDEN_SSID: indicates whether SSID is to be hidden from Beacon
+ *	and Probe Response (when response to wildcard Probe Request); see
+ *	&enum nl80211_hidden_ssid, represented as a u32
+ *
+ * @NL80211_ATTR_IE_PROBE_RESP: Information element(s) for Probe Response frame.
+ *	This is used with %NL80211_CMD_NEW_BEACON and %NL80211_CMD_SET_BEACON to
+ *	provide extra IEs (e.g., WPS/P2P IE) into Probe Response frames when the
+ *	driver (or firmware) replies to Probe Request frames.
+ * @NL80211_ATTR_IE_ASSOC_RESP: Information element(s) for (Re)Association
+ *	Response frames. This is used with %NL80211_CMD_NEW_BEACON and
+ *	%NL80211_CMD_SET_BEACON to provide extra IEs (e.g., WPS/P2P IE) into
+ *	(Re)Association Response frames when the driver (or firmware) replies to
+ *	(Re)Association Request frames.
+ *
+ * @NL80211_ATTR_STA_WME: Nested attribute containing the wme configuration
+ *	of the station, see &enum nl80211_sta_wme_attr.
+ * @NL80211_ATTR_SUPPORT_AP_UAPSD: the device supports uapsd when working
+ *	as AP.
+ *
+ * @NL80211_ATTR_ROAM_SUPPORT: Indicates whether the firmware is capable of
+ *	roaming to another AP in the same ESS if the signal lever is low.
+ *
+ * @NL80211_ATTR_PMKSA_CANDIDATE: Nested attribute containing the PMKSA caching
+ *	candidate information, see &enum nl80211_pmksa_candidate_attr.
+ *
+ * @NL80211_ATTR_TX_NO_CCK_RATE: Indicates whether to use CCK rate or not
+ *	for management frames transmission. In order to avoid p2p probe/action
+ *	frames are being transmitted at CCK rate in 2GHz band, the user space
+ *	applications use this attribute.
+ *	This attribute is used with %NL80211_CMD_TRIGGER_SCAN and
+ *	%NL80211_CMD_FRAME commands.
+ *
+ * @NL80211_ATTR_TDLS_ACTION: Low level TDLS action code (e.g. link setup
+ *	request, link setup confirm, link teardown, etc.). Values are
+ *	described in the TDLS (802.11z) specification.
+ * @NL80211_ATTR_TDLS_DIALOG_TOKEN: Non-zero token for uniquely identifying a
+ *	TDLS conversation between two devices.
+ * @NL80211_ATTR_TDLS_OPERATION: High level TDLS operation; see
+ *	&enum nl80211_tdls_operation, represented as a u8.
+ * @NL80211_ATTR_TDLS_SUPPORT: A flag indicating the device can operate
+ *	as a TDLS peer sta.
+ * @NL80211_ATTR_TDLS_EXTERNAL_SETUP: The TDLS discovery/setup and teardown
+ *	procedures should be performed by sending TDLS packets via
+ *	%NL80211_CMD_TDLS_MGMT. Otherwise %NL80211_CMD_TDLS_OPER should be
+ *	used for asking the driver to perform a TDLS operation.
+ *
+ * @NL80211_ATTR_DEVICE_AP_SME: This u32 attribute may be listed for devices
+ *	that have AP support to indicate that they have the AP SME integrated
+ *	with support for the features listed in this attribute, see
+ *	&enum nl80211_ap_sme_features.
+ *
+ * @NL80211_ATTR_DONT_WAIT_FOR_ACK: Used with %NL80211_CMD_FRAME, this tells
+ *	the driver to not wait for an acknowledgement. Note that due to this,
+ *	it will also not give a status callback nor return a cookie. This is
+ *	mostly useful for probe responses to save airtime.
+ *
+ * @NL80211_ATTR_FEATURE_FLAGS: This u32 attribute contains flags from
+ *	&enum nl80211_feature_flags and is advertised in wiphy information.
+ * @NL80211_ATTR_PROBE_RESP_OFFLOAD: Indicates that the HW responds to probe
+ *	requests while operating in AP-mode.
+ *	This attribute holds a bitmap of the supported protocols for
+ *	offloading (see &enum nl80211_probe_resp_offload_support_attr).
+ *
+ * @NL80211_ATTR_PROBE_RESP: Probe Response template data. Contains the entire
+ *	probe-response frame. The DA field in the 802.11 header is zero-ed out,
+ *	to be filled by the FW.
+ * @NL80211_ATTR_DISABLE_HT:  Force HT capable interfaces to disable
+ *      this feature.  Currently, only supported in mac80211 drivers.
+ * @NL80211_ATTR_HT_CAPABILITY_MASK: Specify which bits of the
+ *      ATTR_HT_CAPABILITY to which attention should be paid.
+ *      Currently, only mac80211 NICs support this feature.
+ *      The values that may be configured are:
+ *       MCS rates, MAX-AMSDU, HT-20-40 and HT_CAP_SGI_40
+ *       AMPDU density and AMPDU factor.
+ *      All values are treated as suggestions and may be ignored
+ *      by the driver as required.  The actual values may be seen in
+ *      the station debugfs ht_caps file.
+ *
+ * @NL80211_ATTR_DFS_REGION: region for regulatory rules which this country
+ *    abides to when initiating radiation on DFS channels. A country maps
+ *    to one DFS region.
+ *
+ * @NL80211_ATTR_NOACK_MAP: This u16 bitmap contains the No Ack Policy of
+ *      up to 16 TIDs.
+ *
+ * @NL80211_ATTR_INACTIVITY_TIMEOUT: timeout value in seconds, this can be
+ *	used by the drivers which has MLME in firmware and does not have support
+ *	to report per station tx/rx activity to free up the staion entry from
+ *	the list. This needs to be used when the driver advertises the
+ *	capability to timeout the stations.
+ *
+ * @NL80211_ATTR_RX_SIGNAL_DBM: signal strength in dBm (as a 32-bit int);
+ *	this attribute is (depending on the driver capabilities) added to
+ *	received frames indicated with %NL80211_CMD_FRAME.
+ *
+ * @NL80211_ATTR_BG_SCAN_PERIOD: Background scan period in seconds
+ *      or 0 to disable background scan.
+ *
+ * @NL80211_ATTR_USER_REG_HINT_TYPE: type of regulatory hint passed from
+ *	userspace. If unset it is assumed the hint comes directly from
+ *	a user. If set code could specify exactly what type of source
+ *	was used to provide the hint. For the different types of
+ *	allowed user regulatory hints see nl80211_user_reg_hint_type.
+ *
+ * @NL80211_ATTR_CONN_FAILED_REASON: The reason for which AP has rejected
+ *	the connection request from a station. nl80211_connect_failed_reason
+ *	enum has different reasons of connection failure.
+ *
+ * @NL80211_ATTR_SAE_DATA: SAE elements in Authentication frames. This starts
+ *	with the Authentication transaction sequence number field.
+ *
+ * @NL80211_ATTR_VHT_CAPABILITY: VHT Capability information element (from
+ *	association request when used with NL80211_CMD_NEW_STATION)
+ *
+ * @NL80211_ATTR_SCAN_FLAGS: scan request control flags (u32)
+ *
+ * @NL80211_ATTR_P2P_CTWINDOW: P2P GO Client Traffic Window (u8), used with
+ *	the START_AP and SET_BSS commands
+ * @NL80211_ATTR_P2P_OPPPS: P2P GO opportunistic PS (u8), used with the
+ *	START_AP and SET_BSS commands. This can have the values 0 or 1;
+ *	if not given in START_AP 0 is assumed, if not given in SET_BSS
+ *	no change is made.
+ *
+ * @NL80211_ATTR_LOCAL_MESH_POWER_MODE: local mesh STA link-specific power mode
+ *	defined in &enum nl80211_mesh_power_mode.
+ *
+ * @NL80211_ATTR_ACL_POLICY: ACL policy, see &enum nl80211_acl_policy,
+ *	carried in a u32 attribute
+ *
+ * @NL80211_ATTR_MAC_ADDRS: Array of nested MAC addresses, used for
+ *	MAC ACL.
+ *
+ * @NL80211_ATTR_MAC_ACL_MAX: u32 attribute to advertise the maximum
+ *	number of MAC addresses that a device can support for MAC
+ *	ACL.
+ *
+ * @NL80211_ATTR_RADAR_EVENT: Type of radar event for notification to userspace,
+ *	contains a value of enum nl80211_radar_event (u32).
+ *
+ * @NL80211_ATTR_EXT_CAPA: 802.11 extended capabilities that the kernel driver
+ *	has and handles. The format is the same as the IE contents. See
+ *	802.11-2012 8.4.2.29 for more information.
+ * @NL80211_ATTR_EXT_CAPA_MASK: Extended capabilities that the kernel driver
+ *	has set in the %NL80211_ATTR_EXT_CAPA value, for multibit fields.
+ *
+ * @NL80211_ATTR_STA_CAPABILITY: Station capabilities (u16) are advertised to
+ *	the driver, e.g., to enable TDLS power save (PU-APSD).
+ *
+ * @NL80211_ATTR_STA_EXT_CAPABILITY: Station extended capabilities are
+ *	advertised to the driver, e.g., to enable TDLS off channel operations
+ *	and PU-APSD.
+ *
+ * @NL80211_ATTR_PROTOCOL_FEATURES: global nl80211 feature flags, see
+ *	&enum nl80211_protocol_features, the attribute is a u32.
+ *
+ * @NL80211_ATTR_SPLIT_WIPHY_DUMP: flag attribute, userspace supports
+ *	receiving the data for a single wiphy split across multiple
+ *	messages, given with wiphy dump message
+ *
+ * @NL80211_ATTR_MDID: Mobility Domain Identifier
+ *
+ * @NL80211_ATTR_IE_RIC: Resource Information Container Information
+ *	Element
+ *
+ * @NL80211_ATTR_CRIT_PROT_ID: critical protocol identifier requiring increased
+ *	reliability, see &enum nl80211_crit_proto_id (u16).
+ * @NL80211_ATTR_MAX_CRIT_PROT_DURATION: duration in milliseconds in which
+ *      the connection should have increased reliability (u16).
+ *
+ * @NL80211_ATTR_PEER_AID: Association ID for the peer TDLS station (u16).
+ *	This is similar to @NL80211_ATTR_STA_AID but with a difference of being
+ *	allowed to be used with the first @NL80211_CMD_SET_STATION command to
+ *	update a TDLS peer STA entry.
+ *
+ * @NL80211_ATTR_COALESCE_RULE: Coalesce rule information.
+ *
+ * @NL80211_ATTR_CH_SWITCH_COUNT: u32 attribute specifying the number of TBTT's
+ *	until the channel switch event.
+ * @NL80211_ATTR_CH_SWITCH_BLOCK_TX: flag attribute specifying that transmission
+ *	must be blocked on the current channel (before the channel switch
+ *	operation).
+ * @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information
+ *	for the time while performing a channel switch.
+ * @NL80211_ATTR_CSA_C_OFF_BEACON: An array of offsets (u16) to the channel
+ *	switch counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
+ * @NL80211_ATTR_CSA_C_OFF_PRESP: An array of offsets (u16) to the channel
+ *	switch counters in the probe response (%NL80211_ATTR_PROBE_RESP).
+ *
+ * @NL80211_ATTR_RXMGMT_FLAGS: flags for nl80211_send_mgmt(), u32.
+ *	As specified in the &enum nl80211_rxmgmt_flags.
+ *
+ * @NL80211_ATTR_STA_SUPPORTED_CHANNELS: array of supported channels.
+ *
+ * @NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES: array of supported
+ *      supported operating classes.
+ *
+ * @NL80211_ATTR_HANDLE_DFS: A flag indicating whether user space
+ *	controls DFS operation in IBSS mode. If the flag is included in
+ *	%NL80211_CMD_JOIN_IBSS request, the driver will allow use of DFS
+ *	channels and reports radar events to userspace. Userspace is required
+ *	to react to radar events, e.g. initiate a channel switch or leave the
+ *	IBSS network.
+ *
+ * @NL80211_ATTR_SUPPORT_5_MHZ: A flag indicating that the device supports
+ *	5 MHz channel bandwidth.
+ * @NL80211_ATTR_SUPPORT_10_MHZ: A flag indicating that the device supports
+ *	10 MHz channel bandwidth.
+ *
+ * @NL80211_ATTR_OPMODE_NOTIF: Operating mode field from Operating Mode
+ *	Notification Element based on association request when used with
+ *	%NL80211_CMD_NEW_STATION; u8 attribute.
+ *
+ * @NL80211_ATTR_VENDOR_ID: The vendor ID, either a 24-bit OUI or, if
+ *	%NL80211_VENDOR_ID_IS_LINUX is set, a special Linux ID (not used yet)
+ * @NL80211_ATTR_VENDOR_SUBCMD: vendor sub-command
+ * @NL80211_ATTR_VENDOR_DATA: data for the vendor command, if any; this
+ *	attribute is also used for vendor command feature advertisement
+ * @NL80211_ATTR_VENDOR_EVENTS: used for event list advertising in the wiphy
+ *	info, containing a nested array of possible events
+ *
+ * @NL80211_ATTR_QOS_MAP: IP DSCP mapping for Interworking QoS mapping. This
+ *	data is in the format defined for the payload of the QoS Map Set element
+ *	in IEEE Std 802.11-2012, 8.4.2.97.
+ *
+ * @NL80211_ATTR_MAC_HINT: MAC address recommendation as initial BSS
+ * @NL80211_ATTR_WIPHY_FREQ_HINT: frequency of the recommended initial BSS
+ *
+ * @NL80211_ATTR_MAX_AP_ASSOC_STA: Device attribute that indicates how many
+ *	associated stations are supported in AP mode (including P2P GO); u32.
+ *	Since drivers may not have a fixed limit on the maximum number (e.g.,
+ *	other concurrent operations may affect this), drivers are allowed to
+ *	advertise values that cannot always be met. In such cases, an attempt
+ *	to add a new station entry with @NL80211_CMD_NEW_STATION may fail.
+ *
+ * @NL80211_ATTR_CSA_C_OFFSETS_TX: An array of csa counter offsets (u16) which
+ *	should be updated when the frame is transmitted.
+ * @NL80211_ATTR_MAX_CSA_COUNTERS: U8 attribute used to advertise the maximum
+ *	supported number of csa counters.
+ *
+ * @NL80211_ATTR_TDLS_PEER_CAPABILITY: flags for TDLS peer capabilities, u32.
+ *	As specified in the &enum nl80211_tdls_peer_capability.
+ *
+ * @NL80211_ATTR_SOCKET_OWNER: Flag attribute, if set during interface
+ *	creation then the new interface will be owned by the netlink socket
+ *	that created it and will be destroyed when the socket is closed.
+ *	If set during scheduled scan start then the new scan req will be
+ *	owned by the netlink socket that created it and the scheduled scan will
+ *	be stopped when the socket is closed.
+ *	If set during configuration of regulatory indoor operation then the
+ *	regulatory indoor configuration would be owned by the netlink socket
+ *	that configured the indoor setting, and the indoor operation would be
+ *	cleared when the socket is closed.
+ *
+ * @NL80211_ATTR_TDLS_INITIATOR: flag attribute indicating the current end is
+ *	the TDLS link initiator.
+ *
+ * @NL80211_ATTR_USE_RRM: flag for indicating whether the current connection
+ *	shall support Radio Resource Measurements (11k). This attribute can be
+ *	used with %NL80211_CMD_ASSOCIATE and %NL80211_CMD_CONNECT requests.
+ *	User space applications are expected to use this flag only if the
+ *	underlying device supports these minimal RRM features:
+ *		%NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES,
+ *		%NL80211_FEATURE_QUIET,
+ *	If this flag is used, driver must add the Power Capabilities IE to the
+ *	association request. In addition, it must also set the RRM capability
+ *	flag in the association request's Capability Info field.
+ *
+ * @NL80211_ATTR_WIPHY_DYN_ACK: flag attribute used to enable ACK timeout
+ *	estimation algorithm (dynack). In order to activate dynack
+ *	%NL80211_FEATURE_ACKTO_ESTIMATION feature flag must be set by lower
+ *	drivers to indicate dynack capability. Dynack is automatically disabled
+ *	setting valid value for coverage class.
+ *
+ * @NL80211_ATTR_TSID: a TSID value (u8 attribute)
+ * @NL80211_ATTR_USER_PRIO: user priority value (u8 attribute)
+ * @NL80211_ATTR_ADMITTED_TIME: admitted time in units of 32 microseconds
+ *	(per second) (u16 attribute)
+ *
+ * @NL80211_ATTR_SMPS_MODE: SMPS mode to use (ap mode). see
+ *	&enum nl80211_smps_mode.
+ *
+ * @NL80211_ATTR_OPER_CLASS: operating class
+ *
+ * @NL80211_ATTR_MAC_MASK: MAC address mask
+ *
+ * @NL80211_ATTR_WIPHY_SELF_MANAGED_REG: flag attribute indicating this device
+ *	is self-managing its regulatory information and any regulatory domain
+ *	obtained from it is coming from the device's wiphy and not the global
+ *	cfg80211 regdomain.
+ *
+ * @NL80211_ATTR_EXT_FEATURES: extended feature flags contained in a byte
+ *	array. The feature flags are identified by their bit index (see &enum
+ *	nl80211_ext_feature_index). The bit index is ordered starting at the
+ *	least-significant bit of the first byte in the array, ie. bit index 0
+ *	is located at bit 0 of byte 0. bit index 25 would be located at bit 1
+ *	of byte 3 (u8 array).
+ *
+ * @NL80211_ATTR_SURVEY_RADIO_STATS: Request overall radio statistics to be
+ *	returned along with other survey data. If set, @NL80211_CMD_GET_SURVEY
+ *	may return a survey entry without a channel indicating global radio
+ *	statistics (only some values are valid and make sense.)
+ *	For devices that don't return such an entry even then, the information
+ *	should be contained in the result as the sum of the respective counters
+ *	over all channels.
+ *
+ * @NL80211_ATTR_SCHED_SCAN_DELAY: delay before a scheduled scan (or a
+ *	WoWLAN net-detect scan) is started, u32 in seconds.
+
+ * @NL80211_ATTR_REG_INDOOR: flag attribute, if set indicates that the device
+ *      is operating in an indoor environment.
+ *
+ * @NUM_NL80211_ATTR: total number of nl80211_attrs available
+ * @NL80211_ATTR_MAX: highest attribute number currently defined
+ * @__NL80211_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_attrs {
+/* don't change the order or add anything between, this is ABI! */
+	NL80211_ATTR_UNSPEC,
+
+	NL80211_ATTR_WIPHY,
+	NL80211_ATTR_WIPHY_NAME,
+
+	NL80211_ATTR_IFINDEX,
+	NL80211_ATTR_IFNAME,
+	NL80211_ATTR_IFTYPE,
+
+	NL80211_ATTR_MAC,
+
+	NL80211_ATTR_KEY_DATA,
+	NL80211_ATTR_KEY_IDX,
+	NL80211_ATTR_KEY_CIPHER,
+	NL80211_ATTR_KEY_SEQ,
+	NL80211_ATTR_KEY_DEFAULT,
+
+	NL80211_ATTR_BEACON_INTERVAL,
+	NL80211_ATTR_DTIM_PERIOD,
+	NL80211_ATTR_BEACON_HEAD,
+	NL80211_ATTR_BEACON_TAIL,
+
+	NL80211_ATTR_STA_AID,
+	NL80211_ATTR_STA_FLAGS,
+	NL80211_ATTR_STA_LISTEN_INTERVAL,
+	NL80211_ATTR_STA_SUPPORTED_RATES,
+	NL80211_ATTR_STA_VLAN,
+	NL80211_ATTR_STA_INFO,
+
+	NL80211_ATTR_WIPHY_BANDS,
+
+	NL80211_ATTR_MNTR_FLAGS,
+
+	NL80211_ATTR_MESH_ID,
+	NL80211_ATTR_STA_PLINK_ACTION,
+	NL80211_ATTR_MPATH_NEXT_HOP,
+	NL80211_ATTR_MPATH_INFO,
+
+	NL80211_ATTR_BSS_CTS_PROT,
+	NL80211_ATTR_BSS_SHORT_PREAMBLE,
+	NL80211_ATTR_BSS_SHORT_SLOT_TIME,
+
+	NL80211_ATTR_HT_CAPABILITY,
+
+	NL80211_ATTR_SUPPORTED_IFTYPES,
+
+	NL80211_ATTR_REG_ALPHA2,
+	NL80211_ATTR_REG_RULES,
+
+	NL80211_ATTR_MESH_CONFIG,
+
+	NL80211_ATTR_BSS_BASIC_RATES,
+
+	NL80211_ATTR_WIPHY_TXQ_PARAMS,
+	NL80211_ATTR_WIPHY_FREQ,
+	NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+
+	NL80211_ATTR_KEY_DEFAULT_MGMT,
+
+	NL80211_ATTR_MGMT_SUBTYPE,
+	NL80211_ATTR_IE,
+
+	NL80211_ATTR_MAX_NUM_SCAN_SSIDS,
+
+	NL80211_ATTR_SCAN_FREQUENCIES,
+	NL80211_ATTR_SCAN_SSIDS,
+	NL80211_ATTR_GENERATION, /* replaces old SCAN_GENERATION */
+	NL80211_ATTR_BSS,
+
+	NL80211_ATTR_REG_INITIATOR,
+	NL80211_ATTR_REG_TYPE,
+
+	NL80211_ATTR_SUPPORTED_COMMANDS,
+
+	NL80211_ATTR_FRAME,
+	NL80211_ATTR_SSID,
+	NL80211_ATTR_AUTH_TYPE,
+	NL80211_ATTR_REASON_CODE,
+
+	NL80211_ATTR_KEY_TYPE,
+
+	NL80211_ATTR_MAX_SCAN_IE_LEN,
+	NL80211_ATTR_CIPHER_SUITES,
+
+	NL80211_ATTR_FREQ_BEFORE,
+	NL80211_ATTR_FREQ_AFTER,
+
+	NL80211_ATTR_FREQ_FIXED,
+
+
+	NL80211_ATTR_WIPHY_RETRY_SHORT,
+	NL80211_ATTR_WIPHY_RETRY_LONG,
+	NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
+	NL80211_ATTR_WIPHY_RTS_THRESHOLD,
+
+	NL80211_ATTR_TIMED_OUT,
+
+	NL80211_ATTR_USE_MFP,
+
+	NL80211_ATTR_STA_FLAGS2,
+
+	NL80211_ATTR_CONTROL_PORT,
+
+	NL80211_ATTR_TESTDATA,
+
+	NL80211_ATTR_PRIVACY,
+
+	NL80211_ATTR_DISCONNECTED_BY_AP,
+	NL80211_ATTR_STATUS_CODE,
+
+	NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
+	NL80211_ATTR_CIPHER_SUITE_GROUP,
+	NL80211_ATTR_WPA_VERSIONS,
+	NL80211_ATTR_AKM_SUITES,
+
+	NL80211_ATTR_REQ_IE,
+	NL80211_ATTR_RESP_IE,
+
+	NL80211_ATTR_PREV_BSSID,
+
+	NL80211_ATTR_KEY,
+	NL80211_ATTR_KEYS,
+
+	NL80211_ATTR_PID,
+
+	NL80211_ATTR_4ADDR,
+
+	NL80211_ATTR_SURVEY_INFO,
+
+	NL80211_ATTR_PMKID,
+	NL80211_ATTR_MAX_NUM_PMKIDS,
+
+	NL80211_ATTR_DURATION,
+
+	NL80211_ATTR_COOKIE,
+
+	NL80211_ATTR_WIPHY_COVERAGE_CLASS,
+
+	NL80211_ATTR_TX_RATES,
+
+	NL80211_ATTR_FRAME_MATCH,
+
+	NL80211_ATTR_ACK,
+
+	NL80211_ATTR_PS_STATE,
+
+	NL80211_ATTR_CQM,
+
+	NL80211_ATTR_LOCAL_STATE_CHANGE,
+
+	NL80211_ATTR_AP_ISOLATE,
+
+	NL80211_ATTR_WIPHY_TX_POWER_SETTING,
+	NL80211_ATTR_WIPHY_TX_POWER_LEVEL,
+
+	NL80211_ATTR_TX_FRAME_TYPES,
+	NL80211_ATTR_RX_FRAME_TYPES,
+	NL80211_ATTR_FRAME_TYPE,
+
+	NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT,
+
+	NL80211_ATTR_SUPPORT_IBSS_RSN,
+
+	NL80211_ATTR_WIPHY_ANTENNA_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_RX,
+
+	NL80211_ATTR_MCAST_RATE,
+
+	NL80211_ATTR_OFFCHANNEL_TX_OK,
+
+	NL80211_ATTR_BSS_HT_OPMODE,
+
+	NL80211_ATTR_KEY_DEFAULT_TYPES,
+
+	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,
+
+	NL80211_ATTR_MESH_SETUP,
+
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,
+
+	NL80211_ATTR_SUPPORT_MESH_AUTH,
+	NL80211_ATTR_STA_PLINK_STATE,
+
+	NL80211_ATTR_WOWLAN_TRIGGERS,
+	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED,
+
+	NL80211_ATTR_SCHED_SCAN_INTERVAL,
+
+	NL80211_ATTR_INTERFACE_COMBINATIONS,
+	NL80211_ATTR_SOFTWARE_IFTYPES,
+
+	NL80211_ATTR_REKEY_DATA,
+
+	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,
+	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,
+
+	NL80211_ATTR_SCAN_SUPP_RATES,
+
+	NL80211_ATTR_HIDDEN_SSID,
+
+	NL80211_ATTR_IE_PROBE_RESP,
+	NL80211_ATTR_IE_ASSOC_RESP,
+
+	NL80211_ATTR_STA_WME,
+	NL80211_ATTR_SUPPORT_AP_UAPSD,
+
+	NL80211_ATTR_ROAM_SUPPORT,
+
+	NL80211_ATTR_SCHED_SCAN_MATCH,
+	NL80211_ATTR_MAX_MATCH_SETS,
+
+	NL80211_ATTR_PMKSA_CANDIDATE,
+
+	NL80211_ATTR_TX_NO_CCK_RATE,
+
+	NL80211_ATTR_TDLS_ACTION,
+	NL80211_ATTR_TDLS_DIALOG_TOKEN,
+	NL80211_ATTR_TDLS_OPERATION,
+	NL80211_ATTR_TDLS_SUPPORT,
+	NL80211_ATTR_TDLS_EXTERNAL_SETUP,
+
+	NL80211_ATTR_DEVICE_AP_SME,
+
+	NL80211_ATTR_DONT_WAIT_FOR_ACK,
+
+	NL80211_ATTR_FEATURE_FLAGS,
+
+	NL80211_ATTR_PROBE_RESP_OFFLOAD,
+
+	NL80211_ATTR_PROBE_RESP,
+
+	NL80211_ATTR_DFS_REGION,
+
+	NL80211_ATTR_DISABLE_HT,
+	NL80211_ATTR_HT_CAPABILITY_MASK,
+
+	NL80211_ATTR_NOACK_MAP,
+
+	NL80211_ATTR_INACTIVITY_TIMEOUT,
+
+	NL80211_ATTR_RX_SIGNAL_DBM,
+
+	NL80211_ATTR_BG_SCAN_PERIOD,
+
+	NL80211_ATTR_WDEV,
+
+	NL80211_ATTR_USER_REG_HINT_TYPE,
+
+	NL80211_ATTR_CONN_FAILED_REASON,
+
+	NL80211_ATTR_SAE_DATA,
+
+	NL80211_ATTR_VHT_CAPABILITY,
+
+	NL80211_ATTR_SCAN_FLAGS,
+
+	NL80211_ATTR_CHANNEL_WIDTH,
+	NL80211_ATTR_CENTER_FREQ1,
+	NL80211_ATTR_CENTER_FREQ2,
+
+	NL80211_ATTR_P2P_CTWINDOW,
+	NL80211_ATTR_P2P_OPPPS,
+
+	NL80211_ATTR_LOCAL_MESH_POWER_MODE,
+
+	NL80211_ATTR_ACL_POLICY,
+
+	NL80211_ATTR_MAC_ADDRS,
+
+	NL80211_ATTR_MAC_ACL_MAX,
+
+	NL80211_ATTR_RADAR_EVENT,
+
+	NL80211_ATTR_EXT_CAPA,
+	NL80211_ATTR_EXT_CAPA_MASK,
+
+	NL80211_ATTR_STA_CAPABILITY,
+	NL80211_ATTR_STA_EXT_CAPABILITY,
+
+	NL80211_ATTR_PROTOCOL_FEATURES,
+	NL80211_ATTR_SPLIT_WIPHY_DUMP,
+
+	NL80211_ATTR_DISABLE_VHT,
+	NL80211_ATTR_VHT_CAPABILITY_MASK,
+
+	NL80211_ATTR_MDID,
+	NL80211_ATTR_IE_RIC,
+
+	NL80211_ATTR_CRIT_PROT_ID,
+	NL80211_ATTR_MAX_CRIT_PROT_DURATION,
+
+	NL80211_ATTR_PEER_AID,
+
+	NL80211_ATTR_COALESCE_RULE,
+
+	NL80211_ATTR_CH_SWITCH_COUNT,
+	NL80211_ATTR_CH_SWITCH_BLOCK_TX,
+	NL80211_ATTR_CSA_IES,
+	NL80211_ATTR_CSA_C_OFF_BEACON,
+	NL80211_ATTR_CSA_C_OFF_PRESP,
+
+	NL80211_ATTR_RXMGMT_FLAGS,
+
+	NL80211_ATTR_STA_SUPPORTED_CHANNELS,
+
+	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES,
+
+	NL80211_ATTR_HANDLE_DFS,
+
+	NL80211_ATTR_SUPPORT_5_MHZ,
+	NL80211_ATTR_SUPPORT_10_MHZ,
+
+	NL80211_ATTR_OPMODE_NOTIF,
+
+	NL80211_ATTR_VENDOR_ID,
+	NL80211_ATTR_VENDOR_SUBCMD,
+	NL80211_ATTR_VENDOR_DATA,
+	NL80211_ATTR_VENDOR_EVENTS,
+
+	NL80211_ATTR_QOS_MAP,
+
+	NL80211_ATTR_MAC_HINT,
+	NL80211_ATTR_WIPHY_FREQ_HINT,
+
+	NL80211_ATTR_MAX_AP_ASSOC_STA,
+
+	NL80211_ATTR_TDLS_PEER_CAPABILITY,
+
+	NL80211_ATTR_SOCKET_OWNER,
+
+	NL80211_ATTR_CSA_C_OFFSETS_TX,
+	NL80211_ATTR_MAX_CSA_COUNTERS,
+
+	NL80211_ATTR_TDLS_INITIATOR,
+
+	NL80211_ATTR_USE_RRM,
+
+	NL80211_ATTR_WIPHY_DYN_ACK,
+
+	NL80211_ATTR_TSID,
+	NL80211_ATTR_USER_PRIO,
+	NL80211_ATTR_ADMITTED_TIME,
+
+	NL80211_ATTR_SMPS_MODE,
+
+	NL80211_ATTR_OPER_CLASS,
+
+	NL80211_ATTR_MAC_MASK,
+
+	NL80211_ATTR_WIPHY_SELF_MANAGED_REG,
+
+	NL80211_ATTR_EXT_FEATURES,
+
+	NL80211_ATTR_SURVEY_RADIO_STATS,
+
+	NL80211_ATTR_NETNS_FD,
+
+	NL80211_ATTR_SCHED_SCAN_DELAY,
+
+	NL80211_ATTR_REG_INDOOR,
+
+	/* add attributes here, update the policy in nl80211.c */
+
+	__NL80211_ATTR_AFTER_LAST,
+	NUM_NL80211_ATTR = __NL80211_ATTR_AFTER_LAST,
+	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
+};
+
+/* source-level API compatibility */
+#define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
+#define	NL80211_ATTR_MESH_PARAMS NL80211_ATTR_MESH_CONFIG
+#define NL80211_ATTR_IFACE_SOCKET_OWNER NL80211_ATTR_SOCKET_OWNER
+
+/*
+ * Allow user space programs to use #ifdef on new attributes by defining them
+ * here
+ */
+#define NL80211_CMD_CONNECT NL80211_CMD_CONNECT
+#define NL80211_ATTR_HT_CAPABILITY NL80211_ATTR_HT_CAPABILITY
+#define NL80211_ATTR_BSS_BASIC_RATES NL80211_ATTR_BSS_BASIC_RATES
+#define NL80211_ATTR_WIPHY_TXQ_PARAMS NL80211_ATTR_WIPHY_TXQ_PARAMS
+#define NL80211_ATTR_WIPHY_FREQ NL80211_ATTR_WIPHY_FREQ
+#define NL80211_ATTR_WIPHY_CHANNEL_TYPE NL80211_ATTR_WIPHY_CHANNEL_TYPE
+#define NL80211_ATTR_MGMT_SUBTYPE NL80211_ATTR_MGMT_SUBTYPE
+#define NL80211_ATTR_IE NL80211_ATTR_IE
+#define NL80211_ATTR_REG_INITIATOR NL80211_ATTR_REG_INITIATOR
+#define NL80211_ATTR_REG_TYPE NL80211_ATTR_REG_TYPE
+#define NL80211_ATTR_FRAME NL80211_ATTR_FRAME
+#define NL80211_ATTR_SSID NL80211_ATTR_SSID
+#define NL80211_ATTR_AUTH_TYPE NL80211_ATTR_AUTH_TYPE
+#define NL80211_ATTR_REASON_CODE NL80211_ATTR_REASON_CODE
+#define NL80211_ATTR_CIPHER_SUITES_PAIRWISE NL80211_ATTR_CIPHER_SUITES_PAIRWISE
+#define NL80211_ATTR_CIPHER_SUITE_GROUP NL80211_ATTR_CIPHER_SUITE_GROUP
+#define NL80211_ATTR_WPA_VERSIONS NL80211_ATTR_WPA_VERSIONS
+#define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
+#define NL80211_ATTR_KEY NL80211_ATTR_KEY
+#define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
+#define NL80211_ATTR_FEATURE_FLAGS NL80211_ATTR_FEATURE_FLAGS
+
+#define NL80211_MAX_SUPP_RATES			32
+#define NL80211_MAX_SUPP_HT_RATES		77
+#define NL80211_MAX_SUPP_REG_RULES		64
+#define NL80211_TKIP_DATA_OFFSET_ENCR_KEY	0
+#define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY	16
+#define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY	24
+#define NL80211_HT_CAPABILITY_LEN		26
+#define NL80211_VHT_CAPABILITY_LEN		12
+
+#define NL80211_MAX_NR_CIPHER_SUITES		5
+#define NL80211_MAX_NR_AKM_SUITES		2
+
+#define NL80211_MIN_REMAIN_ON_CHANNEL_TIME	10
+
+/* default RSSI threshold for scan results if none specified. */
+#define NL80211_SCAN_RSSI_THOLD_OFF		-300
+
+#define NL80211_CQM_TXE_MAX_INTVL		1800
+
+/**
+ * enum nl80211_iftype - (virtual) interface types
+ *
+ * @NL80211_IFTYPE_UNSPECIFIED: unspecified type, driver decides
+ * @NL80211_IFTYPE_ADHOC: independent BSS member
+ * @NL80211_IFTYPE_STATION: managed BSS member
+ * @NL80211_IFTYPE_AP: access point
+ * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points; VLAN interfaces
+ *	are a bit special in that they must always be tied to a pre-existing
+ *	AP type interface.
+ * @NL80211_IFTYPE_WDS: wireless distribution interface
+ * @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames
+ * @NL80211_IFTYPE_MESH_POINT: mesh point
+ * @NL80211_IFTYPE_P2P_CLIENT: P2P client
+ * @NL80211_IFTYPE_P2P_GO: P2P group owner
+ * @NL80211_IFTYPE_P2P_DEVICE: P2P device interface type, this is not a netdev
+ *	and therefore can't be created in the normal ways, use the
+ *	%NL80211_CMD_START_P2P_DEVICE and %NL80211_CMD_STOP_P2P_DEVICE
+ *	commands to create and destroy one
+ * @NL80211_IF_TYPE_OCB: Outside Context of a BSS
+ *	This mode corresponds to the MIB variable dot11OCBActivated=true
+ * @NL80211_IFTYPE_MAX: highest interface type number currently defined
+ * @NUM_NL80211_IFTYPES: number of defined interface types
+ *
+ * These values are used with the %NL80211_ATTR_IFTYPE
+ * to set the type of an interface.
+ *
+ */
+enum nl80211_iftype {
+	NL80211_IFTYPE_UNSPECIFIED,
+	NL80211_IFTYPE_ADHOC,
+	NL80211_IFTYPE_STATION,
+	NL80211_IFTYPE_AP,
+	NL80211_IFTYPE_AP_VLAN,
+	NL80211_IFTYPE_WDS,
+	NL80211_IFTYPE_MONITOR,
+	NL80211_IFTYPE_MESH_POINT,
+	NL80211_IFTYPE_P2P_CLIENT,
+	NL80211_IFTYPE_P2P_GO,
+	NL80211_IFTYPE_P2P_DEVICE,
+	NL80211_IFTYPE_OCB,
+
+	/* keep last */
+	NUM_NL80211_IFTYPES,
+	NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
+};
+
+/**
+ * enum nl80211_sta_flags - station flags
+ *
+ * Station flags. When a station is added to an AP interface, it is
+ * assumed to be already associated (and hence authenticated.)
+ *
+ * @__NL80211_STA_FLAG_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_FLAG_AUTHORIZED: station is authorized (802.1X)
+ * @NL80211_STA_FLAG_SHORT_PREAMBLE: station is capable of receiving frames
+ *	with short barker preamble
+ * @NL80211_STA_FLAG_WME: station is WME/QoS capable
+ * @NL80211_STA_FLAG_MFP: station uses management frame protection
+ * @NL80211_STA_FLAG_AUTHENTICATED: station is authenticated
+ * @NL80211_STA_FLAG_TDLS_PEER: station is a TDLS peer -- this flag should
+ *	only be used in managed mode (even in the flags mask). Note that the
+ *	flag can't be changed, it is only valid while adding a station, and
+ *	attempts to change it will silently be ignored (rather than rejected
+ *	as errors.)
+ * @NL80211_STA_FLAG_ASSOCIATED: station is associated; used with drivers
+ *	that support %NL80211_FEATURE_FULL_AP_CLIENT_STATE to transition a
+ *	previously added station into associated state
+ * @NL80211_STA_FLAG_MAX: highest station flag number currently defined
+ * @__NL80211_STA_FLAG_AFTER_LAST: internal use
+ */
+enum nl80211_sta_flags {
+	__NL80211_STA_FLAG_INVALID,
+	NL80211_STA_FLAG_AUTHORIZED,
+	NL80211_STA_FLAG_SHORT_PREAMBLE,
+	NL80211_STA_FLAG_WME,
+	NL80211_STA_FLAG_MFP,
+	NL80211_STA_FLAG_AUTHENTICATED,
+	NL80211_STA_FLAG_TDLS_PEER,
+	NL80211_STA_FLAG_ASSOCIATED,
+
+	/* keep last */
+	__NL80211_STA_FLAG_AFTER_LAST,
+	NL80211_STA_FLAG_MAX = __NL80211_STA_FLAG_AFTER_LAST - 1
+};
+
+#define NL80211_STA_FLAG_MAX_OLD_API	NL80211_STA_FLAG_TDLS_PEER
+
+/**
+ * struct nl80211_sta_flag_update - station flags mask/set
+ * @mask: mask of station flags to set
+ * @set: which values to set them to
+ *
+ * Both mask and set contain bits as per &enum nl80211_sta_flags.
+ */
+struct nl80211_sta_flag_update {
+	__u32 mask;
+	__u32 set;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_rate_info - bitrate information
+ *
+ * These attribute types are used with %NL80211_STA_INFO_TXRATE
+ * when getting information about the bitrate of a station.
+ * There are 2 attributes for bitrate, a legacy one that represents
+ * a 16-bit value, and new one that represents a 32-bit value.
+ * If the rate value fits into 16 bit, both attributes are reported
+ * with the same value. If the rate is too high to fit into 16 bits
+ * (>6.5535Gbps) only 32-bit attribute is included.
+ * User space tools encouraged to use the 32-bit attribute and fall
+ * back to the 16-bit one for compatibility with older kernels.
+ *
+ * @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)
+ * @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)
+ * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 MHz dualchannel bitrate
+ * @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval
+ * @NL80211_RATE_INFO_BITRATE32: total bitrate (u32, 100kbit/s)
+ * @NL80211_RATE_INFO_MAX: highest rate_info number currently defined
+ * @NL80211_RATE_INFO_VHT_MCS: MCS index for VHT (u8)
+ * @NL80211_RATE_INFO_VHT_NSS: number of streams in VHT (u8)
+ * @NL80211_RATE_INFO_80_MHZ_WIDTH: 80 MHz VHT rate
+ * @NL80211_RATE_INFO_80P80_MHZ_WIDTH: unused - 80+80 is treated the
+ *	same as 160 for purposes of the bitrates
+ * @NL80211_RATE_INFO_160_MHZ_WIDTH: 160 MHz VHT rate
+ * @NL80211_RATE_INFO_10_MHZ_WIDTH: 10 MHz width - note that this is
+ *	a legacy rate and will be reported as the actual bitrate, i.e.
+ *	half the base (20 MHz) rate
+ * @NL80211_RATE_INFO_5_MHZ_WIDTH: 5 MHz width - note that this is
+ *	a legacy rate and will be reported as the actual bitrate, i.e.
+ *	a quarter of the base (20 MHz) rate
+ * @__NL80211_RATE_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_rate_info {
+	__NL80211_RATE_INFO_INVALID,
+	NL80211_RATE_INFO_BITRATE,
+	NL80211_RATE_INFO_MCS,
+	NL80211_RATE_INFO_40_MHZ_WIDTH,
+	NL80211_RATE_INFO_SHORT_GI,
+	NL80211_RATE_INFO_BITRATE32,
+	NL80211_RATE_INFO_VHT_MCS,
+	NL80211_RATE_INFO_VHT_NSS,
+	NL80211_RATE_INFO_80_MHZ_WIDTH,
+	NL80211_RATE_INFO_80P80_MHZ_WIDTH,
+	NL80211_RATE_INFO_160_MHZ_WIDTH,
+	NL80211_RATE_INFO_10_MHZ_WIDTH,
+	NL80211_RATE_INFO_5_MHZ_WIDTH,
+
+	/* keep last */
+	__NL80211_RATE_INFO_AFTER_LAST,
+	NL80211_RATE_INFO_MAX = __NL80211_RATE_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_bss_param - BSS information collected by STA
+ *
+ * These attribute types are used with %NL80211_STA_INFO_BSS_PARAM
+ * when getting information about the bitrate of a station.
+ *
+ * @__NL80211_STA_BSS_PARAM_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_BSS_PARAM_CTS_PROT: whether CTS protection is enabled (flag)
+ * @NL80211_STA_BSS_PARAM_SHORT_PREAMBLE:  whether short preamble is enabled
+ *	(flag)
+ * @NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME:  whether short slot time is enabled
+ *	(flag)
+ * @NL80211_STA_BSS_PARAM_DTIM_PERIOD: DTIM period for beaconing (u8)
+ * @NL80211_STA_BSS_PARAM_BEACON_INTERVAL: Beacon interval (u16)
+ * @NL80211_STA_BSS_PARAM_MAX: highest sta_bss_param number currently defined
+ * @__NL80211_STA_BSS_PARAM_AFTER_LAST: internal use
+ */
+enum nl80211_sta_bss_param {
+	__NL80211_STA_BSS_PARAM_INVALID,
+	NL80211_STA_BSS_PARAM_CTS_PROT,
+	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE,
+	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME,
+	NL80211_STA_BSS_PARAM_DTIM_PERIOD,
+	NL80211_STA_BSS_PARAM_BEACON_INTERVAL,
+
+	/* keep last */
+	__NL80211_STA_BSS_PARAM_AFTER_LAST,
+	NL80211_STA_BSS_PARAM_MAX = __NL80211_STA_BSS_PARAM_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sta_info - station information
+ *
+ * These attribute types are used with %NL80211_ATTR_STA_INFO
+ * when getting information about a station.
+ *
+ * @__NL80211_STA_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
+ * @NL80211_STA_INFO_RX_BYTES: total received bytes (MPDU length)
+ *	(u32, from this station)
+ * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (MPDU length)
+ *	(u32, to this station)
+ * @NL80211_STA_INFO_RX_BYTES64: total received bytes (MPDU length)
+ *	(u64, from this station)
+ * @NL80211_STA_INFO_TX_BYTES64: total transmitted bytes (MPDU length)
+ *	(u64, to this station)
+ * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
+ * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
+ * 	containing info as possible, see &enum nl80211_rate_info
+ * @NL80211_STA_INFO_RX_PACKETS: total received packet (MSDUs and MMPDUs)
+ *	(u32, from this station)
+ * @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (MSDUs and MMPDUs)
+ *	(u32, to this station)
+ * @NL80211_STA_INFO_TX_RETRIES: total retries (MPDUs) (u32, to this station)
+ * @NL80211_STA_INFO_TX_FAILED: total failed packets (MPDUs)
+ *	(u32, to this station)
+ * @NL80211_STA_INFO_SIGNAL_AVG: signal strength average (u8, dBm)
+ * @NL80211_STA_INFO_LLID: the station's mesh LLID
+ * @NL80211_STA_INFO_PLID: the station's mesh PLID
+ * @NL80211_STA_INFO_PLINK_STATE: peer link state for the station
+ *	(see %enum nl80211_plink_state)
+ * @NL80211_STA_INFO_RX_BITRATE: last unicast data frame rx rate, nested
+ *	attribute, like NL80211_STA_INFO_TX_BITRATE.
+ * @NL80211_STA_INFO_BSS_PARAM: current station's view of BSS, nested attribute
+ *     containing info as possible, see &enum nl80211_sta_bss_param
+ * @NL80211_STA_INFO_CONNECTED_TIME: time since the station is last connected
+ * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
+ * @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)
+ * @NL80211_STA_INFO_T_OFFSET: timing offset with respect to this STA (s64)
+ * @NL80211_STA_INFO_LOCAL_PM: local mesh STA link-specific power mode
+ * @NL80211_STA_INFO_PEER_PM: peer mesh STA link-specific power mode
+ * @NL80211_STA_INFO_NONPEER_PM: neighbor mesh STA power save mode towards
+ *	non-peer STA
+ * @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU
+ *	Contains a nested array of signal strength attributes (u8, dBm)
+ * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
+ *	Same format as NL80211_STA_INFO_CHAIN_SIGNAL.
+ * @NL80211_STA_EXPECTED_THROUGHPUT: expected throughput considering also the
+ *	802.11 header (u32, kbps)
+ * @NL80211_STA_INFO_RX_DROP_MISC: RX packets dropped for unspecified reasons
+ *	(u64)
+ * @NL80211_STA_INFO_BEACON_RX: number of beacons received from this peer (u64)
+ * @NL80211_STA_INFO_BEACON_SIGNAL_AVG: signal strength average
+ *	for beacons only (u8, dBm)
+ * @NL80211_STA_INFO_TID_STATS: per-TID statistics (see &enum nl80211_tid_stats)
+ *	This is a nested attribute where each the inner attribute number is the
+ *	TID+1 and the special TID 16 (i.e. value 17) is used for non-QoS frames;
+ *	each one of those is again nested with &enum nl80211_tid_stats
+ *	attributes carrying the actual values.
+ * @__NL80211_STA_INFO_AFTER_LAST: internal
+ * @NL80211_STA_INFO_MAX: highest possible station info attribute
+ */
+enum nl80211_sta_info {
+	__NL80211_STA_INFO_INVALID,
+	NL80211_STA_INFO_INACTIVE_TIME,
+	NL80211_STA_INFO_RX_BYTES,
+	NL80211_STA_INFO_TX_BYTES,
+	NL80211_STA_INFO_LLID,
+	NL80211_STA_INFO_PLID,
+	NL80211_STA_INFO_PLINK_STATE,
+	NL80211_STA_INFO_SIGNAL,
+	NL80211_STA_INFO_TX_BITRATE,
+	NL80211_STA_INFO_RX_PACKETS,
+	NL80211_STA_INFO_TX_PACKETS,
+	NL80211_STA_INFO_TX_RETRIES,
+	NL80211_STA_INFO_TX_FAILED,
+	NL80211_STA_INFO_SIGNAL_AVG,
+	NL80211_STA_INFO_RX_BITRATE,
+	NL80211_STA_INFO_BSS_PARAM,
+	NL80211_STA_INFO_CONNECTED_TIME,
+	NL80211_STA_INFO_STA_FLAGS,
+	NL80211_STA_INFO_BEACON_LOSS,
+	NL80211_STA_INFO_T_OFFSET,
+	NL80211_STA_INFO_LOCAL_PM,
+	NL80211_STA_INFO_PEER_PM,
+	NL80211_STA_INFO_NONPEER_PM,
+	NL80211_STA_INFO_RX_BYTES64,
+	NL80211_STA_INFO_TX_BYTES64,
+	NL80211_STA_INFO_CHAIN_SIGNAL,
+	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
+	NL80211_STA_INFO_EXPECTED_THROUGHPUT,
+	NL80211_STA_INFO_RX_DROP_MISC,
+	NL80211_STA_INFO_BEACON_RX,
+	NL80211_STA_INFO_BEACON_SIGNAL_AVG,
+	NL80211_STA_INFO_TID_STATS,
+
+	/* keep last */
+	__NL80211_STA_INFO_AFTER_LAST,
+	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_tid_stats - per TID statistics attributes
+ * @__NL80211_TID_STATS_INVALID: attribute number 0 is reserved
+ * @NL80211_TID_STATS_RX_MSDU: number of MSDUs received (u64)
+ * @NL80211_TID_STATS_TX_MSDU: number of MSDUs transmitted (or
+ *	attempted to transmit; u64)
+ * @NL80211_TID_STATS_TX_MSDU_RETRIES: number of retries for
+ *	transmitted MSDUs (not counting the first attempt; u64)
+ * @NL80211_TID_STATS_TX_MSDU_FAILED: number of failed transmitted
+ *	MSDUs (u64)
+ * @NUM_NL80211_TID_STATS: number of attributes here
+ * @NL80211_TID_STATS_MAX: highest numbered attribute here
+ */
+enum nl80211_tid_stats {
+	__NL80211_TID_STATS_INVALID,
+	NL80211_TID_STATS_RX_MSDU,
+	NL80211_TID_STATS_TX_MSDU,
+	NL80211_TID_STATS_TX_MSDU_RETRIES,
+	NL80211_TID_STATS_TX_MSDU_FAILED,
+
+	/* keep last */
+	NUM_NL80211_TID_STATS,
+	NL80211_TID_STATS_MAX = NUM_NL80211_TID_STATS - 1
+};
+
+/**
+ * enum nl80211_mpath_flags - nl80211 mesh path flags
+ *
+ * @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active
+ * @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running
+ * @NL80211_MPATH_FLAG_SN_VALID: the mesh path contains a valid SN
+ * @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set
+ * @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded
+ */
+enum nl80211_mpath_flags {
+	NL80211_MPATH_FLAG_ACTIVE =	1<<0,
+	NL80211_MPATH_FLAG_RESOLVING =	1<<1,
+	NL80211_MPATH_FLAG_SN_VALID =	1<<2,
+	NL80211_MPATH_FLAG_FIXED =	1<<3,
+	NL80211_MPATH_FLAG_RESOLVED =	1<<4,
+};
+
+/**
+ * enum nl80211_mpath_info - mesh path information
+ *
+ * These attribute types are used with %NL80211_ATTR_MPATH_INFO when getting
+ * information about a mesh path.
+ *
+ * @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_MPATH_INFO_FRAME_QLEN: number of queued frames for this destination
+ * @NL80211_MPATH_INFO_SN: destination sequence number
+ * @NL80211_MPATH_INFO_METRIC: metric (cost) of this mesh path
+ * @NL80211_MPATH_INFO_EXPTIME: expiration time for the path, in msec from now
+ * @NL80211_MPATH_INFO_FLAGS: mesh path flags, enumerated in
+ * 	&enum nl80211_mpath_flags;
+ * @NL80211_MPATH_INFO_DISCOVERY_TIMEOUT: total path discovery timeout, in msec
+ * @NL80211_MPATH_INFO_DISCOVERY_RETRIES: mesh path discovery retries
+ * @NL80211_MPATH_INFO_MAX: highest mesh path information attribute number
+ *	currently defind
+ * @__NL80211_MPATH_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_mpath_info {
+	__NL80211_MPATH_INFO_INVALID,
+	NL80211_MPATH_INFO_FRAME_QLEN,
+	NL80211_MPATH_INFO_SN,
+	NL80211_MPATH_INFO_METRIC,
+	NL80211_MPATH_INFO_EXPTIME,
+	NL80211_MPATH_INFO_FLAGS,
+	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,
+	NL80211_MPATH_INFO_DISCOVERY_RETRIES,
+
+	/* keep last */
+	__NL80211_MPATH_INFO_AFTER_LAST,
+	NL80211_MPATH_INFO_MAX = __NL80211_MPATH_INFO_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_band_attr - band attributes
+ * @__NL80211_BAND_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BAND_ATTR_FREQS: supported frequencies in this band,
+ *	an array of nested frequency attributes
+ * @NL80211_BAND_ATTR_RATES: supported bitrates in this band,
+ *	an array of nested bitrate attributes
+ * @NL80211_BAND_ATTR_HT_MCS_SET: 16-byte attribute containing the MCS set as
+ *	defined in 802.11n
+ * @NL80211_BAND_ATTR_HT_CAPA: HT capabilities, as in the HT information IE
+ * @NL80211_BAND_ATTR_HT_AMPDU_FACTOR: A-MPDU factor, as in 11n
+ * @NL80211_BAND_ATTR_HT_AMPDU_DENSITY: A-MPDU density, as in 11n
+ * @NL80211_BAND_ATTR_VHT_MCS_SET: 32-byte attribute containing the MCS set as
+ *	defined in 802.11ac
+ * @NL80211_BAND_ATTR_VHT_CAPA: VHT capabilities, as in the HT information IE
+ * @NL80211_BAND_ATTR_MAX: highest band attribute currently defined
+ * @__NL80211_BAND_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_band_attr {
+	__NL80211_BAND_ATTR_INVALID,
+	NL80211_BAND_ATTR_FREQS,
+	NL80211_BAND_ATTR_RATES,
+
+	NL80211_BAND_ATTR_HT_MCS_SET,
+	NL80211_BAND_ATTR_HT_CAPA,
+	NL80211_BAND_ATTR_HT_AMPDU_FACTOR,
+	NL80211_BAND_ATTR_HT_AMPDU_DENSITY,
+
+	NL80211_BAND_ATTR_VHT_MCS_SET,
+	NL80211_BAND_ATTR_VHT_CAPA,
+
+	/* keep last */
+	__NL80211_BAND_ATTR_AFTER_LAST,
+	NL80211_BAND_ATTR_MAX = __NL80211_BAND_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_BAND_ATTR_HT_CAPA NL80211_BAND_ATTR_HT_CAPA
+
+/**
+ * enum nl80211_frequency_attr - frequency attributes
+ * @__NL80211_FREQUENCY_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz
+ * @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current
+ *	regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_IR: no mechanisms that initiate radiation
+ * 	are permitted on this channel, this includes sending probe
+ * 	requests, or modes of operation that require beaconing.
+ * @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
+ *	(100 * dBm).
+ * @NL80211_FREQUENCY_ATTR_DFS_STATE: current state for DFS
+ *	(enum nl80211_dfs_state)
+ * @NL80211_FREQUENCY_ATTR_DFS_TIME: time in miliseconds for how long
+ *	this channel is in this DFS state.
+ * @NL80211_FREQUENCY_ATTR_NO_HT40_MINUS: HT40- isn't possible with this
+ *	channel as the control channel
+ * @NL80211_FREQUENCY_ATTR_NO_HT40_PLUS: HT40+ isn't possible with this
+ *	channel as the control channel
+ * @NL80211_FREQUENCY_ATTR_NO_80MHZ: any 80 MHz channel using this channel
+ *	as the primary or any of the secondary channels isn't possible,
+ *	this includes 80+80 channels
+ * @NL80211_FREQUENCY_ATTR_NO_160MHZ: any 160 MHz (but not 80+80) channel
+ *	using this channel as the primary or any of the secondary channels
+ *	isn't possible
+ * @NL80211_FREQUENCY_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
+ * @NL80211_FREQUENCY_ATTR_INDOOR_ONLY: Only indoor use is permitted on this
+ *	channel. A channel that has the INDOOR_ONLY attribute can only be
+ *	used when there is a clear assessment that the device is operating in
+ *	an indoor surroundings, i.e., it is connected to AC power (and not
+ *	through portable DC inverters) or is under the control of a master
+ *	that is acting as an AP and is connected to AC power.
+ * @NL80211_FREQUENCY_ATTR_GO_CONCURRENT: GO operation is allowed on this
+ *	channel if it's connected concurrently to a BSS on the same channel on
+ *	the 2 GHz band or to a channel in the same UNII band (on the 5 GHz
+ *	band), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO on a
+ *	channel that has the GO_CONCURRENT attribute set can be done when there
+ *	is a clear assessment that the device is operating under the guidance of
+ *	an authorized master, i.e., setting up a GO while the device is also
+ *	connected to an AP with DFS and radar detection on the UNII band (it is
+ *	up to user-space, i.e., wpa_supplicant to perform the required
+ *	verifications)
+ * @NL80211_FREQUENCY_ATTR_NO_20MHZ: 20 MHz operation is not allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_10MHZ: 10 MHz operation is not allowed
+ *	on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
+ *	currently defined
+ * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
+ *
+ * See https://apps.fcc.gov/eas/comments/GetPublishedDocument.html?id=327&tn=528122
+ * for more information on the FCC description of the relaxations allowed
+ * by NL80211_FREQUENCY_ATTR_INDOOR_ONLY and
+ * NL80211_FREQUENCY_ATTR_GO_CONCURRENT.
+ */
+enum nl80211_frequency_attr {
+	__NL80211_FREQUENCY_ATTR_INVALID,
+	NL80211_FREQUENCY_ATTR_FREQ,
+	NL80211_FREQUENCY_ATTR_DISABLED,
+	NL80211_FREQUENCY_ATTR_NO_IR,
+	__NL80211_FREQUENCY_ATTR_NO_IBSS,
+	NL80211_FREQUENCY_ATTR_RADAR,
+	NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
+	NL80211_FREQUENCY_ATTR_DFS_STATE,
+	NL80211_FREQUENCY_ATTR_DFS_TIME,
+	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS,
+	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS,
+	NL80211_FREQUENCY_ATTR_NO_80MHZ,
+	NL80211_FREQUENCY_ATTR_NO_160MHZ,
+	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME,
+	NL80211_FREQUENCY_ATTR_INDOOR_ONLY,
+	NL80211_FREQUENCY_ATTR_GO_CONCURRENT,
+	NL80211_FREQUENCY_ATTR_NO_20MHZ,
+	NL80211_FREQUENCY_ATTR_NO_10MHZ,
+
+	/* keep last */
+	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
+	NL80211_FREQUENCY_ATTR_MAX = __NL80211_FREQUENCY_ATTR_AFTER_LAST - 1
+};
+
+#define NL80211_FREQUENCY_ATTR_MAX_TX_POWER NL80211_FREQUENCY_ATTR_MAX_TX_POWER
+#define NL80211_FREQUENCY_ATTR_PASSIVE_SCAN	NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_NO_IBSS		NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_NO_IR		NL80211_FREQUENCY_ATTR_NO_IR
+
+/**
+ * enum nl80211_bitrate_attr - bitrate attributes
+ * @__NL80211_BITRATE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_BITRATE_ATTR_RATE: Bitrate in units of 100 kbps
+ * @NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: Short preamble supported
+ *	in 2.4 GHz band.
+ * @NL80211_BITRATE_ATTR_MAX: highest bitrate attribute number
+ *	currently defined
+ * @__NL80211_BITRATE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_bitrate_attr {
+	__NL80211_BITRATE_ATTR_INVALID,
+	NL80211_BITRATE_ATTR_RATE,
+	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE,
+
+	/* keep last */
+	__NL80211_BITRATE_ATTR_AFTER_LAST,
+	NL80211_BITRATE_ATTR_MAX = __NL80211_BITRATE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_initiator - Indicates the initiator of a reg domain request
+ * @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the
+ * 	regulatory domain.
+ * @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the
+ * 	wireless core it thinks its knows the regulatory domain we should be in.
+ * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
+ * 	802.11 country information element with regulatory information it
+ * 	thinks we should consider. cfg80211 only processes the country
+ *	code from the IE, and relies on the regulatory domain information
+ *	structure passed by userspace (CRDA) from our wireless-regdb.
+ *	If a channel is enabled but the country code indicates it should
+ *	be disabled we disable the channel and re-enable it upon disassociation.
+ */
+enum nl80211_reg_initiator {
+	NL80211_REGDOM_SET_BY_CORE,
+	NL80211_REGDOM_SET_BY_USER,
+	NL80211_REGDOM_SET_BY_DRIVER,
+	NL80211_REGDOM_SET_BY_COUNTRY_IE,
+};
+
+/**
+ * enum nl80211_reg_type - specifies the type of regulatory domain
+ * @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains
+ *	to a specific country. When this is set you can count on the
+ *	ISO / IEC 3166 alpha2 country code being valid.
+ * @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory
+ * 	domain.
+ * @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom
+ * 	driver specific world regulatory domain. These do not apply system-wide
+ * 	and are only applicable to the individual devices which have requested
+ * 	them to be applied.
+ * @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product
+ *	of an intersection between two regulatory domains -- the previously
+ *	set regulatory domain on the system and the last accepted regulatory
+ *	domain request to be processed.
+ */
+enum nl80211_reg_type {
+	NL80211_REGDOM_TYPE_COUNTRY,
+	NL80211_REGDOM_TYPE_WORLD,
+	NL80211_REGDOM_TYPE_CUSTOM_WORLD,
+	NL80211_REGDOM_TYPE_INTERSECTION,
+};
+
+/**
+ * enum nl80211_reg_rule_attr - regulatory rule attributes
+ * @__NL80211_REG_RULE_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional
+ * 	considerations for a given frequency range. These are the
+ * 	&enum nl80211_reg_rule_flags.
+ * @NL80211_ATTR_FREQ_RANGE_START: starting frequencry for the regulatory
+ * 	rule in KHz. This is not a center of frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_END: ending frequency for the regulatory rule
+ * 	in KHz. This is not a center a frequency but an actual regulatory
+ * 	band edge.
+ * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
+ *	frequency range, in KHz.
+ * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
+ * 	for a given frequency range. The value is in mBi (100 * dBi).
+ * 	If you don't have one then don't send this.
+ * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
+ * 	a given frequency range. The value is in mBm (100 * dBm).
+ * @NL80211_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
+ *	If not present or 0 default CAC time will be used.
+ * @NL80211_REG_RULE_ATTR_MAX: highest regulatory rule attribute number
+ *	currently defined
+ * @__NL80211_REG_RULE_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_reg_rule_attr {
+	__NL80211_REG_RULE_ATTR_INVALID,
+	NL80211_ATTR_REG_RULE_FLAGS,
+
+	NL80211_ATTR_FREQ_RANGE_START,
+	NL80211_ATTR_FREQ_RANGE_END,
+	NL80211_ATTR_FREQ_RANGE_MAX_BW,
+
+	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
+	NL80211_ATTR_POWER_RULE_MAX_EIRP,
+
+	NL80211_ATTR_DFS_CAC_TIME,
+
+	/* keep last */
+	__NL80211_REG_RULE_ATTR_AFTER_LAST,
+	NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
+ * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
+ *	only report BSS with matching SSID.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI: RSSI threshold (in dBm) for reporting a
+ *	BSS in scan results. Filtering is turned off if not specified. Note that
+ *	if this attribute is in a match set of its own, then it is treated as
+ *	the default value for all matchsets with an SSID, rather than being a
+ *	matchset of its own without an RSSI filter. This is due to problems with
+ *	how this API was implemented in the past. Also, due to the same problem,
+ *	the only way to create a matchset with only an RSSI filter (with this
+ *	attribute) is if there's only a single matchset with the RSSI attribute.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
+ *	attribute number currently defined
+ * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_sched_scan_match_attr {
+	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID,
+
+	NL80211_SCHED_SCAN_MATCH_ATTR_SSID,
+	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI,
+
+	/* keep last */
+	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST,
+	NL80211_SCHED_SCAN_MATCH_ATTR_MAX =
+		__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST - 1
+};
+
+/* only for backward compatibility */
+#define NL80211_ATTR_SCHED_SCAN_MATCH_SSID NL80211_SCHED_SCAN_MATCH_ATTR_SSID
+
+/**
+ * enum nl80211_reg_rule_flags - regulatory rule flags
+ *
+ * @NL80211_RRF_NO_OFDM: OFDM modulation not allowed
+ * @NL80211_RRF_NO_CCK: CCK modulation not allowed
+ * @NL80211_RRF_NO_INDOOR: indoor operation not allowed
+ * @NL80211_RRF_NO_OUTDOOR: outdoor operation not allowed
+ * @NL80211_RRF_DFS: DFS support is required to be used
+ * @NL80211_RRF_PTP_ONLY: this is only for Point To Point links
+ * @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links
+ * @NL80211_RRF_NO_IR: no mechanisms that initiate radiation are allowed,
+ * 	this includes probe requests or modes of operation that require
+ * 	beaconing.
+ * @NL80211_RRF_AUTO_BW: maximum available bandwidth should be calculated
+ *	base on contiguous rules and wider channels will be allowed to cross
+ *	multiple contiguous/overlapping frequency ranges.
+ * @NL80211_RRF_GO_CONCURRENT: See &NL80211_FREQUENCY_ATTR_GO_CONCURRENT
+ * @NL80211_RRF_NO_HT40MINUS: channels can't be used in HT40- operation
+ * @NL80211_RRF_NO_HT40PLUS: channels can't be used in HT40+ operation
+ * @NL80211_RRF_NO_80MHZ: 80MHz operation not allowed
+ * @NL80211_RRF_NO_160MHZ: 160MHz operation not allowed
+ */
+enum nl80211_reg_rule_flags {
+	NL80211_RRF_NO_OFDM		= 1<<0,
+	NL80211_RRF_NO_CCK		= 1<<1,
+	NL80211_RRF_NO_INDOOR		= 1<<2,
+	NL80211_RRF_NO_OUTDOOR		= 1<<3,
+	NL80211_RRF_DFS			= 1<<4,
+	NL80211_RRF_PTP_ONLY		= 1<<5,
+	NL80211_RRF_PTMP_ONLY		= 1<<6,
+	NL80211_RRF_NO_IR		= 1<<7,
+	__NL80211_RRF_NO_IBSS		= 1<<8,
+	NL80211_RRF_AUTO_BW		= 1<<11,
+	NL80211_RRF_GO_CONCURRENT	= 1<<12,
+	NL80211_RRF_NO_HT40MINUS	= 1<<13,
+	NL80211_RRF_NO_HT40PLUS		= 1<<14,
+	NL80211_RRF_NO_80MHZ		= 1<<15,
+	NL80211_RRF_NO_160MHZ		= 1<<16,
+};
+
+#define NL80211_RRF_PASSIVE_SCAN	NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_IBSS		NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_IR		NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_HT40		(NL80211_RRF_NO_HT40MINUS |\
+					 NL80211_RRF_NO_HT40PLUS)
+
+/* For backport compatibility with older userspace */
+#define NL80211_RRF_NO_IR_ALL		(NL80211_RRF_NO_IR | __NL80211_RRF_NO_IBSS)
+
+/**
+ * enum nl80211_dfs_regions - regulatory DFS regions
+ *
+ * @NL80211_DFS_UNSET: Country has no DFS master region specified
+ * @NL80211_DFS_FCC: Country follows DFS master rules from FCC
+ * @NL80211_DFS_ETSI: Country follows DFS master rules from ETSI
+ * @NL80211_DFS_JP: Country follows DFS master rules from JP/MKK/Telec
+ */
+enum nl80211_dfs_regions {
+	NL80211_DFS_UNSET	= 0,
+	NL80211_DFS_FCC		= 1,
+	NL80211_DFS_ETSI	= 2,
+	NL80211_DFS_JP		= 3,
+};
+
+/**
+ * enum nl80211_user_reg_hint_type - type of user regulatory hint
+ *
+ * @NL80211_USER_REG_HINT_USER: a user sent the hint. This is always
+ *	assumed if the attribute is not set.
+ * @NL80211_USER_REG_HINT_CELL_BASE: the hint comes from a cellular
+ *	base station. Device drivers that have been tested to work
+ *	properly to support this type of hint can enable these hints
+ *	by setting the NL80211_FEATURE_CELL_BASE_REG_HINTS feature
+ *	capability on the struct wiphy. The wireless core will
+ *	ignore all cell base station hints until at least one device
+ *	present has been registered with the wireless core that
+ *	has listed NL80211_FEATURE_CELL_BASE_REG_HINTS as a
+ *	supported feature.
+ * @NL80211_USER_REG_HINT_INDOOR: a user sent an hint indicating that the
+ *	platform is operating in an indoor environment.
+ */
+enum nl80211_user_reg_hint_type {
+	NL80211_USER_REG_HINT_USER	= 0,
+	NL80211_USER_REG_HINT_CELL_BASE = 1,
+	NL80211_USER_REG_HINT_INDOOR    = 2,
+};
+
+/**
+ * enum nl80211_survey_info - survey information
+ *
+ * These attribute types are used with %NL80211_ATTR_SURVEY_INFO
+ * when getting information about a survey.
+ *
+ * @__NL80211_SURVEY_INFO_INVALID: attribute number 0 is reserved
+ * @NL80211_SURVEY_INFO_FREQUENCY: center frequency of channel
+ * @NL80211_SURVEY_INFO_NOISE: noise level of channel (u8, dBm)
+ * @NL80211_SURVEY_INFO_IN_USE: channel is currently being used
+ * @NL80211_SURVEY_INFO_TIME: amount of time (in ms) that the radio
+ *	was turned on (on channel or globally)
+ * @NL80211_SURVEY_INFO_TIME_BUSY: amount of the time the primary
+ *	channel was sensed busy (either due to activity or energy detect)
+ * @NL80211_SURVEY_INFO_TIME_EXT_BUSY: amount of time the extension
+ *	channel was sensed busy
+ * @NL80211_SURVEY_INFO_TIME_RX: amount of time the radio spent
+ *	receiving data (on channel or globally)
+ * @NL80211_SURVEY_INFO_TIME_TX: amount of time the radio spent
+ *	transmitting data (on channel or globally)
+ * @NL80211_SURVEY_INFO_TIME_SCAN: time the radio spent for scan
+ *	(on this channel or globally)
+ * @NL80211_SURVEY_INFO_MAX: highest survey info attribute number
+ *	currently defined
+ * @__NL80211_SURVEY_INFO_AFTER_LAST: internal use
+ */
+enum nl80211_survey_info {
+	__NL80211_SURVEY_INFO_INVALID,
+	NL80211_SURVEY_INFO_FREQUENCY,
+	NL80211_SURVEY_INFO_NOISE,
+	NL80211_SURVEY_INFO_IN_USE,
+	NL80211_SURVEY_INFO_TIME,
+	NL80211_SURVEY_INFO_TIME_BUSY,
+	NL80211_SURVEY_INFO_TIME_EXT_BUSY,
+	NL80211_SURVEY_INFO_TIME_RX,
+	NL80211_SURVEY_INFO_TIME_TX,
+	NL80211_SURVEY_INFO_TIME_SCAN,
+
+	/* keep last */
+	__NL80211_SURVEY_INFO_AFTER_LAST,
+	NL80211_SURVEY_INFO_MAX = __NL80211_SURVEY_INFO_AFTER_LAST - 1
+};
+
+/* keep old names for compatibility */
+#define NL80211_SURVEY_INFO_CHANNEL_TIME		NL80211_SURVEY_INFO_TIME
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY		NL80211_SURVEY_INFO_TIME_BUSY
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY	NL80211_SURVEY_INFO_TIME_EXT_BUSY
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_RX		NL80211_SURVEY_INFO_TIME_RX
+#define NL80211_SURVEY_INFO_CHANNEL_TIME_TX		NL80211_SURVEY_INFO_TIME_TX
+
+/**
+ * enum nl80211_mntr_flags - monitor configuration flags
+ *
+ * Monitor configuration flags.
+ *
+ * @__NL80211_MNTR_FLAG_INVALID: reserved
+ *
+ * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
+ * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
+ * @NL80211_MNTR_FLAG_CONTROL: pass control frames
+ * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
+ * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
+ *	overrides all other flags.
+ * @NL80211_MNTR_FLAG_ACTIVE: use the configured MAC address
+ *	and ACK incoming unicast packets.
+ *
+ * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
+ * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
+ */
+enum nl80211_mntr_flags {
+	__NL80211_MNTR_FLAG_INVALID,
+	NL80211_MNTR_FLAG_FCSFAIL,
+	NL80211_MNTR_FLAG_PLCPFAIL,
+	NL80211_MNTR_FLAG_CONTROL,
+	NL80211_MNTR_FLAG_OTHER_BSS,
+	NL80211_MNTR_FLAG_COOK_FRAMES,
+	NL80211_MNTR_FLAG_ACTIVE,
+
+	/* keep last */
+	__NL80211_MNTR_FLAG_AFTER_LAST,
+	NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mesh_power_mode - mesh power save modes
+ *
+ * @NL80211_MESH_POWER_UNKNOWN: The mesh power mode of the mesh STA is
+ *	not known or has not been set yet.
+ * @NL80211_MESH_POWER_ACTIVE: Active mesh power mode. The mesh STA is
+ *	in Awake state all the time.
+ * @NL80211_MESH_POWER_LIGHT_SLEEP: Light sleep mode. The mesh STA will
+ *	alternate between Active and Doze states, but will wake up for
+ *	neighbor's beacons.
+ * @NL80211_MESH_POWER_DEEP_SLEEP: Deep sleep mode. The mesh STA will
+ *	alternate between Active and Doze states, but may not wake up
+ *	for neighbor's beacons.
+ *
+ * @__NL80211_MESH_POWER_AFTER_LAST - internal use
+ * @NL80211_MESH_POWER_MAX - highest possible power save level
+ */
+
+enum nl80211_mesh_power_mode {
+	NL80211_MESH_POWER_UNKNOWN,
+	NL80211_MESH_POWER_ACTIVE,
+	NL80211_MESH_POWER_LIGHT_SLEEP,
+	NL80211_MESH_POWER_DEEP_SLEEP,
+
+	__NL80211_MESH_POWER_AFTER_LAST,
+	NL80211_MESH_POWER_MAX = __NL80211_MESH_POWER_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_meshconf_params - mesh configuration parameters
+ *
+ * Mesh configuration parameters. These can be changed while the mesh is
+ * active.
+ *
+ * @__NL80211_MESHCONF_INVALID: internal use
+ *
+ * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
+ *	millisecond units, used by the Peer Link Open message
+ *
+ * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the initial confirm timeout, in
+ *	millisecond units, used by the peer link management to close a peer link
+ *
+ * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
+ *	millisecond units
+ *
+ * @NL80211_MESHCONF_MAX_PEER_LINKS: maximum number of peer links allowed
+ *	on this mesh interface
+ *
+ * @NL80211_MESHCONF_MAX_RETRIES: specifies the maximum number of peer link
+ *	open retries that can be sent to establish a new peer link instance in a
+ *	mesh
+ *
+ * @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh
+ *	point.
+ *
+ * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically open
+ *	peer links when we detect compatible mesh peers. Disabled if
+ *	@NL80211_MESH_SETUP_USERSPACE_MPM or @NL80211_MESH_SETUP_USERSPACE_AMPE are
+ *	set.
+ *
+ * @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames
+ *	containing a PREQ that an MP can send to a particular destination (path
+ *	target)
+ *
+ * @NL80211_MESHCONF_PATH_REFRESH_TIME: how frequently to refresh mesh paths
+ *	(in milliseconds)
+ *
+ * @NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: minimum length of time to wait
+ *	until giving up on a path discovery (in milliseconds)
+ *
+ * @NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT: The time (in TUs) for which mesh
+ *	points receiving a PREQ shall consider the forwarding information from
+ *	the root to be valid. (TU = time unit)
+ *
+ * @NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: The minimum interval of time (in
+ *	TUs) during which an MP can send only one action frame containing a PREQ
+ *	reference element
+ *
+ * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
+ *	that it takes for an HWMP information element to propagate across the
+ *	mesh
+ *
+ * @NL80211_MESHCONF_HWMP_ROOTMODE: whether root mode is enabled or not
+ *
+ * @NL80211_MESHCONF_ELEMENT_TTL: specifies the value of TTL field set at a
+ *	source mesh point for path selection elements.
+ *
+ * @NL80211_MESHCONF_HWMP_RANN_INTERVAL:  The interval of time (in TUs) between
+ *	root announcements are transmitted.
+ *
+ * @NL80211_MESHCONF_GATE_ANNOUNCEMENTS: Advertise that this mesh station has
+ *	access to a broader network beyond the MBSS.  This is done via Root
+ *	Announcement frames.
+ *
+ * @NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL: The minimum interval of time (in
+ *	TUs) during which a mesh STA can send only one Action frame containing a
+ *	PERR element.
+ *
+ * @NL80211_MESHCONF_FORWARDING: set Mesh STA as forwarding or non-forwarding
+ *	or forwarding entity (default is TRUE - forwarding entity)
+ *
+ * @NL80211_MESHCONF_RSSI_THRESHOLD: RSSI threshold in dBm. This specifies the
+ *	threshold for average signal strength of candidate station to establish
+ *	a peer link.
+ *
+ * @NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR: maximum number of neighbors
+ *	to synchronize to for 11s default synchronization method
+ *	(see 11C.12.2.2)
+ *
+ * @NL80211_MESHCONF_HT_OPMODE: set mesh HT protection mode.
+ *
+ * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
+ *
+ * @NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT: The time (in TUs) for
+ *	which mesh STAs receiving a proactive PREQ shall consider the forwarding
+ *	information to the root mesh STA to be valid.
+ *
+ * @NL80211_MESHCONF_HWMP_ROOT_INTERVAL: The interval of time (in TUs) between
+ *	proactive PREQs are transmitted.
+ *
+ * @NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL: The minimum interval of time
+ *	(in TUs) during which a mesh STA can send only one Action frame
+ *	containing a PREQ element for root path confirmation.
+ *
+ * @NL80211_MESHCONF_POWER_MODE: Default mesh power mode for new peer links.
+ *	type &enum nl80211_mesh_power_mode (u32)
+ *
+ * @NL80211_MESHCONF_AWAKE_WINDOW: awake window duration (in TUs)
+ *
+ * @NL80211_MESHCONF_PLINK_TIMEOUT: If no tx activity is seen from a STA we've
+ *	established peering with for longer than this time (in seconds), then
+ *	remove it from the STA's list of peers. You may set this to 0 to disable
+ *	the removal of the STA. Default is 30 minutes.
+ *
+ * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_meshconf_params {
+	__NL80211_MESHCONF_INVALID,
+	NL80211_MESHCONF_RETRY_TIMEOUT,
+	NL80211_MESHCONF_CONFIRM_TIMEOUT,
+	NL80211_MESHCONF_HOLDING_TIMEOUT,
+	NL80211_MESHCONF_MAX_PEER_LINKS,
+	NL80211_MESHCONF_MAX_RETRIES,
+	NL80211_MESHCONF_TTL,
+	NL80211_MESHCONF_AUTO_OPEN_PLINKS,
+	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
+	NL80211_MESHCONF_PATH_REFRESH_TIME,
+	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
+	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
+	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
+	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
+	NL80211_MESHCONF_HWMP_ROOTMODE,
+	NL80211_MESHCONF_ELEMENT_TTL,
+	NL80211_MESHCONF_HWMP_RANN_INTERVAL,
+	NL80211_MESHCONF_GATE_ANNOUNCEMENTS,
+	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,
+	NL80211_MESHCONF_FORWARDING,
+	NL80211_MESHCONF_RSSI_THRESHOLD,
+	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,
+	NL80211_MESHCONF_HT_OPMODE,
+	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,
+	NL80211_MESHCONF_HWMP_ROOT_INTERVAL,
+	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,
+	NL80211_MESHCONF_POWER_MODE,
+	NL80211_MESHCONF_AWAKE_WINDOW,
+	NL80211_MESHCONF_PLINK_TIMEOUT,
+
+	/* keep last */
+	__NL80211_MESHCONF_ATTR_AFTER_LAST,
+	NL80211_MESHCONF_ATTR_MAX = __NL80211_MESHCONF_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_mesh_setup_params - mesh setup parameters
+ *
+ * Mesh setup parameters.  These are used to start/join a mesh and cannot be
+ * changed while the mesh is active.
+ *
+ * @__NL80211_MESH_SETUP_INVALID: Internal use
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL: Enable this option to use a
+ *	vendor specific path selection algorithm or disable it to use the
+ *	default HWMP.
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC: Enable this option to use a
+ *	vendor specific path metric or disable it to use the default Airtime
+ *	metric.
+ *
+ * @NL80211_MESH_SETUP_IE: Information elements for this mesh, for instance, a
+ *	robust security network ie, or a vendor specific information element
+ *	that vendors will use to identify the path selection methods and
+ *	metrics in use.
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_AUTH: Enable this option if an authentication
+ *	daemon will be authenticating mesh candidates.
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_AMPE: Enable this option if an authentication
+ *	daemon will be securing peer link frames.  AMPE is a secured version of
+ *	Mesh Peering Management (MPM) and is implemented with the assistance of
+ *	a userspace daemon.  When this flag is set, the kernel will send peer
+ *	management frames to a userspace daemon that will implement AMPE
+ *	functionality (security capabilities selection, key confirmation, and
+ *	key management).  When the flag is unset (default), the kernel can
+ *	autonomously complete (unsecured) mesh peering without the need of a
+ *	userspace daemon.
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC: Enable this option to use a
+ *	vendor specific synchronization method or disable it to use the default
+ *	neighbor offset synchronization
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_MPM: Enable this option if userspace will
+ *	implement an MPM which handles peer allocation and state.
+ *
+ * @NL80211_MESH_SETUP_AUTH_PROTOCOL: Inform the kernel of the authentication
+ *	method (u8, as defined in IEEE 8.4.2.100.6, e.g. 0x1 for SAE).
+ *	Default is no authentication method required.
+ *
+ * @NL80211_MESH_SETUP_ATTR_MAX: highest possible mesh setup attribute number
+ *
+ * @__NL80211_MESH_SETUP_ATTR_AFTER_LAST: Internal use
+ */
+enum nl80211_mesh_setup_params {
+	__NL80211_MESH_SETUP_INVALID,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC,
+	NL80211_MESH_SETUP_IE,
+	NL80211_MESH_SETUP_USERSPACE_AUTH,
+	NL80211_MESH_SETUP_USERSPACE_AMPE,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC,
+	NL80211_MESH_SETUP_USERSPACE_MPM,
+	NL80211_MESH_SETUP_AUTH_PROTOCOL,
+
+	/* keep last */
+	__NL80211_MESH_SETUP_ATTR_AFTER_LAST,
+	NL80211_MESH_SETUP_ATTR_MAX = __NL80211_MESH_SETUP_ATTR_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_txq_attr - TX queue parameter attributes
+ * @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved
+ * @NL80211_TXQ_ATTR_AC: AC identifier (NL80211_AC_*)
+ * @NL80211_TXQ_ATTR_TXOP: Maximum burst time in units of 32 usecs, 0 meaning
+ *	disabled
+ * @NL80211_TXQ_ATTR_CWMIN: Minimum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_CWMAX: Maximum contention window [a value of the form
+ *	2^n-1 in the range 1..32767]
+ * @NL80211_TXQ_ATTR_AIFS: Arbitration interframe space [0..255]
+ * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
+ * @NL80211_TXQ_ATTR_MAX: Maximum TXQ attribute number
+ */
+enum nl80211_txq_attr {
+	__NL80211_TXQ_ATTR_INVALID,
+	NL80211_TXQ_ATTR_AC,
+	NL80211_TXQ_ATTR_TXOP,
+	NL80211_TXQ_ATTR_CWMIN,
+	NL80211_TXQ_ATTR_CWMAX,
+	NL80211_TXQ_ATTR_AIFS,
+
+	/* keep last */
+	__NL80211_TXQ_ATTR_AFTER_LAST,
+	NL80211_TXQ_ATTR_MAX = __NL80211_TXQ_ATTR_AFTER_LAST - 1
+};
+
+enum nl80211_ac {
+	NL80211_AC_VO,
+	NL80211_AC_VI,
+	NL80211_AC_BE,
+	NL80211_AC_BK,
+	NL80211_NUM_ACS
+};
+
+/* backward compat */
+#define NL80211_TXQ_ATTR_QUEUE	NL80211_TXQ_ATTR_AC
+#define NL80211_TXQ_Q_VO	NL80211_AC_VO
+#define NL80211_TXQ_Q_VI	NL80211_AC_VI
+#define NL80211_TXQ_Q_BE	NL80211_AC_BE
+#define NL80211_TXQ_Q_BK	NL80211_AC_BK
+
+/**
+ * enum nl80211_channel_type - channel type
+ * @NL80211_CHAN_NO_HT: 20 MHz, non-HT channel
+ * @NL80211_CHAN_HT20: 20 MHz HT channel
+ * @NL80211_CHAN_HT40MINUS: HT40 channel, secondary channel
+ *	below the control channel
+ * @NL80211_CHAN_HT40PLUS: HT40 channel, secondary channel
+ *	above the control channel
+ */
+enum nl80211_channel_type {
+	NL80211_CHAN_NO_HT,
+	NL80211_CHAN_HT20,
+	NL80211_CHAN_HT40MINUS,
+	NL80211_CHAN_HT40PLUS
+};
+
+/**
+ * enum nl80211_chan_width - channel width definitions
+ *
+ * These values are used with the %NL80211_ATTR_CHANNEL_WIDTH
+ * attribute.
+ *
+ * @NL80211_CHAN_WIDTH_20_NOHT: 20 MHz, non-HT channel
+ * @NL80211_CHAN_WIDTH_20: 20 MHz HT channel
+ * @NL80211_CHAN_WIDTH_40: 40 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_80: 80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_80P80: 80+80 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	and %NL80211_ATTR_CENTER_FREQ2 attributes must be provided as well
+ * @NL80211_CHAN_WIDTH_160: 160 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
+ *	attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel
+ */
+enum nl80211_chan_width {
+	NL80211_CHAN_WIDTH_20_NOHT,
+	NL80211_CHAN_WIDTH_20,
+	NL80211_CHAN_WIDTH_40,
+	NL80211_CHAN_WIDTH_80,
+	NL80211_CHAN_WIDTH_80P80,
+	NL80211_CHAN_WIDTH_160,
+	NL80211_CHAN_WIDTH_5,
+	NL80211_CHAN_WIDTH_10,
+};
+
+/**
+ * enum nl80211_bss_scan_width - control channel width for a BSS
+ *
+ * These values are used with the %NL80211_BSS_CHAN_WIDTH attribute.
+ *
+ * @NL80211_BSS_CHAN_WIDTH_20: control channel is 20 MHz wide or compatible
+ * @NL80211_BSS_CHAN_WIDTH_10: control channel is 10 MHz wide
+ * @NL80211_BSS_CHAN_WIDTH_5: control channel is 5 MHz wide
+ */
+enum nl80211_bss_scan_width {
+	NL80211_BSS_CHAN_WIDTH_20,
+	NL80211_BSS_CHAN_WIDTH_10,
+	NL80211_BSS_CHAN_WIDTH_5,
+};
+
+/**
+ * enum nl80211_bss - netlink attributes for a BSS
+ *
+ * @__NL80211_BSS_INVALID: invalid
+ * @NL80211_BSS_BSSID: BSSID of the BSS (6 octets)
+ * @NL80211_BSS_FREQUENCY: frequency in MHz (u32)
+ * @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)
+ *	(if @NL80211_BSS_PRESP_DATA is present then this is known to be
+ *	from a probe response, otherwise it may be from the same beacon
+ *	that the NL80211_BSS_BEACON_TSF will be from)
+ * @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)
+ * @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)
+ * @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the
+ *	raw information elements from the probe response/beacon (bin);
+ *	if the %NL80211_BSS_BEACON_IES attribute is present and the data is
+ *	different then the IEs here are from a Probe Response frame; otherwise
+ *	they are from a Beacon frame.
+ *	However, if the driver does not indicate the source of the IEs, these
+ *	IEs may be from either frame subtype.
+ *	If present, the @NL80211_BSS_PRESP_DATA attribute indicates that the
+ *	data here is known to be from a probe response, without any heuristics.
+ * @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon
+ *	in mBm (100 * dBm) (s32)
+ * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
+ *	in unspecified units, scaled to 0..100 (u8)
+ * @NL80211_BSS_STATUS: status, if this BSS is "used"
+ * @NL80211_BSS_SEEN_MS_AGO: age of this BSS entry in ms
+ * @NL80211_BSS_BEACON_IES: binary attribute containing the raw information
+ *	elements from a Beacon frame (bin); not present if no Beacon frame has
+ *	yet been received
+ * @NL80211_BSS_CHAN_WIDTH: channel width of the control channel
+ *	(u32, enum nl80211_bss_scan_width)
+ * @NL80211_BSS_BEACON_TSF: TSF of the last received beacon (u64)
+ *	(not present if no beacon frame has been received yet)
+ * @NL80211_BSS_PRESP_DATA: the data in @NL80211_BSS_INFORMATION_ELEMENTS and
+ *	@NL80211_BSS_TSF is known to be from a probe response (flag attribute)
+ * @__NL80211_BSS_AFTER_LAST: internal
+ * @NL80211_BSS_MAX: highest BSS attribute
+ */
+enum nl80211_bss {
+	__NL80211_BSS_INVALID,
+	NL80211_BSS_BSSID,
+	NL80211_BSS_FREQUENCY,
+	NL80211_BSS_TSF,
+	NL80211_BSS_BEACON_INTERVAL,
+	NL80211_BSS_CAPABILITY,
+	NL80211_BSS_INFORMATION_ELEMENTS,
+	NL80211_BSS_SIGNAL_MBM,
+	NL80211_BSS_SIGNAL_UNSPEC,
+	NL80211_BSS_STATUS,
+	NL80211_BSS_SEEN_MS_AGO,
+	NL80211_BSS_BEACON_IES,
+	NL80211_BSS_CHAN_WIDTH,
+	NL80211_BSS_BEACON_TSF,
+	NL80211_BSS_PRESP_DATA,
+
+	/* keep last */
+	__NL80211_BSS_AFTER_LAST,
+	NL80211_BSS_MAX = __NL80211_BSS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_bss_status - BSS "status"
+ * @NL80211_BSS_STATUS_AUTHENTICATED: Authenticated with this BSS.
+ *	Note that this is no longer used since cfg80211 no longer
+ *	keeps track of whether or not authentication was done with
+ *	a given BSS.
+ * @NL80211_BSS_STATUS_ASSOCIATED: Associated with this BSS.
+ * @NL80211_BSS_STATUS_IBSS_JOINED: Joined to this IBSS.
+ *
+ * The BSS status is a BSS attribute in scan dumps, which
+ * indicates the status the interface has wrt. this BSS.
+ */
+enum nl80211_bss_status {
+	NL80211_BSS_STATUS_AUTHENTICATED,
+	NL80211_BSS_STATUS_ASSOCIATED,
+	NL80211_BSS_STATUS_IBSS_JOINED,
+};
+
+/**
+ * enum nl80211_auth_type - AuthenticationType
+ *
+ * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
+ * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
+ * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
+ * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
+ * @NL80211_AUTHTYPE_SAE: Simultaneous authentication of equals
+ * @__NL80211_AUTHTYPE_NUM: internal
+ * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
+ * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
+ *	trying multiple times); this is invalid in netlink -- leave out
+ *	the attribute for this on CONNECT commands.
+ */
+enum nl80211_auth_type {
+	NL80211_AUTHTYPE_OPEN_SYSTEM,
+	NL80211_AUTHTYPE_SHARED_KEY,
+	NL80211_AUTHTYPE_FT,
+	NL80211_AUTHTYPE_NETWORK_EAP,
+	NL80211_AUTHTYPE_SAE,
+
+	/* keep last */
+	__NL80211_AUTHTYPE_NUM,
+	NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
+	NL80211_AUTHTYPE_AUTOMATIC
+};
+
+/**
+ * enum nl80211_key_type - Key Type
+ * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
+ * @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key
+ * @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)
+ * @NUM_NL80211_KEYTYPES: number of defined key types
+ */
+enum nl80211_key_type {
+	NL80211_KEYTYPE_GROUP,
+	NL80211_KEYTYPE_PAIRWISE,
+	NL80211_KEYTYPE_PEERKEY,
+
+	NUM_NL80211_KEYTYPES
+};
+
+/**
+ * enum nl80211_mfp - Management frame protection state
+ * @NL80211_MFP_NO: Management frame protection not used
+ * @NL80211_MFP_REQUIRED: Management frame protection required
+ */
+enum nl80211_mfp {
+	NL80211_MFP_NO,
+	NL80211_MFP_REQUIRED,
+};
+
+enum nl80211_wpa_versions {
+	NL80211_WPA_VERSION_1 = 1 << 0,
+	NL80211_WPA_VERSION_2 = 1 << 1,
+};
+
+/**
+ * enum nl80211_key_default_types - key default types
+ * @__NL80211_KEY_DEFAULT_TYPE_INVALID: invalid
+ * @NL80211_KEY_DEFAULT_TYPE_UNICAST: key should be used as default
+ *	unicast key
+ * @NL80211_KEY_DEFAULT_TYPE_MULTICAST: key should be used as default
+ *	multicast key
+ * @NUM_NL80211_KEY_DEFAULT_TYPES: number of default types
+ */
+enum nl80211_key_default_types {
+	__NL80211_KEY_DEFAULT_TYPE_INVALID,
+	NL80211_KEY_DEFAULT_TYPE_UNICAST,
+	NL80211_KEY_DEFAULT_TYPE_MULTICAST,
+
+	NUM_NL80211_KEY_DEFAULT_TYPES
+};
+
+/**
+ * enum nl80211_key_attributes - key attributes
+ * @__NL80211_KEY_INVALID: invalid
+ * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
+ *	16 bytes encryption key followed by 8 bytes each for TX and RX MIC
+ *	keys
+ * @NL80211_KEY_IDX: key ID (u8, 0-3)
+ * @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
+ *	section 7.3.2.25.1, e.g. 0x000FAC04)
+ * @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
+ *	CCMP keys, each six bytes in little endian
+ * @NL80211_KEY_DEFAULT: flag indicating default key
+ * @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key
+ * @NL80211_KEY_TYPE: the key type from enum nl80211_key_type, if not
+ *	specified the default depends on whether a MAC address was
+ *	given with the command using the key or not (u32)
+ * @NL80211_KEY_DEFAULT_TYPES: A nested attribute containing flags
+ *	attributes, specifying what a key should be set as default as.
+ *	See &enum nl80211_key_default_types.
+ * @__NL80211_KEY_AFTER_LAST: internal
+ * @NL80211_KEY_MAX: highest key attribute
+ */
+enum nl80211_key_attributes {
+	__NL80211_KEY_INVALID,
+	NL80211_KEY_DATA,
+	NL80211_KEY_IDX,
+	NL80211_KEY_CIPHER,
+	NL80211_KEY_SEQ,
+	NL80211_KEY_DEFAULT,
+	NL80211_KEY_DEFAULT_MGMT,
+	NL80211_KEY_TYPE,
+	NL80211_KEY_DEFAULT_TYPES,
+
+	/* keep last */
+	__NL80211_KEY_AFTER_LAST,
+	NL80211_KEY_MAX = __NL80211_KEY_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_tx_rate_attributes - TX rate set attributes
+ * @__NL80211_TXRATE_INVALID: invalid
+ * @NL80211_TXRATE_LEGACY: Legacy (non-MCS) rates allowed for TX rate selection
+ *	in an array of rates as defined in IEEE 802.11 7.3.2.2 (u8 values with
+ *	1 = 500 kbps) but without the IE length restriction (at most
+ *	%NL80211_MAX_SUPP_RATES in a single array).
+ * @NL80211_TXRATE_HT: HT (MCS) rates allowed for TX rate selection
+ *	in an array of MCS numbers.
+ * @NL80211_TXRATE_VHT: VHT rates allowed for TX rate selection,
+ *	see &struct nl80211_txrate_vht
+ * @NL80211_TXRATE_GI: configure GI, see &enum nl80211_txrate_gi
+ * @__NL80211_TXRATE_AFTER_LAST: internal
+ * @NL80211_TXRATE_MAX: highest TX rate attribute
+ */
+enum nl80211_tx_rate_attributes {
+	__NL80211_TXRATE_INVALID,
+	NL80211_TXRATE_LEGACY,
+	NL80211_TXRATE_HT,
+	NL80211_TXRATE_VHT,
+	NL80211_TXRATE_GI,
+
+	/* keep last */
+	__NL80211_TXRATE_AFTER_LAST,
+	NL80211_TXRATE_MAX = __NL80211_TXRATE_AFTER_LAST - 1
+};
+
+#define NL80211_TXRATE_MCS NL80211_TXRATE_HT
+#define NL80211_VHT_NSS_MAX		8
+
+/**
+ * struct nl80211_txrate_vht - VHT MCS/NSS txrate bitmap
+ * @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)
+ */
+struct nl80211_txrate_vht {
+	__u16 mcs[NL80211_VHT_NSS_MAX];
+};
+
+enum nl80211_txrate_gi {
+	NL80211_TXRATE_DEFAULT_GI,
+	NL80211_TXRATE_FORCE_SGI,
+	NL80211_TXRATE_FORCE_LGI,
+};
+
+/**
+ * enum nl80211_band - Frequency band
+ * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
+ * @NL80211_BAND_5GHZ: around 5 GHz band (4.9 - 5.7 GHz)
+ * @NL80211_BAND_60GHZ: around 60 GHz band (58.32 - 64.80 GHz)
+ */
+enum nl80211_band {
+	NL80211_BAND_2GHZ,
+	NL80211_BAND_5GHZ,
+	NL80211_BAND_60GHZ,
+};
+
+/**
+ * enum nl80211_ps_state - powersave state
+ * @NL80211_PS_DISABLED: powersave is disabled
+ * @NL80211_PS_ENABLED: powersave is enabled
+ */
+enum nl80211_ps_state {
+	NL80211_PS_DISABLED,
+	NL80211_PS_ENABLED,
+};
+
+/**
+ * enum nl80211_attr_cqm - connection quality monitor attributes
+ * @__NL80211_ATTR_CQM_INVALID: invalid
+ * @NL80211_ATTR_CQM_RSSI_THOLD: RSSI threshold in dBm. This value specifies
+ *	the threshold for the RSSI level at which an event will be sent. Zero
+ *	to disable.
+ * @NL80211_ATTR_CQM_RSSI_HYST: RSSI hysteresis in dBm. This value specifies
+ *	the minimum amount the RSSI level must change after an event before a
+ *	new event may be issued (to reduce effects of RSSI oscillation).
+ * @NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT: RSSI threshold event
+ * @NL80211_ATTR_CQM_PKT_LOSS_EVENT: a u32 value indicating that this many
+ *	consecutive packets were not acknowledged by the peer
+ * @NL80211_ATTR_CQM_TXE_RATE: TX error rate in %. Minimum % of TX failures
+ *	during the given %NL80211_ATTR_CQM_TXE_INTVL before an
+ *	%NL80211_CMD_NOTIFY_CQM with reported %NL80211_ATTR_CQM_TXE_RATE and
+ *	%NL80211_ATTR_CQM_TXE_PKTS is generated.
+ * @NL80211_ATTR_CQM_TXE_PKTS: number of attempted packets in a given
+ *	%NL80211_ATTR_CQM_TXE_INTVL before %NL80211_ATTR_CQM_TXE_RATE is
+ *	checked.
+ * @NL80211_ATTR_CQM_TXE_INTVL: interval in seconds. Specifies the periodic
+ *	interval in which %NL80211_ATTR_CQM_TXE_PKTS and
+ *	%NL80211_ATTR_CQM_TXE_RATE must be satisfied before generating an
+ *	%NL80211_CMD_NOTIFY_CQM. Set to 0 to turn off TX error reporting.
+ * @NL80211_ATTR_CQM_BEACON_LOSS_EVENT: flag attribute that's set in a beacon
+ *	loss event
+ * @__NL80211_ATTR_CQM_AFTER_LAST: internal
+ * @NL80211_ATTR_CQM_MAX: highest key attribute
+ */
+enum nl80211_attr_cqm {
+	__NL80211_ATTR_CQM_INVALID,
+	NL80211_ATTR_CQM_RSSI_THOLD,
+	NL80211_ATTR_CQM_RSSI_HYST,
+	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,
+	NL80211_ATTR_CQM_PKT_LOSS_EVENT,
+	NL80211_ATTR_CQM_TXE_RATE,
+	NL80211_ATTR_CQM_TXE_PKTS,
+	NL80211_ATTR_CQM_TXE_INTVL,
+	NL80211_ATTR_CQM_BEACON_LOSS_EVENT,
+
+	/* keep last */
+	__NL80211_ATTR_CQM_AFTER_LAST,
+	NL80211_ATTR_CQM_MAX = __NL80211_ATTR_CQM_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_cqm_rssi_threshold_event - RSSI threshold event
+ * @NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW: The RSSI level is lower than the
+ *      configured threshold
+ * @NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH: The RSSI is higher than the
+ *      configured threshold
+ * @NL80211_CQM_RSSI_BEACON_LOSS_EVENT: (reserved, never sent)
+ */
+enum nl80211_cqm_rssi_threshold_event {
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+	NL80211_CQM_RSSI_BEACON_LOSS_EVENT,
+};
+
+
+/**
+ * enum nl80211_tx_power_setting - TX power adjustment
+ * @NL80211_TX_POWER_AUTOMATIC: automatically determine transmit power
+ * @NL80211_TX_POWER_LIMITED: limit TX power by the mBm parameter
+ * @NL80211_TX_POWER_FIXED: fix TX power to the mBm parameter
+ */
+enum nl80211_tx_power_setting {
+	NL80211_TX_POWER_AUTOMATIC,
+	NL80211_TX_POWER_LIMITED,
+	NL80211_TX_POWER_FIXED,
+};
+
+/**
+ * enum nl80211_packet_pattern_attr - packet pattern attribute
+ * @__NL80211_PKTPAT_INVALID: invalid number for nested attribute
+ * @NL80211_PKTPAT_PATTERN: the pattern, values where the mask has
+ *	a zero bit are ignored
+ * @NL80211_PKTPAT_MASK: pattern mask, must be long enough to have
+ *	a bit for each byte in the pattern. The lowest-order bit corresponds
+ *	to the first byte of the pattern, but the bytes of the pattern are
+ *	in a little-endian-like format, i.e. the 9th byte of the pattern
+ *	corresponds to the lowest-order bit in the second byte of the mask.
+ *	For example: The match 00:xx:00:00:xx:00:00:00:00:xx:xx:xx (where
+ *	xx indicates "don't care") would be represented by a pattern of
+ *	twelve zero bytes, and a mask of "0xed,0x01".
+ *	Note that the pattern matching is done as though frames were not
+ *	802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
+ *	first (including SNAP header unpacking) and then matched.
+ * @NL80211_PKTPAT_OFFSET: packet offset, pattern is matched after
+ *	these fixed number of bytes of received packet
+ * @NUM_NL80211_PKTPAT: number of attributes
+ * @MAX_NL80211_PKTPAT: max attribute number
+ */
+enum nl80211_packet_pattern_attr {
+	__NL80211_PKTPAT_INVALID,
+	NL80211_PKTPAT_MASK,
+	NL80211_PKTPAT_PATTERN,
+	NL80211_PKTPAT_OFFSET,
+
+	NUM_NL80211_PKTPAT,
+	MAX_NL80211_PKTPAT = NUM_NL80211_PKTPAT - 1,
+};
+
+/**
+ * struct nl80211_pattern_support - packet pattern support information
+ * @max_patterns: maximum number of patterns supported
+ * @min_pattern_len: minimum length of each pattern
+ * @max_pattern_len: maximum length of each pattern
+ * @max_pkt_offset: maximum Rx packet offset
+ *
+ * This struct is carried in %NL80211_WOWLAN_TRIG_PKT_PATTERN when
+ * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED or in
+ * %NL80211_ATTR_COALESCE_RULE_PKT_PATTERN when that is part of
+ * %NL80211_ATTR_COALESCE_RULE in the capability information given
+ * by the kernel to userspace.
+ */
+struct nl80211_pattern_support {
+	__u32 max_patterns;
+	__u32 min_pattern_len;
+	__u32 max_pattern_len;
+	__u32 max_pkt_offset;
+} __attribute__((packed));
+
+/* only for backward compatibility */
+#define __NL80211_WOWLAN_PKTPAT_INVALID __NL80211_PKTPAT_INVALID
+#define NL80211_WOWLAN_PKTPAT_MASK NL80211_PKTPAT_MASK
+#define NL80211_WOWLAN_PKTPAT_PATTERN NL80211_PKTPAT_PATTERN
+#define NL80211_WOWLAN_PKTPAT_OFFSET NL80211_PKTPAT_OFFSET
+#define NUM_NL80211_WOWLAN_PKTPAT NUM_NL80211_PKTPAT
+#define MAX_NL80211_WOWLAN_PKTPAT MAX_NL80211_PKTPAT
+#define nl80211_wowlan_pattern_support nl80211_pattern_support
+
+/**
+ * enum nl80211_wowlan_triggers - WoWLAN trigger definitions
+ * @__NL80211_WOWLAN_TRIG_INVALID: invalid number for nested attributes
+ * @NL80211_WOWLAN_TRIG_ANY: wake up on any activity, do not really put
+ *	the chip into a special state -- works best with chips that have
+ *	support for low-power operation already (flag)
+ *	Note that this mode is incompatible with all of the others, if
+ *	any others are even supported by the device.
+ * @NL80211_WOWLAN_TRIG_DISCONNECT: wake up on disconnect, the way disconnect
+ *	is detected is implementation-specific (flag)
+ * @NL80211_WOWLAN_TRIG_MAGIC_PKT: wake up on magic packet (6x 0xff, followed
+ *	by 16 repetitions of MAC addr, anywhere in payload) (flag)
+ * @NL80211_WOWLAN_TRIG_PKT_PATTERN: wake up on the specified packet patterns
+ *	which are passed in an array of nested attributes, each nested attribute
+ *	defining a with attributes from &struct nl80211_wowlan_trig_pkt_pattern.
+ *	Each pattern defines a wakeup packet. Packet offset is associated with
+ *	each pattern which is used while matching the pattern. The matching is
+ *	done on the MSDU, i.e. as though the packet was an 802.3 packet, so the
+ *	pattern matching is done after the packet is converted to the MSDU.
+ *
+ *	In %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute
+ *	carrying a &struct nl80211_pattern_support.
+ *
+ *	When reporting wakeup. it is a u32 attribute containing the 0-based
+ *	index of the pattern that caused the wakeup, in the patterns passed
+ *	to the kernel when configuring.
+ * @NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: Not a real trigger, and cannot be
+ *	used when setting, used only to indicate that GTK rekeying is supported
+ *	by the device (flag)
+ * @NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE: wake up on GTK rekey failure (if
+ *	done by the device) (flag)
+ * @NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST: wake up on EAP Identity Request
+ *	packet (flag)
+ * @NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: wake up on 4-way handshake (flag)
+ * @NL80211_WOWLAN_TRIG_RFKILL_RELEASE: wake up when rfkill is released
+ *	(on devices that have rfkill in the device) (flag)
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211: For wakeup reporting only, contains
+ *	the 802.11 packet that caused the wakeup, e.g. a deauth frame. The frame
+ *	may be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN
+ *	attribute contains the original length.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN: Original length of the 802.11
+ *	packet, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211
+ *	attribute if the packet was truncated somewhere.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023: For wakeup reporting only, contains the
+ *	802.11 packet that caused the wakeup, e.g. a magic packet. The frame may
+ *	be truncated, the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN attribute
+ *	contains the original length.
+ * @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN: Original length of the 802.3
+ *	packet, may be bigger than the @NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023
+ *	attribute if the packet was truncated somewhere.
+ * @NL80211_WOWLAN_TRIG_TCP_CONNECTION: TCP connection wake, see DOC section
+ *	"TCP connection wakeup" for more details. This is a nested attribute
+ *	containing the exact information for establishing and keeping alive
+ *	the TCP connection.
+ * @NL80211_WOWLAN_TRIG_TCP_WAKEUP_MATCH: For wakeup reporting only, the
+ *	wakeup packet was received on the TCP connection
+ * @NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST: For wakeup reporting only, the
+ *	TCP connection was lost or failed to be established
+ * @NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS: For wakeup reporting only,
+ *	the TCP connection ran out of tokens to use for data to send to the
+ *	service
+ * @NL80211_WOWLAN_TRIG_NET_DETECT: wake up when a configured network
+ *	is detected.  This is a nested attribute that contains the
+ *	same attributes used with @NL80211_CMD_START_SCHED_SCAN.  It
+ *	specifies how the scan is performed (e.g. the interval, the
+ *	channels to scan and the initial delay) as well as the scan
+ *	results that will trigger a wake (i.e. the matchsets).  This
+ *	attribute is also sent in a response to
+ *	@NL80211_CMD_GET_WIPHY, indicating the number of match sets
+ *	supported by the driver (u32).
+ * @NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS: nested attribute
+ *	containing an array with information about what triggered the
+ *	wake up.  If no elements are present in the array, it means
+ *	that the information is not available.  If more than one
+ *	element is present, it means that more than one match
+ *	occurred.
+ *	Each element in the array is a nested attribute that contains
+ *	one optional %NL80211_ATTR_SSID attribute and one optional
+ *	%NL80211_ATTR_SCAN_FREQUENCIES attribute.  At least one of
+ *	these attributes must be present.  If
+ *	%NL80211_ATTR_SCAN_FREQUENCIES contains more than one
+ *	frequency, it means that the match occurred in more than one
+ *	channel.
+ * @NUM_NL80211_WOWLAN_TRIG: number of wake on wireless triggers
+ * @MAX_NL80211_WOWLAN_TRIG: highest wowlan trigger attribute number
+ *
+ * These nested attributes are used to configure the wakeup triggers and
+ * to report the wakeup reason(s).
+ */
+enum nl80211_wowlan_triggers {
+	__NL80211_WOWLAN_TRIG_INVALID,
+	NL80211_WOWLAN_TRIG_ANY,
+	NL80211_WOWLAN_TRIG_DISCONNECT,
+	NL80211_WOWLAN_TRIG_MAGIC_PKT,
+	NL80211_WOWLAN_TRIG_PKT_PATTERN,
+	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED,
+	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE,
+	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST,
+	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE,
+	NL80211_WOWLAN_TRIG_RFKILL_RELEASE,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023,
+	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN,
+	NL80211_WOWLAN_TRIG_TCP_CONNECTION,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST,
+	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS,
+	NL80211_WOWLAN_TRIG_NET_DETECT,
+	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_TRIG,
+	MAX_NL80211_WOWLAN_TRIG = NUM_NL80211_WOWLAN_TRIG - 1
+};
+
+/**
+ * DOC: TCP connection wakeup
+ *
+ * Some devices can establish a TCP connection in order to be woken up by a
+ * packet coming in from outside their network segment, or behind NAT. If
+ * configured, the device will establish a TCP connection to the given
+ * service, and periodically send data to that service. The first data
+ * packet is usually transmitted after SYN/ACK, also ACKing the SYN/ACK.
+ * The data packets can optionally include a (little endian) sequence
+ * number (in the TCP payload!) that is generated by the device, and, also
+ * optionally, a token from a list of tokens. This serves as a keep-alive
+ * with the service, and for NATed connections, etc.
+ *
+ * During this keep-alive period, the server doesn't send any data to the
+ * client. When receiving data, it is compared against the wakeup pattern
+ * (and mask) and if it matches, the host is woken up. Similarly, if the
+ * connection breaks or cannot be established to start with, the host is
+ * also woken up.
+ *
+ * Developer's note: ARP offload is required for this, otherwise TCP
+ * response packets might not go through correctly.
+ */
+
+/**
+ * struct nl80211_wowlan_tcp_data_seq - WoWLAN TCP data sequence
+ * @start: starting value
+ * @offset: offset of sequence number in packet
+ * @len: length of the sequence value to write, 1 through 4
+ *
+ * Note: don't confuse with the TCP sequence number(s), this is for the
+ * keepalive packet payload. The actual value is written into the packet
+ * in little endian.
+ */
+struct nl80211_wowlan_tcp_data_seq {
+	__u32 start, offset, len;
+};
+
+/**
+ * struct nl80211_wowlan_tcp_data_token - WoWLAN TCP data token config
+ * @offset: offset of token in packet
+ * @len: length of each token
+ * @token_stream: stream of data to be used for the tokens, the length must
+ *	be a multiple of @len for this to make sense
+ */
+struct nl80211_wowlan_tcp_data_token {
+	__u32 offset, len;
+	__u8 token_stream[];
+};
+
+/**
+ * struct nl80211_wowlan_tcp_data_token_feature - data token features
+ * @min_len: minimum token length
+ * @max_len: maximum token length
+ * @bufsize: total available token buffer size (max size of @token_stream)
+ */
+struct nl80211_wowlan_tcp_data_token_feature {
+	__u32 min_len, max_len, bufsize;
+};
+
+/**
+ * enum nl80211_wowlan_tcp_attrs - WoWLAN TCP connection parameters
+ * @__NL80211_WOWLAN_TCP_INVALID: invalid number for nested attributes
+ * @NL80211_WOWLAN_TCP_SRC_IPV4: source IPv4 address (in network byte order)
+ * @NL80211_WOWLAN_TCP_DST_IPV4: destination IPv4 address
+ *	(in network byte order)
+ * @NL80211_WOWLAN_TCP_DST_MAC: destination MAC address, this is given because
+ *	route lookup when configured might be invalid by the time we suspend,
+ *	and doing a route lookup when suspending is no longer possible as it
+ *	might require ARP querying.
+ * @NL80211_WOWLAN_TCP_SRC_PORT: source port (u16); optional, if not given a
+ *	socket and port will be allocated
+ * @NL80211_WOWLAN_TCP_DST_PORT: destination port (u16)
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD: data packet payload, at least one byte.
+ *	For feature advertising, a u32 attribute holding the maximum length
+ *	of the data payload.
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ: data packet sequence configuration
+ *	(if desired), a &struct nl80211_wowlan_tcp_data_seq. For feature
+ *	advertising it is just a flag
+ * @NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN: data packet token configuration,
+ *	see &struct nl80211_wowlan_tcp_data_token and for advertising see
+ *	&struct nl80211_wowlan_tcp_data_token_feature.
+ * @NL80211_WOWLAN_TCP_DATA_INTERVAL: data interval in seconds, maximum
+ *	interval in feature advertising (u32)
+ * @NL80211_WOWLAN_TCP_WAKE_PAYLOAD: wake packet payload, for advertising a
+ *	u32 attribute holding the maximum length
+ * @NL80211_WOWLAN_TCP_WAKE_MASK: Wake packet payload mask, not used for
+ *	feature advertising. The mask works like @NL80211_PKTPAT_MASK
+ *	but on the TCP payload only.
+ * @NUM_NL80211_WOWLAN_TCP: number of TCP attributes
+ * @MAX_NL80211_WOWLAN_TCP: highest attribute number
+ */
+enum nl80211_wowlan_tcp_attrs {
+	__NL80211_WOWLAN_TCP_INVALID,
+	NL80211_WOWLAN_TCP_SRC_IPV4,
+	NL80211_WOWLAN_TCP_DST_IPV4,
+	NL80211_WOWLAN_TCP_DST_MAC,
+	NL80211_WOWLAN_TCP_SRC_PORT,
+	NL80211_WOWLAN_TCP_DST_PORT,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,
+	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,
+	NL80211_WOWLAN_TCP_DATA_INTERVAL,
+	NL80211_WOWLAN_TCP_WAKE_PAYLOAD,
+	NL80211_WOWLAN_TCP_WAKE_MASK,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_TCP,
+	MAX_NL80211_WOWLAN_TCP = NUM_NL80211_WOWLAN_TCP - 1
+};
+
+/**
+ * struct nl80211_coalesce_rule_support - coalesce rule support information
+ * @max_rules: maximum number of rules supported
+ * @pat: packet pattern support information
+ * @max_delay: maximum supported coalescing delay in msecs
+ *
+ * This struct is carried in %NL80211_ATTR_COALESCE_RULE in the
+ * capability information given by the kernel to userspace.
+ */
+struct nl80211_coalesce_rule_support {
+	__u32 max_rules;
+	struct nl80211_pattern_support pat;
+	__u32 max_delay;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_attr_coalesce_rule - coalesce rule attribute
+ * @__NL80211_COALESCE_RULE_INVALID: invalid number for nested attribute
+ * @NL80211_ATTR_COALESCE_RULE_DELAY: delay in msecs used for packet coalescing
+ * @NL80211_ATTR_COALESCE_RULE_CONDITION: condition for packet coalescence,
+ *	see &enum nl80211_coalesce_condition.
+ * @NL80211_ATTR_COALESCE_RULE_PKT_PATTERN: packet offset, pattern is matched
+ *	after these fixed number of bytes of received packet
+ * @NUM_NL80211_ATTR_COALESCE_RULE: number of attributes
+ * @NL80211_ATTR_COALESCE_RULE_MAX: max attribute number
+ */
+enum nl80211_attr_coalesce_rule {
+	__NL80211_COALESCE_RULE_INVALID,
+	NL80211_ATTR_COALESCE_RULE_DELAY,
+	NL80211_ATTR_COALESCE_RULE_CONDITION,
+	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN,
+
+	/* keep last */
+	NUM_NL80211_ATTR_COALESCE_RULE,
+	NL80211_ATTR_COALESCE_RULE_MAX = NUM_NL80211_ATTR_COALESCE_RULE - 1
+};
+
+/**
+ * enum nl80211_coalesce_condition - coalesce rule conditions
+ * @NL80211_COALESCE_CONDITION_MATCH: coalaesce Rx packets when patterns
+ *	in a rule are matched.
+ * @NL80211_COALESCE_CONDITION_NO_MATCH: coalesce Rx packets when patterns
+ *	in a rule are not matched.
+ */
+enum nl80211_coalesce_condition {
+	NL80211_COALESCE_CONDITION_MATCH,
+	NL80211_COALESCE_CONDITION_NO_MATCH
+};
+
+/**
+ * enum nl80211_iface_limit_attrs - limit attributes
+ * @NL80211_IFACE_LIMIT_UNSPEC: (reserved)
+ * @NL80211_IFACE_LIMIT_MAX: maximum number of interfaces that
+ *	can be chosen from this set of interface types (u32)
+ * @NL80211_IFACE_LIMIT_TYPES: nested attribute containing a
+ *	flag attribute for each interface type in this set
+ * @NUM_NL80211_IFACE_LIMIT: number of attributes
+ * @MAX_NL80211_IFACE_LIMIT: highest attribute number
+ */
+enum nl80211_iface_limit_attrs {
+	NL80211_IFACE_LIMIT_UNSPEC,
+	NL80211_IFACE_LIMIT_MAX,
+	NL80211_IFACE_LIMIT_TYPES,
+
+	/* keep last */
+	NUM_NL80211_IFACE_LIMIT,
+	MAX_NL80211_IFACE_LIMIT = NUM_NL80211_IFACE_LIMIT - 1
+};
+
+/**
+ * enum nl80211_if_combination_attrs -- interface combination attributes
+ *
+ * @NL80211_IFACE_COMB_UNSPEC: (reserved)
+ * @NL80211_IFACE_COMB_LIMITS: Nested attributes containing the limits
+ *	for given interface types, see &enum nl80211_iface_limit_attrs.
+ * @NL80211_IFACE_COMB_MAXNUM: u32 attribute giving the total number of
+ *	interfaces that can be created in this group. This number doesn't
+ *	apply to interfaces purely managed in software, which are listed
+ *	in a separate attribute %NL80211_ATTR_INTERFACES_SOFTWARE.
+ * @NL80211_IFACE_COMB_STA_AP_BI_MATCH: flag attribute specifying that
+ *	beacon intervals within this group must be all the same even for
+ *	infrastructure and AP/GO combinations, i.e. the GO(s) must adopt
+ *	the infrastructure network's beacon interval.
+ * @NL80211_IFACE_COMB_NUM_CHANNELS: u32 attribute specifying how many
+ *	different channels may be used within this group.
+ * @NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS: u32 attribute containing the bitmap
+ *	of supported channel widths for radar detection.
+ * @NL80211_IFACE_COMB_RADAR_DETECT_REGIONS: u32 attribute containing the bitmap
+ *	of supported regulatory regions for radar detection.
+ * @NUM_NL80211_IFACE_COMB: number of attributes
+ * @MAX_NL80211_IFACE_COMB: highest attribute number
+ *
+ * Examples:
+ *	limits = [ #{STA} <= 1, #{AP} <= 1 ], matching BI, channels = 1, max = 2
+ *	=> allows an AP and a STA that must match BIs
+ *
+ *	numbers = [ #{AP, P2P-GO} <= 8 ], channels = 1, max = 8
+ *	=> allows 8 of AP/GO
+ *
+ *	numbers = [ #{STA} <= 2 ], channels = 2, max = 2
+ *	=> allows two STAs on different channels
+ *
+ *	numbers = [ #{STA} <= 1, #{P2P-client,P2P-GO} <= 3 ], max = 4
+ *	=> allows a STA plus three P2P interfaces
+ *
+ * The list of these four possiblities could completely be contained
+ * within the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute to indicate
+ * that any of these groups must match.
+ *
+ * "Combinations" of just a single interface will not be listed here,
+ * a single interface of any valid interface type is assumed to always
+ * be possible by itself. This means that implicitly, for each valid
+ * interface type, the following group always exists:
+ *	numbers = [ #{<type>} <= 1 ], channels = 1, max = 1
+ */
+enum nl80211_if_combination_attrs {
+	NL80211_IFACE_COMB_UNSPEC,
+	NL80211_IFACE_COMB_LIMITS,
+	NL80211_IFACE_COMB_MAXNUM,
+	NL80211_IFACE_COMB_STA_AP_BI_MATCH,
+	NL80211_IFACE_COMB_NUM_CHANNELS,
+	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
+	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
+
+	/* keep last */
+	NUM_NL80211_IFACE_COMB,
+	MAX_NL80211_IFACE_COMB = NUM_NL80211_IFACE_COMB - 1
+};
+
+
+/**
+ * enum nl80211_plink_state - state of a mesh peer link finite state machine
+ *
+ * @NL80211_PLINK_LISTEN: initial state, considered the implicit
+ *	state of non existant mesh peer links
+ * @NL80211_PLINK_OPN_SNT: mesh plink open frame has been sent to
+ *	this mesh peer
+ * @NL80211_PLINK_OPN_RCVD: mesh plink open frame has been received
+ *	from this mesh peer
+ * @NL80211_PLINK_CNF_RCVD: mesh plink confirm frame has been
+ *	received from this mesh peer
+ * @NL80211_PLINK_ESTAB: mesh peer link is established
+ * @NL80211_PLINK_HOLDING: mesh peer link is being closed or cancelled
+ * @NL80211_PLINK_BLOCKED: all frames transmitted from this mesh
+ *	plink are discarded
+ * @NUM_NL80211_PLINK_STATES: number of peer link states
+ * @MAX_NL80211_PLINK_STATES: highest numerical value of plink states
+ */
+enum nl80211_plink_state {
+	NL80211_PLINK_LISTEN,
+	NL80211_PLINK_OPN_SNT,
+	NL80211_PLINK_OPN_RCVD,
+	NL80211_PLINK_CNF_RCVD,
+	NL80211_PLINK_ESTAB,
+	NL80211_PLINK_HOLDING,
+	NL80211_PLINK_BLOCKED,
+
+	/* keep last */
+	NUM_NL80211_PLINK_STATES,
+	MAX_NL80211_PLINK_STATES = NUM_NL80211_PLINK_STATES - 1
+};
+
+/**
+ * enum nl80211_plink_action - actions to perform in mesh peers
+ *
+ * @NL80211_PLINK_ACTION_NO_ACTION: perform no action
+ * @NL80211_PLINK_ACTION_OPEN: start mesh peer link establishment
+ * @NL80211_PLINK_ACTION_BLOCK: block traffic from this mesh peer
+ * @NUM_NL80211_PLINK_ACTIONS: number of possible actions
+ */
+enum plink_actions {
+	NL80211_PLINK_ACTION_NO_ACTION,
+	NL80211_PLINK_ACTION_OPEN,
+	NL80211_PLINK_ACTION_BLOCK,
+
+	NUM_NL80211_PLINK_ACTIONS,
+};
+
+
+#define NL80211_KCK_LEN			16
+#define NL80211_KEK_LEN			16
+#define NL80211_REPLAY_CTR_LEN		8
+
+/**
+ * enum nl80211_rekey_data - attributes for GTK rekey offload
+ * @__NL80211_REKEY_DATA_INVALID: invalid number for nested attributes
+ * @NL80211_REKEY_DATA_KEK: key encryption key (binary)
+ * @NL80211_REKEY_DATA_KCK: key confirmation key (binary)
+ * @NL80211_REKEY_DATA_REPLAY_CTR: replay counter (binary)
+ * @NUM_NL80211_REKEY_DATA: number of rekey attributes (internal)
+ * @MAX_NL80211_REKEY_DATA: highest rekey attribute (internal)
+ */
+enum nl80211_rekey_data {
+	__NL80211_REKEY_DATA_INVALID,
+	NL80211_REKEY_DATA_KEK,
+	NL80211_REKEY_DATA_KCK,
+	NL80211_REKEY_DATA_REPLAY_CTR,
+
+	/* keep last */
+	NUM_NL80211_REKEY_DATA,
+	MAX_NL80211_REKEY_DATA = NUM_NL80211_REKEY_DATA - 1
+};
+
+/**
+ * enum nl80211_hidden_ssid - values for %NL80211_ATTR_HIDDEN_SSID
+ * @NL80211_HIDDEN_SSID_NOT_IN_USE: do not hide SSID (i.e., broadcast it in
+ *	Beacon frames)
+ * @NL80211_HIDDEN_SSID_ZERO_LEN: hide SSID by using zero-length SSID element
+ *	in Beacon frames
+ * @NL80211_HIDDEN_SSID_ZERO_CONTENTS: hide SSID by using correct length of SSID
+ *	element in Beacon frames but zero out each byte in the SSID
+ */
+enum nl80211_hidden_ssid {
+	NL80211_HIDDEN_SSID_NOT_IN_USE,
+	NL80211_HIDDEN_SSID_ZERO_LEN,
+	NL80211_HIDDEN_SSID_ZERO_CONTENTS
+};
+
+/**
+ * enum nl80211_sta_wme_attr - station WME attributes
+ * @__NL80211_STA_WME_INVALID: invalid number for nested attribute
+ * @NL80211_STA_WME_UAPSD_QUEUES: bitmap of uapsd queues. the format
+ *	is the same as the AC bitmap in the QoS info field.
+ * @NL80211_STA_WME_MAX_SP: max service period. the format is the same
+ *	as the MAX_SP field in the QoS info field (but already shifted down).
+ * @__NL80211_STA_WME_AFTER_LAST: internal
+ * @NL80211_STA_WME_MAX: highest station WME attribute
+ */
+enum nl80211_sta_wme_attr {
+	__NL80211_STA_WME_INVALID,
+	NL80211_STA_WME_UAPSD_QUEUES,
+	NL80211_STA_WME_MAX_SP,
+
+	/* keep last */
+	__NL80211_STA_WME_AFTER_LAST,
+	NL80211_STA_WME_MAX = __NL80211_STA_WME_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_pmksa_candidate_attr - attributes for PMKSA caching candidates
+ * @__NL80211_PMKSA_CANDIDATE_INVALID: invalid number for nested attributes
+ * @NL80211_PMKSA_CANDIDATE_INDEX: candidate index (u32; the smaller, the higher
+ *	priority)
+ * @NL80211_PMKSA_CANDIDATE_BSSID: candidate BSSID (6 octets)
+ * @NL80211_PMKSA_CANDIDATE_PREAUTH: RSN pre-authentication supported (flag)
+ * @NUM_NL80211_PMKSA_CANDIDATE: number of PMKSA caching candidate attributes
+ *	(internal)
+ * @MAX_NL80211_PMKSA_CANDIDATE: highest PMKSA caching candidate attribute
+ *	(internal)
+ */
+enum nl80211_pmksa_candidate_attr {
+	__NL80211_PMKSA_CANDIDATE_INVALID,
+	NL80211_PMKSA_CANDIDATE_INDEX,
+	NL80211_PMKSA_CANDIDATE_BSSID,
+	NL80211_PMKSA_CANDIDATE_PREAUTH,
+
+	/* keep last */
+	NUM_NL80211_PMKSA_CANDIDATE,
+	MAX_NL80211_PMKSA_CANDIDATE = NUM_NL80211_PMKSA_CANDIDATE - 1
+};
+
+/**
+ * enum nl80211_tdls_operation - values for %NL80211_ATTR_TDLS_OPERATION
+ * @NL80211_TDLS_DISCOVERY_REQ: Send a TDLS discovery request
+ * @NL80211_TDLS_SETUP: Setup TDLS link
+ * @NL80211_TDLS_TEARDOWN: Teardown a TDLS link which is already established
+ * @NL80211_TDLS_ENABLE_LINK: Enable TDLS link
+ * @NL80211_TDLS_DISABLE_LINK: Disable TDLS link
+ */
+enum nl80211_tdls_operation {
+	NL80211_TDLS_DISCOVERY_REQ,
+	NL80211_TDLS_SETUP,
+	NL80211_TDLS_TEARDOWN,
+	NL80211_TDLS_ENABLE_LINK,
+	NL80211_TDLS_DISABLE_LINK,
+};
+
+/*
+ * enum nl80211_ap_sme_features - device-integrated AP features
+ * Reserved for future use, no bits are defined in
+ * NL80211_ATTR_DEVICE_AP_SME yet.
+enum nl80211_ap_sme_features {
+};
+ */
+
+/**
+ * enum nl80211_feature_flags - device/driver features
+ * @NL80211_FEATURE_SK_TX_STATUS: This driver supports reflecting back
+ *	TX status to the socket error queue when requested with the
+ *	socket option.
+ * @NL80211_FEATURE_HT_IBSS: This driver supports IBSS with HT datarates.
+ * @NL80211_FEATURE_INACTIVITY_TIMER: This driver takes care of freeing up
+ *	the connected inactive stations in AP mode.
+ * @NL80211_FEATURE_CELL_BASE_REG_HINTS: This driver has been tested
+ *	to work properly to suppport receiving regulatory hints from
+ *	cellular base stations.
+ * @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: (no longer available, only
+ *	here to reserve the value for API/ABI compatibility)
+ * @NL80211_FEATURE_SAE: This driver supports simultaneous authentication of
+ *	equals (SAE) with user space SME (NL80211_CMD_AUTHENTICATE) in station
+ *	mode
+ * @NL80211_FEATURE_LOW_PRIORITY_SCAN: This driver supports low priority scan
+ * @NL80211_FEATURE_SCAN_FLUSH: Scan flush is supported
+ * @NL80211_FEATURE_AP_SCAN: Support scanning using an AP vif
+ * @NL80211_FEATURE_VIF_TXPOWER: The driver supports per-vif TX power setting
+ * @NL80211_FEATURE_NEED_OBSS_SCAN: The driver expects userspace to perform
+ *	OBSS scans and generate 20/40 BSS coex reports. This flag is used only
+ *	for drivers implementing the CONNECT API, for AUTH/ASSOC it is implied.
+ * @NL80211_FEATURE_P2P_GO_CTWIN: P2P GO implementation supports CT Window
+ *	setting
+ * @NL80211_FEATURE_P2P_GO_OPPPS: P2P GO implementation supports opportunistic
+ *	powersave
+ * @NL80211_FEATURE_FULL_AP_CLIENT_STATE: The driver supports full state
+ *	transitions for AP clients. Without this flag (and if the driver
+ *	doesn't have the AP SME in the device) the driver supports adding
+ *	stations only when they're associated and adds them in associated
+ *	state (to later be transitioned into authorized), with this flag
+ *	they should be added before even sending the authentication reply
+ *	and then transitioned into authenticated, associated and authorized
+ *	states using station flags.
+ *	Note that even for drivers that support this, the default is to add
+ *	stations in authenticated/associated state, so to add unauthenticated
+ *	stations the authenticated/associated bits have to be set in the mask.
+ * @NL80211_FEATURE_ADVERTISE_CHAN_LIMITS: cfg80211 advertises channel limits
+ *	(HT40, VHT 80/160 MHz) if this flag is set
+ * @NL80211_FEATURE_USERSPACE_MPM: This driver supports a userspace Mesh
+ *	Peering Management entity which may be implemented by registering for
+ *	beacons or NL80211_CMD_NEW_PEER_CANDIDATE events. The mesh beacon is
+ *	still generated by the driver.
+ * @NL80211_FEATURE_ACTIVE_MONITOR: This driver supports an active monitor
+ *	interface. An active monitor interface behaves like a normal monitor
+ *	interface, but gets added to the driver. It ensures that incoming
+ *	unicast packets directed at the configured interface address get ACKed.
+ * @NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE: This driver supports dynamic
+ *	channel bandwidth change (e.g., HT 20 <-> 40 MHz channel) during the
+ *	lifetime of a BSS.
+ * @NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES: This device adds a DS Parameter
+ *	Set IE to probe requests.
+ * @NL80211_FEATURE_WFA_TPC_IE_IN_PROBES: This device adds a WFA TPC Report IE
+ *	to probe requests.
+ * @NL80211_FEATURE_QUIET: This device, in client mode, supports Quiet Period
+ *	requests sent to it by an AP.
+ * @NL80211_FEATURE_TX_POWER_INSERTION: This device is capable of inserting the
+ *	current tx power value into the TPC Report IE in the spectrum
+ *	management TPC Report action frame, and in the Radio Measurement Link
+ *	Measurement Report action frame.
+ * @NL80211_FEATURE_ACKTO_ESTIMATION: This driver supports dynamic ACK timeout
+ *	estimation (dynack). %NL80211_ATTR_WIPHY_DYN_ACK flag attribute is used
+ *	to enable dynack.
+ * @NL80211_FEATURE_STATIC_SMPS: Device supports static spatial
+ *	multiplexing powersave, ie. can turn off all but one chain
+ *	even on HT connections that should be using more chains.
+ * @NL80211_FEATURE_DYNAMIC_SMPS: Device supports dynamic spatial
+ *	multiplexing powersave, ie. can turn off all but one chain
+ *	and then wake the rest up as required after, for example,
+ *	rts/cts handshake.
+ * @NL80211_FEATURE_SUPPORTS_WMM_ADMISSION: the device supports setting up WMM
+ *	TSPEC sessions (TID aka TSID 0-7) with the %NL80211_CMD_ADD_TX_TS
+ *	command. Standard IEEE 802.11 TSPEC setup is not yet supported, it
+ *	needs to be able to handle Block-Ack agreements and other things.
+ * @NL80211_FEATURE_MAC_ON_CREATE: Device supports configuring
+ *	the vif's MAC address upon creation.
+ *	See 'macaddr' field in the vif_params (cfg80211.h).
+ * @NL80211_FEATURE_TDLS_CHANNEL_SWITCH: Driver supports channel switching when
+ *	operating as a TDLS peer.
+ * @NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR: This device/driver supports using a
+ *	random MAC address during scan (if the device is unassociated); the
+ *	%NL80211_SCAN_FLAG_RANDOM_ADDR flag may be set for scans and the MAC
+ *	address mask/value will be used.
+ * @NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR: This device/driver supports
+ *	using a random MAC address for every scan iteration during scheduled
+ *	scan (while not associated), the %NL80211_SCAN_FLAG_RANDOM_ADDR may
+ *	be set for scheduled scan and the MAC address mask/value will be used.
+ * @NL80211_FEATURE_ND_RANDOM_MAC_ADDR: This device/driver supports using a
+ *	random MAC address for every scan iteration during "net detect", i.e.
+ *	scan in unassociated WoWLAN, the %NL80211_SCAN_FLAG_RANDOM_ADDR may
+ *	be set for scheduled scan and the MAC address mask/value will be used.
+ */
+enum nl80211_feature_flags {
+	NL80211_FEATURE_SK_TX_STATUS			= 1 << 0,
+	NL80211_FEATURE_HT_IBSS				= 1 << 1,
+	NL80211_FEATURE_INACTIVITY_TIMER		= 1 << 2,
+	NL80211_FEATURE_CELL_BASE_REG_HINTS		= 1 << 3,
+	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL	= 1 << 4,
+	NL80211_FEATURE_SAE				= 1 << 5,
+	NL80211_FEATURE_LOW_PRIORITY_SCAN		= 1 << 6,
+	NL80211_FEATURE_SCAN_FLUSH			= 1 << 7,
+	NL80211_FEATURE_AP_SCAN				= 1 << 8,
+	NL80211_FEATURE_VIF_TXPOWER			= 1 << 9,
+	NL80211_FEATURE_NEED_OBSS_SCAN			= 1 << 10,
+	NL80211_FEATURE_P2P_GO_CTWIN			= 1 << 11,
+	NL80211_FEATURE_P2P_GO_OPPPS			= 1 << 12,
+	/* bit 13 is reserved */
+	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS		= 1 << 14,
+	NL80211_FEATURE_FULL_AP_CLIENT_STATE		= 1 << 15,
+	NL80211_FEATURE_USERSPACE_MPM			= 1 << 16,
+	NL80211_FEATURE_ACTIVE_MONITOR			= 1 << 17,
+	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE	= 1 << 18,
+	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES	= 1 << 19,
+	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES		= 1 << 20,
+	NL80211_FEATURE_QUIET				= 1 << 21,
+	NL80211_FEATURE_TX_POWER_INSERTION		= 1 << 22,
+	NL80211_FEATURE_ACKTO_ESTIMATION		= 1 << 23,
+	NL80211_FEATURE_STATIC_SMPS			= 1 << 24,
+	NL80211_FEATURE_DYNAMIC_SMPS			= 1 << 25,
+	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION		= 1 << 26,
+	NL80211_FEATURE_MAC_ON_CREATE			= 1 << 27,
+	NL80211_FEATURE_TDLS_CHANNEL_SWITCH		= 1 << 28,
+	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR		= 1 << 29,
+	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR	= 1 << 30,
+	NL80211_FEATURE_ND_RANDOM_MAC_ADDR		= 1 << 31,
+};
+
+/**
+ * enum nl80211_ext_feature_index - bit index of extended features.
+ * @NL80211_EXT_FEATURE_VHT_IBSS: This driver supports IBSS with VHT datarates.
+ *
+ * @NUM_NL80211_EXT_FEATURES: number of extended features.
+ * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
+ */
+enum nl80211_ext_feature_index {
+	NL80211_EXT_FEATURE_VHT_IBSS,
+
+	/* add new features before the definition below */
+	NUM_NL80211_EXT_FEATURES,
+	MAX_NL80211_EXT_FEATURES = NUM_NL80211_EXT_FEATURES - 1
+};
+
+/**
+ * enum nl80211_probe_resp_offload_support_attr - optional supported
+ *	protocols for probe-response offloading by the driver/FW.
+ *	To be used with the %NL80211_ATTR_PROBE_RESP_OFFLOAD attribute.
+ *	Each enum value represents a bit in the bitmap of supported
+ *	protocols. Typically a subset of probe-requests belonging to a
+ *	supported protocol will be excluded from offload and uploaded
+ *	to the host.
+ *
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS: Support for WPS ver. 1
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2: Support for WPS ver. 2
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P: Support for P2P
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U: Support for 802.11u
+ */
+enum nl80211_probe_resp_offload_support_attr {
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS =	1<<0,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 =	1<<1,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P =	1<<2,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U =	1<<3,
+};
+
+/**
+ * enum nl80211_connect_failed_reason - connection request failed reasons
+ * @NL80211_CONN_FAIL_MAX_CLIENTS: Maximum number of clients that can be
+ *	handled by the AP is reached.
+ * @NL80211_CONN_FAIL_BLOCKED_CLIENT: Connection request is rejected due to ACL.
+ */
+enum nl80211_connect_failed_reason {
+	NL80211_CONN_FAIL_MAX_CLIENTS,
+	NL80211_CONN_FAIL_BLOCKED_CLIENT,
+};
+
+/**
+ * enum nl80211_scan_flags -  scan request control flags
+ *
+ * Scan request control flags are used to control the handling
+ * of NL80211_CMD_TRIGGER_SCAN and NL80211_CMD_START_SCHED_SCAN
+ * requests.
+ *
+ * @NL80211_SCAN_FLAG_LOW_PRIORITY: scan request has low priority
+ * @NL80211_SCAN_FLAG_FLUSH: flush cache before scanning
+ * @NL80211_SCAN_FLAG_AP: force a scan even if the interface is configured
+ *	as AP and the beaconing has already been configured. This attribute is
+ *	dangerous because will destroy stations performance as a lot of frames
+ *	will be lost while scanning off-channel, therefore it must be used only
+ *	when really needed
+ * @NL80211_SCAN_FLAG_RANDOM_ADDR: use a random MAC address for this scan (or
+ *	for scheduled scan: a different one for every scan iteration). When the
+ *	flag is set, depending on device capabilities the @NL80211_ATTR_MAC and
+ *	@NL80211_ATTR_MAC_MASK attributes may also be given in which case only
+ *	the masked bits will be preserved from the MAC address and the remainder
+ *	randomised. If the attributes are not given full randomisation (46 bits,
+ *	locally administered 1, multicast 0) is assumed.
+ *	This flag must not be requested when the feature isn't supported, check
+ *	the nl80211 feature flags for the device.
+ */
+enum nl80211_scan_flags {
+	NL80211_SCAN_FLAG_LOW_PRIORITY			= 1<<0,
+	NL80211_SCAN_FLAG_FLUSH				= 1<<1,
+	NL80211_SCAN_FLAG_AP				= 1<<2,
+	NL80211_SCAN_FLAG_RANDOM_ADDR			= 1<<3,
+};
+
+/**
+ * enum nl80211_acl_policy - access control policy
+ *
+ * Access control policy is applied on a MAC list set by
+ * %NL80211_CMD_START_AP and %NL80211_CMD_SET_MAC_ACL, to
+ * be used with %NL80211_ATTR_ACL_POLICY.
+ *
+ * @NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: Deny stations which are
+ *	listed in ACL, i.e. allow all the stations which are not listed
+ *	in ACL to authenticate.
+ * @NL80211_ACL_POLICY_DENY_UNLESS_LISTED: Allow the stations which are listed
+ *	in ACL, i.e. deny all the stations which are not listed in ACL.
+ */
+enum nl80211_acl_policy {
+	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED,
+	NL80211_ACL_POLICY_DENY_UNLESS_LISTED,
+};
+
+/**
+ * enum nl80211_smps_mode - SMPS mode
+ *
+ * Requested SMPS mode (for AP mode)
+ *
+ * @NL80211_SMPS_OFF: SMPS off (use all antennas).
+ * @NL80211_SMPS_STATIC: static SMPS (use a single antenna)
+ * @NL80211_SMPS_DYNAMIC: dynamic smps (start with a single antenna and
+ *	turn on other antennas after CTS/RTS).
+ */
+enum nl80211_smps_mode {
+	NL80211_SMPS_OFF,
+	NL80211_SMPS_STATIC,
+	NL80211_SMPS_DYNAMIC,
+
+	__NL80211_SMPS_AFTER_LAST,
+	NL80211_SMPS_MAX = __NL80211_SMPS_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_radar_event - type of radar event for DFS operation
+ *
+ * Type of event to be used with NL80211_ATTR_RADAR_EVENT to inform userspace
+ * about detected radars or success of the channel available check (CAC)
+ *
+ * @NL80211_RADAR_DETECTED: A radar pattern has been detected. The channel is
+ *	now unusable.
+ * @NL80211_RADAR_CAC_FINISHED: Channel Availability Check has been finished,
+ *	the channel is now available.
+ * @NL80211_RADAR_CAC_ABORTED: Channel Availability Check has been aborted, no
+ *	change to the channel status.
+ * @NL80211_RADAR_NOP_FINISHED: The Non-Occupancy Period for this channel is
+ *	over, channel becomes usable.
+ */
+enum nl80211_radar_event {
+	NL80211_RADAR_DETECTED,
+	NL80211_RADAR_CAC_FINISHED,
+	NL80211_RADAR_CAC_ABORTED,
+	NL80211_RADAR_NOP_FINISHED,
+};
+
+/**
+ * enum nl80211_dfs_state - DFS states for channels
+ *
+ * Channel states used by the DFS code.
+ *
+ * @NL80211_DFS_USABLE: The channel can be used, but channel availability
+ *	check (CAC) must be performed before using it for AP or IBSS.
+ * @NL80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it
+ *	is therefore marked as not available.
+ * @NL80211_DFS_AVAILABLE: The channel has been CAC checked and is available.
+ */
+enum nl80211_dfs_state {
+	NL80211_DFS_USABLE,
+	NL80211_DFS_UNAVAILABLE,
+	NL80211_DFS_AVAILABLE,
+};
+
+/**
+ * enum enum nl80211_protocol_features - nl80211 protocol features
+ * @NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP: nl80211 supports splitting
+ *	wiphy dumps (if requested by the application with the attribute
+ *	%NL80211_ATTR_SPLIT_WIPHY_DUMP. Also supported is filtering the
+ *	wiphy dump by %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFINDEX or
+ *	%NL80211_ATTR_WDEV.
+ */
+enum nl80211_protocol_features {
+	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP =	1 << 0,
+};
+
+/**
+ * enum nl80211_crit_proto_id - nl80211 critical protocol identifiers
+ *
+ * @NL80211_CRIT_PROTO_UNSPEC: protocol unspecified.
+ * @NL80211_CRIT_PROTO_DHCP: BOOTP or DHCPv6 protocol.
+ * @NL80211_CRIT_PROTO_EAPOL: EAPOL protocol.
+ * @NL80211_CRIT_PROTO_APIPA: APIPA protocol.
+ * @NUM_NL80211_CRIT_PROTO: must be kept last.
+ */
+enum nl80211_crit_proto_id {
+	NL80211_CRIT_PROTO_UNSPEC,
+	NL80211_CRIT_PROTO_DHCP,
+	NL80211_CRIT_PROTO_EAPOL,
+	NL80211_CRIT_PROTO_APIPA,
+	/* add other protocols before this one */
+	NUM_NL80211_CRIT_PROTO
+};
+
+/* maximum duration for critical protocol measures */
+#define NL80211_CRIT_PROTO_MAX_DURATION		5000 /* msec */
+
+/**
+ * enum nl80211_rxmgmt_flags - flags for received management frame.
+ *
+ * Used by cfg80211_rx_mgmt()
+ *
+ * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
+ */
+enum nl80211_rxmgmt_flags {
+	NL80211_RXMGMT_FLAG_ANSWERED = 1 << 0,
+};
+
+/*
+ * If this flag is unset, the lower 24 bits are an OUI, if set
+ * a Linux nl80211 vendor ID is used (no such IDs are allocated
+ * yet, so that's not valid so far)
+ */
+#define NL80211_VENDOR_ID_IS_LINUX	0x80000000
+
+/**
+ * struct nl80211_vendor_cmd_info - vendor command data
+ * @vendor_id: If the %NL80211_VENDOR_ID_IS_LINUX flag is clear, then the
+ *	value is a 24-bit OUI; if it is set then a separately allocated ID
+ *	may be used, but no such IDs are allocated yet. New IDs should be
+ *	added to this file when needed.
+ * @subcmd: sub-command ID for the command
+ */
+struct nl80211_vendor_cmd_info {
+	__u32 vendor_id;
+	__u32 subcmd;
+};
+
+/**
+ * enum nl80211_tdls_peer_capability - TDLS peer flags.
+ *
+ * Used by tdls_mgmt() to determine which conditional elements need
+ * to be added to TDLS Setup frames.
+ *
+ * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
+ * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
+ * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
+ */
+enum nl80211_tdls_peer_capability {
+	NL80211_TDLS_PEER_HT = 1<<0,
+	NL80211_TDLS_PEER_VHT = 1<<1,
+	NL80211_TDLS_PEER_WMM = 1<<2,
+};
+
+#endif /* __LINUX_NL80211_H */
diff --git a/88x9098/wlan/hal/wifi_hal/pkt_stats.h b/88x9098/wlan/hal/wifi_hal/pkt_stats.h
new file mode 100644
index 0000000..af75c73
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/pkt_stats.h
@@ -0,0 +1,57 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+* Portion copyright 2017-2020 NXP
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "wifi_hal.h"
+#include "common.h"
+
+#ifndef _PKT_STATS_H_
+#define _PKT_STATS_H_
+
+typedef struct {
+    frame_type payload_type;
+    u32 driver_timestamp_usec;
+    u32 firmware_timestamp_usec;
+    u32 frame_len;
+    char *frame_content;
+} frame_info_i;
+
+typedef struct {
+    // Prefix of MD5 hash of |frame_inf.frame_content|. If frame
+    // content is not provided, prefix of MD5 hash over the same data
+    // that would be in frame_content, if frame content were provided.
+    char md5_prefix[MD5_PREFIX_LEN];  // Prefix of MD5 hash of packet bytes
+    wifi_tx_packet_fate fate;
+    frame_info_i frame_inf;
+} wifi_tx_report_i;
+
+typedef struct {
+    // Prefix of MD5 hash of |frame_inf.frame_content|. If frame
+    // content is not provided, prefix of MD5 hash over the same data
+    // that would be in frame_content, if frame content were provided.
+    char md5_prefix[MD5_PREFIX_LEN];
+    wifi_rx_packet_fate fate;
+    frame_info_i frame_inf;
+} wifi_rx_report_i;
+
+typedef struct {
+    wifi_tx_report_i tx_fate_stats[MAX_FATE_LOG_LEN];
+    size_t n_tx_stats_collected;
+    wifi_rx_report_i rx_fate_stats[MAX_FATE_LOG_LEN];
+    size_t n_rx_stats_collected;
+} packet_fate_monitor_info;
+
+#endif
diff --git a/88x9098/wlan/hal/wifi_hal/roam.cpp b/88x9098/wlan/hal/wifi_hal/roam.cpp
new file mode 100644
index 0000000..83bed35
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/roam.cpp
@@ -0,0 +1,220 @@
+/*
+* Copyright 2017-2020 NXP
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+//#include <netlink/handlers.h>
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+#include <utils/String8.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+
+using namespace android;
+
+typedef enum {
+    NXP_ATTR_ROAMING_INVALID = 0,
+    NXP_ATTR_ROAMING_CAPA,
+    NXP_ATTR_FW_ROAMING_CONTROL,
+    NXP_ATTR_ROAMING_CONFIG_BSSID,
+    NXP_ATTR_ROAMING_CONFIG_SSID,
+
+    /* keep last */
+    NXP_ATTR_ROAMING_AFTER_LAST,
+    NXP_ATTR_ROAMING_MAX =
+    NXP_ATTR_ROAMING_AFTER_LAST - 1
+
+} ROAMING_ATTRIBUTE;
+
+/* BSSID blacklist */
+typedef struct {
+    int num_bssid;                           // number of blacklisted BSSIDs
+    mac_addr bssids[MAX_BLACKLIST_BSSID];    // blacklisted BSSIDs
+} wifi_bssid_params;
+
+typedef struct {
+    u32 num_ssid;
+    ssid_t *ssids;
+} wifi_ssid_params;
+
+class GetRoamingCapa : public WifiCommand
+{
+private:
+    wifi_roaming_capabilities *Capa;
+
+public:
+    GetRoamingCapa(wifi_interface_handle handle, wifi_roaming_capabilities *caps)
+    : WifiCommand("GetRoamingCapa", handle, 0)
+    {
+        Capa = caps;
+        memset(Capa, 0, sizeof(wifi_roaming_capabilities));
+    }
+
+    virtual int create(){
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_GET_ROAMING_CAPA);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get roaming capabilities\n");
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply){
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+        return NL_SKIP;
+        }
+
+        nlattr *vendor_data = (nlattr *)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in command response");
+            return NL_SKIP;
+        }
+
+        struct nlattr *tb_vendor[NXP_ATTR_ROAMING_MAX];
+        nla_parse(tb_vendor, NXP_ATTR_ROAMING_MAX - 1, vendor_data, len, NULL);
+        if(!tb_vendor[NXP_ATTR_ROAMING_CAPA]){
+            ALOGE("NXP_ATTR_ROAMING_CAPA not found\n");
+            return NL_SKIP;
+        }
+        memcpy(Capa, (wifi_roaming_capabilities *)nla_data(tb_vendor[NXP_ATTR_ROAMING_CAPA]), 
+               sizeof(wifi_roaming_capabilities));
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_get_roaming_capabilities(wifi_interface_handle handle, 
+                                                wifi_roaming_capabilities *caps)
+{
+    int ret = 0;
+    GetRoamingCapa Capa(handle, caps);
+    ret = Capa.requestResponse();
+    return (wifi_error) ret;
+}
+
+class EnableFirmwareRoaming : public WifiCommand
+{
+private:
+    fw_roaming_state_t roamingState;
+
+public:
+    EnableFirmwareRoaming(wifi_interface_handle handle, fw_roaming_state_t state)
+    : WifiCommand("EnableFirmwareRoaming", handle, 0)
+    {
+        roamingState = state;
+    }
+
+    virtual int create(){
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_ENABLE_FW_ROAMING);
+        if (ret < 0) {
+            ALOGE("Failed to create message to enable firmware roaming\n");
+            return ret;
+        }
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_FW_ROAMING_CONTROL, roamingState);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_enable_firmware_roaming(wifi_interface_handle handle, 
+                                                 fw_roaming_state_t state)
+{
+    int ret = 0;
+    EnableFirmwareRoaming Roaming(handle, state);
+    ret = Roaming.requestResponse();
+    return (wifi_error) ret;
+}
+
+class ConfigureRoaming : public WifiCommand
+{
+private:
+    wifi_roaming_config *roamingConfig;
+    wifi_bssid_params Bssid;
+    wifi_ssid_params Ssid;
+
+public:
+    ConfigureRoaming(wifi_interface_handle handle, wifi_roaming_config *roaming_config)
+    : WifiCommand("ConfigureRoaming", handle, 0)
+    {
+        roamingConfig = roaming_config;
+        Bssid.num_bssid = roamingConfig->num_blacklist_bssid;
+        memcpy(Bssid.bssids, roamingConfig->blacklist_bssid, (Bssid.num_bssid * sizeof(mac_addr)));
+        Ssid.num_ssid = roamingConfig->num_whitelist_ssid;
+        Ssid.ssids = roamingConfig->whitelist_ssid;
+   }
+
+    virtual int create(){
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_ROAMING_CONFIG);
+        if (ret < 0) {
+            ALOGE("Failed to create message to configure roaming\n");
+            return ret;
+        }
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_ROAMING_CONFIG_BSSID,(void *)(&Bssid), sizeof(wifi_bssid_params));
+        if (ret < 0)
+            return ret;
+        ret = mMsg.put(NXP_ATTR_ROAMING_CONFIG_SSID, (void *)(&Ssid), sizeof(wifi_ssid_params));
+        if(ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply){
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+};
+
+wifi_error wifi_configure_roaming(wifi_interface_handle handle, 
+                                        wifi_roaming_config *roaming_config)
+{
+    int ret = 0;
+    ConfigureRoaming Config(handle, roaming_config );
+    ret = Config.requestResponse();
+    return (wifi_error) ret;
+}
+
diff --git a/88x9098/wlan/hal/wifi_hal/rtt.cpp b/88x9098/wlan/hal/wifi_hal/rtt.cpp
new file mode 100644
index 0000000..3b12434
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/rtt.cpp
@@ -0,0 +1,692 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include "nl80211_copy.h"
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+#include <utils/String8.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+
+using namespace android;
+#define RTT_RESULT_SIZE (sizeof(wifi_rtt_result))
+
+typedef enum {
+    NXP_ATTR_RTT_INVALID = 0,
+    NXP_ATTR_RTT_CAPA,
+    NXP_ATTR_RTT_NUM_CONFIG,
+    NXP_ATTR_RTT_CONFIG,
+    NXP_ATTR_RTT_DEVICE_ADDR,
+    NXP_ATTR_RTT_RESULT_COMPLETE,
+    NXP_ATTR_RTT_RESULT_NUM,
+    NXP_ATTR_RTT_RESULT_FULL,
+    NXP_ATTR_RTT_CHANNEL_INFO,
+    NXP_ATTR_RTT_MAX_DUR_SEC,
+    NXP_ATTR_RTT_PREAMBLE,
+    NXP_ATTR_RTT_LCI_INFO,
+    NXP_ATTR_RTT_LCR_INFO,
+
+    /* keep last */
+    NXP_ATTR_RTT_AFTER_LAST,
+    NXP_ATTR_RTT_MAX =
+    NXP_ATTR_RTT_AFTER_LAST
+} RTT_ATTRIBUTE;
+
+typedef enum {
+    RTT_SET_LCI,
+    RTT_SET_LCR,
+} ConfigureType;
+
+#define DOT11_MEASURE_TYPE_LCI          8   /* d11 measurement LCI type */
+#define DOT11_MEASURE_TYPE_CIVICLOC     11  /* d11 measurement location civic */
+
+class GetRttCapa :public WifiCommand
+{
+private:
+    wifi_rtt_capabilities *Capa;
+
+public:
+    GetRttCapa(wifi_interface_handle iface, wifi_rtt_capabilities *capabilities)
+        : WifiCommand("GetRttCapa", iface, 0)
+    {
+        Capa = capabilities;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_RTT_GET_CAPA);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get RTT capabilities - %d", ret);
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d\n", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        nlattr *tb = (nlattr*)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if(tb == NULL || len == 0){
+            ALOGE("ERROR! No data in command response\n");
+            return NL_SKIP;
+        }
+        
+        struct nlattr *tb_vendor[NXP_ATTR_RTT_MAX];
+        nla_parse(tb_vendor, (NXP_ATTR_RTT_MAX - 1) ,tb, len, NULL);
+        if (!tb_vendor[NXP_ATTR_RTT_CAPA]){
+            ALOGE("NXP_ATTR_RTT_CAPA not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        memcpy(Capa, (wifi_rtt_capabilities *)nla_data(tb_vendor[NXP_ATTR_RTT_CAPA]),
+                sizeof(wifi_rtt_capabilities));
+        return NL_OK;
+    }
+};
+
+
+class RttRangeControl : public WifiCommand
+{
+private:
+    unsigned numConfig;
+    int mCompleted;
+    int Index;
+    int totalCnt;
+    static const int MAX_RESULTS = 1024;
+    wifi_rtt_result *rttResults[MAX_RESULTS];
+    wifi_rtt_config *rttConfig;
+    wifi_rtt_event_handler Handler;
+
+public:
+    RttRangeControl(wifi_interface_handle iface, int id, unsigned num_rtt_config,
+                         wifi_rtt_config rtt_config[], wifi_rtt_event_handler handler)
+    : WifiCommand("RttRangeControl", iface, id)
+    {
+        numConfig = num_rtt_config;
+        rttConfig = rtt_config;
+        Handler = handler;
+        memset(rttResults, 0, sizeof(wifi_rtt_result*) * MAX_RESULTS);
+        Index = 0;
+        mCompleted = 0;
+        totalCnt = 0;
+    }
+
+    RttRangeControl(wifi_interface_handle iface, int id)
+    : WifiCommand("RttRangeControl", iface, id)
+    {
+        Index = 0;
+        mCompleted = 0;
+        totalCnt = 0;
+        numConfig = 0;
+    }
+
+    int createSetupRequest(WifiRequest& request) {
+        int result = 0;
+        result = request.create(MARVELL_OUI, NXP_SUBCMD_RTT_RANGE_REQUEST);
+        if (result < 0) {
+            ALOGE("Failed to create message to request RTT range - %d", result);
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(NXP_ATTR_RTT_NUM_CONFIG, numConfig);
+        if (result < 0) {
+            ALOGE("Failed to put num of rtt params\n");
+            return result;
+        }
+
+        unsigned len = numConfig * sizeof(wifi_rtt_config);
+        result = request.put(NXP_ATTR_RTT_CONFIG, rttConfig, len);
+        if(result < 0) {
+            ALOGE("Failed to put rtt params\n");
+            return result;
+        }
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int createTeardownRequest(WifiRequest& request, unsigned num_devices, mac_addr *addr) {
+        int result = 0;
+        result = request.create(MARVELL_OUI, NXP_SUBCMD_RTT_RANGE_CANCEL);
+        if (result < 0) {
+            ALOGE("Failed to create message to cancel RTT range");
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_u8(NXP_ATTR_RTT_NUM_CONFIG, num_devices);
+        if(result < 0)
+            return result;
+        result = request.put_addr(NXP_ATTR_RTT_DEVICE_ADDR, *addr);
+        if(result < 0)
+            return result;
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int start() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createSetupRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create setup request; result = %d", result);
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to configure RTT setup; result = %d", result);
+            return result;
+        }
+
+        result = registerVendorHandler(MARVELL_OUI, NXP_EVENT_RTT_RANGE_RESULT);
+        if (result < 0) {
+            ALOGE("Failed to register handler");
+            unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_RTT_RANGE_RESULT);
+            return result;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    int cancel_specific(unsigned num_devices, mac_addr addr[]) {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request, num_devices, addr);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create stop request; result = %d", result);
+            return result;
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to stop RTT; result = %d", result);
+                return result;
+            }
+        }
+        unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_RTT_RANGE_RESULT);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        u8 *data = NULL;
+        u8 *pHead = NULL;
+        u8 *pEnd = NULL;
+        int result_cnt = 0;
+
+        nlattr *vendor_data = (nlattr*)(event.get_attribute(NL80211_ATTR_VENDOR_DATA));
+        int len = event.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No rtt results found");
+            return NL_SKIP;
+        }
+
+        for (nl_iterator it(vendor_data); it.has_next(); it.next()) {
+            if (it.get_type() == NXP_ATTR_RTT_RESULT_COMPLETE) {
+                /* 1: result event is complete  0: resultes event is not complete */
+                mCompleted = it.get_u32();
+                ALOGV("result event is %d\n", mCompleted);
+                ALOGV("retrieved completed flag : %d\n", mCompleted);
+            } else if (it.get_type() == NXP_ATTR_RTT_RESULT_NUM) {
+                result_cnt = it.get_u32();
+                ALOGV("number of result is %d\n", result_cnt);
+                ALOGV("Number of RTT results: %d\n", result_cnt);
+            } else if(it.get_type() == NXP_ATTR_RTT_RESULT_FULL) {
+                unsigned long result_len = 0;
+
+                result_len = it.get_len();
+                data = (u8 *)(it.get_data());
+                pHead = data;
+                pEnd = data;
+                pEnd += result_len;
+                if(result_len < RTT_RESULT_SIZE){
+                    ALOGE("Event buffer size is too small\n");
+                    return NL_SKIP;
+                } else {
+                    rttResults[Index] = (wifi_rtt_result *)malloc(RTT_RESULT_SIZE);
+                    memset(rttResults[Index], 0, RTT_RESULT_SIZE);
+                    memcpy(rttResults[Index], data, RTT_RESULT_SIZE);
+                    rttResults[Index]->LCI = NULL;
+                    rttResults[Index]->LCR = NULL;
+                    data += RTT_RESULT_SIZE;
+                    while(data < pEnd){
+                        u8 *type = data;
+                        u8 *element_len = data;
+                        element_len += 1;
+                        type += 4;
+                        switch(*type){
+                            case DOT11_MEASURE_TYPE_LCI:
+                            {
+                                rttResults[Index]->LCI = (wifi_information_element *)data;
+                                data += (*element_len + 2);
+                                break;
+                            }
+                            case DOT11_MEASURE_TYPE_CIVICLOC:
+                            {
+                                rttResults[Index]->LCR = (wifi_information_element *)data;
+                                data += (*element_len + 2);
+                                break;
+                            }
+                            default:
+                            {
+                                ALOGE("Unknow attribute data\n");
+                                return NL_SKIP;
+                            }
+                        }
+                    }
+                }
+                Index ++;
+            }
+        }
+        totalCnt = Index;
+        if (mCompleted) {
+            unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_RTT_RANGE_RESULT);
+            if(Handler.on_rtt_results){
+                 (Handler.on_rtt_results)(id(), totalCnt, rttResults);
+            }
+            for(int n = 0; n < totalCnt; n++){
+                 ALOGV("Addr %02x:%02x:%02x:%02x:%02x:%02x\n", 
+                         rttResults[n]->addr[0], rttResults[n]->addr[1], rttResults[n]->addr[2], 
+                         rttResults[n]->addr[3], rttResults[n]->addr[4], rttResults[n]->addr[5]);
+                 ALOGV("burst_num = %02x\tmeasurement_num = %02x\nsuccess_num = %02x\tnumber_per_burst_peer = %02x\n",
+                         rttResults[n]->burst_num, rttResults[n]->measurement_number, 
+                         rttResults[n]->success_number, rttResults[n]->number_per_burst_peer);
+                 ALOGV("status = %02x\tretry_after_duration = %02x\ntype = %02x\trssi = %02x\n",
+                         rttResults[n]->status, rttResults[n]->retry_after_duration, rttResults[n]->type,
+                         rttResults[n]->rssi);
+//                 ALOGV("rssi_spread = %02x\trtt = %ld\nrtt_sd = %lld\trtt_spread = %lld\n", 
+//                         rttResults[n]->rssi_spread, rttResults[n]->rtt, rttResults[n]->rtt_sd, 
+//                         rttResults[n]->rtt_spread);
+//                 ALOGV("distance_mm = %02x\tdistance_sd_mm = %02x\ndistance_spread_mm = %02x\tts = %lld\n",
+//                         rttResults[n]->distance_mm, rttResults[n]->distance_sd_mm, 
+//                         rttResults[n]->distance_spread_mm, rttResults[n]->ts);
+                 ALOGV("burst_duration = %02x\tnegotiated_burst_num = %02x\n", 
+                         rttResults[n]->burst_duration, rttResults[n]->negotiated_burst_num);
+                 if(rttResults[n]->LCI){
+                     ALOGV("lci_id = %d\tlci_len = %d\n", rttResults[n]->LCI->id, rttResults[n]->LCI->len);
+                     ALOGV("data :\n");
+                     for(int lci_index = 0; lci_index < rttResults[n]->LCI->len; lci_index ++){
+                         ALOGV("%02x ", rttResults[n]->LCI->data[lci_index]);
+                     }
+                     ALOGV("\n");
+                 }
+                 if(rttResults[n]->LCR){
+                     ALOGV("lcr_id = %d\tlcr_len = %d\n", rttResults[n]->LCR->id, rttResults[n]->LCR->len);
+                     for (int lcr_index = 0; lcr_index < rttResults[n]->LCR->len; lcr_index ++){
+                         ALOGV("%02x ", rttResults[n]->LCR->data[lcr_index]);
+                     }
+                     ALOGV("\n");
+                 }
+            }
+            for (int m = 0; m < totalCnt; m++) {
+                free(rttResults[m]);
+                rttResults[m] = NULL;
+            }
+            totalCnt = Index = 0;
+            WifiCommand *cmd = wifi_unregister_cmd(wifiHandle(), id());
+            if (cmd)
+                cmd->releaseRef();
+        }
+        return NL_SKIP;
+    }
+};
+
+class GetRttResponderInfo :public WifiCommand
+{
+private:
+    wifi_rtt_responder *responderInfo;
+
+public:
+    GetRttResponderInfo (wifi_interface_handle iface, wifi_rtt_responder *responder_info)
+    : WifiCommand("GetRttResponderInfo", iface, 0)
+    {
+        responderInfo = responder_info;
+        memset(responderInfo, 0, sizeof(wifi_rtt_responder));
+    }
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_RTT_GET_RESPONDER_INFO);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get responder info\n");
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+        nlattr *tb = (nlattr*)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if(tb == NULL || len == 0){
+            ALOGE("ERROR\n");
+            return NL_SKIP;
+        }
+        struct nlattr *tb_vendor[NXP_ATTR_RTT_MAX];
+        nla_parse(tb_vendor, (NXP_ATTR_RTT_MAX - 1), tb, len, NULL);
+        if (!tb_vendor[NXP_ATTR_RTT_CHANNEL_INFO]){
+            ALOGE("NXP_ATTR_RTT_CHANNEL_INFO not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        memcpy(&(responderInfo->channel),(wifi_channel_info *)nla_data(tb_vendor[NXP_ATTR_RTT_CHANNEL_INFO]), 
+               sizeof(wifi_channel_info));
+        if (!tb_vendor[NXP_ATTR_RTT_PREAMBLE]){
+            ALOGE("NXP_ATTR_RTT_PREAMBLE not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        memcpy(&(responderInfo->preamble), (wifi_rtt_preamble *)nla_data(tb_vendor[NXP_ATTR_RTT_PREAMBLE]),
+                sizeof(wifi_rtt_preamble));
+        ALOGV("channel width = %d\n", responderInfo->channel.width);
+        ALOGV("center freq = %d\n", responderInfo->channel.center_freq);
+        ALOGV("preamble = %d\n", responderInfo->preamble);
+        return NL_OK;
+    }
+};
+
+
+/* API to request RTT measurement */
+wifi_error wifi_rtt_range_request(wifi_request_id id, wifi_interface_handle iface,
+                                       unsigned num_rtt_config, wifi_rtt_config rtt_config[], 
+                                       wifi_rtt_event_handler handler)
+{
+    int ret = 0;
+    wifi_handle handle = getWifiHandle(iface);
+    RttRangeControl *RangeReq = new RttRangeControl(iface, id, num_rtt_config, 
+                                                     rtt_config, handler);
+    wifi_register_cmd(handle, id, RangeReq);
+    ret = RangeReq->start();
+    return (wifi_error) ret;
+}
+
+/* API to cancel RTT measurements */
+wifi_error wifi_rtt_range_cancel(wifi_request_id id,  wifi_interface_handle iface,
+                                      unsigned num_devices, mac_addr *addr)
+{
+    RttRangeControl *RangeCancel = new RttRangeControl(iface, id);
+    if (RangeCancel) {
+        RangeCancel->cancel_specific(num_devices, addr);
+        RangeCancel->releaseRef();
+        return WIFI_SUCCESS;
+    }
+    return WIFI_ERROR_INVALID_ARGS;
+}
+
+/* API to get RTT capabilities */
+wifi_error wifi_get_rtt_capabilities(wifi_interface_handle iface,
+                                        wifi_rtt_capabilities *capabilities)
+{
+    int ret = 0;
+    GetRttCapa RttCapa(iface, capabilities);
+    ret = RttCapa.requestResponse();
+    return (wifi_error) ret;
+}
+
+/* API to get RTT responder info */
+wifi_error wifi_rtt_get_responder_info(wifi_interface_handle iface, 
+                                             wifi_rtt_responder *responder_info)
+{
+    int ret = 0;
+    GetRttResponderInfo Info(iface, responder_info);
+    ret = Info.requestResponse();
+    return (wifi_error) ret;
+}
+
+class RttEnableResponder : public WifiCommand
+{
+private:
+    wifi_channel_info channelHint;
+    unsigned maxDurSec;
+    wifi_rtt_responder * responderInfo;
+
+public:
+    RttEnableResponder(wifi_request_id id, wifi_interface_handle iface, 
+                             wifi_channel_info channel_hint, unsigned max_duration_seconds,
+                              wifi_rtt_responder *responder_info)
+    : WifiCommand("RttEnableResponder", iface, id)
+    {
+        channelHint = channel_hint;
+        maxDurSec = max_duration_seconds;
+        responderInfo = responder_info;
+        memset(responderInfo, 0, sizeof(wifi_rtt_responder));
+    }
+
+    virtual int create() {
+        int result = 0;
+        result = mMsg.create(MARVELL_OUI, NXP_SUBCMD_RTT_ENABLE_RESPONDER);
+        if (result < 0) {
+            ALOGE("Failed to create message to enable RTT responder");
+            return result;
+        }
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = mMsg.put(NXP_ATTR_RTT_CHANNEL_INFO, &channelHint, sizeof(wifi_channel_info));
+        if (result < 0) {
+            ALOGE("Failed to set channel hint\n");
+            return result;
+        }
+
+        result = mMsg.put_u32(NXP_ATTR_RTT_MAX_DUR_SEC, maxDurSec);
+        if(result < 0) {
+            ALOGE("Failed to set max duration seconds\n");
+            return result;
+        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+    virtual int handleResponse(WifiEvent& reply){
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        nlattr *tb = (nlattr*)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if(tb == NULL || len == 0){
+            ALOGE("ERROR! No data in command response\n");
+            return NL_SKIP;
+        }
+
+        struct nlattr *tb_vendor[NXP_ATTR_RTT_MAX];
+        int status = WIFI_ERROR_NONE;
+        nla_parse(tb_vendor, (NXP_ATTR_RTT_MAX - 1), tb, len, NULL);
+        if(!tb_vendor[NXP_ATTR_RTT_CHANNEL_INFO]){
+            ALOGE("NXP_ATTR_RTT_CHANNEL not found");
+            status = WIFI_ERROR_INVALID_ARGS;
+            return status;
+        }
+        memcpy(&(responderInfo->channel), (wifi_channel_info *)nla_data(tb_vendor[NXP_ATTR_RTT_CHANNEL_INFO]),
+                sizeof(wifi_channel_info));
+        if(!tb_vendor[NXP_ATTR_RTT_PREAMBLE]){
+            ALOGE("NXP_ATTR_RTT_PREAMBLE not found");
+            status = WIFI_ERROR_INVALID_ARGS;
+            return status;
+        }
+        memcpy(&(responderInfo->preamble), (wifi_rtt_preamble *)nla_data(tb_vendor[NXP_ATTR_RTT_PREAMBLE]),
+                sizeof(wifi_rtt_preamble));
+        return NL_OK;
+    }
+};
+
+/** 
+* Enable RTT responder mode.
+* channel_hint - hint of the channel information where RTT responder should be enabled on.
+* max_duration_seconds - timeout of responder mode.
+* channel_used - channel used for RTT responder, NULL if responder is not enabled.
+*/
+wifi_error wifi_enable_responder(wifi_request_id id, wifi_interface_handle iface,
+                                       wifi_channel_info channel_hint, 
+                                       unsigned max_duration_seconds,
+                                       wifi_rtt_responder *responder_info)
+{
+    int ret = 0;
+    RttEnableResponder Responder(id, iface, channel_hint, max_duration_seconds,
+                                 responder_info);
+    ret = Responder.requestResponse();
+    return (wifi_error)ret;
+}
+
+class RttDisableResponder : public WifiCommand
+{
+public:
+    RttDisableResponder(wifi_request_id id, wifi_interface_handle iface)
+    : WifiCommand("RttDisableResponder", iface, id)
+    { }
+
+    virtual int create(){
+        int result = 0;
+        result = mMsg.create(MARVELL_OUI, NXP_SUBCMD_RTT_DISABLE_RESPONDER);
+        if (result < 0) {
+            ALOGE("Failed to create message to disable rtt responder");
+            return result;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply){
+        /* Nothing to do in response! */
+        return NL_SKIP;
+    }
+};
+
+/* Disable RTT responder mode */
+wifi_error wifi_disable_responder(wifi_request_id id, wifi_interface_handle iface)
+{
+    int ret = 0;
+    RttDisableResponder Responder(id, iface);
+    ret = Responder.requestResponse();
+    return (wifi_error)ret;
+}
+
+class RttSetCommand : public WifiCommand
+{
+private:
+    wifi_lci_information *LCI;
+    wifi_lcr_information *LCR;
+    ConfigureType Config;
+
+public:
+    RttSetCommand(wifi_request_id id, wifi_interface_handle iface, 
+                         wifi_lci_information *lci, ConfigureType cmdType)
+    : WifiCommand("RttSetCommand", iface, id)
+    {
+        LCI = lci;
+        Config = cmdType;
+    }
+
+    RttSetCommand(wifi_request_id id, wifi_interface_handle iface,
+                         wifi_lcr_information *lcr, ConfigureType cmdType)
+    : WifiCommand("RttSetCommand", iface, id)
+    {
+        LCR = lcr;
+        Config = cmdType;
+    }
+
+    virtual int create(){
+        int result = 0;
+        switch(Config){
+            case RTT_SET_LCI:
+            {
+                result = mMsg.create(MARVELL_OUI, NXP_SUBCMD_RTT_SET_LCI);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create message to set LCI - %d", result);
+                    return result;
+                }
+                
+                nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+                result = mMsg.put(NXP_ATTR_RTT_LCI_INFO, LCI, sizeof(wifi_lci_information));
+                if (result < 0) {
+                    ALOGE("Failed to set channel hint\n");
+                    return result;
+                }
+                mMsg.attr_end(data);
+                break;
+            }
+            case RTT_SET_LCR:
+            {
+                result = mMsg.create(MARVELL_OUI, NXP_SUBCMD_RTT_SET_LCR);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create message to set LCR - %d", result);
+                    return result;
+                }
+                nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+                result = mMsg.put(NXP_ATTR_RTT_LCR_INFO, LCR, sizeof(wifi_lcr_information));
+                if (result < 0) {
+                    ALOGE("Failed to set channel hint\n");
+                    return result;
+                }
+                mMsg.attr_end(data);
+                break;
+            }
+            default:
+                ALOGE("Unknow command");
+                return WIFI_ERROR_UNKNOWN;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply){
+        /* Nothing to do in response! */
+        return NL_SKIP;
+    }
+};
+
+/* API to configure the LCI */
+wifi_error wifi_set_lci(wifi_request_id id, wifi_interface_handle iface, 
+                          wifi_lci_information *lci)
+{
+    int ret = 0;
+    RttSetCommand SetLci(id, iface, lci, RTT_SET_LCI);
+    ret = SetLci.requestResponse();
+    return (wifi_error)ret;
+}
+
+/* API to configure the LCR */
+wifi_error wifi_set_lcr(wifi_request_id id, wifi_interface_handle iface, 
+                          wifi_lcr_information *lcr)
+{
+    int ret = 0;
+    RttSetCommand SetLcr(id, iface, lcr, RTT_SET_LCR);
+    ret = SetLcr.requestResponse();
+    return (wifi_error) ret;
+}
diff --git a/88x9098/wlan/hal/wifi_hal/wifi_hal.cpp b/88x9098/wlan/hal/wifi_hal/wifi_hal.cpp
new file mode 100644
index 0000000..72b4960
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/wifi_hal.cpp
@@ -0,0 +1,1498 @@
+/* 
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+#include <errno.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+#include <netlink/attr.h>
+#include <netlink/msg.h>
+
+#include <dirent.h>
+#include <net/if.h>
+
+#include "common.h"
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+#include "rtt.h"
+#include "roam.h"
+/*
+ BUGBUG: normally, libnl allocates ports for all connections it makes; but
+ being a static library, it doesn't really know how many other netlink connections
+ are made by the same process, if connections come from different shared libraries.
+ These port assignments exist to solve that problem - temporarily. We need to fix
+ libnl to try and allocate ports across the entire process.
+ */
+
+#define WIFI_HAL_CMD_SOCK_PORT       644
+#define WIFI_HAL_EVENT_SOCK_PORT     645
+
+/*
+* Defines for wifi_wait_for_driver_ready()
+* Specify durations between polls and max wait time 
+*/
+#define POLL_DRIVER_DURATION_US (100000)  /*100ms*/
+#define POLL_DRIVER_MAX_TIME_MS (20000)  /*20s*/
+
+
+static void internal_event_handler(wifi_handle handle, int events);
+static int internal_no_seq_check(nl_msg *msg, void *arg);
+static int internal_valid_message_handler(nl_msg *msg, void *arg);
+static int wifi_get_multicast_id(wifi_handle handle, const char *name, const char *group);
+static int wifi_add_membership(wifi_handle handle, const char *group);
+static wifi_error wifi_init_interfaces(wifi_handle handle);
+wifi_error wifi_configure_nd_offload(wifi_interface_handle iface, u8 enable);
+wifi_error wifi_start_rssi_monitoring(wifi_request_id id, wifi_interface_handle iface, s8 max_rssi,
+                                           s8 min_rssi, wifi_rssi_event_handler eh);
+wifi_error wifi_stop_rssi_monitoring(wifi_request_id id, wifi_interface_handle iface);
+
+/**
+* API to set packe filter
+* @param program        pointer to the program byte-code
+* @param len               length of the program byte_code 
+*/
+wifi_error wifi_set_packet_filter(wifi_interface_handle iface, const u8* program, u32 len);
+wifi_error wifi_start_wake_reason_cnt(hal_info * info);
+
+/**
+* API to get packet filter capabilities. Returns the chipset's hardware filtering capabilities
+* @param version         pointer to version of the packet filter interpreter supported, filled in upon return. 0 indicates no support
+* @param max_len       pointer to maximum size of the filter bytecode, filled in upon return
+*/
+wifi_error wifi_get_packet_filter_capabilities(wifi_interface_handle handle, u32* version, u32* max_len);
+wifi_error wifi_get_wake_reason_stats(wifi_interface_handle iface, 
+                                            WLAN_DRIVER_WAKE_REASON_CNT *wifi_wake_reason_cnt);
+wifi_error wifi_get_valid_channels(wifi_interface_handle handle, int band, int max_channels, 
+                                        wifi_channel *channels, int *num_channels);
+
+typedef enum wifi_attr {
+    NXP_ATTR_WIFI_COMMON_INVALID = 0,
+    NXP_ATTR_SET_SCAN_MAC_OUI,
+    NXP_ATTR_SUPPORTED_FEATURE_SET,
+    NXP_ATTR_NODFS,
+    NXP_ATTR_COUNTRY_CODE,
+    NXP_ATTR_VALID_CHANNELS_BAND,
+    NXP_ATTR_VALID_CHANNELS_NUM_CHANNELS,
+    NXP_ATTR_VALID_CHANNEL_LIST,
+    NXP_ATTR_CONCURRENCY_MATRIX_SET_SIZE_MAX,
+    NXP_ATTR_CONCURRENCY_MATRIX_SET_SIZE,
+    NXP_ATTR_CONCURRENCY_MATRIX_SET,
+
+    NXP_ATTR_WIFI_COMMON_AFTER_LAST,
+    NXP_ATTR_WIFI_COMMON_MAX =
+    NXP_ATTR_WIFI_COMMON_AFTER_LAST - 1,
+} wifi_attr_t;
+
+enum wifi_rssi_monitor_attr {
+    NXP_ATTR_RSSI_MONITOR_INVALID = 0,
+    NXP_ATTR_RSSI_MONITOR_CONTROL,
+    NXP_ATTR_RSSI_MONITOR_MIN_RSSI,
+    NXP_ATTR_RSSI_MONITOR_MAX_RSSI,
+    NXP_ATTR_RSSI_MONITOR_CUR_BSSID,
+    NXP_ATTR_RSSI_MONITOR_CUR_RSSI,
+
+    /* keep last */
+    NXP_ATTR_RSSI_MONITOR_AFTER_LAST,
+    NXP_ATTR_RSSI_MONITOR_MAX =
+    NXP_ATTR_RSSI_MONITOR_AFTER_LAST - 1,
+};
+
+enum wifi_attr_nd_offload
+{
+    NXP_WIFI_ATTR_ND_OFFLOAD_INVALID = 0,
+    NXP_ATTR_ND_OFFLOAD_CONTROL,
+
+    /* keep last */
+    NXP_WIFI_ATTR_ND_OFFLOAD_AFTER_LAST,
+    NXP_WIFI_ATTR_ND_OFFLOAD_MAX =
+    NXP_WIFI_ATTR_ND_OFFLOAD_AFTER_LAST - 1,
+};
+
+enum wifi_attr_packet_filter 
+{
+    NXP_ATTR_PACKET_FILTER_INVALID = 0,
+    NXP_ATTR_PACKET_FILTER_TOTAL_LENGTH,
+    NXP_ATTR_PACKET_FILTER_PROGRAM,
+    NXP_ATTR_PACKET_FILTER_VERSION,
+    NXP_ATTR_PACKET_FILTER_MAX_LEN,
+    NXP_ATTR_PACKET_FILTER_MAX,
+};
+
+/* Initialize/Cleanup */
+
+wifi_interface_handle wifi_get_iface_handle(wifi_handle handle, char *name)
+{
+    hal_info *info = (hal_info *)handle;
+    for (int i=0;i<info->num_interfaces;i++)
+    {
+        if (!strcmp(info->interfaces[i]->name, name))
+        {
+            return ((wifi_interface_handle )(info->interfaces)[i]);
+        }
+    }
+    return NULL;
+}
+
+void wifi_socket_set_local_port(struct nl_sock *sock, uint32_t port)
+{
+    uint32_t pid = getpid() & 0x3FFFFF;
+    ALOGV("pid = %d", pid);
+    nl_socket_set_local_port(sock, pid + (port << 22));
+}
+
+static nl_sock * wifi_create_nl_socket(int port)
+{
+    ALOGV("create cmd socket, port = %d", port);
+    struct nl_sock *sock = nl_socket_alloc();
+    if (sock == NULL) {
+        ALOGE("Could not create handle");
+        return NULL;
+    }
+
+    wifi_socket_set_local_port(sock, port);
+
+    struct sockaddr *addr = NULL;
+
+    if (nl_connect(sock, NETLINK_GENERIC)) {
+        ALOGE("Could not connect handle");
+        nl_socket_free(sock);
+        return NULL;
+    }
+
+    if (nl_socket_set_nonblocking(sock)) {
+        ALOGE("Could not make socket non-blocking");
+        nl_socket_free(sock);
+        return NULL;
+    }
+    
+    return sock;
+}
+
+
+/*initialize function pointer table with Broadcom HHAL API*/
+wifi_error init_wifi_vendor_hal_func_table(wifi_hal_fn *fn)
+{
+    ALOGV("***init_wifi_vendor_hal_func_table***");
+    if (fn == NULL) {
+        return WIFI_ERROR_UNKNOWN;
+    }
+    fn->wifi_initialize = wifi_initialize;
+    fn->wifi_wait_for_driver_ready = wifi_wait_for_driver_ready;
+    fn->wifi_cleanup = wifi_cleanup;
+    fn->wifi_event_loop = wifi_event_loop;
+    fn->wifi_get_supported_feature_set = wifi_get_supported_feature_set;
+    fn->wifi_get_concurrency_matrix = wifi_get_concurrency_matrix;
+    fn->wifi_set_scanning_mac_oui =  wifi_set_scanning_mac_oui;
+    fn->wifi_get_ifaces = wifi_get_ifaces;
+    fn->wifi_get_iface_name = wifi_get_iface_name;
+    fn->wifi_set_link_stats = wifi_set_link_stats;
+    fn->wifi_get_link_stats = wifi_get_link_stats;
+    fn->wifi_clear_link_stats = wifi_clear_link_stats;
+    fn->wifi_get_valid_channels = wifi_get_valid_channels;
+    fn->wifi_rtt_range_request = wifi_rtt_range_request;
+    fn->wifi_rtt_range_cancel = wifi_rtt_range_cancel;
+    fn->wifi_get_rtt_capabilities = wifi_get_rtt_capabilities;
+    fn->wifi_rtt_get_responder_info = wifi_rtt_get_responder_info;
+    fn->wifi_enable_responder = wifi_enable_responder;
+    fn->wifi_disable_responder = wifi_disable_responder;
+    fn->wifi_set_lci = wifi_set_lci;
+    fn->wifi_set_lcr = wifi_set_lcr;
+    fn->wifi_set_nodfs_flag = wifi_set_nodfs_flag;
+    fn->wifi_start_logging = wifi_start_logging;
+    fn->wifi_set_country_code = wifi_set_country_code;
+    fn->wifi_get_firmware_memory_dump = wifi_get_firmware_memory_dump;
+    fn->wifi_get_driver_memory_dump = wifi_get_driver_memory_dump;
+    fn->wifi_set_log_handler = wifi_set_log_handler;
+    fn->wifi_reset_log_handler = wifi_reset_log_handler;
+    fn->wifi_set_alert_handler = wifi_set_alert_handler;
+    fn->wifi_reset_alert_handler = wifi_reset_alert_handler;
+    fn->wifi_get_firmware_version = wifi_get_firmware_version;
+    fn->wifi_get_ring_buffers_status = wifi_get_ring_buffers_status;
+    fn->wifi_get_logger_supported_feature_set = wifi_get_logger_supported_feature_set;
+    fn->wifi_get_ring_data = wifi_get_ring_data;
+    fn->wifi_get_driver_version = wifi_get_driver_version;
+    fn->wifi_start_rssi_monitoring = wifi_start_rssi_monitoring;
+    fn->wifi_stop_rssi_monitoring = wifi_stop_rssi_monitoring;
+    fn->wifi_get_wake_reason_stats = wifi_get_wake_reason_stats;
+    fn->wifi_configure_nd_offload = wifi_configure_nd_offload;
+    fn->wifi_start_pkt_fate_monitoring = wifi_start_pkt_fate_monitoring;
+    fn->wifi_get_tx_pkt_fates = wifi_get_tx_pkt_fates;
+    fn->wifi_get_rx_pkt_fates = wifi_get_rx_pkt_fates;
+    fn->wifi_nan_enable_request = nan_enable_request;
+    fn->wifi_nan_disable_request = nan_disable_request;
+    fn->wifi_nan_publish_request = nan_publish_request;
+    fn->wifi_nan_publish_cancel_request= nan_publish_cancel_request;
+    fn->wifi_nan_subscribe_request = nan_subscribe_request;
+    fn->wifi_nan_subscribe_cancel_request = nan_subscribe_cancel_request;
+    fn->wifi_nan_transmit_followup_request = nan_transmit_followup_request;
+    fn->wifi_nan_stats_request = nan_stats_request;
+    fn->wifi_nan_config_request = nan_config_request;
+    fn->wifi_nan_tca_request = nan_tca_request;
+    fn->wifi_nan_beacon_sdf_payload_request = nan_beacon_sdf_payload_request;
+    fn->wifi_nan_register_handler = nan_register_handler;
+    fn->wifi_nan_get_version = nan_get_version;
+    fn->wifi_nan_get_capabilities = nan_get_capabilities;
+    fn->wifi_nan_data_interface_create = nan_data_interface_create;
+    fn->wifi_nan_data_interface_delete = nan_data_interface_delete;
+    fn->wifi_nan_data_request_initiator = nan_data_request_initiator;
+    fn->wifi_nan_data_indication_response = nan_data_indication_response;
+    fn->wifi_nan_data_end = nan_data_end;
+    fn->wifi_set_packet_filter = wifi_set_packet_filter;
+    fn->wifi_get_packet_filter_capabilities = wifi_get_packet_filter_capabilities;
+    fn->wifi_get_roaming_capabilities = wifi_get_roaming_capabilities;
+    fn->wifi_enable_firmware_roaming = wifi_enable_firmware_roaming;
+    fn->wifi_configure_roaming = wifi_configure_roaming;
+    fn->wifi_start_sending_offloaded_packet = wifi_start_sending_offloaded_packet;
+    fn->wifi_stop_sending_offloaded_packet = wifi_stop_sending_offloaded_packet;
+    ALOGV("***over init_wifi_vendor_hal_func_table***");
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_initialize(wifi_handle *handle)
+{
+    struct nl_cb *cb = NULL;
+    struct nl_sock *cmd_sock = NULL;
+    struct nl_sock *event_sock = NULL;
+    wifi_error ret = WIFI_SUCCESS;
+
+    hal_info *info = (hal_info *)malloc(sizeof(hal_info));
+    if (info == NULL) {
+        ALOGE("Could not allocate hal_info");
+        ret = WIFI_ERROR_OUT_OF_MEMORY;
+        goto exit;
+    }
+
+    memset(info, 0, sizeof(*info));
+
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, info->cleanup_socks) == -1) {
+        ALOGE("Could not create cleanup sockets");
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    cmd_sock = wifi_create_nl_socket(WIFI_HAL_CMD_SOCK_PORT);
+    if (cmd_sock == NULL) {
+        ALOGE("Could not create handle");
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    event_sock = wifi_create_nl_socket(WIFI_HAL_EVENT_SOCK_PORT);
+    if (event_sock == NULL) {
+        ALOGE("Could not create handle");
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    cb = nl_socket_get_cb(event_sock);
+    if (cb == NULL) {
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    ALOGV("cb->refcnt = %d\n", cb->cb_refcnt);
+    nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, internal_no_seq_check, info);
+    nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, internal_valid_message_handler, info);
+    nl_cb_put(cb);
+
+    info->cmd_sock = cmd_sock;
+    info->event_sock = event_sock;
+    info->clean_up = false;
+    info->in_event_loop = false;
+
+    info->event_cb = (cb_info *)malloc(sizeof(cb_info) * DEFAULT_EVENT_CB_SIZE);
+    if (info->event_cb == NULL) {
+        ALOGE("Could not allocate event_cb");
+        ret = WIFI_ERROR_OUT_OF_MEMORY;
+        goto exit;
+    }
+    info->alloc_event_cb = DEFAULT_EVENT_CB_SIZE;
+    info->num_event_cb = 0;
+
+    info->cmd = (cmd_info *)malloc(sizeof(cmd_info) * DEFAULT_CMD_SIZE);
+    if (info->cmd == NULL) {
+        ALOGE("Could not allocate cmd info");
+        ret = WIFI_ERROR_OUT_OF_MEMORY;
+        goto exit;
+    }
+    info->alloc_cmd = DEFAULT_CMD_SIZE;
+    info->num_cmd = 0;
+
+    info->nl80211_family_id = genl_ctrl_resolve(cmd_sock, "nl80211");
+    if (info->nl80211_family_id < 0) {
+        ALOGE("Could not resolve nl80211 familty id");
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    pthread_mutex_init(&info->cb_lock, NULL);
+
+    *handle = (wifi_handle) info;
+
+    wifi_add_membership(*handle, "scan");
+    wifi_add_membership(*handle, "mlme");
+    wifi_add_membership(*handle, "regulatory");
+    wifi_add_membership(*handle, "vendor");
+
+    ret = wifi_init_interfaces(*handle);
+    if (ret != WIFI_SUCCESS) {
+        ALOGE("wifi_init_interfaces Failed");
+        pthread_mutex_destroy(&info->cb_lock);
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    ret = wifi_start_wake_reason_cnt(info);
+    if (ret != WIFI_SUCCESS) {
+        ALOGE("Initializing Wake Reason Event Handler Failed");
+        pthread_mutex_destroy(&info->cb_lock);
+        ret = WIFI_ERROR_UNKNOWN;
+        goto exit;
+    }
+
+    srand(getpid());
+
+    ALOGV("Initialized Wifi HAL Successfully; vendor cmd = %d", NL80211_CMD_VENDOR);
+exit:
+    if (ret != WIFI_SUCCESS) {
+        if (event_sock)
+            nl_socket_free(event_sock);
+        if (cmd_sock)
+            nl_socket_free(cmd_sock);
+        if (info) {
+            if (info->cmd) free(info->cmd);
+            if (info->event_cb) free(info->event_cb);
+            free(info);
+        }
+    }
+
+    return ret;
+}
+
+wifi_error wifi_wait_for_driver_ready(void)
+{
+
+    // This function will wait to make sure basic client netdev is created
+    // Function times out after 20 seconds
+    int count = (POLL_DRIVER_MAX_TIME_MS * 1000) / POLL_DRIVER_DURATION_US;
+    FILE *fd;
+
+    do {
+        if ((fd = fopen("/sys/class/net/wlan0", "r")) != NULL) {
+            fclose(fd);
+            return WIFI_SUCCESS;
+        }
+        usleep(POLL_DRIVER_DURATION_US);
+    } while(--count > 0);
+
+    ALOGE("Timed out waiting on Driver ready ... ");
+    return WIFI_ERROR_TIMED_OUT;
+}
+
+
+
+static int wifi_add_membership(wifi_handle handle, const char *group)
+{
+    hal_info *info = getHalInfo(handle);
+
+    int id = wifi_get_multicast_id(handle, "nl80211", group);
+    if (id < 0) {
+        ALOGE("Could not find group %s", group);
+        return id;
+    }
+
+    int ret = nl_socket_add_membership(info->event_sock, id);
+    if (ret < 0) {
+        ALOGE("Could not add membership to group %s", group);
+    }
+
+    ALOGV("Successfully added membership for group %s", group);
+    return ret;
+}
+
+static void internal_cleaned_up_handler(wifi_handle handle)
+{
+    hal_info *info = getHalInfo(handle);
+    wifi_cleaned_up_handler cleaned_up_handler = info->cleaned_up_handler;
+
+    if (info->cmd_sock != 0) {
+        close(info->cleanup_socks[0]);
+        close(info->cleanup_socks[1]);
+        nl_socket_free(info->cmd_sock);
+        nl_socket_free(info->event_sock);
+        info->cmd_sock = NULL;
+        info->event_sock = NULL;
+    }
+
+    (*cleaned_up_handler)(handle);
+    pthread_mutex_destroy(&info->cb_lock);
+    free(info);
+
+    ALOGV("Internal cleanup completed");
+}
+
+void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
+{
+    hal_info *info = getHalInfo(handle);
+    info->cleaned_up_handler = handler;
+    info->clean_up = true;
+
+    pthread_mutex_lock(&info->cb_lock);
+
+    int bad_commands = 0;
+
+    while (info->num_cmd > bad_commands) {
+        int num_cmd = info->num_cmd;
+        cmd_info *cmdi = &(info->cmd[bad_commands]);
+        WifiCommand *cmd = cmdi->cmd;
+        if (cmd != NULL) {
+            pthread_mutex_unlock(&info->cb_lock);
+            cmd->cancel();
+            pthread_mutex_lock(&info->cb_lock);
+            /* release reference added when command is saved */
+            cmd->releaseRef();
+            if (num_cmd == info->num_cmd) {
+                bad_commands++;
+            }
+        }
+    }
+
+    for (int i = 0; i < info->num_event_cb; i++) {
+        cb_info *cbi = &(info->event_cb[i]);
+        WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
+        ALOGE("Leaked command %p", cmd);
+    }
+
+    pthread_mutex_unlock(&info->cb_lock);
+    WLAN_DRIVER_WAKE_REASON_CNT *wake_reason_stat = NULL;
+    wake_reason_stat = info->wifi_wake_reason_cnt;
+    free(wake_reason_stat->cmd_event_wake_cnt);
+    wake_reason_stat->cmd_event_wake_cnt = NULL;
+    free(wake_reason_stat->driver_fw_local_wake_cnt);
+    wake_reason_stat->driver_fw_local_wake_cnt = NULL;
+    free(info->wifi_wake_reason_cnt);
+    info->wifi_wake_reason_cnt = NULL;
+	
+    if(info->pkt_fate_stats) {
+        free(info->pkt_fate_stats);
+        info->pkt_fate_stats = NULL;
+    }
+		
+
+    if (write(info->cleanup_socks[0], "T", 1) < 1) {
+        ALOGE("could not write to cleanup socket");
+    } else {
+        ALOGV("Wifi cleanup completed\n");
+    }
+}
+
+static int internal_pollin_handler(wifi_handle handle)
+{
+    hal_info *info = getHalInfo(handle);
+    struct nl_cb *cb = nl_socket_get_cb(info->event_sock);
+    int res = nl_recvmsgs(info->event_sock, cb);
+    nl_cb_put(cb);
+    return res;
+}
+
+/* Run event handler */
+void wifi_event_loop(wifi_handle handle)
+{
+    hal_info *info = getHalInfo(handle);
+    if (info->in_event_loop) {
+        return;
+    } else {
+        info->in_event_loop = true;
+    }
+
+    pollfd pfd[2];
+    memset(&pfd[0], 0, sizeof(pollfd) * 2);
+
+    pfd[0].fd = nl_socket_get_fd(info->event_sock);	
+    pfd[0].events = POLLIN;
+    pfd[1].fd = info->cleanup_socks[1];
+    pfd[1].events = POLLIN;
+    char buf[2048];
+    /* TODO: Add support for timeouts */
+
+    do {
+        int timeout = -1;                   /* Infinite timeout */
+        pfd[0].revents = 0;
+        pfd[1].revents = 0;
+        int result = poll(pfd, 2, timeout);
+        if (result < 0) {
+            ALOGE("Error polling socket");
+        } else if (pfd[0].revents & POLLERR) {
+            ALOGE("POLL Error; error no = %d", errno);
+            int result2 = read(pfd[0].fd, buf, sizeof(buf));
+            ALOGE("Read after POLL returned %d, error no = %d", result2, errno);
+        } else if (pfd[0].revents & POLLHUP) {
+            ALOGE("Remote side hung up");
+            break;
+        } else if (pfd[0].revents & POLLIN) {
+            internal_pollin_handler(handle);
+        } else if (pfd[1].revents & POLLIN) {
+            ALOGV("Got a signal to exit!!!");
+            int result2 = read(pfd[1].fd, buf, sizeof(buf));
+            ALOGV("Read after POLL returned %d, error no = %d", result2, errno);
+        } else {
+            ALOGE("Unknown event - %0x, %0x", pfd[0].revents, pfd[1].revents);
+        }
+    } while (!info->clean_up);
+
+    internal_cleaned_up_handler(handle);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////
+
+static int internal_no_seq_check(struct nl_msg *msg, void *arg)
+{
+    return NL_OK;
+}
+
+static int internal_valid_message_handler(nl_msg *msg, void *arg)
+{
+
+    wifi_handle handle = (wifi_handle)arg;
+    hal_info *info = getHalInfo(handle);
+    bool dispatched = false;
+    WifiEvent event(msg);
+    int res = event.parse();
+    if (res < 0) {
+        ALOGE("Failed to parse event: %d", res);
+        return NL_SKIP;
+    }
+
+    int cmd = event.get_cmd();
+    uint32_t vendor_id = 0;
+    int subcmd = 0;
+    if (cmd == NL80211_CMD_VENDOR) {
+        vendor_id = event.get_u32(NL80211_ATTR_VENDOR_ID);
+        subcmd = event.get_u32(NL80211_ATTR_VENDOR_SUBCMD);
+        ALOGV("event received %s, vendor_id = 0x%0x, subcmd = 0x%0x",
+                event.get_cmdString(), vendor_id, subcmd);
+    } else {
+        ALOGV("event received %s", event.get_cmdString());
+    }
+
+    pthread_mutex_lock(&info->cb_lock);
+
+    for (int i = 0; i < info->num_event_cb; i++) {
+        if (cmd == info->event_cb[i].nl_cmd) {
+            if (cmd == NL80211_CMD_VENDOR
+                && ((vendor_id != info->event_cb[i].vendor_id)
+                || (subcmd != info->event_cb[i].vendor_subcmd)))
+            {
+                /* event for a different vendor, ignore it */
+                continue;
+            }
+            cb_info *cbi = &(info->event_cb[i]);
+            nl_recvmsg_msg_cb_t cb_func = cbi->cb_func;
+            void *cb_arg = cbi->cb_arg;
+            WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
+            if (cmd != NULL) {
+                cmd->addRef();
+            }
+            pthread_mutex_unlock(&info->cb_lock);
+            (*cb_func)(msg, cb_arg);
+            if (cmd != NULL) {
+                cmd->releaseRef();
+            }
+            return NL_OK;
+        }
+    }
+
+    pthread_mutex_unlock(&info->cb_lock);
+    return NL_OK;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////
+
+class GetMulticastIdCommand : public WifiCommand
+{
+private:
+    const char *mName;
+    const char *mGroup;
+    int   mId;
+public:
+    GetMulticastIdCommand(wifi_handle handle, const char *name, const char *group)
+        : WifiCommand("GetMulticastIdCommand", handle, 0)
+    {
+        mName = name;
+        mGroup = group;
+        mId = -1;
+    }
+
+    int getId() {
+        return mId;
+    }
+
+    virtual int create() {
+        int nlctrlFamily = genl_ctrl_resolve(mInfo->cmd_sock, "nlctrl");
+        ALOGV("ctrl family = %d", nlctrlFamily);
+        int ret = mMsg.create(nlctrlFamily, CTRL_CMD_GETFAMILY, 0, 0);
+        if (ret < 0) {
+            return ret;
+        }
+        ret = mMsg.put_string(CTRL_ATTR_FAMILY_NAME, mName);
+        return ret;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+
+        struct nlattr **tb = reply.attributes();
+        struct genlmsghdr *gnlh = reply.header();
+        struct nlattr *mcgrp = NULL;
+        int i;
+
+        if (!tb[CTRL_ATTR_MCAST_GROUPS]) {
+            ALOGE("No multicast groups found");
+            return NL_SKIP;
+        } else {
+            ALOGV("Multicast groups attr size = %d", nla_len(tb[CTRL_ATTR_MCAST_GROUPS]));
+        }
+
+        for_each_attr(mcgrp, tb[CTRL_ATTR_MCAST_GROUPS], i) {
+
+            struct nlattr *tb2[CTRL_ATTR_MCAST_GRP_MAX + 1];
+            nla_parse(tb2, CTRL_ATTR_MCAST_GRP_MAX, (nlattr *)nla_data(mcgrp),
+                nla_len(mcgrp), NULL);
+            if (!tb2[CTRL_ATTR_MCAST_GRP_NAME] || !tb2[CTRL_ATTR_MCAST_GRP_ID]) {
+                continue;
+            }
+
+            char *grpName = (char *)nla_data(tb2[CTRL_ATTR_MCAST_GRP_NAME]);
+            int grpNameLen = nla_len(tb2[CTRL_ATTR_MCAST_GRP_NAME]);
+
+            if (strncmp(grpName, mGroup, grpNameLen) != 0)
+                continue;
+
+            mId = nla_get_u32(tb2[CTRL_ATTR_MCAST_GRP_ID]);
+            break;
+        }
+
+        return NL_SKIP;
+    }
+
+};
+
+class SetScanningMacOui : public WifiCommand {
+private:
+    byte *Oui;
+
+public:
+    SetScanningMacOui(wifi_interface_handle handle, oui scan_oui)
+        : WifiCommand("SetScanningMacOui", handle, 0)
+    {
+        Oui = scan_oui;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_SCAN_MAC_OUI);
+        if (ret < 0) {
+            ALOGE("Failed to create message to set scanning mac oui - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_SET_SCAN_MAC_OUI, Oui, MAC_OUI_LEN);
+        if (ret < 0) {
+            return ret;
+        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        return NL_SKIP;
+    }
+};
+
+class SetNodfsFlag : public WifiCommand {
+private:
+    u32 nodFs;
+
+public:
+    SetNodfsFlag(wifi_interface_handle handle, u32 nodfs)
+        : WifiCommand("SetNodfsFlag", handle, 0) 
+    {
+        nodFs = nodfs;
+    }
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_SET_NODFS_FLAG);
+        if (ret < 0) {
+            ALOGE("Failed to create message to set nodfs flag - %d", ret);
+            return ret;
+        }
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_NODFS, nodFs);
+        if (ret < 0) {
+             ALOGE("Failed to put nodfs flag");
+             return ret;
+        }
+
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+
+class SetCountryCodeCommand : public WifiCommand {
+private:
+    const char *mCountryCode;
+
+public:
+    SetCountryCodeCommand(wifi_interface_handle handle, const char *country_code)
+        : WifiCommand("SetCountryCodeCommand", handle, 0) 
+    {
+        mCountryCode = country_code;
+    }
+    virtual int create() {
+        int ret;
+        ret = mMsg.create(NL80211_CMD_REQ_SET_REG);
+        if (ret < 0) {
+             ALOGE("Can't create message to send to driver - %d", ret);
+             return ret;
+        }
+        ret = mMsg.put_string(NL80211_ATTR_REG_ALPHA2, mCountryCode);
+        if (ret < 0) {
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+};
+
+class RSSIMonitorControl : public WifiCommand {
+private:
+    s8 maxRSSI;
+    s8 minRSSI;
+    wifi_rssi_event_handler handler;
+    s8 currRSSI;
+    u8 BSSID[6];
+
+public:
+    RSSIMonitorControl(wifi_request_id id, wifi_interface_handle handle,
+                             s8 max_rssi, s8 min_rssi, wifi_rssi_event_handler eh)
+        : WifiCommand("RSSIMonitorControl", handle, id)
+    {
+        maxRSSI = max_rssi;
+        minRSSI = min_rssi;
+        handler = eh;
+        currRSSI = 0;
+        memset(BSSID, 0, sizeof(BSSID));
+    }
+
+    RSSIMonitorControl(wifi_request_id id, wifi_interface_handle handle)
+        : WifiCommand("RSSIMonitorControl", handle, id)
+    {
+        maxRSSI = 0;
+        minRSSI = 0;
+        //handler.on_rssi_threshold_breached = NULL;
+        memset(&handler, 0, sizeof(handler));
+        currRSSI = 0;
+        memset(BSSID, 0, sizeof(BSSID));
+    }
+
+    int createRequest(WifiRequest& request) {
+        u32 enable = 1;
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_RSSI_MONITOR);
+        if (result < 0) {
+            ALOGE("Failed to create message to start RSSI monitor - %d", result);
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_s8(NXP_ATTR_RSSI_MONITOR_MAX_RSSI, maxRSSI);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_s8(NXP_ATTR_RSSI_MONITOR_MIN_RSSI, minRSSI);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u32(NXP_ATTR_RSSI_MONITOR_CONTROL, enable);
+        if (result < 0) {
+            return result;
+        }
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int createTeardownRequest(WifiRequest &request, s8 max_rssi, s8 min_rssi) {
+        u32 disable = 0;
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_RSSI_MONITOR);
+        if(result < 0) {
+            return result;
+        }
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put_s8(NXP_ATTR_RSSI_MONITOR_MAX_RSSI, maxRSSI);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_s8(NXP_ATTR_RSSI_MONITOR_MIN_RSSI, minRSSI);
+        if (result < 0) {
+            return result;
+        }
+        result = request.put_u32(NXP_ATTR_RSSI_MONITOR_CONTROL, disable);
+        if (result < 0) {
+            return result;
+        }
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+
+    }
+    int start() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result < 0) {
+            return result;
+        }
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGE("Failed to set RSSI Monitor, result = %d", result);
+            return result;
+        }
+        result = registerVendorHandler(MARVELL_OUI, NXP_EVENT_RSSI_MONITOR);
+        if (result < 0) {
+            ALOGE("Failed to register handler");
+            unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_RSSI_MONITOR);
+            return result;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int cancel_specific(s8 max_rssi, s8 min_rssi) {
+
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request, 0, 0);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to stop RSSI monitoring = %d", result);
+            }
+        }
+        unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_RSSI_MONITOR);
+        return NL_OK;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        /* Nothing to do on response! */
+        return NL_SKIP;
+    }
+
+   virtual int handleEvent(WifiEvent& event) {
+
+       if (event.get_cmd() != NL80211_CMD_VENDOR) {
+           ALOGE("Ignoring reply with cmd = %d", event.get_cmd());
+           return NL_SKIP;
+       }
+
+       nlattr *vendor_data =(nlattr *) (event.get_data(NL80211_ATTR_VENDOR_DATA));
+       int len = event.get_vendor_data_len();
+       int event_id = event.get_vendor_subcmd();
+       struct nlattr *nl_attr = NULL;
+       s8 tmp_rssi = 0;
+
+       if (vendor_data == NULL || len == 0) {
+           ALOGE("RSSI monitor: No data");
+           return NL_SKIP;
+       }
+       
+       if(event_id == NXP_EVENT_RSSI_MONITOR){
+           struct nlattr *tb_vendor[NXP_ATTR_RSSI_MONITOR_MAX + 1];
+           nla_parse(tb_vendor, NXP_ATTR_RSSI_MONITOR_MAX, vendor_data, len, NULL);
+           if(!tb_vendor[NXP_ATTR_RSSI_MONITOR_CUR_RSSI]){
+               ALOGE("NXP_ATTR_RSSI_MONITOR_CUR_RSSI not found\n");
+               return NL_SKIP;
+           }
+           nl_attr = tb_vendor[NXP_ATTR_RSSI_MONITOR_CUR_RSSI];
+           tmp_rssi = *((s8 *)(void *)nl_attr + 4);
+           currRSSI = *(s8 *)(tb_vendor[NXP_ATTR_RSSI_MONITOR_CUR_RSSI]);
+           if(!tb_vendor[NXP_ATTR_RSSI_MONITOR_CUR_BSSID]){
+               ALOGE("NXP_ATTR_RSSI_MONITOR_CUR_BSSID not found\n");
+               return NL_SKIP;
+           }
+           if(nla_len(tb_vendor[NXP_ATTR_RSSI_MONITOR_CUR_BSSID]) != sizeof(*BSSID)){
+               ALOGE("Invalid mac addr length\n");
+               return NL_SKIP;
+           }
+           memcpy(BSSID,(u8*)nla_data(tb_vendor[NXP_ATTR_RSSI_MONITOR_CUR_BSSID]), sizeof(*BSSID));
+           if (*handler.on_rssi_threshold_breached) {
+               (*handler.on_rssi_threshold_breached)(id(), BSSID, currRSSI);
+           } else {
+               ALOGE("No RSSI monitor handler registered");
+           }
+          return NL_OK;
+       }
+       return NL_OK;
+    }
+
+};
+
+class GetSupportedFeatureSet : public WifiCommand {
+private:
+    feature_set *featureSet;
+
+public:
+    GetSupportedFeatureSet(wifi_interface_handle handle, feature_set *set)
+    : WifiCommand("GetSupportedFeatureSet", handle, 0)
+    {
+        featureSet = set;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_GET_SUPPORTED_FEATURE_SET);
+        if (ret < 0){
+            ALOGE("Failed to create message to get supported feature set - %d", ret);
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+        nlattr *vendor_data = (nlattr *)reply.get_data(NL80211_ATTR_VENDOR_DATA);
+        int len = reply.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in command response");
+            return NL_SKIP;
+        }
+        struct nlattr *tb_vendor[NXP_ATTR_WIFI_COMMON_MAX + 1];
+        nla_parse(tb_vendor, NXP_ATTR_WIFI_COMMON_MAX, vendor_data, len, NULL);
+        if(!tb_vendor[NXP_ATTR_SUPPORTED_FEATURE_SET]){
+            ALOGE("NXP_ATTR_SUPPORTED_FEATURE_SET not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        *featureSet = nla_get_u32(tb_vendor[NXP_ATTR_SUPPORTED_FEATURE_SET]);
+        return NL_OK;
+    }
+};
+
+class GetConcurrencyMatrix : public WifiCommand 
+{
+private:
+    int setMax;
+    feature_set *Set;
+    int *setSize;
+
+public:
+    GetConcurrencyMatrix(wifi_interface_handle handle, int set_size_max,
+                                feature_set *set, int *set_size)
+    : WifiCommand("GetConcurrencyMatrix", handle,0)
+    {
+        setMax = set_size_max;
+        Set = set;
+        setSize = set_size;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_GET_CONCURRENCY_MATRIX);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get concurrency matrix - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_CONCURRENCY_MATRIX_SET_SIZE_MAX, setMax);
+        if (ret < 0) {
+            return ret;
+        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+        nlattr *vendor_data = (nlattr *)reply.get_data(NL80211_ATTR_VENDOR_DATA);
+        int len = reply.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in command response");
+            return NL_SKIP;
+        }
+        struct nlattr *tb_vendor[NXP_ATTR_WIFI_COMMON_MAX + 1];
+        nla_parse(tb_vendor, NXP_ATTR_WIFI_COMMON_MAX, vendor_data, len, NULL);
+        if(!tb_vendor[NXP_ATTR_CONCURRENCY_MATRIX_SET_SIZE]){
+            ALOGE("NXP_ATTR_CONCURRENCY_MATRIX_SET_SIZE not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        *setSize = nla_get_u32(tb_vendor[NXP_ATTR_CONCURRENCY_MATRIX_SET_SIZE]);
+        if(!tb_vendor[NXP_ATTR_CONCURRENCY_MATRIX_SET]){
+            ALOGE("NXP_ATTR_CONCURRENCY_MATRIX_SET not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        memcpy(Set,(nlattr *) tb_vendor[NXP_ATTR_CONCURRENCY_MATRIX_SET], *setSize);
+        return NL_OK;
+    }
+};
+
+class ConfigureNdOffLoad : public WifiCommand {
+private:
+    u8 Enable;
+
+public:
+    ConfigureNdOffLoad(wifi_interface_handle iface, u8 enable)
+    : WifiCommand("ConfigureNdOffLoad", iface, 0) 
+    {
+        Enable = enable;
+    }
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_CONFIGURE_ND_OFFLOAD);
+        if (ret < 0) {
+            ALOGE("Failed to create message to configure nd offload - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u8(NXP_ATTR_ND_OFFLOAD_CONTROL, Enable);
+        if (ret < 0) {
+            return ret;
+        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+
+class SetPacketFilterCommand : public WifiCommand {
+private:
+    u32 mLen;
+    char* mProgram;
+
+public:
+    SetPacketFilterCommand(wifi_interface_handle iface, const u8* program, 
+                                   u32 len)
+    : WifiCommand("SetPacketFilterCommand", iface, 0)
+    {
+        mProgram = (char *)program;
+        mLen = len;
+    }
+
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_SET_PACKET_FILTER);
+        if(ret < 0){
+            ALOGE("Can't create message to send to driver - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_PACKET_FILTER_TOTAL_LENGTH, mLen);
+        if(ret < 0) {
+            ALOGE("Failed to put attribute len");
+            return ret;
+        }
+        ret = mMsg.put_string(NXP_ATTR_PACKET_FILTER_PROGRAM, mProgram);
+        if(ret < 0) {
+            ALOGE("Failed to put attribute program");
+            return ret;
+        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class GetPacketFilterCapaCommand : public WifiCommand {
+private: 
+    u32 *mVersion;
+    u32 *mMax_len;
+
+public:
+    GetPacketFilterCapaCommand(wifi_interface_handle handle,
+                                         u32 *version, u32 *max_len)
+    : WifiCommand("GetPacketFilterCapaCommand", handle, 0)
+    {
+        mVersion = version;
+        mMax_len = max_len;
+    }
+
+    virtual int createSetupRequest(WifiRequest &request) {
+        int ret = 0;
+        ret = request.create(MARVELL_OUI,NXP_SUBCMD_GET_PACKET_FILTER_CAPA);
+        if(ret < 0){
+            ALOGE("Can't create message to send to driver - %d", ret);
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    int start() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = 0;
+        result = createSetupRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGE("%s: requestResponse() error: %d", __FUNCTION__, result);
+            if (result == -ENOTSUP) {
+                /* Packet filtering is not supported currently, so return version
+                            * and length as 0
+                            */
+                ALOGE("Packet filtering is not supported");
+                *mVersion = 0;
+                *mMax_len = 0;
+                result = WIFI_SUCCESS;
+            } else {
+                ALOGE("Failed to get packet filter capa, result = %d", result);
+                return result;
+            }
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent &reply){
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+        ALOGE("Ignoring reply with cmd = %d\n", reply.get_cmd());
+        return NL_SKIP;
+        }
+
+        nlattr *tb = (nlattr*)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if(tb == NULL || len == 0){
+            ALOGE("ERROR\n");
+            return NL_SKIP;
+        }
+
+        struct nlattr *tb_vendor[NXP_ATTR_PACKET_FILTER_MAX + 1];
+        nla_parse(tb_vendor, NXP_ATTR_PACKET_FILTER_MAX, tb, len, NULL);
+        if (!tb_vendor[NXP_ATTR_PACKET_FILTER_VERSION]){
+            ALOGE("%s: NXP_ATTR_PACKET_FILTER_VERSION not found", __FUNCTION__);
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        *mVersion = nla_get_u32(tb_vendor[NXP_ATTR_PACKET_FILTER_VERSION]);
+        if (!tb_vendor[NXP_ATTR_PACKET_FILTER_MAX_LEN]) {
+            ALOGE("%s: NXP_ATTR_PACKET_FILTER_MAX_LEN not found", __FUNCTION__);
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        *mMax_len = nla_get_u32(tb_vendor[NXP_ATTR_PACKET_FILTER_MAX_LEN]);
+        return NL_OK;
+    }
+};
+
+class GetValidChannels : public WifiCommand
+{
+private:
+    int Band;
+    int maxChannels;
+    wifi_channel *Channels;
+    int *numChannels;
+
+public:
+    GetValidChannels(wifi_interface_handle iface, int band, int max_channels,
+                           wifi_channel *channels, int *num_channels)
+    : WifiCommand("GetValidChannels", iface, 0)
+{
+    Band = band;
+    maxChannels = max_channels;
+    numChannels = num_channels;
+    Channels = channels;
+    memset(Channels, 0, sizeof(wifi_channel) * maxChannels);
+}
+    virtual int create() {
+        int ret = 0;
+        ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_GET_VALID_CHANNELS);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get valid channels - %d", ret);
+            return ret;
+        }
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put_u32(NXP_ATTR_VALID_CHANNELS_BAND, Band);
+        if (ret < 0) {
+            return ret;
+        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+        nlattr *vendor_data = (nlattr *)reply.get_data(NL80211_ATTR_VENDOR_DATA);
+        int len = reply.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in command response");
+            return NL_SKIP;
+        }
+        struct nlattr *tb_vendor[NXP_ATTR_WIFI_COMMON_MAX + 1];
+        nla_parse(tb_vendor, NXP_ATTR_WIFI_COMMON_MAX, vendor_data, len, NULL);
+        if(!tb_vendor[NXP_ATTR_VALID_CHANNELS_NUM_CHANNELS]){
+            ALOGE("NXP_ATTR_VALID_CHANNELS_NUM_CHANNELS not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        *numChannels= nla_get_u32(tb_vendor[NXP_ATTR_VALID_CHANNELS_NUM_CHANNELS]);
+        if(*numChannels > maxChannels)
+            *numChannels = maxChannels;
+        if(!tb_vendor[NXP_ATTR_VALID_CHANNEL_LIST]){
+            ALOGE("NXP_ATTR_VALID_CHANNEL_LIST not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        memcpy(Channels, (wifi_channel *)nla_data(tb_vendor[NXP_ATTR_VALID_CHANNEL_LIST]), 
+                sizeof(wifi_channel) * (*numChannels));
+        return NL_OK;
+    }
+};
+
+static int wifi_get_multicast_id(wifi_handle handle, const char *name, const char *group)
+{
+    GetMulticastIdCommand cmd(handle, name, group);
+    int res = cmd.requestResponse();
+    if (res < 0)
+        return res;
+    else
+        return cmd.getId();
+}
+
+/////////////////////////////////////////////////////////////////////////
+
+static bool is_wifi_interface(const char *name)
+{
+    if (strncmp(name, "wlan", 4) != 0 && strncmp(name, "p2p", 3) != 0 &&
+          strncmp(name, "mlan", 4) != 0 && strncmp(name, "nan", 3) != 0 &&
+	  strncmp(name, "uap", 3) != 0) {
+        /* not a wifi interface; ignore it */
+        return false;
+    } else {
+        return true;
+    }
+}
+
+static int get_interface(const char *name, interface_info *info)
+{
+    strcpy(info->name, name);
+    info->id = if_nametoindex(name);
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_init_interfaces(wifi_handle handle)
+{
+    hal_info *info = (hal_info *)handle;
+
+    struct dirent *de;
+
+    DIR *d = opendir("/sys/class/net");
+    if (d == 0)
+        return WIFI_ERROR_UNKNOWN;
+
+    int n = 0;
+    while ((de = readdir(d))) {
+        if (de->d_name[0] == '.')
+            continue;
+        if (is_wifi_interface(de->d_name) ) {
+            n++;
+        }
+    }
+
+    closedir(d);
+
+    if (n == 0)
+        return WIFI_ERROR_NOT_AVAILABLE;
+
+    d = opendir("/sys/class/net");
+    if (d == 0)
+        return WIFI_ERROR_UNKNOWN;
+
+    info->interfaces = (interface_info **)malloc(sizeof(interface_info *) * n);
+
+    int i = 0;
+    while ((de = readdir(d))) {
+        if (de->d_name[0] == '.')
+            continue;
+        if (is_wifi_interface(de->d_name)) {
+            interface_info *ifinfo = (interface_info *)malloc(sizeof(interface_info));
+            if (get_interface(de->d_name, ifinfo) != WIFI_SUCCESS) {
+                free(ifinfo);
+                continue;
+            }
+            ifinfo->handle = handle;
+            info->interfaces[i] = ifinfo;
+            i++;
+        }
+    }
+
+    closedir(d);
+    ALOGV("Found %d interfaces", n);
+    info->num_interfaces = n;
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_get_ifaces(wifi_handle handle, int *num, wifi_interface_handle **interfaces)
+{
+    hal_info *info = (hal_info *)handle;
+
+    *interfaces = (wifi_interface_handle *)info->interfaces;
+    *num = info->num_interfaces;
+
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_get_iface_name(wifi_interface_handle handle, char *name, size_t size)
+{
+    interface_info *info = (interface_info *)handle;
+    strcpy(name, info->name);
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_get_supported_feature_set(wifi_interface_handle handle, feature_set *set)
+{
+    int ret = 0;
+    GetSupportedFeatureSet getFeatureSet(handle, set);
+    ret = getFeatureSet.requestResponse();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_concurrency_matrix(wifi_interface_handle handle, int set_size_max,
+       feature_set set[], int *set_size)
+{
+    int ret = 0;
+    GetConcurrencyMatrix getConcurrencyMatrix(handle, set_size_max, set, set_size);
+    ret = getConcurrencyMatrix.requestResponse();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_set_scanning_mac_oui(wifi_interface_handle handle, oui scan_oui)
+{
+    int ret = 0;
+    SetScanningMacOui SetMacOui(handle, scan_oui);
+    ret = SetMacOui.requestResponse();
+    return (wifi_error) ret;
+
+}
+
+wifi_error wifi_set_nodfs_flag(wifi_interface_handle handle, u32 nodfs)
+{
+    int ret = 0;
+    SetNodfsFlag NodsFlag(handle, nodfs);
+    ret = NodsFlag.requestResponse();
+    return (wifi_error) ret;
+}
+
+wifi_error wifi_configure_nd_offload(wifi_interface_handle iface, u8 enable)
+{
+    int ret = 0;
+    ConfigureNdOffLoad NdOffload(iface, enable);
+    ret = NdOffload.requestResponse();
+    return (wifi_error) ret;
+}
+
+wifi_error wifi_set_country_code(wifi_interface_handle handle, const char *country_code)
+{
+    if(!country_code){
+        ALOGE("country_code is NULL");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    SetCountryCodeCommand command(handle, country_code);
+    return (wifi_error) command.requestResponse();
+}
+
+wifi_error wifi_start_rssi_monitoring(wifi_request_id id, wifi_interface_handle
+                        iface, s8 max_rssi, s8 min_rssi, wifi_rssi_event_handler eh)
+{
+    int ret = 0;
+    wifi_handle handle = getWifiHandle(iface);
+    RSSIMonitorControl *StartRSSI = new RSSIMonitorControl(id, iface, max_rssi, 
+                                                           min_rssi, eh);
+    wifi_register_cmd(handle, id, StartRSSI);
+    ret = StartRSSI->start();
+    return (wifi_error)ret;
+}
+
+
+wifi_error wifi_stop_rssi_monitoring(wifi_request_id id, wifi_interface_handle iface)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    wifi_rssi_event_handler handler;
+    memset(&handler, 0, sizeof(handler));
+    RSSIMonitorControl *StopRSSI = new RSSIMonitorControl(id, iface);
+    StopRSSI->cancel_specific(0, 0);
+    StopRSSI->releaseRef();
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_set_packet_filter(wifi_interface_handle iface, const u8* program, u32 len)
+{
+    int ret = 0;
+    /* len=0 clears the filters in driver/firmware */
+    if(len != 0 && program == NULL){
+        ALOGE("No valid program provided");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    SetPacketFilterCommand SetFilter (iface, program, len);
+    ret = SetFilter.requestResponse();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_packet_filter_capabilities(wifi_interface_handle handle, u32 *version, u32 *max_len)
+{
+    int ret = 0;
+    if(version == NULL || max_len == NULL) {
+        ALOGE("Error! The input version/max_len is NULL");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    GetPacketFilterCapaCommand *GetCapa= new GetPacketFilterCapaCommand(handle, version, max_len);
+    ret = GetCapa->start();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_valid_channels(wifi_interface_handle handle,
+        int band, int max_channels, wifi_channel *channels, int *num_channels)
+{
+    int ret = 0;
+    if(!max_channels || channels == NULL){
+        ALOGE("Error! The input channels is NULL or max_channel is zero");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    GetValidChannels ValidChannels(handle, band, max_channels, channels, num_channels);
+    ret = ValidChannels.requestResponse();
+    return (wifi_error) ret;
+}
+
+/////////////////////////////////////////////////////////////////////////////
diff --git a/88x9098/wlan/hal/wifi_hal/wifi_logger.cpp b/88x9098/wlan/hal/wifi_hal/wifi_logger.cpp
new file mode 100644
index 0000000..c26ae65
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/wifi_logger.cpp
@@ -0,0 +1,1437 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include "nl80211_copy.h"
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+#include <utils/String8.h>
+
+using namespace android;
+#define MEM_DUMP_CHUNK_SIZE (4 * 1024)
+#define MEM_DUMP_PATH_LENGTH      128
+#define DEFAULT_CMD_EVENT_WAKE_CNT_SZ 32
+#define DEFAULT_DRIVER_FW_LOCAL_WAKE_CNT_SZ 32
+
+typedef enum {
+    NXP_ATTR_LOGGER_INVALID = 0,
+    NXP_ATTR_LOGGER_RING_ID,
+    NXP_ATTR_LOGGER_FLAGS,
+    NXP_ATTR_LOGGER_VERBOSE_LEVEL,
+    NXP_ATTR_LOGGER_MIN_DATA_SIZE,
+    NXP_ATTR_LOGGER_RING_BUFFER_STATUS,
+    NXP_ATTR_LOGGER_NUM_RINGS,
+    NXP_ATTR_LOGGER_FEATURE_SET,
+    NXP_ATTR_LOGGER_MAX_INTERVAL_SEC,
+    NXP_ATTR_LOGGER_RING_BUFFER,
+    NXP_ATTR_LOGGER_NAME,
+    NXP_ATTR_MEM_DUMP,
+    NXP_ATTR_LOGGER_ERR_CODE,
+    NXP_ATTR_LOGGER_RING_DATA,
+    NXP_ATTR_LOGGER_WAKE_REASON_STAT,
+    NXP_ATTR_LOGGER_TX_REPORT_BUFFS,
+    NXP_ATTR_LOGGER_RX_REPORT_BUFFS,
+    NXP_ATTR_LOGGER_PKT_FATE_FRAME_CONTENT,
+    NXP_ATTR_LOGGER_FW_DUMP_PATH = 20,
+    NXP_ATTR_LOGGER_DRV_DUMP_PATH = 21,
+
+    NXP_ATTR_WIFI_LOGGER_AFTER_LAST,
+    NXP_ATTR_WIFI_LOGGER_MAX = 
+    NXP_ATTR_WIFI_LOGGER_AFTER_LAST - 1
+} LOGGER_ATTRIBUTE;
+
+typedef enum {
+    NXP_EVENT_RING_BUFFER_DATA = 0x1000b,
+    NXP_EVENT_ALERT,
+    NXP_EVENT_START_PKT_FATE,
+    NXP_EVENT_WAKE_REASON_REPORT,
+} LOGGER_EVENT;
+
+typedef enum {
+    FW_VERSION,
+    DRV_VERSION,
+    RING_DATA,
+    RING_STATUS,
+    GET_FEATURE,
+    START_LOGGING,
+    FW_MEM_DUMP,
+    DRV_MEM_DUMP,
+} CmdType;
+
+typedef enum
+{
+    NO_HSWAKEUP_REASON = 0,     //0.unknown 
+    BCAST_DATA_MATCHED,         // 1. Broadcast data matched
+    MCAST_DATA_MATCHED,         // 2. Multicast data matched
+    UCAST_DATA_MATCHED,         // 3. Unicast data matched
+    MASKTABLE_EVENT_MATCHED,    // 4. Maskable event matched
+    NON_MASKABLE_EVENT_MATCHED, // 5. Non-maskable event matched
+    NON_MASKABLE_CONDITION_MATCHED, // 6. Non-maskable condition matched (EAPoL rekey)
+    MAGIC_PATTERN_MATCHED,      // 7. Magic pattern matched
+    CONTROL_FRAME_MATCHED,      // 8. Control frame matched
+    MANAGEMENT_FRAME_MATCHED,   // 9. Management frame matched
+    GTK_REKEY_FAILURE,          //10. GTK rekey failure
+    RESERVED                    // Others: reserved
+} HSWakeupReason_t;
+
+///////////////////////////////////////////////////////////////////////////////
+class LoggerGetVersion : public WifiCommand
+{
+private:
+    char *Buffer;
+    int bufferSize;
+    CmdType Type;
+
+public:
+    LoggerGetVersion(wifi_interface_handle iface, char *buffer, 
+                           int buffer_size, CmdType type)
+    : WifiCommand("LoggerGetVersion", iface, 0)
+    {
+        Buffer = buffer;
+        bufferSize = buffer_size;
+        Type = type;
+        memset(Buffer, 0, bufferSize);
+    }
+
+    virtual int create(){
+        int result = 0;
+        switch(Type){
+            case FW_VERSION:
+            {
+                result = mMsg.create(MARVELL_OUI, NXP_SUBCMD_GET_FW_VERSION);
+                if (result < 0) {
+                    ALOGE("Failed to create message to get fw version - %d", result);
+                    return result;
+                }
+                 break;
+             }
+            case DRV_VERSION:
+            {
+                result = mMsg.create(MARVELL_OUI, NXP_SUBCMD_GET_DRIVER_VERSION);
+                if (result < 0) {
+                    ALOGE("Failed to create message to get driver version - %d", result);
+                    return result;
+                }
+                 break;
+            }
+            default:
+                ALOGE("Unknow command");
+                return WIFI_ERROR_UNKNOWN;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply){
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGW("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        nlattr *tb = (nlattr*)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if(tb == NULL || len == 0){
+            ALOGE("ERROR! No data in command response");
+            return NL_SKIP;
+        }
+
+        struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX];
+        int status = WIFI_ERROR_NONE;
+        nla_parse(tb_vendor, (NXP_ATTR_WIFI_LOGGER_MAX-1),tb, len, NULL);
+        if (bufferSize < len)
+           return NL_SKIP;
+        bufferSize = len;
+        if (!tb_vendor[NXP_ATTR_LOGGER_NAME]){
+            ALOGE("NXP_ATTR_NAME not found");
+            status = WIFI_ERROR_INVALID_ARGS;
+            return status;
+        }
+        memcpy(Buffer, nla_data(tb_vendor[NXP_ATTR_LOGGER_NAME]) ,bufferSize);
+        return NL_OK;
+    }
+};
+
+class LoggerCommand : public WifiCommand
+{
+private:
+    u32 *numRings;
+    wifi_ring_buffer_status *ringStatus;
+    unsigned int *Support;
+    u32 verboseLevel;
+    u32 Flags;
+    u32 maxIntervalSec;
+    u32 minDataSize;
+    char *ringName;
+    CmdType Type;
+
+public:
+    // constructor for ring data
+    LoggerCommand(wifi_interface_handle iface, char *ring_name, CmdType cmdType)
+        : WifiCommand("LoggerCommand", iface, 0)
+    {
+        ringName = ring_name;
+        Type = cmdType;
+        numRings = NULL;
+        ringStatus = NULL;
+        Support = NULL;
+        verboseLevel = 0;
+        Flags = 0;
+        maxIntervalSec = 0;
+        minDataSize = 0;
+    }
+
+    // constructor for ring status
+    LoggerCommand(wifi_interface_handle iface, u32 *num_rings,
+                         wifi_ring_buffer_status *status, CmdType cmdType)
+        : WifiCommand("LoggerCommand", iface, 0)
+    {
+        numRings = num_rings;
+        ringStatus = status;
+        Type = cmdType;
+        Support = NULL;
+        verboseLevel = 0;
+        Flags = 0;
+        maxIntervalSec = 0;
+        minDataSize = 0;
+        ringName = NULL;
+    }
+
+    // constructor for feature set
+    LoggerCommand(wifi_interface_handle iface, unsigned int *support,
+                          CmdType cmdType)
+        : WifiCommand("LoggerCommand", iface, 0)
+    {
+        Support = support;
+        Type = cmdType;
+        numRings = NULL;
+        ringStatus = NULL;
+        verboseLevel = 0;
+        Flags = 0;
+        maxIntervalSec = 0;
+        minDataSize = 0;
+        ringName = NULL;
+    }
+
+    // constructor for start logging
+    LoggerCommand(wifi_interface_handle iface, u32 verbose_level, u32 flags,
+                          u32 max_interval_sec, u32 min_data_size, char *ring_name,
+                          CmdType cmdType)
+        : WifiCommand("LoggerCommand", iface, 0)
+    {
+        verboseLevel = verbose_level;
+        Flags = flags;
+        maxIntervalSec = max_interval_sec;
+        minDataSize = min_data_size;
+        ringName = ring_name;
+        Type = cmdType;
+        numRings = NULL;
+        ringStatus = NULL;
+        Support = NULL;
+    }
+
+    int createRequest(WifiRequest &request) {
+        int result = 0;
+        switch (Type) {
+            case RING_DATA:
+            {
+                result = request.create(MARVELL_OUI, NXP_SUBCMD_GET_RING_DATA);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create message to get ring data - %d", result);
+                    return result;
+                }
+
+                nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+                result = request.put_string(NXP_ATTR_LOGGER_RING_ID, ringName);
+                if (result != WIFI_SUCCESS)
+                    return result;
+                request.attr_end(data);
+                break;
+            }
+
+            case RING_STATUS:
+            {
+                result = request.create(MARVELL_OUI, NXP_SUBCMD_GET_RING_STATUS);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create message to get ring status - %d", result);
+                    return result;
+                }
+                break;
+            }
+
+            case GET_FEATURE:
+            {
+                result = request.create(MARVELL_OUI, NXP_SUBCMD_GET_LOGGER_FEATURE_SET);
+                if (result < 0) {
+                    ALOGE("Failed to create message to get logger feature set - %d", result);
+                    return result;
+                }
+                break;
+            }
+
+            case START_LOGGING:
+            {
+                result = request.create(MARVELL_OUI, NXP_SUBCMD_START_LOGGING);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create request to start logging - %d", result);
+                    return result;
+                }
+                nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+                result = request.put_u32(NXP_ATTR_LOGGER_VERBOSE_LEVEL, verboseLevel);
+                if (result != WIFI_SUCCESS)
+                    return result;
+                result = request.put_u32(NXP_ATTR_LOGGER_FLAGS, Flags);
+                if (result != WIFI_SUCCESS)
+                    return result;
+                result = request.put_u32(NXP_ATTR_LOGGER_MAX_INTERVAL_SEC, maxIntervalSec);
+                if (result != WIFI_SUCCESS)
+                    return result;
+                result = request.put_u32(NXP_ATTR_LOGGER_MIN_DATA_SIZE, minDataSize);
+                if (result != WIFI_SUCCESS)
+                    return result;
+                result = request.put_string(NXP_ATTR_LOGGER_RING_ID, ringName);
+                if (result != WIFI_SUCCESS)
+                    return result;
+                request.attr_end(data);
+                break;
+            }
+            default:
+                ALOGE("Unknown Debug command");
+                result = WIFI_ERROR_UNKNOWN;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    int start() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("Failed to create debug request; result = %d", result);
+            return result;
+        }
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("Failed to register debug response; result = %d", result);
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        switch (Type) {
+            case START_LOGGING:
+            case RING_DATA:
+                break;
+            case RING_STATUS:
+            {
+                nlattr *vendor_data = (nlattr *)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+                int len = reply.get_vendor_data_len();
+                unsigned int num_rings = 0;
+                if (vendor_data == NULL || len == 0) {
+                    ALOGE("No Debug data found");
+                    return NL_SKIP;
+                }
+
+                struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+                nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+                if(!tb_vendor[NXP_ATTR_LOGGER_NUM_RINGS]){
+                    ALOGE("NXP_ATTR_LOGGER_NUM_RINGS not found");
+                    return NL_SKIP;
+                }
+                num_rings = nla_get_u32(tb_vendor[NXP_ATTR_LOGGER_NUM_RINGS]);
+                if(*numRings < num_rings){
+                    ALOGE("Not enough status buffers provided, available: %d", (*numRings));
+                    return NL_SKIP;
+                }
+
+                *numRings = num_rings;
+                if(!tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER_STATUS]){
+                    ALOGE("NXP_ATTR_LOGGER_RING_BUFFER_STATUS not found");
+                    return NL_SKIP;
+                }
+                int total_len = 0;
+                total_len = (*numRings) * sizeof(wifi_ring_buffer_status);
+                memset(ringStatus, 0, total_len);
+                memcpy(ringStatus, (void *)nla_data(tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER_STATUS]),
+                       total_len);
+                break;
+            }
+            case GET_FEATURE:
+            {
+                int len = reply.get_vendor_data_len();
+                struct nlattr *vendor_data = (nlattr *)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+                if(vendor_data == NULL || len == 0){
+                    ALOGE("ERROR! No data in get feature command response\n");
+                    return NL_SKIP;
+                }
+                struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+                nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+                if(!tb_vendor[NXP_ATTR_LOGGER_FEATURE_SET]){
+                    ALOGE("NXP_ATTR_WIFI_LOGGER_FEATURE_SET not found\n");
+                    return NL_SKIP;
+                }
+                *Support = nla_get_u32(tb_vendor[NXP_ATTR_LOGGER_FEATURE_SET]);
+                ALOGE("get supported feature = 0x%x\n", (*Support));
+                break;
+            }
+            default:
+                ALOGW("Unknown Logger command");
+        }
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_get_firmware_version(wifi_interface_handle iface, 
+                                            char *buffer, int buffer_size)
+{
+   int ret = 0;
+    if(!buffer || (buffer_size < 0)){
+        ALOGE("buffer is NULL or invalid buffer size\n");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    LoggerGetVersion FwVersion(iface, buffer, buffer_size, FW_VERSION);
+    ret = FwVersion.requestResponse();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_driver_version(wifi_interface_handle iface, 
+                                        char *buffer, int buffer_size)
+{
+     int ret = 0;
+    if(!buffer || (buffer_size < 0)){
+        ALOGE("buffer is NULL or invalid buffer size");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    LoggerGetVersion DrvVersion(iface, buffer, buffer_size, DRV_VERSION);
+    ret = DrvVersion.requestResponse();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_ring_data(wifi_interface_handle iface, char *ring_name)
+{
+    int ret = 0;
+    if(!ring_name){
+        ALOGE("ring_name is NULL");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    LoggerCommand *RingData = new LoggerCommand(iface, ring_name, RING_DATA);
+    ret = RingData->start();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_ring_buffers_status(wifi_interface_handle iface, u32 *num_rings,
+                                              wifi_ring_buffer_status *status)
+{
+    int ret = 0;
+    if(!status || !(*num_rings)){
+        ALOGE("Ring status buffer NULL or num_rings is zero");
+        return  WIFI_ERROR_INVALID_ARGS;
+    }
+    LoggerCommand *RingStatus = new LoggerCommand(iface, num_rings, status, RING_STATUS);
+    ret = RingStatus->start();
+        return (wifi_error)ret;
+}
+
+/* API to get supportable feature */
+wifi_error wifi_get_logger_supported_feature_set(wifi_interface_handle iface,
+                                                          unsigned int *support)
+{
+    int ret = 0;
+    if(!support){
+        ALOGE("Logger support feature set buffer is NULL");
+        return  WIFI_ERROR_INVALID_ARGS;
+    }
+    LoggerCommand *FeatureSet = new LoggerCommand(iface, support, GET_FEATURE);
+    ret = FeatureSet->start();
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_start_logging(wifi_interface_handle iface, u32 verbose_level,
+                                  u32 flags, u32 max_interval_sec,
+                                  u32 min_data_size, char *ring_name)
+{
+    int ret = 0;
+    if(!ring_name){
+        ALOGE("Ring name is NULL");
+        return  WIFI_ERROR_INVALID_ARGS;
+    }
+    LoggerCommand *Start = new LoggerCommand(iface, verbose_level, flags, max_interval_sec,
+                                             min_data_size, ring_name, START_LOGGING);
+    ret = Start->start();
+    return (wifi_error)ret;
+}
+class StartPktFateCommand : public WifiCommand
+{
+public:
+    StartPktFateCommand(wifi_interface_handle handle)
+    : WifiCommand("StartPktFateCommand", handle, 0)
+    { }
+
+    int createRequest(WifiRequest& request) {
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_START_PKT_FATE_MONITORING);
+        if (result < 0) {
+            ALOGE("Failed to create message to start packet fate monitor");
+            return result;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int start(){
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result < 0)
+            return result;
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGE("Failed to start packet fate, result = %d", result);
+            return result;
+        }
+        registerVendorHandler(MARVELL_OUI, NXP_EVENT_START_PKT_FATE);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+       hal_info *info = mInfo;
+       if (event.get_cmd() != NL80211_CMD_VENDOR) {
+           ALOGE("Ignoring reply with cmd = %d", event.get_cmd());
+       return NL_SKIP;
+       }
+
+       nlattr *vendor_data =(nlattr *) (event.get_data(NL80211_ATTR_VENDOR_DATA));
+       int len = event.get_vendor_data_len();
+       if (vendor_data == NULL || len == 0) {
+            ALOGE("Start packet fate: No data");
+            return NL_SKIP;
+        }
+
+        struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+        struct nlattr *nla = NULL;
+        nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+        nla = tb_vendor[NXP_ATTR_LOGGER_TX_REPORT_BUFFS];
+        if(nla){
+            memcpy(&info->pkt_fate_stats->tx_fate_stats[info->pkt_fate_stats->n_tx_stats_collected],
+                    (wifi_tx_report_i *)nla_data(nla), nla->nla_len);
+            info->pkt_fate_stats->tx_fate_stats[info->pkt_fate_stats->n_tx_stats_collected].frame_inf.frame_content = NULL;
+            if(tb_vendor[NXP_ATTR_LOGGER_PKT_FATE_FRAME_CONTENT]){
+                info->pkt_fate_stats->tx_fate_stats[info->pkt_fate_stats->n_tx_stats_collected].frame_inf.frame_content\
+                = (char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_PKT_FATE_FRAME_CONTENT]);
+                int ftypetx =(int)(info->pkt_fate_stats->tx_fate_stats[info->pkt_fate_stats->n_tx_stats_collected].frame_inf.payload_type);
+                if ((ftypetx != FRAME_TYPE_ETHERNET_II) && (ftypetx != FRAME_TYPE_80211_MGMT)) {
+                     info->pkt_fate_stats->tx_fate_stats[info->pkt_fate_stats->n_tx_stats_collected].frame_inf.payload_type = FRAME_TYPE_UNKNOWN;
+                }
+                info->pkt_fate_stats->n_tx_stats_collected ++;
+                info->pkt_fate_stats->n_tx_stats_collected %= MAX_FATE_LOG_LEN;
+            }
+        }
+        nla = tb_vendor[NXP_ATTR_LOGGER_RX_REPORT_BUFFS];
+        if(nla){
+            memcpy(&info->pkt_fate_stats->rx_fate_stats[info->pkt_fate_stats->n_rx_stats_collected],
+                    (wifi_rx_report_i *)nla_data(nla), nla->nla_len);
+            info->pkt_fate_stats->rx_fate_stats[info->pkt_fate_stats->n_rx_stats_collected].frame_inf.frame_content = NULL;
+            if(tb_vendor[NXP_ATTR_LOGGER_PKT_FATE_FRAME_CONTENT]){
+                info->pkt_fate_stats->rx_fate_stats[info->pkt_fate_stats->n_rx_stats_collected].frame_inf.frame_content\
+                = (char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_PKT_FATE_FRAME_CONTENT]);
+                int ftyperx =(int)(info->pkt_fate_stats->rx_fate_stats[info->pkt_fate_stats->n_rx_stats_collected].frame_inf.payload_type);
+                if ((ftyperx != FRAME_TYPE_ETHERNET_II) && (ftyperx != FRAME_TYPE_80211_MGMT)) {
+                     info->pkt_fate_stats->rx_fate_stats[info->pkt_fate_stats->n_rx_stats_collected].frame_inf.payload_type = FRAME_TYPE_UNKNOWN;
+                }
+                info->pkt_fate_stats->n_rx_stats_collected ++;
+                info->pkt_fate_stats->n_rx_stats_collected %= MAX_FATE_LOG_LEN; 
+            }
+        }
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_start_pkt_fate_monitoring(wifi_interface_handle handle)
+{
+    wifi_handle wifiHandle = getWifiHandle(handle);
+    hal_info *info = getHalInfo(wifiHandle);
+
+    if (info->fate_monitoring_enabled == true) {
+        ALOGW("Packet monitoring is already enabled");
+        return WIFI_SUCCESS;
+    }
+    StartPktFateCommand *cmd = new StartPktFateCommand(handle);
+    if (cmd) {
+        wifi_register_cmd(wifiHandle, 0, cmd);
+        wifi_error result = (wifi_error)cmd->start();
+        if (result != WIFI_SUCCESS)
+            wifi_unregister_cmd(wifiHandle, 0);
+        info->pkt_fate_stats = (packet_fate_monitor_info *) malloc (
+                                              sizeof(packet_fate_monitor_info));
+        if (info->pkt_fate_stats == NULL) {
+            ALOGE("Failed to allocate memory for : %zu bytes",
+                  sizeof(packet_fate_monitor_info));
+            return WIFI_ERROR_OUT_OF_MEMORY;
+        }
+        memset(info->pkt_fate_stats, 0, sizeof(packet_fate_monitor_info));
+        pthread_mutex_lock(&info->pkt_fate_stats_lock);
+        info->fate_monitoring_enabled = true;
+        pthread_mutex_unlock(&info->pkt_fate_stats_lock);
+        return result;
+    } else {
+        ALOGE("Out of memory");
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+}
+
+class StartWakeReasonCnt : public WifiCommand
+{
+public:
+    StartWakeReasonCnt(wifi_handle handle)
+        : WifiCommand("StartWakeReasonCnt", handle, 0)
+    {
+        mInfo = getHalInfo(handle);
+    }
+
+    virtual int start(){
+        registerVendorHandler(MARVELL_OUI, NXP_EVENT_WAKE_REASON_REPORT);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleEvent(WifiEvent &event){
+        u16 reason = 0;
+        WLAN_DRIVER_WAKE_REASON_CNT *mWifiWakeReasonCnt = mInfo->wifi_wake_reason_cnt;
+        nlattr *vendor_data = (nlattr *)event.get_data(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("No data found");
+            return NL_SKIP;
+        }
+
+        struct nlattr* tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+        nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+
+        if (!tb_vendor[NXP_ATTR_LOGGER_WAKE_REASON_STAT]){
+            ALOGE("NXP_ATTR_LOGGER_WAKE_REASON_STAT not found");
+            return WIFI_ERROR_INVALID_ARGS;
+        }
+        reason = nla_get_u16(tb_vendor[NXP_ATTR_LOGGER_WAKE_REASON_STAT]);
+        switch (reason) {
+            case BCAST_DATA_MATCHED:
+                mWifiWakeReasonCnt->total_rx_data_wake++;
+                mWifiWakeReasonCnt->rx_wake_details.rx_broadcast_cnt++;
+                break;
+            case MCAST_DATA_MATCHED:
+                mWifiWakeReasonCnt->total_rx_data_wake++;
+                mWifiWakeReasonCnt->rx_wake_details.rx_multicast_cnt++;
+                break;
+            case UCAST_DATA_MATCHED:
+                mWifiWakeReasonCnt->total_rx_data_wake++;
+                mWifiWakeReasonCnt->rx_wake_details.rx_unicast_cnt++;
+                break;
+            case MASKTABLE_EVENT_MATCHED:
+            case NON_MASKABLE_EVENT_MATCHED:
+                mWifiWakeReasonCnt->total_cmd_event_wake++;
+                if (mWifiWakeReasonCnt->cmd_event_wake_cnt_used < mWifiWakeReasonCnt->cmd_event_wake_cnt_sz - 1) {
+                    mWifiWakeReasonCnt->cmd_event_wake_cnt[mWifiWakeReasonCnt->cmd_event_wake_cnt_used++] =
+                         reason;
+                } else {
+                    ALOGE("cmd_event_wake_cnt_used reached its size at %d",
+                           mWifiWakeReasonCnt->cmd_event_wake_cnt_used);
+                }
+                break;
+            case NON_MASKABLE_CONDITION_MATCHED:
+            case MAGIC_PATTERN_MATCHED:
+            case CONTROL_FRAME_MATCHED:
+            case MANAGEMENT_FRAME_MATCHED:
+            case GTK_REKEY_FAILURE:
+            case NO_HSWAKEUP_REASON:
+                mWifiWakeReasonCnt->total_driver_fw_local_wake++;
+                if (mWifiWakeReasonCnt->driver_fw_local_wake_cnt_used <
+                    mWifiWakeReasonCnt->driver_fw_local_wake_cnt_sz - 1) {
+                    mWifiWakeReasonCnt
+                        ->driver_fw_local_wake_cnt[mWifiWakeReasonCnt->driver_fw_local_wake_cnt_used++] =
+                        reason;
+                } else {
+                    ALOGE("driver_fw_local_wake_cnt_used reached its size at %d",
+                           mWifiWakeReasonCnt->driver_fw_local_wake_cnt_used);
+                }
+                break;
+            default:
+                break;
+        }
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_start_wake_reason_cnt(hal_info *info)
+{
+    WLAN_DRIVER_WAKE_REASON_CNT *mWifiWakeReasonCnt = NULL;
+
+    mWifiWakeReasonCnt = (WLAN_DRIVER_WAKE_REASON_CNT *)malloc(sizeof(WLAN_DRIVER_WAKE_REASON_CNT));
+    if (!(mWifiWakeReasonCnt)) {
+        ALOGE("WiFi Logger: wake_reason_stat alloc failed");
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+    memset(mWifiWakeReasonCnt, 0, sizeof(WLAN_DRIVER_WAKE_REASON_CNT));
+
+    mWifiWakeReasonCnt->cmd_event_wake_cnt = (int*)malloc(sizeof(int) * DEFAULT_CMD_EVENT_WAKE_CNT_SZ);
+    if (mWifiWakeReasonCnt->cmd_event_wake_cnt == NULL) {
+        ALOGE("WiFi Logger: wake_reason_stat cmd_event_wake_cnt alloc failed");
+        free(mWifiWakeReasonCnt);
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+    memset(mWifiWakeReasonCnt->cmd_event_wake_cnt, 0, sizeof(int) * DEFAULT_CMD_EVENT_WAKE_CNT_SZ);
+    mWifiWakeReasonCnt->cmd_event_wake_cnt_sz = DEFAULT_CMD_EVENT_WAKE_CNT_SZ;
+
+    mWifiWakeReasonCnt->driver_fw_local_wake_cnt = (int*)malloc(sizeof(int) * DEFAULT_DRIVER_FW_LOCAL_WAKE_CNT_SZ);
+    if (!(mWifiWakeReasonCnt->driver_fw_local_wake_cnt)) {
+        ALOGE("WiFi Logger: wake_reason_stat driver_fw_local_wake_cnt alloc failed");
+        free(mWifiWakeReasonCnt->cmd_event_wake_cnt);
+        free(mWifiWakeReasonCnt);
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+    memset(mWifiWakeReasonCnt->driver_fw_local_wake_cnt, 0, 
+           sizeof(int) * DEFAULT_DRIVER_FW_LOCAL_WAKE_CNT_SZ);
+    mWifiWakeReasonCnt->driver_fw_local_wake_cnt_sz = DEFAULT_DRIVER_FW_LOCAL_WAKE_CNT_SZ;
+    info->wifi_wake_reason_cnt = mWifiWakeReasonCnt;
+
+    wifi_handle handle = getWifiHandle(info);
+    StartWakeReasonCnt *cmd = new StartWakeReasonCnt(handle);
+    if (cmd) {
+        wifi_register_cmd(handle, 0, cmd);
+        wifi_error result = (wifi_error)cmd->start();
+        if (result != WIFI_SUCCESS)
+            wifi_unregister_cmd(handle, 0);
+        return result;
+    } else {
+        ALOGE("Out of memory");
+        free(mWifiWakeReasonCnt->driver_fw_local_wake_cnt);
+        free(mWifiWakeReasonCnt->cmd_event_wake_cnt);
+        free(mWifiWakeReasonCnt);
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////////
+class SetLogHandler : public WifiCommand
+{
+private:
+    wifi_ring_buffer_data_handler Handler;
+    wifi_ring_buffer_status buffStatus;
+    char *Buffer;
+    int bufferSize;
+
+public:
+    SetLogHandler(wifi_interface_handle iface, int id, 
+                       wifi_ring_buffer_data_handler handler)
+    : WifiCommand("SetLogHandler", iface, id)
+    {
+        Handler = handler;
+        memset(&buffStatus, 0, sizeof(wifi_ring_buffer_status));
+        Buffer = NULL;
+        bufferSize = 0;
+    }
+
+    int start() {
+        int ret = 0;
+        ALOGV("Register loghandler");
+        ret = registerVendorHandler(MARVELL_OUI, NXP_EVENT_RING_BUFFER_DATA);
+        if(ret < 0){
+            ALOGE("Failed to register vendor handler for NXP_EVENT_RING_BUFFER_DATA");
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int cancel() {
+        /* Send a command to driver to stop generating logging events */
+        ALOGV("Clear loghandler");
+        /* unregister event handler */
+        unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_RING_BUFFER_DATA);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        if (event.get_cmd() != NL80211_CMD_VENDOR) {
+           ALOGD("Ignoring reply with cmd = %d", event.get_cmd());
+           return NL_SKIP;
+        }
+
+        nlattr *vendor_data = (nlattr *)event.get_data(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+        int event_id = event.get_vendor_subcmd();
+
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in event");
+            return NL_SKIP;
+        }
+
+        if(event_id == NXP_EVENT_RING_BUFFER_DATA) {
+            struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+            nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+
+            if(!tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER_STATUS]){
+                ALOGE("NXP_ATTR_LOGGER_RING_BUFFER_STATUS not found");
+                return NL_SKIP;
+            }
+            memcpy(&buffStatus, (void *)nla_data(tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER_STATUS]),
+                    sizeof(buffStatus));
+            if(!tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER]){
+                ALOGE("NXP_ATTR_LOGGER_RING_BUFFER not found");
+                return NL_SKIP;
+            }
+            bufferSize = nla_len(tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER]);
+            Buffer = (char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_RING_BUFFER]);
+            if (Handler.on_ring_buffer_data)
+                (*Handler.on_ring_buffer_data)((char *)buffStatus.name, Buffer, bufferSize, &buffStatus);
+            } else {
+                ALOGE("Unknown Event");
+                return NL_SKIP;
+            }
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_set_log_handler(wifi_request_id id, 
+                                     wifi_interface_handle iface,
+                                     wifi_ring_buffer_data_handler handler)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    int ret = 0;
+
+    SetLogHandler *SetHandler = new SetLogHandler(iface, id, handler);
+    if (!SetHandler){
+        ALOGE("Out of memory");
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+    wifi_register_cmd(handle, id, SetHandler);
+    ret = SetHandler->start();
+    if (ret != WIFI_SUCCESS)
+        wifi_unregister_cmd(handle, id);
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_reset_log_handler(wifi_request_id id, wifi_interface_handle iface)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    ALOGV("Loghandler reset, wifi_request_id = %d, handle = %p", id, handle);
+    if (id == -1) {
+        wifi_ring_buffer_data_handler handler;
+        memset(&handler, 0, sizeof(handler));
+        SetLogHandler *Reset = new SetLogHandler(iface, id, handler);
+        Reset->cancel();
+        Reset->releaseRef();
+        return WIFI_SUCCESS;
+    }
+    return wifi_cancel_cmd(id, iface);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+class SetAlertHandler : public WifiCommand
+{
+private:
+    wifi_alert_handler Handler;
+    int buffSize;
+    char *Buff;
+    int errCode;
+
+public:
+    SetAlertHandler(wifi_interface_handle iface, int id, wifi_alert_handler handler)
+    : WifiCommand("SetAlertHandler", iface, id)
+    {
+        Handler = handler;
+        buffSize = 0;
+        Buff = NULL;
+        errCode = 0;
+    }
+
+    int start() {
+        int ret = 0;
+        ret = registerVendorHandler(MARVELL_OUI, NXP_EVENT_ALERT);
+        if(ret < 0){
+            ALOGE("Failed to register vendor handler for NXP_EVENT_ALERT");
+            return ret;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int cancel() {
+        /* unregister alert handler */
+        unregisterVendorHandler(MARVELL_OUI, NXP_EVENT_ALERT);
+        wifi_unregister_cmd(wifiHandle(), id());
+        ALOGV("Success to clear alerthandler");
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+
+        if (event.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", event.get_cmd());
+            return NL_SKIP;
+        }
+
+        nlattr *vendor_data = (nlattr *)event.get_data(NL80211_ATTR_VENDOR_DATA);
+        int len = event.get_vendor_data_len();
+        int event_id = event.get_vendor_subcmd();
+
+        ALOGV("len = %d", len);
+        if (vendor_data == NULL || len == 0) {
+            ALOGE("Error! No data in event");
+            return NL_SKIP;
+        }
+
+        if (event_id == NXP_EVENT_ALERT) {
+            struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+            nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+
+            if(!tb_vendor[NXP_ATTR_LOGGER_ERR_CODE]){
+                ALOGE("NXP_ATTR_LOGGER_ERR_CODE not found");
+                return NL_SKIP;
+            }
+            errCode = nla_get_u32(tb_vendor[NXP_ATTR_LOGGER_ERR_CODE]);
+            if(!tb_vendor[NXP_ATTR_LOGGER_RING_DATA]){
+                ALOGE("NXP_ATTR_LOGGER_RING_DATA not found");
+                return NL_SKIP;
+            }
+            buffSize = nla_len(tb_vendor[NXP_ATTR_LOGGER_RING_DATA]);
+            Buff = (char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_RING_DATA]);
+            if (Handler.on_alert) {
+                 (*Handler.on_alert)(id(), Buff, buffSize, errCode);
+             }
+        }
+        return NL_OK;
+    }
+};
+
+wifi_error wifi_set_alert_handler(wifi_request_id id, 
+                                      wifi_interface_handle iface,
+                                      wifi_alert_handler handler)
+{
+    int ret = 0;
+    wifi_handle handle = getWifiHandle(iface);
+    ALOGV("Alerthandler start, handle = %p", handle);
+    SetAlertHandler *SetAlert = new SetAlertHandler(iface, id, handler);
+    if(!SetAlert){
+        ALOGE("Out of memory");
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+    wifi_register_cmd(handle, id, SetAlert);
+    ret = SetAlert->start();
+    if (ret != WIFI_SUCCESS)
+        wifi_unregister_cmd(handle, id);
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_reset_alert_handler(wifi_request_id id, wifi_interface_handle iface)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    ALOGV("Alerthandler reset, wifi_request_id = %d, handle = %p", id, handle);
+
+    if (id == -1) {
+        wifi_alert_handler handler;
+        memset(&handler, 0, sizeof(handler));
+
+        SetAlertHandler *ResetAlert = new SetAlertHandler(iface, id, handler);
+        ResetAlert->cancel();
+        ResetAlert->releaseRef();
+        return WIFI_SUCCESS;
+    }
+
+    return wifi_cancel_cmd(id, iface);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+class MemoryDumpCommand: public WifiCommand
+{
+private:
+    wifi_firmware_memory_dump_handler Handler;
+    wifi_driver_memory_dump_callbacks Callbacks;
+    CmdType Type;
+    u32 buffSize;
+    char *Buff;
+    u32 mStatus;
+
+public:
+    //Constructor for get firmware memory dumps
+    MemoryDumpCommand(wifi_interface_handle iface, 
+                                 wifi_firmware_memory_dump_handler handler,
+                                 CmdType cmdType)
+        : WifiCommand("MemoryDumpCommand", iface, 0)
+    {
+        Handler = handler;
+        buffSize = 0;
+        Buff = NULL;
+        Type = cmdType;
+        // Callbacks.on_driver_memory_dump = NULL;
+        memset(&Callbacks, 0, sizeof(Callbacks));
+        mStatus = 0;
+    }
+
+    //Constructor for get driver memory dumps
+    MemoryDumpCommand(wifi_interface_handle iface, 
+                                 wifi_driver_memory_dump_callbacks callbacks,
+                                 CmdType cmdType)
+        : WifiCommand("MemoryDumpCommand", iface, 0)
+    {
+        Callbacks = callbacks;
+        buffSize = 0;
+        Buff = NULL;
+        Type = cmdType;
+        // Handler.on_firmware_memory_dump = NULL;
+        memset(&Handler, 0, sizeof(Handler));
+        mStatus = 0;
+    }
+
+    int createRequest(WifiRequest &request) {
+        int result = 0;
+        switch (Type) {
+            case FW_MEM_DUMP:
+            {
+                result = request.create(MARVELL_OUI, NXP_SUBCMD_GET_FW_MEM_DUMP);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create request to get firmware memory dump - %d\n", result);
+                    return result;
+                }
+                break;
+            }
+            case DRV_MEM_DUMP:
+            {
+                result = request.create(MARVELL_OUI, NXP_SUBCMD_GET_DRIVER_MEM_DUMP);
+                if (result != WIFI_SUCCESS) {
+                    ALOGE("Failed to create request to get driver memory dump - %d\n", result);
+                    return result;
+                }
+                break;
+            }
+            default:
+                ALOGE("Unknown Debug command");
+                result = WIFI_ERROR_UNKNOWN;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    int start() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result != WIFI_SUCCESS) {
+            return NL_SKIP;
+        }
+
+        result = requestResponse(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("Failed to register debug response; result = %d", result);
+            return NL_SKIP;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        FILE *dumpPtr = NULL;
+        u32 dumpRead = 0;
+        int remained = 0;
+        int path_len = 0;
+        char *buffer = NULL;
+        char full_path[MEM_DUMP_PATH_LENGTH];
+        long int ftell_ret_val = 0;
+
+        if (reply.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", reply.get_cmd());
+            return NL_SKIP;
+        }
+
+        nlattr *vendor_data = (nlattr *)(reply.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = reply.get_vendor_data_len();
+        if (vendor_data == NULL) {
+            ALOGE("Error! No data in command response");
+            return NL_SKIP;
+        }
+
+        switch(Type){
+            case FW_MEM_DUMP:
+            {
+                struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+                nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+                if(!tb_vendor[NXP_ATTR_LOGGER_FW_DUMP_PATH]){
+                    ALOGE("NXP_ATTR_LOGGER_FW_DUMP_PATH not found");
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                memset(full_path, 0, MEM_DUMP_PATH_LENGTH);
+                path_len = strlen((char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_FW_DUMP_PATH]));
+                if(path_len >= MEM_DUMP_PATH_LENGTH)
+                    return NL_SKIP;
+                strcpy(full_path, (char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_FW_DUMP_PATH]));
+                dumpPtr = fopen(full_path, "r");
+                if(!dumpPtr){
+                    ALOGE("Failed to open firmware dump file");
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                fseek(dumpPtr, 0, SEEK_END);
+                ftell_ret_val = ftell(dumpPtr);
+                if(ftell_ret_val < 0) {
+                    ALOGE("failed to get current position of file pointer");
+                    if(dumpPtr) {
+                       fclose(dumpPtr);
+                       dumpPtr = NULL;
+                    }
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                else {
+                    buffSize = ftell_ret_val;
+                }
+                Buff = (char *)malloc(sizeof(char) * buffSize);
+                if(!Buff){
+                    ALOGE("Failed to allocate buffer for firmware memory dump");
+                    if(dumpPtr) {
+                       fclose(dumpPtr);
+                       dumpPtr = NULL;
+                    }
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                memset(Buff, 0, buffSize);
+                dumpRead = fread(Buff, 1, buffSize, dumpPtr);
+                if(dumpRead <=0 || dumpRead != buffSize){
+                    ALOGE("Failed to read firmware dump file at once, dumpRead = %d", dumpRead);
+                    rewind(dumpPtr);
+                    remained = (int)buffSize;
+                    buffer = Buff;
+                    while(remained){
+                        u32 readBytes = 0;
+                        if(remained >= MEM_DUMP_CHUNK_SIZE)
+                            readBytes = MEM_DUMP_CHUNK_SIZE;
+                        else
+                            readBytes = remained;
+                        dumpRead = fread(buffer, 1, readBytes, dumpPtr);
+                        if(dumpRead){
+                            remained -= readBytes;
+                            buffer += readBytes;
+                            ALOGE("Read successfully, readBytes = %d, remained = %d", readBytes, remained);
+                        } else {
+                            ALOGE("Chunk read failed");
+                            mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                        }
+                    }
+                }
+                if (Handler.on_firmware_memory_dump) {
+                    (*Handler.on_firmware_memory_dump)(Buff, buffSize);
+                }
+                break;
+            }
+            case DRV_MEM_DUMP:
+            {
+                struct nlattr *tb_vendor[NXP_ATTR_WIFI_LOGGER_MAX + 1];
+                nla_parse(tb_vendor, NXP_ATTR_WIFI_LOGGER_MAX, vendor_data, len, NULL);
+                if(!tb_vendor[NXP_ATTR_LOGGER_DRV_DUMP_PATH]){
+                    ALOGE("NXP_ATTR_LOGGER_DRV_DUMP_PATH not found");
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                memset(full_path, 0, MEM_DUMP_PATH_LENGTH);
+                path_len = strlen((char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_DRV_DUMP_PATH]));
+                if(path_len >= MEM_DUMP_PATH_LENGTH)
+                    return NL_SKIP;
+                strcpy(full_path, (char *)nla_data(tb_vendor[NXP_ATTR_LOGGER_DRV_DUMP_PATH]));
+                dumpPtr = fopen(full_path, "r");
+                if(!dumpPtr){
+                    ALOGE("Failed to open driver memory dump file");
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                fseek(dumpPtr, 0, SEEK_END);
+                ftell_ret_val = ftell(dumpPtr);
+                if(ftell_ret_val < 0) {
+                    ALOGE("failed to get current position of file pointer");
+                    if(dumpPtr) {
+                       fclose(dumpPtr);
+                       dumpPtr = NULL;
+                    }
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                else {
+                    buffSize = ftell_ret_val;
+                }
+                Buff = (char *)malloc(sizeof(char) * buffSize);
+                if(!Buff){
+                    ALOGE("Failed to allocate buffer for driver memory dump");
+                    if(dumpPtr){
+                       fclose(dumpPtr);
+                       dumpPtr = NULL;
+                    }
+                    mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                    return NL_SKIP;
+                }
+                memset(Buff, 0, sizeof(char) * buffSize);
+                dumpRead = fread(Buff, 1, buffSize, dumpPtr);
+                if(dumpRead <=0 || dumpRead != buffSize){
+                    ALOGE("Failed to read driver dump file at once, dumpRead = %d", dumpRead);
+                    rewind(dumpPtr);
+                    remained = (int)buffSize;
+                    buffer = Buff;
+                    while(remained){
+                        u32 readBytes = 0;
+                        if(remained >= MEM_DUMP_CHUNK_SIZE)
+                            readBytes = MEM_DUMP_CHUNK_SIZE;
+                        else
+                            readBytes = remained;
+                        dumpRead = fread(buffer, 1, readBytes, dumpPtr);
+                        if(dumpRead){
+                            remained -= readBytes;
+                            buffer += readBytes;
+                            ALOGE("Read successfully, readBytes = %d, remained = %d", readBytes, remained);
+                        } else {
+                            ALOGE("Chunk read failed");
+                            mStatus = WIFI_ERROR_NOT_SUPPORTED;
+                        }
+                    }
+                }
+                if(Callbacks.on_driver_memory_dump) {
+                    (*Callbacks.on_driver_memory_dump)(Buff, buffSize);
+                }
+                break;
+            }
+            case FW_VERSION:
+            case DRV_VERSION:
+            case RING_DATA:
+            case RING_STATUS:
+            case GET_FEATURE:
+            case START_LOGGING:
+                ALOGE("Not supported type");
+                break;
+        }
+        if(Buff)
+            free(Buff);
+        if(dumpPtr) {
+           fclose(dumpPtr);
+           dumpPtr = NULL;
+        }
+        return NL_OK;
+    }
+
+    int getStatus() {
+        return mStatus;
+    }
+
+    virtual int handleEvent(WifiEvent& event) {
+        /* NO events! */
+        return NL_SKIP;
+    }
+};
+
+/////////////////////////////////////////////////////////////////////////////////
+
+wifi_error wifi_get_firmware_memory_dump(wifi_interface_handle iface,
+                                                    wifi_firmware_memory_dump_handler handler)
+{
+    int ret;
+    u32 status = 0;
+    MemoryDumpCommand *FwDump = new MemoryDumpCommand(iface, handler, FW_MEM_DUMP);
+    ret = FwDump->start();
+    status = FwDump->getStatus();
+    ALOGV("get firmware dump ret = %d", ret);
+    ALOGV("get firmware status = %d", status);
+    if (ret != WIFI_SUCCESS || status != 0){
+        ret = WIFI_ERROR_NOT_SUPPORTED;
+        ALOGE("get firmware dump not supported.");   
+    }
+    return (wifi_error)ret;
+}
+
+wifi_error wifi_get_driver_memory_dump(wifi_interface_handle iface,
+                                                 wifi_driver_memory_dump_callbacks callbacks)
+{
+     int ret;
+     u32 status = 0;
+     MemoryDumpCommand *DrvDump = new MemoryDumpCommand(iface, callbacks, DRV_MEM_DUMP);
+     ret = DrvDump->start();
+     status = DrvDump->getStatus();
+     ALOGV("get driver ret = %d", ret);
+     ALOGV("get driver status = %d", status);
+     if (ret != WIFI_SUCCESS || status != 0){
+         ret = WIFI_ERROR_NOT_SUPPORTED;
+         ALOGE("get driver dump not supported.");
+     }
+     return (wifi_error)ret;
+}
+
+wifi_error wifi_get_wake_reason_stats(wifi_interface_handle iface, 
+                                      WLAN_DRIVER_WAKE_REASON_CNT *wifi_wake_reason_cnt)
+{
+    wifi_handle handle = getWifiHandle(iface);
+    hal_info *info = getHalInfo(handle);
+    WLAN_DRIVER_WAKE_REASON_CNT *pos = info->wifi_wake_reason_cnt;
+    wifi_wake_reason_cnt->total_cmd_event_wake = pos->total_cmd_event_wake;
+    wifi_wake_reason_cnt->cmd_event_wake_cnt = pos->cmd_event_wake_cnt;
+    wifi_wake_reason_cnt->cmd_event_wake_cnt_sz = pos->cmd_event_wake_cnt_sz;
+    wifi_wake_reason_cnt->cmd_event_wake_cnt_used = pos->cmd_event_wake_cnt_used;
+    wifi_wake_reason_cnt->total_driver_fw_local_wake = pos->total_driver_fw_local_wake;
+    wifi_wake_reason_cnt->driver_fw_local_wake_cnt = pos->driver_fw_local_wake_cnt;
+    wifi_wake_reason_cnt->driver_fw_local_wake_cnt_sz = pos->driver_fw_local_wake_cnt_sz;
+    wifi_wake_reason_cnt->driver_fw_local_wake_cnt_used = pos->driver_fw_local_wake_cnt_used;
+    wifi_wake_reason_cnt->total_rx_data_wake = pos->total_rx_data_wake;
+    wifi_wake_reason_cnt->rx_wake_details.rx_unicast_cnt = pos->rx_wake_details.rx_unicast_cnt;
+    wifi_wake_reason_cnt->rx_wake_details.rx_multicast_cnt = pos->rx_wake_details.rx_multicast_cnt;
+    wifi_wake_reason_cnt->rx_wake_details.rx_broadcast_cnt = pos->rx_wake_details.rx_broadcast_cnt;
+    wifi_wake_reason_cnt->rx_wake_pkt_classification_info.icmp_pkt = pos->rx_wake_pkt_classification_info.icmp_pkt;
+    wifi_wake_reason_cnt->rx_wake_pkt_classification_info.icmp6_pkt = pos->rx_wake_pkt_classification_info.icmp6_pkt;
+    wifi_wake_reason_cnt->rx_wake_pkt_classification_info.icmp6_ra = pos->rx_wake_pkt_classification_info.icmp6_ra;
+    wifi_wake_reason_cnt->rx_wake_pkt_classification_info.icmp6_na = pos->rx_wake_pkt_classification_info.icmp6_na;
+    wifi_wake_reason_cnt->rx_wake_pkt_classification_info.icmp6_ns = pos->rx_wake_pkt_classification_info.icmp6_ns;
+    wifi_wake_reason_cnt->rx_multicast_wake_pkt_info.ipv4_rx_multicast_addr_cnt = 
+                        pos->rx_multicast_wake_pkt_info.ipv4_rx_multicast_addr_cnt;
+    wifi_wake_reason_cnt->rx_multicast_wake_pkt_info.ipv6_rx_multicast_addr_cnt = 
+                        pos->rx_multicast_wake_pkt_info.ipv6_rx_multicast_addr_cnt;
+    wifi_wake_reason_cnt->rx_multicast_wake_pkt_info.other_rx_multicast_addr_cnt = 
+                        pos->rx_multicast_wake_pkt_info.other_rx_multicast_addr_cnt;
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_get_tx_pkt_fates(wifi_interface_handle iface,
+                                 wifi_tx_report *tx_report_bufs,
+                                 size_t n_requested_fates,
+                                 size_t *n_provided_fates)
+{
+    wifi_handle wifiHandle = getWifiHandle(iface);
+    hal_info *info = getHalInfo(wifiHandle);
+    wifi_tx_report_i *tx_fate_stats;
+    size_t i;
+
+    if (info->fate_monitoring_enabled != true) {
+        ALOGE("Packet monitoring is not yet triggered");
+        return WIFI_ERROR_UNINITIALIZED;
+    }
+    pthread_mutex_lock(&info->pkt_fate_stats_lock);
+
+    tx_fate_stats = &info->pkt_fate_stats->tx_fate_stats[0];
+
+    *n_provided_fates = min(n_requested_fates,
+                            info->pkt_fate_stats->n_tx_stats_collected);
+
+    for (i=0; i < *n_provided_fates; i++) {
+        memcpy(tx_report_bufs[i].md5_prefix,
+                    tx_fate_stats[i].md5_prefix, MD5_PREFIX_LEN);
+        tx_report_bufs[i].fate = tx_fate_stats[i].fate;
+        tx_report_bufs[i].frame_inf.payload_type =
+            tx_fate_stats[i].frame_inf.payload_type;
+        tx_report_bufs[i].frame_inf.driver_timestamp_usec =
+            tx_fate_stats[i].frame_inf.driver_timestamp_usec;
+        tx_report_bufs[i].frame_inf.firmware_timestamp_usec =
+            tx_fate_stats[i].frame_inf.firmware_timestamp_usec;
+        tx_report_bufs[i].frame_inf.frame_len =
+            tx_fate_stats[i].frame_inf.frame_len;
+
+        if (tx_report_bufs[i].frame_inf.payload_type == FRAME_TYPE_ETHERNET_II)
+            memcpy(tx_report_bufs[i].frame_inf.frame_content.ethernet_ii_bytes,
+                   tx_fate_stats[i].frame_inf.frame_content,
+                   min(tx_fate_stats[i].frame_inf.frame_len,
+                       MAX_FRAME_LEN_ETHERNET));
+        else if (tx_report_bufs[i].frame_inf.payload_type ==
+                                                         FRAME_TYPE_80211_MGMT)
+            memcpy(
+                tx_report_bufs[i].frame_inf.frame_content.ieee_80211_mgmt_bytes,
+                tx_fate_stats[i].frame_inf.frame_content,
+                min(tx_fate_stats[i].frame_inf.frame_len,
+                    MAX_FRAME_LEN_80211_MGMT));
+        else
+            /* Currently framework is interested only two types(
+             * FRAME_TYPE_ETHERNET_II and FRAME_TYPE_80211_MGMT) of packets, so
+             * ignore the all other types of packets received from driver */
+
+            ALOGE("Unknown format packet");
+    }
+    pthread_mutex_unlock(&info->pkt_fate_stats_lock);
+
+    return WIFI_SUCCESS;
+}
+
+wifi_error wifi_get_rx_pkt_fates(wifi_interface_handle iface,
+                                 wifi_rx_report *rx_report_bufs,
+                                 size_t n_requested_fates,
+                                 size_t *n_provided_fates)
+{
+    wifi_handle wifiHandle = getWifiHandle(iface);
+    hal_info *info = getHalInfo(wifiHandle);
+    wifi_rx_report_i *rx_fate_stats;
+    size_t i;
+
+    if (info->fate_monitoring_enabled != true) {
+        ALOGE("Packet monitoring is not yet triggered");
+        return WIFI_ERROR_UNINITIALIZED;
+    }
+    pthread_mutex_lock(&info->pkt_fate_stats_lock);
+
+    rx_fate_stats = &info->pkt_fate_stats->rx_fate_stats[0];
+
+    *n_provided_fates = min(n_requested_fates,
+                            info->pkt_fate_stats->n_rx_stats_collected);
+
+    for (i=0; i < *n_provided_fates; i++) {
+        memcpy(rx_report_bufs[i].md5_prefix,
+                    rx_fate_stats[i].md5_prefix, MD5_PREFIX_LEN);
+        rx_report_bufs[i].fate = rx_fate_stats[i].fate;
+        rx_report_bufs[i].frame_inf.payload_type =
+            rx_fate_stats[i].frame_inf.payload_type;
+        rx_report_bufs[i].frame_inf.driver_timestamp_usec =
+            rx_fate_stats[i].frame_inf.driver_timestamp_usec;
+        rx_report_bufs[i].frame_inf.firmware_timestamp_usec =
+            rx_fate_stats[i].frame_inf.firmware_timestamp_usec;
+        rx_report_bufs[i].frame_inf.frame_len =
+            rx_fate_stats[i].frame_inf.frame_len;
+
+        if (rx_report_bufs[i].frame_inf.payload_type == FRAME_TYPE_ETHERNET_II)
+            memcpy(rx_report_bufs[i].frame_inf.frame_content.ethernet_ii_bytes,
+                   rx_fate_stats[i].frame_inf.frame_content,
+                   min(rx_fate_stats[i].frame_inf.frame_len,
+                   MAX_FRAME_LEN_ETHERNET));
+        else if (rx_report_bufs[i].frame_inf.payload_type ==
+                                                         FRAME_TYPE_80211_MGMT)
+            memcpy(
+                rx_report_bufs[i].frame_inf.frame_content.ieee_80211_mgmt_bytes,
+                rx_fate_stats[i].frame_inf.frame_content,
+                min(rx_fate_stats[i].frame_inf.frame_len,
+                    MAX_FRAME_LEN_80211_MGMT));
+        else
+            /* Currently framework is interested only two types(
+             * FRAME_TYPE_ETHERNET_II and FRAME_TYPE_80211_MGMT) of packets, so
+             * ignore the all other types of packets received from driver */
+
+            ALOGE("Unknown format packet");
+    }
+    pthread_mutex_unlock(&info->pkt_fate_stats_lock);
+    return WIFI_SUCCESS;
+}
+
diff --git a/88x9098/wlan/hal/wifi_hal/wifi_nan.cpp b/88x9098/wlan/hal/wifi_hal/wifi_nan.cpp
new file mode 100644
index 0000000..f1e6cd5
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/wifi_nan.cpp
@@ -0,0 +1,1708 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+* Portion copyright 2017-2020 NXP
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include "nl80211_copy.h"
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+#include "nan_nxp.h"
+#include <utils/String8.h>
+
+using namespace android;
+
+typedef enum{
+    NXP_ATTR_NAN_INVALID = 0,
+    NXP_ATTR_NAN_FAKE,
+    NXP_ATTR_NAN_IND,
+    NXP_ATTR_NAN_TRANSTIION_ID,
+    NXP_ATTR_NAN_RSP_TYPE,
+    NXP_ATTR_NAN_ENABLE_REQ,
+    NXP_ATTR_NAN_PUBLISH_REQ,
+    NXP_ATTR_NAN_PUBLISH_CANCEL_REQ,
+    NXP_ATTR_NAN_SUBSCRIBE_REQ,
+    NXP_ATTR_NAN_SUBSCRIBE_CANCEL_REQ,
+    NXP_ATTR_NAN_TRANSMIT_FOLLOWUP_REQ,
+    NXP_ATTR_NAN_STATS_REQ,
+    NXP_ATTR_NAN_CONFIG_REQ,
+    NXP_ATTR_NAN_TCA_REQ,
+    NXP_ATTR_NAN_BEACON_SDF_PAYLOAD_REQ,
+    NXP_ATTR_NAN_VERSION_REQ,
+    NXP_ATTR_NAN_DATA_IF_REQ,
+    NXP_ATTR_NAN_REQ_INITOR_REQ,
+    NXP_ATTR_NAN_INDI_RESP_REQ,
+    NXP_ATTR_NAN_DATA_END,
+    NXP_ATTR_NOTIFY_RESPONSE,
+    NXP_ATTR_PUBLISH_TERMINATED,
+    NXP_ATTR_MATCH,
+    NXP_ATTR_MATCH_EXPIRED,
+    NXP_ATTR_SUBSCRIBE_TERMINATED,
+    NXP_ATTR_FOLLOWUP,
+    NXP_ATTR_DISC_ENG_EVENT,
+    NXP_ATTR_DISABLED,
+    NXP_ATTR_TCA,
+    NXP_ATTR_BEACON_SDF_PAYLOAD,
+    NXP_ATTR_DATA_REQUEST,
+    NXP_ATTR_DATA_CONFIRM,
+    NXP_ATTR_DATA_END,
+    NXP_ATTR_TRANSMIT_FOLLOWUP,
+    NXP_ATTR_RANGE_REQUEST,
+    NXP_ATTR_RANGE_REPORT,
+
+    NXP_ATTR_NAN_AFTER_LAST,
+    NXP_ATTR_NAN_MAX = 
+    NXP_ATTR_NAN_AFTER_LAST - 1,
+} NAN_ATTRIBUTES;
+
+typedef struct
+{
+    u16 MsgId;
+    u16 MsgLen;
+    u16 handle;
+    u16 transactionId;
+} NanHeader;
+
+typedef struct 
+{
+    NanHeader header;
+    u16 status;
+    u16 value;
+} NanRespHeader;
+
+typedef enum{
+    NXP_EVENT_NAN = 0x10010,
+} NAN_EVENTS;
+
+struct errorCode {
+    NanStatusType frameworkError;
+    NanInternalStatusType firmwareError;
+    char nan_error[NAN_ERROR_STR_LEN];
+};
+
+struct errorCode errorCodeTranslation[] = {
+    {NAN_STATUS_SUCCESS, NAN_I_STATUS_SUCCESS,
+     "NAN status success"},
+
+    {NAN_STATUS_INTERNAL_FAILURE, NAN_I_STATUS_DE_FAILURE,
+     "NAN Discovery engine failure"},
+
+    {NAN_STATUS_INVALID_PUBLISH_SUBSCRIBE_ID, NAN_I_STATUS_INVALID_HANDLE,
+     "Invalid Publish/Subscribe ID"},
+
+    {NAN_STATUS_NO_RESOURCE_AVAILABLE, NAN_I_STATUS_NO_SPACE_AVAILABLE,
+     "No space available"},
+
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_PUBLISH_TYPE,
+     "Invalid Publish type, can be 0 or 1"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_TX_TYPE,
+     "Invalid Tx type"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_MSG_VERSION,
+     "Invalid internal message version"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_MSG_LEN,
+     "Invalid message length"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_MSG_ID,
+     "Invalid message ID"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_MATCH_ALGORITHM,
+     "Invalid matching algorithm, can be 0(match once), 1(match continuous) or 2(match never)"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_TLV_LEN,
+     "Invalid TLV length"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_TLV_TYPE,
+     "Invalid TLV type"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_MISSING_TLV_TYPE,
+     "Missing TLV type"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_TOTAL_TLVS_LEN,
+     "Invalid total TLV length"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_TLV_VALUE,
+     "Invalid TLV value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_TX_PRIORITY,
+     "Invalid Tx priority"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_CONNECTION_MAP,
+     "Invalid connection map"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_THRESHOLD_CROSSING_ALERT_ID,
+     "Invalid TCA-Threshold Crossing Alert ID"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_STATS_ID,
+     "Invalid STATS ID"},
+
+    {NAN_STATUS_PROTOCOL_FAILURE, NAN_I_STATUS_TX_FAIL,
+     "Tx Fail"},
+
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_RSSI_CLOSE_VALUE,
+     "Invalid RSSI close value range is 20dbm to 60dbm"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_RSSI_MIDDLE_VALUE,
+     "Invalid RSSI middle value range is 20dbm to 75dbm"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_HOP_COUNT_LIMIT,
+     "Invalid hop count limit, max hop count limit is 5"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_HIGH_CLUSTER_ID_VALUE,
+     "Invalid cluster ID value. Please set the cluster id high greater than the cluster id low"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_BACKGROUND_SCAN_PERIOD,
+     "Invalid background scan period. The range is 10 to 30 milliseconds"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_SCAN_CHANNEL,
+     "Invalid scan channel. Only valid channels are the NAN social channels"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_POST_NAN_CONNECTIVITY_CAPABILITIES_BITMAP,
+     "Invalid post nan connectivity bitmap"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_NUMCHAN_VALUE,
+     "Invalid further availability map number of channel value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_DURATION_VALUE,
+     "Invalid further availability map duration value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_CLASS_VALUE,
+     "Invalid further availability map class value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_CHANNEL_VALUE,
+     "Invalid further availability map channel value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_AVAILABILITY_INTERVAL_BITMAP_VALUE,
+     "Invalid further availability map availability interval bitmap value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_FURTHER_AVAILABILITY_MAP_MAP_ID,
+     "Invalid further availability map map ID"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_CONN_TYPE_VALUE,
+     "Invalid post nan discovery connection type value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_DEVICE_ROLE_VALUE,
+     "Invalid post nan discovery device role value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_DURATION_VALUE,
+     "Invalid post nan discovery duration value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_POST_NAN_DISCOVERY_BITMAP_VALUE,
+     "Invalid post nan discovery bitmap value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_MISSING_FUTHER_AVAILABILITY_MAP,
+     "Missing further availability map"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_BAND_CONFIG_FLAGS,
+     "Invalid band configuration flags"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_RANDOM_FACTOR_UPDATE_TIME_VALUE,
+     "Invalid random factor update time value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_ONGOING_SCAN_PERIOD,
+     "Invalid ongoing scan period"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_DW_INTERVAL_VALUE,
+     "Invalid DW interval value"},
+    {NAN_STATUS_INVALID_PARAM, NAN_I_STATUS_INVALID_DB_INTERVAL_VALUE,
+     "Invalid DB interval value"},
+
+    {NAN_STATUS_SUCCESS, NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_TIMEOUT,
+     "Terminated Reason: Timeout"},
+    {NAN_STATUS_SUCCESS, NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_USER_REQUEST,
+     "Terminated Reason: User Request"},
+    {NAN_STATUS_SUCCESS, NAN_I_PUBLISH_SUBSCRIBE_TERMINATED_REASON_COUNT_REACHED,
+     "Terminated Reason: Count Reached"},
+
+    {NAN_STATUS_INVALID_REQUESTOR_INSTANCE_ID, NAN_I_STATUS_INVALID_REQUESTER_INSTANCE_ID,
+     "Invalid match handle"},
+    {NAN_STATUS_NAN_NOT_ALLOWED, NAN_I_STATUS_NAN_NOT_ALLOWED,
+     "Nan not allowed"},
+    {NAN_STATUS_NO_OTA_ACK, NAN_I_STATUS_NO_OTA_ACK,
+     "No OTA ack"},
+    {NAN_STATUS_ALREADY_ENABLED, NAN_I_STATUS_NAN_ALREADY_ENABLED,
+     "NAN is Already enabled"},
+    {NAN_STATUS_FOLLOWUP_QUEUE_FULL, NAN_I_STATUS_FOLLOWUP_QUEUE_FULL,
+     "Follow-up queue full"},
+
+    {NAN_STATUS_UNSUPPORTED_CONCURRENCY_NAN_DISABLED, NDP_I_UNSUPPORTED_CONCURRENCY,
+     "Unsupported Concurrency"},
+
+    {NAN_STATUS_INTERNAL_FAILURE, NDP_I_NAN_DATA_IFACE_CREATE_FAILED,
+     "NAN data interface create failed"},
+    {NAN_STATUS_INTERNAL_FAILURE, NDP_I_NAN_DATA_IFACE_DELETE_FAILED,
+     "NAN data interface delete failed"},
+    {NAN_STATUS_INTERNAL_FAILURE, NDP_I_DATA_INITIATOR_REQUEST_FAILED,
+     "NAN data initiator request failed"},
+    {NAN_STATUS_INTERNAL_FAILURE, NDP_I_DATA_RESPONDER_REQUEST_FAILED,
+     "NAN data responder request failed"},
+
+    {NAN_STATUS_INVALID_NDP_ID, NDP_I_INVALID_NDP_INSTANCE_ID,
+     "Invalid NDP instance ID"},
+
+    {NAN_STATUS_INVALID_PARAM, NDP_I_INVALID_RESPONSE_CODE,
+     "Invalid response code"},
+    {NAN_STATUS_INVALID_PARAM, NDP_I_INVALID_APP_INFO_LEN,
+     "Invalid app info length"},
+
+    {NAN_STATUS_PROTOCOL_FAILURE, NDP_I_MGMT_FRAME_REQUEST_FAILED,
+     "Management frame request failed"},
+    {NAN_STATUS_PROTOCOL_FAILURE, NDP_I_MGMT_FRAME_RESPONSE_FAILED,
+     "Management frame response failed"},
+    {NAN_STATUS_PROTOCOL_FAILURE, NDP_I_MGMT_FRAME_CONFIRM_FAILED,
+     "Management frame confirm failed"},
+
+    {NAN_STATUS_INTERNAL_FAILURE, NDP_I_END_FAILED,
+     "NDP end failed"},
+
+    {NAN_STATUS_PROTOCOL_FAILURE, NDP_I_MGMT_FRAME_END_REQUEST_FAILED,
+     "Management frame end request failed"},
+
+    {NAN_STATUS_INTERNAL_FAILURE, NDP_I_VENDOR_SPECIFIC_ERROR,
+     "Vendor specific error"}
+};
+
+///////////////////////////////////////////////////////////////////////
+class NanControlCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanEnableRequest *Msg;
+    NanHeader header;
+    NanNxpRequestType mtype; 
+
+public:
+    // Constructor for nan enable
+    NanControlCommand(transaction_id id, wifi_interface_handle iface, 
+                              NanNxpRequestType type, NanEnableRequest *msg)
+    : WifiCommand("NanControlCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        mtype = type;
+        memset(&header, 0, sizeof(NanHeader));
+    }
+
+    // Constructor for nan disable
+    NanControlCommand(transaction_id id, wifi_interface_handle iface,
+                              NanNxpRequestType type)
+    : WifiCommand("NanControlCommand", iface, 0)
+    {
+        mId = id;
+        mtype = type;
+        memset(&header, 0, sizeof(NanHeader));
+    }
+
+    int createRequest(WifiRequest& request) {
+        int enable_len = sizeof(NanHeader);
+        u32 type = 0;
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_NAN_ENABLE_REQ);
+        if (result < 0) {
+            ALOGE("Failed to create message to enable nan\n");
+            return result;
+        }
+        header.MsgId = NAN_MSG_ID_ENABLE;
+        header.transactionId = mId;
+        type = NAN_DE_MAC_ADDR;
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put(NXP_ATTR_NAN_FAKE, &header, enable_len);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("Failed to put NanHeader, result = %d", result);
+            return result;
+        }
+
+        if (mtype == NAN_REQUEST_ENABLED) {
+            result = request.put_u32(NXP_ATTR_NAN_IND, type);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("Failed to put IND type, result = %d", result);
+                return result;
+            }
+            result = request.put_u32(NXP_ATTR_NAN_IND, type);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("Failed to put IND type, result = %d", result);
+                return result;
+            }
+        }
+//        result = request.put(ATTR_NAN_ENABLE_REQ, (void *)Msg, len);
+//        if (result < 0) {
+//            ALOGE("Failed to put msg, result = %d", result);
+//            return result;
+//        }
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int createTeardownRequest(WifiRequest &request) {
+
+        int disable_len = sizeof(NanHeader);
+        u32 type = 0;
+
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_NAN_DISABLE_REQ);
+        if(result < 0) {
+            ALOGE("Failed to create message to enable nan\n");
+            return result;
+        }
+        header.MsgId = NAN_MSG_ID_DISABLE;
+        header.transactionId = mId;
+        type = NAN_DE_MAC_ADDR;
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put(NXP_ATTR_NAN_FAKE, &header, disable_len);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("Failed to put NanHeader, result = %d", result);
+            return result;
+        }
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int start() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result < 0) {
+            return result;
+        }
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGE("Failed to enable nan, result = %d", result);
+            return result;
+        }
+        return result;
+    }
+
+    virtual int cancel_specific() {
+
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to disable nan = %d", result);
+            }
+        }
+        return result;
+    }
+};
+
+class NanPublishReqCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanPublishRequest* Preq;
+    NanPublishCancelRequest* Pcancelreq;
+    NanHeader publishHeader;
+
+public:
+    //Constructor for publish request
+    NanPublishReqCommand(transaction_id id, wifi_interface_handle iface, 
+                                   NanPublishRequest *msg)
+    : WifiCommand("NanPublishReqCommand", iface, 0)
+    {
+        mId = id;
+        Preq = msg;
+        memset(&publishHeader, 0, sizeof(NanHeader));
+        Pcancelreq = NULL;
+    }
+
+    //Constructor for publish cancel request
+    NanPublishReqCommand(transaction_id id, wifi_interface_handle iface, 
+                                   NanPublishCancelRequest *msg)
+    : WifiCommand("NanPublishReqCommand", iface, 0)
+    {
+        mId = id;
+        Pcancelreq = msg;
+        memset(&publishHeader, 0, sizeof(NanHeader));
+    }
+
+    int createRequest(WifiRequest& request) {
+        int len = sizeof(NanHeader);
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_NAN_PUBLISH_REQ);
+        if (result < 0)
+            return result;
+        publishHeader.MsgId = NAN_MSG_ID_PUBLISH_SERVICE;
+        publishHeader.transactionId = mId;
+        publishHeader.handle = Preq->publish_id;
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put(NXP_ATTR_NAN_FAKE, &publishHeader, len);
+        if (result < 0) {
+            ALOGE("Failed to create publish request message");
+            return result;
+        }
+
+        if (Preq->ttl > 0) {
+            ALOGV("publish limit ttl = %d", Preq->ttl);
+            result = request.put_u32(NXP_ATTR_NAN_IND, Preq->ttl);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("Failed to put IND type, result = %d", result);
+                return result;
+            }
+        }
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    int createTeardownRequest(WifiRequest &request) {
+        int len = sizeof(NanHeader);
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_NAN_PUBLISH_CANCEL);
+        if(result < 0) {
+            ALOGE("Failed to create publish cancel message");
+            return result;
+        }
+        publishHeader.MsgId = NAN_MSG_ID_PUBLISH_SERVICE_CANCEL;
+        publishHeader.transactionId = mId;
+        publishHeader.handle = Pcancelreq->publish_id;
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put(NXP_ATTR_NAN_FAKE, &publishHeader, len);
+        if (result < 0)
+            return result;
+        request.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int start(){
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result < 0) {
+            return result;
+        }
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGE("Failed to request publish, result = %d", result);
+            return result;
+        }
+        return result;
+    }
+
+    virtual int cancel_specific() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to cancel publish = %d", result);
+            }
+        }
+        return result;
+    }
+};
+
+class SubscribeReqCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanSubscribeRequest* Msg;
+    NanSubscribeCancelRequest* cMsg;
+    NanHeader subscribeHeader;
+
+public:
+    //Constructor for subscribe request
+    SubscribeReqCommand(transaction_id id, wifi_interface_handle iface, 
+                                 NanSubscribeRequest* msg)
+    : WifiCommand("SubscribeReqCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&subscribeHeader, 0, sizeof(NanHeader));
+    }
+
+    //Constructor for subscribe cancel request
+    SubscribeReqCommand(transaction_id id, wifi_interface_handle iface, 
+                                 NanSubscribeCancelRequest* msg)
+    : WifiCommand("SubscribeReqCommand", iface, 0)
+    {
+        mId = id;
+        cMsg = msg;
+        memset(&subscribeHeader, 0, sizeof(NanHeader));
+    }
+
+    int createRequest(WifiRequest& request) {
+        int len = sizeof(NanHeader);
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_NAN_SUBSCRIBE_REQ);
+        if (result < 0)
+            return result;
+        subscribeHeader.MsgId = NAN_MSG_ID_SUBSCRIBE_SERVICE;
+        subscribeHeader.transactionId = mId;
+        subscribeHeader.handle = Msg->subscribe_id;
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put(NXP_ATTR_NAN_FAKE, &subscribeHeader, len);
+        if (result < 0)
+            return result;
+        if (Msg->ttl > 0) {
+            ALOGV("subscribe limit ttl = %d", Msg->ttl);
+            result = request.put_u32(NXP_ATTR_NAN_IND, Msg->ttl);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("Failed to put IND type, result = %d", result);
+                return result;
+            }
+        }
+        request.attr_end(data);
+        return result;
+    }
+
+    int createTeardownRequest(WifiRequest &request) {
+        int len = sizeof(NanHeader);
+        int result = request.create(MARVELL_OUI, NXP_SUBCMD_NAN_SUBSCRIBE_CANCEL);
+        if(result < 0)
+            return result;
+        subscribeHeader.MsgId = NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL;
+        subscribeHeader.transactionId = mId;
+        subscribeHeader.handle = cMsg->subscribe_id;
+
+        nlattr *data = request.attr_start(NL80211_ATTR_VENDOR_DATA);
+        result = request.put(NXP_ATTR_NAN_FAKE, &subscribeHeader, len);
+        if (result < 0)
+            return result;
+        request.attr_end(data);
+        return result;
+    }
+
+    virtual int start(){
+        WifiRequest request(familyId(), ifaceId());
+        int result = createRequest(request);
+        if (result < 0)
+            return result;
+        result = requestResponse(request);
+        if (result < 0) {
+            ALOGE("Failed to request subscribe, result = %d", result);
+            return result;
+        }
+        return WIFI_SUCCESS;
+    }
+
+    virtual int cancel_specific() {
+        WifiRequest request(familyId(), ifaceId());
+        int result = createTeardownRequest(request);
+        if (result != WIFI_SUCCESS) {
+            ALOGE("failed to create request; result = %d", result);
+            return result;
+        } else {
+            result = requestResponse(request);
+            if (result != WIFI_SUCCESS) {
+                ALOGE("failed to cancel subscribe = %d", result);
+                return result;
+            }
+        }
+        return WIFI_SUCCESS;
+    }
+};
+
+class TransmitFollowupCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanTransmitFollowupRequest* Msg;
+    NanHeader transmitHeader;
+
+public:
+    TransmitFollowupCommand(transaction_id id, wifi_interface_handle iface, 
+                                      NanTransmitFollowupRequest *msg)
+    : WifiCommand("TransmitFollowupCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&transmitHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_TRANSMIT_FOLLOWUP);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to request transmit followup\n");
+            return ret;
+        }
+        transmitHeader.MsgId = NAN_MSG_ID_TRANSMIT_FOLLOWUP;
+        transmitHeader.transactionId = mId;
+        transmitHeader.handle = Msg->publish_subscribe_id;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &transmitHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class StatsRequestCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanStatsRequest *Msg;
+    NanHeader statsHeader;
+
+public:
+    StatsRequestCommand(transaction_id id, wifi_interface_handle iface, 
+                                NanStatsRequest *msg)
+    : WifiCommand("StatsRequestCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&statsHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_STATS_REQ);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to request nan statistics from Discovery Engine\n");
+            return ret;
+        }
+        statsHeader.MsgId = NAN_MSG_ID_STATS;
+        statsHeader.transactionId = mId;
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &statsHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class ConfigRequestCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanConfigRequest *Msg;
+    NanHeader configHeader;
+
+public:
+    ConfigRequestCommand(transaction_id id, wifi_interface_handle iface, 
+                                  NanNxpRequestType type, NanConfigRequest *msg)
+    : WifiCommand("ConfigRequestCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&configHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_CONFIG_REQ);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to request nan configuration\n");
+            return ret;
+        }
+        configHeader.MsgId = NAN_MSG_ID_CONFIGURATION;
+        configHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &configHeader, len);
+        if (ret != WIFI_SUCCESS) {
+            ALOGE("Failed to put config_header, result = %d", ret);
+            return ret;
+        }
+//        ret = mMsg.put(ATTR_NAN_CONFIG_REQ, (void *)Msg, len);
+//        if (ret < 0) {
+//            return ret;
+//        }
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class TcaRequestCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanTCARequest *Msg;
+    NanHeader tcaHeader;
+
+public:
+    TcaRequestCommand(transaction_id id, wifi_interface_handle iface, 
+                               NanTCARequest *msg)
+    : WifiCommand("TcaRequestCommand", iface, 0)
+    {
+        mId =  id;
+        Msg = msg;
+        memset(&tcaHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_TCA_REQ);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to configure the various threshold crossing alerts\n");
+            return ret;
+        }
+        tcaHeader.MsgId = NAN_MSG_ID_TCA;
+        tcaHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &tcaHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class BeaconSDFPayload : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanBeaconSdfPayloadRequest* Msg;
+    NanHeader SDFHeader;
+
+public:
+    BeaconSDFPayload(transaction_id id, wifi_interface_handle iface, 
+                            NanBeaconSdfPayloadRequest* msg)
+    : WifiCommand("BeaconSDFPayload", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&SDFHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_BEACON_SDF_PAYLOAD);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to set beacon or sdf payload to DE\n");
+            return ret;
+        }
+        SDFHeader.MsgId = NAN_MSG_ID_BEACON_SDF;
+        SDFHeader.transactionId = mId;
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &SDFHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+static int enable_num = 0;
+
+class SetRegisterHandlerCommand : public WifiCommand
+{
+private:
+    NanCallbackHandler mHandler;
+    NanPublishTerminatedInd mNptInd;
+//    NanMatchInd *mNmInd;
+//    NanMatchExpiredInd *mNmeInd;
+    NanSubscribeTerminatedInd mNstInd;
+//    NanFollowupInd *mNfpInd;
+    NanDiscEngEventInd mNDEeventInd;
+//    NanDisabledInd *mNdisabledInd;
+//    NanTCAInd *mNTCAInd;
+//    NanBeaconSdfPayloadInd *mNbspInd;
+//    NanDataPathRequestInd *mNDPreqInd;
+//    NanDataPathConfirmInd *mNDPconfirmInd;
+//    NanDataPathEndInd *mNDPendInd;
+//    NanTransmitFollowupInd *mNtransfpInd;
+//    NanRangeRequestInd *mNRangereqInd;
+//    NanRangeReportInd *mNRangerepInd;
+
+public:
+    SetRegisterHandlerCommand(wifi_interface_handle iface, 
+                                        NanCallbackHandler handlers)
+    : WifiCommand("SetRegisterHandlerCommand", iface, 0)
+    {
+        mHandler = handlers;
+    }
+
+    int start(){
+        ALOGV("Register Nan handler");
+        registerVendorHandler(MARVELL_OUI, NXP_EVENT_NAN);
+        return WIFI_SUCCESS;
+    }
+
+    virtual int handleEvent(WifiEvent & event){
+        ALOGV("***Got a NAN event***");
+        if (event.get_cmd() != NL80211_CMD_VENDOR) {
+            ALOGE("Ignoring reply with cmd = %d", event.get_cmd());
+            return NL_SKIP;
+        }
+
+        nlattr *vendor_data =(nlattr *) (event.get_data(NL80211_ATTR_VENDOR_DATA));
+        int len = event.get_vendor_data_len();
+        ALOGV("len = %d\n", len);
+//        hexdump((void *)vendor_data, len);
+
+        if (vendor_data == NULL || len == 0) {
+           ALOGE("NAN: No data");
+           return NL_SKIP;
+        }
+
+        struct nlattr *tb_vendor[NXP_ATTR_NAN_MAX + 1];
+        NanRespHeader respHeader;
+        NanResponseMsg rsp_data;
+//        rsp_data = (NanResponseMsg *)malloc(sizeof(NanResponseMsg));
+        memset(&rsp_data, 0, sizeof(NanResponseMsg));
+        memset(&respHeader, 0, sizeof(NanRespHeader));
+        nla_parse(tb_vendor, NXP_ATTR_NAN_MAX, vendor_data, len, NULL);
+
+        ALOGV("handle Event: start parser tb_vendor");
+
+        if (tb_vendor[NXP_ATTR_NAN_FAKE]){
+            ALOGV("handle Event:ATTR_NAN_FAKE");
+            memcpy(&respHeader, (NanRespHeader *)nla_data(tb_vendor[NXP_ATTR_NAN_FAKE]), sizeof(NanRespHeader));
+            switch(respHeader.header.MsgId){
+                case NAN_MSG_ID_ENABLE:
+                {
+                    ALOGV("handle Event:NAN_MSG_ID_ENABLE");
+                    enable_num++;
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_ENABLED;
+                    break;
+                }
+                case NAN_MSG_ID_DISABLE:
+                {
+                    ALOGV("handle Event:NAN_MSG_ID_DISABLE");
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_DISABLED;
+                    break;
+                }
+                case NAN_MSG_ID_CONFIGURATION:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_CONFIG;
+                    break;
+                }
+                case NAN_MSG_ID_TCA:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_TCA;
+                    break;
+                }
+                case NAN_MSG_ID_PUBLISH_SERVICE:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_PUBLISH;
+                    rsp_data.body.publish_response.publish_id= respHeader.header.handle;
+                    break;
+                }
+                case NAN_MSG_ID_PUBLISH_SERVICE_CANCEL:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_PUBLISH_CANCEL;
+                    rsp_data.body.publish_response.publish_id= respHeader.header.handle;
+                    break;
+                }
+                case NAN_MSG_ID_SUBSCRIBE_SERVICE:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_SUBSCRIBE;
+                    rsp_data.body.subscribe_response.subscribe_id= respHeader.header.handle;
+                    break;
+                }
+                case NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_SUBSCRIBE_CANCEL;
+                    rsp_data.body.subscribe_response.subscribe_id= respHeader.header.handle;
+                    break;
+                }
+                case NAN_MSG_ID_TRANSMIT_FOLLOWUP:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_TRANSMIT_FOLLOWUP;
+                    break;
+                }
+                case NAN_MSG_ID_STATS:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_STATS;
+                    rsp_data.body.stats_response.stats_type = NAN_STATS_ID_DE_SUBSCRIBE;
+                    break;
+                }
+                case NAN_MSG_ID_BEACON_SDF:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_BEACON_SDF_PAYLOAD;
+                    break;
+                }
+                case NAN_MSG_ID_CAPABILITIES:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_GET_CAPABILITIES;
+//                    rsp_data.body.nan_capabilities.max_concurrent_nan_clusters = \
+//                                pFwRsp->max_concurrent_nan_clusters;
+//                    rsp_data.body.nan_capabilities.max_publishes = \
+//                                pFwRsp->max_publishes;
+//                    rsp_data.body.nan_capabilities.max_subscribes = \
+//                                pFwRsp->max_subscribes;
+                    rsp_data.body.nan_capabilities.max_service_name_len = 255;
+//                                pFwRsp->max_service_name_len;
+                    rsp_data.body.nan_capabilities.max_match_filter_len = 255;
+//                                pFwRsp->max_match_filter_len;
+                    rsp_data.body.nan_capabilities.max_total_match_filter_len = 255; 
+//                                pFwRsp->max_total_match_filter_len;
+                    rsp_data.body.nan_capabilities.max_service_specific_info_len = 255;
+//                                pFwRsp->max_service_specific_info_len;
+//                    rsp_data.body.nan_capabilities.max_vsa_data_len = \
+//                                pFwRsp->max_vsa_data_len;
+//                    rsp_data.body.nan_capabilities.max_mesh_data_len = \
+//                                pFwRsp->max_mesh_data_len;
+//                    rsp_data.body.nan_capabilities.max_ndi_interfaces = \
+//                               pFwRsp->max_ndi_interfaces;
+//                    rsp_data.body.nan_capabilities.max_ndp_sessions = \
+//                               pFwRsp->max_ndp_sessions;
+//                    rsp_data.body.nan_capabilities.max_app_info_len = \
+//                               pFwRsp->max_app_info_len;
+//                    rsp_data.body.nan_capabilities.max_queued_transmit_followup_msgs = \
+//                               pFwRsp->max_queued_transmit_followup_msgs;
+//                    rsp_data.body.nan_capabilities.ndp_supported_bands = \
+//                               pFwRsp->ndp_supported_bands;
+//                    rsp_data.body.nan_capabilities.cipher_suites_supported = \
+//                               pFwRsp->cipher_suites_supported;
+//                    rsp_data.body.nan_capabilities.max_scid_len = \
+//                               pFwRsp->max_scid_len;
+//                    rsp_data.body.nan_capabilities.is_ndp_security_supported = \
+//                               pFwRsp->is_ndp_security_supported;
+//                    rsp_data.body.nan_capabilities.max_sdea_service_specific_info_len = \
+//                               pFwRsp->max_sdea_service_specific_info_len;
+//                    rsp_data.body.nan_capabilities.max_subscribe_address = \
+//                               pFwRsp->max_subscribe_address;
+                    break;
+                }
+                case NAN_MSG_ID_NDP_IF_CREATE:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_DP_INTERFACE_CREATE;
+                    break;
+                }
+                case NAN_MSG_ID_NDP_IF_DELETE:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_DP_INTERFACE_DELETE;
+                    break;
+                }
+                case NAN_MSG_ID_NDP_REQ_INITIATOR:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_DP_INITIATOR_RESPONSE;
+                    rsp_data.body.data_request_response.ndp_instance_id = respHeader.header.handle;
+                    break;
+                }
+                case NAN_MSG_ID_NDP_IND_RESP:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_DP_RESPONDER_RESPONSE;
+                    break;
+                }
+                case NAN_MSG_ID_NDP_END:
+                {
+                    rsp_data.status = NAN_STATUS_SUCCESS;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_DP_END;
+                    break;
+                }
+                default:
+                {
+                    ALOGE("Error. MsgId not found");
+                    //return NL_SKIP;
+                }
+            }
+            ALOGV("handle Event: rsp type = %d", rsp_data.response_type);
+            ALOGV("handle Event: rsp status = %d", rsp_data.status);
+            ALOGV("handle Event: rsp nan error = %s", rsp_data.nan_error);
+            ALOGV("handle Event: rsp transtionId = %d", respHeader.header.transactionId);
+            /*handle enable and disable request*/
+            if ((respHeader.header.MsgId == NAN_MSG_ID_ENABLE || respHeader.header.MsgId == NAN_MSG_ID_DISABLE) && (enable_num == 1)) {
+                if(mHandler.NotifyResponse && (respHeader.header.transactionId != 0xffff)){
+                    ALOGE("handle enable or disable Event: ATTR_NOTIFY_RESPONSE");
+                    mHandler.NotifyResponse(respHeader.header.transactionId, &rsp_data);
+                }
+            }
+            if (enable_num == 3)
+                enable_num = 0;
+
+            /*handle enable and disable request*/
+            if ((respHeader.header.MsgId == NAN_MSG_ID_PUBLISH_SERVICE || respHeader.header.MsgId == NAN_MSG_ID_PUBLISH_SERVICE_CANCEL)
+                    || (respHeader.header.MsgId == NAN_MSG_ID_SUBSCRIBE_SERVICE || respHeader.header.MsgId == NAN_MSG_ID_PUBLISH_SERVICE_CANCEL)
+                    || (respHeader.header.MsgId == NAN_MSG_ID_CAPABILITIES)){
+                if(mHandler.NotifyResponse && (respHeader.header.transactionId != 0xffff)){
+                    ALOGV("handle publish  Event: ATTR_NOTIFY_RESPONSE");
+                    mHandler.NotifyResponse(respHeader.header.transactionId, &rsp_data);
+                }
+            }
+        }
+
+        usleep(500000);
+        if(tb_vendor[NXP_ATTR_NAN_IND]){
+            ALOGV("handle Event:ATTR_NAN_IND");
+            if (respHeader.header.MsgId == NAN_MSG_ID_ENABLE) {
+              u32 ind_type = 0;
+              memset(&mNDEeventInd, 0, sizeof(NanDiscEngEventInd));
+              ind_type = nla_get_u32(tb_vendor[NXP_ATTR_NAN_IND]);
+              switch(ind_type)
+              {
+                  case NAN_DE_MAC_ADDR:
+                  {
+                      ALOGV("handle Event:NAN_DE_MAC_ADDR");
+                      mNDEeventInd.event_type = NAN_EVENT_ID_DISC_MAC_ADDR;
+                      for(int i=0; i<6; i++) {
+                          mNDEeventInd.data.mac_addr.addr[i] = (unsigned char)rand()%125;
+                          ALOGE("handle event: mac_addr[i] = 0x%c", mNDEeventInd.data.mac_addr.addr[i]);
+                      }
+                      break;
+                  }
+                  case NAN_DE_START_CLUSTER:
+                  {
+                      ALOGV("handle Event:NAN_DE_START_CLUSTER");
+                      mNDEeventInd.event_type = NAN_EVENT_ID_STARTED_CLUSTER;
+                      for(int i=0; i<6; i++) {
+                          mNDEeventInd.data.mac_addr.addr[i] = (unsigned char)rand()%125;
+                      }
+                      break;
+                  }
+                  case NAN_DE_JOIN_CLUSTER:
+                  {
+                      ALOGV("handle Event:NAN_DE_JOIN_CLUSTER");
+                      mNDEeventInd.event_type = NAN_EVENT_ID_JOINED_CLUSTER;
+                      for(int i=0; i<6; i++) {
+                          mNDEeventInd.data.mac_addr.addr[i] = (unsigned char)rand()%125;
+                      }
+                      break;
+                  }
+                  default:
+                      ALOGE("Error. nan indication not found");
+                      //return NL_SKIP;
+              }
+              if(mHandler.EventDiscEngEvent){
+                  ALOGV("handle Event: EventDiscEngEvent");
+                  mHandler.EventDiscEngEvent(&mNDEeventInd);
+              }
+            }
+
+            if (respHeader.header.MsgId == NAN_MSG_ID_PUBLISH_SERVICE) {
+              u32 ind_ttl = 0;
+              memset(&mNptInd, 0, sizeof(NanPublishTerminatedInd));
+              ind_ttl = nla_get_u32(tb_vendor[NXP_ATTR_NAN_IND]);
+              ALOGV("handle Event:publish ttl = %d", ind_ttl);
+              if (ind_ttl > 0)
+                  usleep(ind_ttl*1000*1000);
+
+              mNptInd.reason = NAN_STATUS_SUCCESS;
+              strlcpy(mNptInd.nan_reason, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+              mNptInd.publish_id= respHeader.header.handle;
+
+              if (mHandler.EventPublishTerminated) {
+                  ALOGV("handle Event: EventPublishTerminated");
+                  mHandler.EventPublishTerminated(&mNptInd);
+              }
+            }
+
+            if (respHeader.header.MsgId == NAN_MSG_ID_SUBSCRIBE_SERVICE) {
+              u32 ind_ttl = 0;
+              memset(&mNstInd, 0, sizeof(NanSubscribeTerminatedInd));
+              ind_ttl = nla_get_u32(tb_vendor[NXP_ATTR_NAN_IND]);
+              ALOGV("handle Event:subscribe ttl = %d", ind_ttl);
+              if (ind_ttl > 0)
+                  usleep(ind_ttl*1000*1000);
+
+              mNstInd.reason = NAN_STATUS_SUCCESS;
+              strlcpy(mNstInd.nan_reason, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+              mNstInd.subscribe_id = respHeader.header.handle;
+               
+              if (mHandler.EventSubscribeTerminated) {
+                  ALOGV("handle Event: mHandler.EventSubscribeTerminated");
+                  mHandler.EventSubscribeTerminated(&mNstInd);
+              }
+            }
+        }
+/*        if(tb_vendor[ATTR_NAN_TRANSTIION_ID]){
+           transaction_Id = nla_get_u32(tb_vendor[ATTR_NAN_TRANSTIION_ID]); 
+           ALOGE("handle Event: transactionId = %d", transaction_Id);
+        }
+
+        ALOGE("handle Event: start response type");
+        if(tb_vendor[ATTR_NAN_RSP_TYPE]){
+            mType = (NanNxpRequestType)nla_get_u32(tb_vendor[ATTR_NAN_RSP_TYPE]); 
+            ALOGE("handle Event: nan rsp type = 0x%x", mType);
+            if (mType == NAN_REQUEST_MAX) {
+                ALOGE("RSP type is invalid");
+                return NL_SKIP;
+            }
+
+            switch(mType){
+                case NAN_REQUEST_ENABLED:
+                {
+                    ALOGE("handle Event: NAN_REQUEST_ENABLED");
+                    rsp_data.status = errorCodeTranslation[0].frameworkError;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_ENABLED;
+                    break;
+                }
+                case NAN_REQUEST_DISABLED:
+                {
+                    ALOGE("handle Event: NAN_REQUEST_DISABLED");
+                    rsp_data.status = errorCodeTranslation[0].frameworkError;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_DISABLED;
+                    break;
+                }
+                case NAN_REQUEST_CONFIG:
+                {
+                    ALOGE("handle Event: NAN_REQUEST_CONFIG");
+                    rsp_data.status = errorCodeTranslation[0].frameworkError;
+                    strlcpy(rsp_data.nan_error, errorCodeTranslation[0].nan_error, NAN_ERROR_STR_LEN);
+                    rsp_data.response_type = NAN_RESPONSE_CONFIG;
+                    break;
+                }
+                default:
+                {
+                    return NL_SKIP;
+                }
+            }
+            ALOGE("handle Event: rsp type = %d", rsp_data.response_type);
+            ALOGE("handle Event: rsp status = %d", rsp_data.status);
+            ALOGE("handle Event: rsp nan error = %s", rsp_data.nan_error);
+            ALOGE("handle Event: rsp transtionId = %d", transaction_Id);
+            if(mHandler.NotifyResponse && (transaction_Id != 0xffff)){
+                ALOGE("handle Event: ATTR_NOTIFY_RESPONSE");
+                mHandler.NotifyResponse(transaction_Id, &rsp_data);
+            }
+        }*/
+///_________________________________________________________________________________________
+/*
+        if(tb_vendor[ATTR_PUBLISH_TERMINATED]){
+            memset(mNptInd, 0, sizeof(NanPublishTerminatedInd));
+            mNptInd = (NanPublishTerminatedInd *)tb_vendor[ATTR_PUBLISH_TERMINATED];
+            if(mHandler.EventPublishTerminated){
+                mHandler.EventPublishTerminated(mNptInd);
+            }
+        }
+        if(tb_vendor[ATTR_MATCH]){
+            memset(mNmInd, 0, sizeof(NanMatchInd));
+            mNmInd = (NanMatchInd *)tb_vendor[ATTR_MATCH];
+            if(mHandler.EventMatch){
+                mHandler.EventMatch(mNmInd);
+            }
+        }
+        if(tb_vendor[ATTR_MATCH_EXPIRED]){
+            memset(mNmeInd, 0, sizeof(NanMatchExpiredInd));
+            mNmeInd = (NanMatchExpiredInd *)tb_vendor[ATTR_MATCH_EXPIRED];
+            if(mHandler.EventMatchExpired){
+                mHandler.EventMatchExpired(mNmeInd);
+            }
+        }
+        if(tb_vendor[ATTR_SUBSCRIBE_TERMINATED]){
+           memset(mNstInd, 0, sizeof(NanSubscribeTerminatedInd));
+           mNstInd = (NanSubscribeTerminatedInd *)tb_vendor[ATTR_SUBSCRIBE_TERMINATED];
+           if(mHandler.EventSubscribeTerminated){
+                mHandler.EventSubscribeTerminated(mNstInd);
+            }
+        }
+        if(tb_vendor[ATTR_FOLLOWUP]){
+            memset(mNfpInd, 0, sizeof(NanFollowupInd));
+            mNfpInd = (NanFollowupInd *)tb_vendor[ATTR_FOLLOWUP];
+            if(mHandler.EventFollowup){
+                mHandler.EventFollowup(mNfpInd);
+            }
+        }
+        if(tb_vendor[ATTR_DISC_ENG_EVENT]){
+            memset(mNDEeventInd, 0, sizeof(NanDiscEngEventInd));
+            mNDEeventInd = (NanDiscEngEventInd *)tb_vendor[ATTR_DISC_ENG_EVENT];
+            if(mHandler.EventDiscEngEvent){
+                mHandler.EventDiscEngEvent(mNDEeventInd);
+            }
+        }
+        if(tb_vendor[ATTR_DISABLED]){
+            memset(mNdisabledInd, 0, sizeof(NanDisabledInd));
+            mNdisabledInd = (NanDisabledInd*)tb_vendor[ATTR_DISABLED];
+            if(mHandler.EventDisabled){
+                mHandler.EventDisabled(mNdisabledInd);
+            }
+        }
+        if(tb_vendor[ATTR_TCA]){
+            memset(mNTCAInd, 0, sizeof(NanTCAInd));
+            mNTCAInd = (NanTCAInd *)tb_vendor[ATTR_TCA];
+            if(mHandler.EventTca){
+                mHandler.EventTca(mNTCAInd);
+            }
+        }
+        if(tb_vendor[ATTR_BEACON_SDF_PAYLOAD]){
+            memset(mNbspInd, 0, sizeof(NanBeaconSdfPayloadInd));
+            mNbspInd = (NanBeaconSdfPayloadInd *)tb_vendor[ATTR_BEACON_SDF_PAYLOAD];
+            if(mHandler.EventBeaconSdfPayload){
+                mHandler.EventBeaconSdfPayload(mNbspInd);
+            }
+        }
+        if(tb_vendor[ATTR_DATA_REQUEST]){
+            memset(mNDPreqInd, 0, sizeof(NanDataPathRequestInd));
+            mNDPreqInd = (NanDataPathRequestInd *)tb_vendor[ATTR_DATA_REQUEST];
+            if(mHandler.EventDataRequest){
+                mHandler.EventDataRequest(mNDPreqInd);
+            }
+        }
+        if(tb_vendor[ATTR_DATA_CONFIRM]){
+            memset(mNDPconfirmInd, 0, sizeof(NanDataPathConfirmInd));
+            mNDPconfirmInd = (NanDataPathConfirmInd *)tb_vendor[ATTR_DATA_CONFIRM];
+            if(mHandler.EventDataConfirm){
+                mHandler.EventDataConfirm(mNDPconfirmInd);
+            }
+        }
+        if(tb_vendor[ATTR_DATA_END]){
+            memset(mNDPendInd, 0, sizeof(NanDataPathEndInd));
+            mNDPendInd = (NanDataPathEndInd *)tb_vendor[ATTR_DATA_END];
+            if(mHandler.EventDataEnd){
+                mHandler.EventDataEnd(mNDPendInd);
+            }
+        }
+        if(tb_vendor[ATTR_TRANSMIT_FOLLOWUP]){
+            memset(mNtransfpInd, 0, sizeof(NanTransmitFollowupInd));
+            mNtransfpInd = (NanTransmitFollowupInd *)tb_vendor[ATTR_TRANSMIT_FOLLOWUP];
+            if(mHandler.EventTransmitFollowup){
+                mHandler.EventTransmitFollowup(mNtransfpInd);
+            }
+        }
+        if(tb_vendor[ATTR_RANGE_REQUEST]){
+            memset(mNRangereqInd, 0, sizeof(NanRangeRequestInd));
+            mNRangereqInd = (NanRangeRequestInd *)tb_vendor[ATTR_RANGE_REQUEST];
+            if(mHandler.EventRangeRequest){
+                mHandler.EventRangeRequest(mNRangereqInd);
+            }
+        }
+        if(tb_vendor[ATTR_RANGE_REPORT]){
+            memset(mNRangerepInd, 0, sizeof(NanRangeReportInd));
+            mNRangerepInd = (NanRangeReportInd *)tb_vendor[ATTR_RANGE_REPORT];
+            if(mHandler.EventRangeReport){
+                mHandler.EventRangeReport(mNRangerepInd);
+            }
+        }*/
+        else{
+            ALOGE("Unknown attribute, ignore\n");
+        }
+        return NL_OK;
+    }
+};
+
+class GetNANCapaCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanHeader capaHeader;
+
+public:
+    GetNANCapaCommand(transaction_id id, wifi_interface_handle iface)
+    : WifiCommand("GetNANCapaCommand", iface, 0)
+    {
+        mId = id;
+        memset(&capaHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_GET_CAPA);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to get NAN capabilities\n");
+            return ret;
+        }
+        capaHeader.MsgId = NAN_MSG_ID_CAPABILITIES;
+        capaHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &capaHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class DataIfCreateCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    char *mIface_name;
+    NanHeader NDPHeader;
+
+public:
+    DataIfCreateCommand(transaction_id id, wifi_interface_handle iface,
+                                char *iface_name)
+    : WifiCommand("DataIfCreateCommand", iface, 0)
+    {
+        mId = id;
+        mIface_name = iface_name;
+        memset(&NDPHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_DATA_IF_CREATE);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to create data interface\n");
+            return ret;
+        }
+        NDPHeader.MsgId = NAN_MSG_ID_NDP_IF_CREATE;
+        NDPHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &NDPHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class DataIfDeleteCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    char *mIface_name;
+    NanHeader NDPHeader;
+
+public:
+    DataIfDeleteCommand(transaction_id id, wifi_interface_handle iface, char *iface_name)
+    : WifiCommand("DataIfDeleteCommand", iface, 0)
+    {
+        mId = id;
+        mIface_name = iface_name;
+        memset(&NDPHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_DATA_IF_DELETE);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to delete data interface\n");
+            return ret;
+        }
+        NDPHeader.MsgId = NAN_MSG_ID_NDP_IF_DELETE;
+        NDPHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &NDPHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class DataReqInitiatorCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanDataPathInitiatorRequest* Msg;
+    NanHeader NDPHeader;
+
+public:
+    DataReqInitiatorCommand(transaction_id id, wifi_interface_handle iface,
+                                    NanDataPathInitiatorRequest *msg)
+    : WifiCommand("DataReqInitiatorCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&NDPHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_DATA_REQ_INITOR);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to request initiator\n");
+            return ret;
+        }
+        NDPHeader.MsgId = NAN_MSG_ID_NDP_REQ_INITIATOR;
+        NDPHeader.transactionId = mId;
+        NDPHeader.handle = Msg->requestor_instance_id;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &NDPHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class DataIndicationRspCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanDataPathIndicationResponse* Msg;
+    NanHeader NDPHeader;
+
+public:
+    DataIndicationRspCommand(transaction_id id, wifi_interface_handle iface,
+                                       NanDataPathIndicationResponse *msg)
+    : WifiCommand("DataIndicationRspCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&NDPHeader, 0, sizeof(NanHeader));
+    }
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_DATA_INDI_RESP);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to config data indication response\n");
+            return ret;
+        }
+        NDPHeader.MsgId = NAN_MSG_ID_NDP_IND_RESP;
+        NDPHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &NDPHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+class DataEndCommand : public WifiCommand
+{
+private:
+    transaction_id mId;
+    NanDataPathEndRequest* Msg;
+    NanHeader NDPHeader;
+
+public:
+    DataEndCommand(transaction_id id, wifi_interface_handle iface, 
+                           NanDataPathEndRequest *msg)
+    : WifiCommand("DataEndCommand", iface, 0)
+    {
+        mId = id;
+        Msg = msg;
+        memset(&NDPHeader, 0, sizeof(NanHeader));
+    }
+
+    virtual int create(){
+        int ret = mMsg.create(MARVELL_OUI, NXP_SUBCMD_NAN_DATA_END);
+        int len = sizeof(NanHeader);
+        if (ret < 0) {
+            ALOGE("Failed to create message to end data path\n");
+            return ret;
+        }
+        NDPHeader.MsgId = NAN_MSG_ID_NDP_END;
+        NDPHeader.transactionId = mId;
+
+        nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+        ret = mMsg.put(NXP_ATTR_NAN_FAKE, &NDPHeader, len);
+        if (ret < 0)
+            return ret;
+        mMsg.attr_end(data);
+        return WIFI_SUCCESS;
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////////////
+wifi_error nan_enable_request(transaction_id id, wifi_interface_handle iface, 
+                                   NanEnableRequest *msg)
+{
+    ALOGV("***nan_enable_request***");
+    wifi_error ret;
+    wifi_handle handle = getWifiHandle(iface);
+    NanControlCommand *cmd = new NanControlCommand(id, iface, NAN_REQUEST_ENABLED, msg);
+    wifi_register_cmd(handle, id, cmd);
+    ret = (wifi_error)cmd->start();
+    ALOGV("nan_enable_request, ret = %d", ret);
+    ALOGV("nan_enable_request, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_disable_request(transaction_id id, wifi_interface_handle iface)
+{
+    ALOGV("***nan_disable_request***");
+    wifi_error ret;
+    wifi_handle handle = getWifiHandle(iface);
+    NanControlCommand *cmd = new NanControlCommand(id, iface, NAN_REQUEST_DISABLED);
+    wifi_register_cmd(handle, id, cmd);
+    ret = (wifi_error)cmd->cancel_specific();
+    ALOGV("nan_disable_request, ret = %d", ret);
+    ALOGV("nan_disable_request, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_publish_request(transaction_id id, wifi_interface_handle iface, 
+                                    NanPublishRequest *msg)
+{
+    ALOGV("***nan_publish_request***");
+    wifi_error ret;
+    wifi_handle handle = getWifiHandle(iface);
+    NanPublishReqCommand *cmd = new NanPublishReqCommand(id, iface, msg);
+    wifi_register_cmd(handle, id, cmd);
+    ret = (wifi_error)cmd->start();
+    ALOGV("nan_publish_request, ret = %d", ret);
+    ALOGV("nan_publish_request, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_publish_cancel_request(transaction_id id, wifi_interface_handle iface, 
+                                             NanPublishCancelRequest *msg)
+{
+    ALOGV("***nan_publish_cancel_request***");
+    wifi_error ret;
+    wifi_handle handle = getWifiHandle(iface);
+    NanPublishReqCommand *cmd = new NanPublishReqCommand(id, iface, msg);
+    wifi_register_cmd(handle, id, cmd);
+    ret = (wifi_error)cmd->cancel_specific();
+    ALOGV("nan_publish_cancel_request, ret = %d", ret);
+    ALOGV("nan_publish_cancel_request, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_subscribe_request(transaction_id id, wifi_interface_handle iface, 
+                                       NanSubscribeRequest *msg)
+{
+    ALOGV("***nan_subscribe_request***");
+    wifi_error ret;
+    wifi_handle handle = getWifiHandle(iface);
+    SubscribeReqCommand *cmd = new SubscribeReqCommand(id, iface, msg);
+    wifi_register_cmd(handle, id, cmd);
+    ret = (wifi_error)cmd->start();
+    ALOGV("nan_subscribe_request, ret = %d", ret);
+    ALOGV("nan_subscribe_request, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_subscribe_cancel_request(transaction_id id, wifi_interface_handle iface, 
+                                                NanSubscribeCancelRequest *msg)
+{
+    ALOGV("***nan_subscribe_cancel_request***");
+    wifi_error ret;
+    wifi_handle handle = getWifiHandle(iface);
+    SubscribeReqCommand *cmd = new SubscribeReqCommand(id, iface, msg);
+    wifi_register_cmd(handle, id, cmd);
+    ret = (wifi_error)cmd->cancel_specific();
+    ALOGV("nan_subscribe_cancel_request, ret = %d", ret);
+    ALOGV("nan_subscribe_cancel_request, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_transmit_followup_request(transaction_id id, wifi_interface_handle iface, 
+                                                NanTransmitFollowupRequest * msg)
+{
+   // TransmitFollowupCommand command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_stats_request(transaction_id id, wifi_interface_handle iface, 
+                                 NanStatsRequest *msg)
+{
+   // StatsRequestCommand command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_config_request(transaction_id id, wifi_interface_handle iface,
+                                   NanConfigRequest *msg)
+{
+    ALOGV("***nan_config_request*****");
+    wifi_error ret;
+    ConfigRequestCommand command(id, iface, NAN_REQUEST_CONFIG, msg);
+    ret = (wifi_error) command.requestResponse();
+    ALOGV("nan_config_request, ret = %d", ret);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_tca_request(transaction_id id, wifi_interface_handle iface,
+                               NanTCARequest *msg)
+{
+   // TcaRequestCommand command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_beacon_sdf_payload_request(transaction_id id,wifi_interface_handle iface,
+                                                   NanBeaconSdfPayloadRequest * msg)
+{
+   // BeaconSDFPayload command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_get_version(wifi_handle handle, NanVersion *version)
+{
+    *version = (NAN_MAJOR_VERSION <<16 | NAN_MINOR_VERSION << 8 | NAN_MICRO_VERSION);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_register_handler(wifi_interface_handle iface, NanCallbackHandler handlers)
+{
+    ALOGV("***wifi_nan_register_handler***");
+
+    wifi_handle handle = getWifiHandle(iface);
+    ALOGV("nanhandler start, handle = %p", handle);
+
+    SetRegisterHandlerCommand *cmd = new SetRegisterHandlerCommand(iface, handlers);
+    if (cmd) {
+        wifi_register_cmd(handle, 0, cmd);
+        wifi_error result = (wifi_error)cmd->start();
+        if (result != WIFI_SUCCESS)
+            wifi_unregister_cmd(handle, 0);
+        return result;
+    } else {
+        ALOGE("Out of memory");
+        return WIFI_ERROR_OUT_OF_MEMORY;
+    }
+
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_get_capabilities(transaction_id id, wifi_interface_handle iface)
+{
+    ALOGV("***nan_get_capabilities*****");
+    wifi_error ret;
+    GetNANCapaCommand command(id, iface);
+    ret = (wifi_error) command.requestResponse();
+    ALOGV("nan_get_capabilities, ret = %d", ret);
+    ALOGV("nan_get_capabilities, transaction id = %d", id);
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_data_interface_create(transaction_id id,wifi_interface_handle iface,char * iface_name)
+{
+   // DataIfCreateCommand command(id, iface, iface_name);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_data_interface_delete(transaction_id id, wifi_interface_handle iface, char * iface_name)
+{
+   // DataIfDeleteCommand command(id, iface, iface_name);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_data_request_initiator(transaction_id id, wifi_interface_handle iface,
+                                           NanDataPathInitiatorRequest * msg)
+{
+   // DataReqInitiatorCommand command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_data_indication_response(transaction_id id, wifi_interface_handle iface,
+                                        NanDataPathIndicationResponse * msg)
+{
+   // DataIndicationRspCommand command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
+
+wifi_error nan_data_end(transaction_id id, wifi_interface_handle iface, NanDataPathEndRequest * msg)
+{
+   // DataEndCommand command(id, iface, msg);
+   // return (wifi_error) command.requestResponse();
+    return WIFI_SUCCESS;
+}
diff --git a/88x9098/wlan/hal/wifi_hal/wifi_offload.cpp b/88x9098/wlan/hal/wifi_hal/wifi_offload.cpp
new file mode 100644
index 0000000..4ef3420
--- /dev/null
+++ b/88x9098/wlan/hal/wifi_hal/wifi_offload.cpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2020 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <linux/rtnetlink.h>
+#include <netpacket/packet.h>
+#include <linux/filter.h>
+#include <linux/errqueue.h>
+
+#include <linux/pkt_sched.h>
+#include <netlink/object-api.h>
+#include <netlink/netlink.h>
+#include <netlink/socket.h>
+
+#include "nl80211_copy.h"
+
+#define LOG_TAG  "WifiHAL"
+
+#include <utils/Log.h>
+
+#include "wifi_hal.h"
+#include "common.h"
+#include "cpp_bindings.h"
+#include <utils/String8.h>
+
+using namespace android;
+
+typedef enum {
+    NXP_ATTR_OFFLOAD_INVALID = 0,
+    NXP_ATTR_OFFLOAD_PACKET_ID,
+    NXP_ATTR_OFFLOAD_PACKET_ETHER_TYPE,
+    NXP_ATTR_OFFLOAD_PACKET_IP_PKT,
+    NXP_ATTR_OFFLOAD_PACKET_IP_PKT_LEN,
+    NXP_ATTR_OFFLOAD_PACKET_SRC_MAC_ADDR,
+    NXP_ATTR_OFFLOAD_PACKET_DST_MAC_ADDR,
+    NXP_ATTR_OFFLOAD_PACKET_PERIOD_MSEC,
+} WIFI_OFFLOAD_ATTRIBUTE;
+
+typedef enum {
+    START_SENDING_OFFLOAD_PACKET,
+    STOP_SENDING_OFFLOAD_PACKET,
+} CmdType;
+
+///////////////////////////////////////////////////////////////////////////////
+class SendOffloadPacket : public WifiCommand
+{
+private:
+    u8 Id;
+    u16 etherType;
+    u8 *ipPacket;
+    u16 packetLen;
+    u8 *srcMacAddr;
+    u8 *dstMacAddr;
+    u32 periodMsec;
+    CmdType Type;
+
+public:
+    SendOffloadPacket(wifi_request_id id, wifi_interface_handle iface, u16 ether_type,
+                            u8 *ip_packet, u16 ip_packet_len, u8 *src_mac_addr, 
+                            u8 *dst_mac_addr, u32 period_msec, CmdType cmdType)
+    : WifiCommand("SendOffloadPacket", iface, 0)
+    {
+        Id = id;
+        etherType = ether_type;
+        ipPacket = ip_packet;
+        packetLen = ip_packet_len;
+        srcMacAddr = src_mac_addr;
+        dstMacAddr = dst_mac_addr;
+        periodMsec = period_msec;
+        Type = cmdType;
+    }
+
+    SendOffloadPacket(wifi_request_id id, wifi_interface_handle iface, CmdType cmdType)
+    : WifiCommand("SendOffloadPacket", iface, 0)
+    {
+        Id = id;
+        Type = cmdType;
+        etherType = 0;
+        ipPacket = NULL;
+        packetLen = 0;
+        srcMacAddr = NULL;
+        dstMacAddr = NULL;
+        periodMsec = 0;
+    }
+
+    virtual int create(){
+        int ret = 0;
+        switch(Type){
+            case START_SENDING_OFFLOAD_PACKET:
+            {
+                ret = mMsg.create(MARVELL_OUI, NXP_OFFLOAD_START_SENDING_PACKET);
+                if (ret!= WIFI_SUCCESS) {
+                    ALOGE("Failed to create message start sending offload packet - %d", ret);
+                    return ret;
+                }
+                nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+                ret = mMsg.put_u8(NXP_ATTR_OFFLOAD_PACKET_ID, Id);
+                if (ret < 0)
+                    return ret;
+                if (etherType){
+                    ret = mMsg.put_u16(NXP_ATTR_OFFLOAD_PACKET_ETHER_TYPE, etherType);
+                    if(ret < 0)
+                        return ret;
+                }
+                ret = mMsg.put_u16(NXP_ATTR_OFFLOAD_PACKET_IP_PKT_LEN, packetLen);
+                if (ret < 0)
+                    return ret;
+                ret = mMsg.put(NXP_ATTR_OFFLOAD_PACKET_IP_PKT, ipPacket, packetLen);
+                if(ret < 0)
+                    return ret;
+                ret = mMsg.put_addr(NXP_ATTR_OFFLOAD_PACKET_SRC_MAC_ADDR, srcMacAddr);
+                if(ret < 0)
+                    return ret;
+                ret = mMsg.put_addr(NXP_ATTR_OFFLOAD_PACKET_DST_MAC_ADDR, dstMacAddr);
+                if(ret < 0)
+                    return ret;
+                ret = mMsg.put_u32(NXP_ATTR_OFFLOAD_PACKET_PERIOD_MSEC, periodMsec);
+                if(ret < 0)
+                    return ret;
+                mMsg.attr_end(data);
+                break;
+            }
+            case STOP_SENDING_OFFLOAD_PACKET:
+            {
+                ret = mMsg.create(MARVELL_OUI, NXP_OFFLOAD_STOP_SENDING_PACKET);
+                if (ret!= WIFI_SUCCESS) {
+                    ALOGE("Failed to create message to stop sending offload packet - %d", ret);
+                    return ret;
+                }
+                nlattr *data = mMsg.attr_start(NL80211_ATTR_VENDOR_DATA);
+                ret = mMsg.put_u8(NXP_ATTR_OFFLOAD_PACKET_ID, Id);
+                if (ret < 0)
+                    return ret;
+                mMsg.attr_end(data);
+                break;
+            }
+            default:
+                ALOGE("Unknown offload packet command");
+                return WIFI_ERROR_UNKNOWN;
+        }
+    return WIFI_SUCCESS;
+    }
+
+    virtual int handleResponse(WifiEvent& reply) {
+        return NL_OK;
+    }
+};
+
+
+/* API to send specified mkeep_alive packet periodically. */
+wifi_error wifi_start_sending_offloaded_packet(wifi_request_id id, wifi_interface_handle iface,
+                                                        u16 ether_type, u8 *ip_packet, u16 ip_packet_len, 
+                                                        u8 *src_mac_addr, u8 *dst_mac_addr, 
+                                                        u32 period_msec)
+{
+    int ret = 0;
+    if(!ip_packet || !src_mac_addr || !dst_mac_addr){
+        ALOGE("The ip_packet/src_mac_addr/dst_mac_addr is NULL");
+        return WIFI_ERROR_INVALID_ARGS;
+    }
+    SendOffloadPacket Start(id, iface, ether_type, ip_packet, ip_packet_len, src_mac_addr, 
+                            dst_mac_addr, period_msec, START_SENDING_OFFLOAD_PACKET);
+    ret = Start.requestResponse();
+    return (wifi_error)ret;
+}
+
+/* API to stop sending mkeep_alive packet. */
+wifi_error wifi_stop_sending_offloaded_packet(wifi_request_id id, wifi_interface_handle iface)
+{
+    int ret = 0;
+    SendOffloadPacket Stop(id, iface, STOP_SENDING_OFFLOAD_PACKET);
+    ret = Stop.requestResponse();
+    return (wifi_error)ret;
+}
diff --git a/88x9098/wlan/hal/wlan_lib/APACHE_LICENSE-2.0.txt b/88x9098/wlan/hal/wlan_lib/APACHE_LICENSE-2.0.txt
new file mode 100644
index 0000000..75b5248
--- /dev/null
+++ b/88x9098/wlan/hal/wlan_lib/APACHE_LICENSE-2.0.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/88x9098/wlan/hal/wlan_lib/Android.mk b/88x9098/wlan/hal/wlan_lib/Android.mk
new file mode 100644
index 0000000..fa4abff
--- /dev/null
+++ b/88x9098/wlan/hal/wlan_lib/Android.mk
@@ -0,0 +1,73 @@
+#
+# Copyright (C) 2008 The Android Open Source Project
+# Copyright 2012-2020 NXP
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+LOCAL_PATH := $(call my-dir)
+
+ifeq ($(WPA_SUPPLICANT_VERSION),VER_0_8_X)
+
+ifneq ($(BOARD_WPA_SUPPLICANT_DRIVER),)
+  CONFIG_DRIVER_$(BOARD_WPA_SUPPLICANT_DRIVER) := y
+endif
+
+WPA_SUPPL_DIR = external/wpa_supplicant_8
+WPA_SRC_FILE :=
+
+include $(WPA_SUPPL_DIR)/wpa_supplicant/android.config
+
+WPA_SUPPL_DIR_INCLUDE = $(WPA_SUPPL_DIR)/src \
+	$(WPA_SUPPL_DIR)/src/common \
+	$(WPA_SUPPL_DIR)/src/drivers \
+	$(WPA_SUPPL_DIR)/src/l2_packet \
+	$(WPA_SUPPL_DIR)/src/utils \
+	$(WPA_SUPPL_DIR)/src/wps \
+	$(WPA_SUPPL_DIR)/wpa_supplicant
+
+ifdef CONFIG_DRIVER_NL80211
+ifneq ($(wildcard external/libnl),)
+WPA_SUPPL_DIR_INCLUDE += external/libnl/include
+else
+WPA_SUPPL_DIR_INCLUDE += external/libnl-headers
+endif
+
+WPA_SRC_FILE += driver_cmd_nl80211.c
+endif
+
+ifdef CONFIG_DRIVER_WEXT
+WPA_SRC_FILE += driver_cmd_wext.c
+endif
+
+# To force sizeof(enum) = 4
+L_CFLAGS_32 += -mabi=aapcs-linux
+L_CFLAGS_64 += -mabi=lp64
+
+ifdef CONFIG_ANDROID_LOG
+L_CFLAGS += -DCONFIG_ANDROID_LOG
+endif
+
+########################
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := lib_driver_cmd_nxp
+LOCAL_SHARED_LIBRARIES := libc libcutils
+LOCAL_CFLAGS := $(L_CFLAGS)
+LOCAL_CFLAGS += -Werror -Wno-unused-parameter -Wno-macro-redefined
+LOCAL_SRC_FILES := $(WPA_SRC_FILE)
+LOCAL_C_INCLUDES := $(WPA_SUPPL_DIR_INCLUDE)
+LOCAL_PROPRIETARY_MODULE := true
+include $(BUILD_STATIC_LIBRARY)
+
+########################
+
+endif
diff --git a/88x9098/wlan/hal/wlan_lib/MODULE_LICENSE_BSD b/88x9098/wlan/hal/wlan_lib/MODULE_LICENSE_BSD
new file mode 100644
index 0000000..e69de29
diff --git a/88x9098/wlan/hal/wlan_lib/NOTICE b/88x9098/wlan/hal/wlan_lib/NOTICE
new file mode 100644
index 0000000..9e26dc4
--- /dev/null
+++ b/88x9098/wlan/hal/wlan_lib/NOTICE
@@ -0,0 +1,44 @@
+
+Copyright (c) 2005-2010, The Android Open Source Project
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+ * Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in
+   the documentation and/or other materials provided with the 
+   distribution.
+ * Neither the name of The Android Open Source Project nor the names
+   of its contributors may be used to endorse or promote products
+   derived from this software without specific prior written
+   permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
+AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+
+ * Copyright (c) 2002-2010, Jouni Malinen <j@w1.fi>
+ * Copyright (c) 2003-2004, Instant802 Networks, Inc.
+ * Copyright (c) 2005-2006, Devicescape Software, Inc.
+ * Copyright (c) 2007, Johannes Berg <johannes@sipsolutions.net>
+ * Copyright (c) 2009-2010, Atheros Communications
+ * Copyright 2012-2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
diff --git a/88x9098/wlan/hal/wlan_lib/driver_cmd_nl80211.c b/88x9098/wlan/hal/wlan_lib/driver_cmd_nl80211.c
new file mode 100644
index 0000000..8c54257
--- /dev/null
+++ b/88x9098/wlan/hal/wlan_lib/driver_cmd_nl80211.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2021 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "includes.h"
+#include <netlink/genl/genl.h>
+#include <net/if.h>
+#include "utils/common.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "common/qca-vendor.h"
+#include "common/qca-vendor-attr.h"
+#include "driver_nl80211.h"
+#include "wpa_supplicant_i.h"
+#include "config.h"
+#ifdef ANDROID
+#include "android_drv.h"
+#endif
+#include "linux_ioctl.h"
+
+#define WPA_PS_ENABLED        0
+#define WPA_PS_DISABLED        1
+
+#define MAX_WPSP2PIE_CMD_SIZE        512
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+typedef struct android_wifi_priv_cmd {
+    u64 buf;
+    int used_len;
+    int total_len;
+} android_wifi_priv_cmd;
+
+
+static int drv_errors = 0;
+
+static void wpa_driver_send_hang_msg(struct wpa_driver_nl80211_data *drv)
+{
+    drv_errors++;
+    if (drv_errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
+        drv_errors = 0;
+        wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+    }
+}
+
+static int get_power_mode_handler(struct nl_msg *msg, void *arg)
+{
+    struct nlattr *tb[NL80211_ATTR_MAX + 1];
+    struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+    int *state = (int *)arg;
+
+    nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+          genlmsg_attrlen(gnlh, 0), NULL);
+
+    if (!tb[NL80211_ATTR_PS_STATE])
+        return NL_SKIP;
+
+    if (state) {
+        *state = (int)nla_get_u32(tb[NL80211_ATTR_PS_STATE]);
+        wpa_printf(MSG_DEBUG, "nl80211: Get power mode = %d", *state);
+        *state = (*state == NL80211_PS_ENABLED) ?
+                WPA_PS_ENABLED : WPA_PS_DISABLED;
+    }
+
+    return NL_SKIP;
+}
+
+
+#ifndef HOSTAPD
+#define NL80211_BGSCAN_HEADER           "BGSCAN-CONFIG "
+#define NL80211_BGSCAN_HEADER_SIZE      14
+#define NL80211_SSID_AMOUNT             16
+#define NL80211_BGCAN_BUF_LEN           720
+#define NL80211_CSCAN_SSID_SECTION      'S'
+#define NL80211_SSID_MAX_SIZE           32
+#define NL80211_BGSCAN_RSSI_SECTION     'R'
+#define NL80211_BGSCAN_INTERVAL_SECTION 'T'
+#define NL80211_BGSCAN_INTERVAL_DEF     30
+#define NL80211_BGSCAN_REPEAT_SECTION   'E'
+#define NL80211_BGSCAN_REPEAT_DEF       5
+
+static char *getop(char *s, int *first_time)
+{
+    const char delim[] = " \t\n";
+    char *p;
+    if (*first_time){
+        p = strtok(s, delim);
+        *first_time = FALSE;
+    }
+    else{
+        p = strtok(NULL, delim);
+    }
+    return (p);
+}
+
+static int wpa_driver_set_backgroundscan_params(void *priv, char *cmd)
+{
+    struct i802_bss *bss = priv;
+    struct wpa_driver_nl80211_data *drv = bss->drv;
+    struct ifreq ifr;
+    android_wifi_priv_cmd priv_cmd;
+    struct wpa_supplicant *wpa_s;
+    int ret = 0, i = 0, bp;
+    char buf[NL80211_BGCAN_BUF_LEN];
+    struct wpa_ssid *ssid_conf;
+    int first_time = TRUE;
+    char    *opstr = NULL;
+    char      *ptr = NULL;
+    int find_ssid = 0;
+    int find_interval = 0;
+    int find_repeat = 0;
+
+    if (drv == NULL) {
+        wpa_printf(MSG_ERROR, "%s: drv is NULL. Exiting", __func__);
+        return -1;
+    }
+    if (drv->ctx == NULL) {
+        wpa_printf(MSG_ERROR, "%s: drv->ctx is NULL. Exiting", __func__);
+        return -1;
+    }
+    wpa_s = (struct wpa_supplicant *)(drv->ctx);
+    if (wpa_s->conf == NULL) {
+        wpa_printf(MSG_ERROR, "%s: wpa_s->conf is NULL. Exiting", __func__);
+        return -1;
+    }
+    ssid_conf = wpa_s->conf->ssid;
+
+    bp = NL80211_BGSCAN_HEADER_SIZE;
+    os_memcpy(buf, NL80211_BGSCAN_HEADER, bp);
+
+    opstr = getop(cmd, &first_time);
+    while ((opstr = getop(cmd, &first_time)) != NULL) {
+        if((ptr = strstr(opstr, "SSID=")) != NULL) {
+            find_ssid = 1;
+            ptr = ptr + strlen("SSID=");
+            buf[bp++] = NL80211_CSCAN_SSID_SECTION;
+            buf[bp++] = strlen(ptr);
+            os_memcpy(&buf[bp], ptr, strlen(ptr));
+            bp += strlen(ptr);
+            i++;
+        }
+        else if((ptr = strstr(opstr, "RSSI=")) != NULL) {
+            ptr = ptr + strlen("RSSI=");
+            buf[bp++] = NL80211_BGSCAN_RSSI_SECTION;
+            buf[bp++] = atoi(ptr);
+        }
+        else if((ptr = strstr(opstr, "INTERVAL=")) != NULL) {
+            find_interval = 1;
+            ptr = ptr + strlen("INTERVAL=");
+            buf[bp++] = NL80211_BGSCAN_INTERVAL_SECTION;
+            buf[bp++] = (u8)atoi(ptr);
+            buf[bp++] = (u8)(atoi(ptr) >> 8);
+        }
+        else if((ptr = strstr(opstr, "REPEAT=")) != NULL) {
+            find_repeat = 1;
+            ptr = ptr + strlen("REPEAT=");
+            buf[bp++] = NL80211_BGSCAN_REPEAT_SECTION;
+            buf[bp++] = (u8)atoi(ptr);
+        }
+    }
+
+    if(!find_ssid) {
+        while ((i < NL80211_SSID_AMOUNT) && (ssid_conf != NULL)) {
+            if ((!ssid_conf->disabled) && (ssid_conf->ssid_len <= NL80211_SSID_MAX_SIZE)){
+                wpa_printf(MSG_DEBUG, "For BG Scan: %s", ssid_conf->ssid);
+                buf[bp++] = NL80211_CSCAN_SSID_SECTION;
+                buf[bp++] = ssid_conf->ssid_len;
+                os_memcpy(&buf[bp], ssid_conf->ssid, ssid_conf->ssid_len);
+                bp += ssid_conf->ssid_len;
+                i++;
+            }
+            ssid_conf = ssid_conf->next;
+        }
+    }
+
+    if(!find_interval){
+        buf[bp++] = NL80211_BGSCAN_INTERVAL_SECTION;
+        buf[bp++] = NL80211_BGSCAN_INTERVAL_DEF;
+        buf[bp++] = (NL80211_BGSCAN_INTERVAL_DEF >> 8);
+    }
+
+    if(!find_repeat){
+        buf[bp++] = NL80211_BGSCAN_REPEAT_SECTION;
+        buf[bp++] = NL80211_BGSCAN_REPEAT_DEF;
+    }
+
+    memset(&ifr, 0, sizeof(ifr));
+    memset(&priv_cmd, 0, sizeof(priv_cmd));
+    os_strlcpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+#if defined(__LP64__)
+    //driver only support 32bit user space, we fake one
+    priv_cmd.buf = (u64)buf & 0x00000000ffffffff;
+#else
+    u32 tmp = (u32)buf;
+    priv_cmd.buf = tmp;
+#endif
+    priv_cmd.used_len = NL80211_BGCAN_BUF_LEN;
+    priv_cmd.total_len = NL80211_BGCAN_BUF_LEN;
+    ifr.ifr_data = &priv_cmd;
+
+    if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 14, &ifr)) < 0) {
+        wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (bgscan config): %d", ret);
+    } else {
+        wpa_printf(MSG_DEBUG, "%s %s len = %d, %zu", __func__, buf, ret, strlen(buf));
+    }
+    return ret;
+}
+#endif
+
+int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
+                  size_t buf_len )
+{
+    struct i802_bss *bss = priv;
+    struct wpa_driver_nl80211_data *drv = bss->drv;
+    struct ifreq ifr;
+    android_wifi_priv_cmd priv_cmd;
+    int ret = 0;
+    wpa_printf(MSG_INFO, "the nl80211 driver cmd is %s\n", cmd);
+    wpa_printf(MSG_INFO, "the nl80211 driver cmd len is %zu\n", strlen(cmd));
+    if (os_strcasecmp(cmd, "STOP") == 0) {
+        linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 0);
+        wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
+    } else if (os_strcasecmp(cmd, "START") == 0) {
+        linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
+        wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
+    } else if(os_strncasecmp(cmd, "COUNTRY", strlen("COUNTRY")) == 0 && ((strlen(cmd) - strlen("COUNTRY") - 1) >= 2)) {
+        char alpha2[3];
+    struct nl_msg *msg;
+
+    msg = nlmsg_alloc();
+    if (!msg)
+        return -ENOMEM;
+
+    memcpy(alpha2, cmd + strlen("COUNTRY") + 1, strlen(cmd) - strlen("COUNTRY") - 1);
+    alpha2[2] = '\0';
+    if (!nl80211_cmd(drv, msg, 0, NL80211_CMD_REQ_SET_REG) ||
+    nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, alpha2)) {
+        nlmsg_free(msg);
+        return -EINVAL;
+    }
+    if (send_and_recv_msgs(drv, msg, NULL, NULL))
+        return -EINVAL;
+    } else if (os_strcasecmp(cmd, "MACADDR") == 0) {
+        u8 macaddr[ETH_ALEN] = {};
+
+        ret = linux_get_ifhwaddr(drv->global->ioctl_sock, bss->ifname, macaddr);
+        if (!ret)
+            ret = os_snprintf(buf, buf_len,
+                      "Macaddr = " MACSTR "\n", MAC2STR(macaddr));
+    } else if (os_strcasecmp(cmd, "RELOAD") == 0) {
+        wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+    } else { /* Use private command */
+#ifndef HOSTAPD
+        if (os_strncasecmp(cmd, "BGSCAN-START", 12) == 0) {
+            /* Issue a command 'BGSCAN-CONFIG' to driver */
+            ret = wpa_driver_set_backgroundscan_params(priv, cmd);
+            if (ret < 0){
+                wpa_printf(MSG_ERROR,
+                    "%s: failed to issue private command: BGSCAN-START\n", __func__);
+            }
+            return ret;
+        } else
+#endif
+        {
+            os_memcpy(buf, cmd, strlen(cmd) + 1);
+        }
+        memset(&ifr, 0, sizeof(ifr));
+        memset(&priv_cmd, 0, sizeof(priv_cmd));
+        os_strlcpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+
+#if defined(__LP64__)
+        priv_cmd.buf = (u64)buf;
+#else
+        u32 tmp = (u32)buf;
+        wpa_printf(MSG_ERROR, "%s: Buffer len = <%zu>\n", __func__, buf_len);
+        priv_cmd.buf = tmp;
+#endif
+        priv_cmd.used_len = buf_len;
+        priv_cmd.total_len = buf_len;
+        ifr.ifr_data = &priv_cmd;
+
+        if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 14, &ifr)) < 0) {
+            wpa_printf(MSG_ERROR, "%s: failed to issue private commands\n", __func__);
+            wpa_printf(MSG_ERROR, "the cmd is %s\n", cmd);
+            wpa_printf(MSG_ERROR, "the error is [%d]  [%s] \n", errno, strerror(errno));
+            //wpa_driver_send_hang_msg(drv);
+        } else {
+            drv_errors = 0;
+            ret = 0;
+            if ((os_strcasecmp(cmd, "LINKSPEED") == 0) ||
+                (os_strcasecmp(cmd, "RSSI") == 0) ||
+                (os_strcasecmp(cmd, "GETBAND") == 0) ||
+                (os_strncasecmp(cmd, "WLS_BATCHING", 12) == 0))
+                ret = strlen(buf);
+            else if ((os_strncasecmp(cmd, "COUNTRY", 7) == 0) ||
+                 (os_strncasecmp(cmd, "SETBAND", 7) == 0))
+
+                //wpa_supplicant_event(drv->ctx,
+                //    EVENT_CHANNEL_LIST_CHANGED, NULL);
+             //wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
+             wpa_printf(MSG_DEBUG, "%s %d %d", __func__, __LINE__, ret);
+        }
+    }
+    return ret;
+}
+
+int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration)
+{
+    char buf[MAX_DRV_CMD_SIZE];
+
+    memset(buf, 0, sizeof(buf));
+    wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+    snprintf(buf, sizeof(buf), "P2P_SET_NOA %d %d %d", count, start, duration);
+    return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf)+1);
+}
+
+int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len)
+{
+    /* Return 0 till we handle p2p_presence request completely in the driver */
+    return 0;
+}
+
+int wpa_driver_set_p2p_ps(void *priv, int legacy_ps, int opp_ps, int ctwindow)
+{
+    char buf[MAX_DRV_CMD_SIZE];
+
+    memset(buf, 0, sizeof(buf));
+    wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+    snprintf(buf, sizeof(buf), "P2P_SET_PS %d %d %d", legacy_ps, opp_ps, ctwindow);
+    return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf) + 1);
+}
+
+int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
+                 const struct wpabuf *proberesp,
+                 const struct wpabuf *assocresp)
+{
+    char *buf = NULL;
+    struct wpabuf *ap_wps_p2p_ie = NULL;
+    char *_cmd = "SET_AP_WPS_P2P_IE";
+    char *pbuf;
+    char *tb = NULL;
+    int ret = 0;
+    int i;
+    size_t buf_size, offset;
+    struct cmd_desc {
+        int cmd;
+        const struct wpabuf *src;
+    } cmd_arr[] = {
+        {0x1, beacon},
+        {0x2, proberesp},
+        {0x4, assocresp},
+        {-1, NULL}
+    };
+
+    buf = os_malloc(MAX_WPSP2PIE_CMD_SIZE);
+    if (buf == NULL) {
+        wpa_printf(MSG_DEBUG, "%s: %s (%d)", __func__, strerror(errno), errno);
+        return errno;
+    }
+    buf_size = MAX_WPSP2PIE_CMD_SIZE;
+    wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+    for (i = 0; cmd_arr[i].cmd != -1; i++) {
+        os_memset(buf, 0, buf_size);
+        pbuf = buf;
+        pbuf += sprintf(pbuf, "%s %d", _cmd, cmd_arr[i].cmd);
+        *pbuf++ = '\0';
+        ap_wps_p2p_ie = cmd_arr[i].src ?
+            wpabuf_dup(cmd_arr[i].src) : NULL;
+        if (ap_wps_p2p_ie) {
+            if ((size_t)(buf + buf_size - pbuf) < wpabuf_len(ap_wps_p2p_ie)) {
+                offset = pbuf - buf;
+                tb = os_realloc(buf, buf_size + wpabuf_len(ap_wps_p2p_ie) + 1);
+                if (tb == NULL) {
+                    wpa_printf(MSG_DEBUG, "%s: %s (%d)", __func__, strerror(errno), errno);
+                    os_free(buf);
+                    return errno;
+                }
+                buf = tb;
+                pbuf = buf + offset;
+                buf_size += wpabuf_len(ap_wps_p2p_ie) + 1;
+                os_memset(pbuf, 0, (buf_size - offset));
+                wpa_printf(MSG_DEBUG, "Realloc WPS P2P IE buffer size to %zu bytes", buf_size);
+            }
+            os_memcpy(pbuf, wpabuf_head(ap_wps_p2p_ie), wpabuf_len(ap_wps_p2p_ie));
+            ret = wpa_driver_nl80211_driver_cmd(priv, buf, buf,
+                strlen(_cmd) + 3 + wpabuf_len(ap_wps_p2p_ie));
+            wpabuf_free(ap_wps_p2p_ie);
+            if (ret < 0)
+                break;
+        }
+    }
+
+    if (buf) os_free(buf);
+    return ret;
+}
diff --git a/88x9098/wlan/hal/wlan_lib/driver_cmd_wext.c b/88x9098/wlan/hal/wlan_lib/driver_cmd_wext.c
new file mode 100644
index 0000000..e529eda
--- /dev/null
+++ b/88x9098/wlan/hal/wlan_lib/driver_cmd_wext.c
@@ -0,0 +1,462 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2021 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "includes.h"
+#include <sys/ioctl.h>
+#include <net/if_arp.h>
+#include <net/if.h>
+
+#include "linux_wext.h"
+#include "common.h"
+#include "driver.h"
+#include "eloop.h"
+#include "priv_netlink.h"
+#include "driver_wext.h"
+#include "ieee802_11_defs.h"
+#include "wpa_common.h"
+#include "wpa_ctrl.h"
+#include "wpa_supplicant_i.h"
+#include "config.h"
+#include "linux_ioctl.h"
+#include "scan.h"
+
+#include "driver_cmd_wext.h"
+#ifdef ANDROID
+#include "android_drv.h"
+#endif /* ANDROID */
+
+#define RSSI_CMD			"RSSI"
+#define LINKSPEED_CMD			"LINKSPEED"
+
+/**
+ * wpa_driver_wext_set_scan_timeout - Set scan timeout to report scan completion
+ * @priv:  Pointer to private wext data from wpa_driver_wext_init()
+ *
+ * This function can be used to set registered timeout when starting a scan to
+ * generate a scan completed event if the driver does not report this.
+ */
+static void wpa_driver_wext_set_scan_timeout(void *priv)
+{
+	struct wpa_driver_wext_data *drv = priv;
+	int timeout = 10; /* In case scan A and B bands it can be long */
+
+	/* Not all drivers generate "scan completed" wireless event, so try to
+	 * read results after a timeout. */
+	if (drv->scan_complete_events) {
+	/*
+	 * The driver seems to deliver SIOCGIWSCAN events to notify
+	 * when scan is complete, so use longer timeout to avoid race
+	 * conditions with scanning and following association request.
+	 */
+		timeout = 30;
+	}
+	wpa_printf(MSG_DEBUG, "Scan requested - scan timeout %d seconds",
+		   timeout);
+	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
+	eloop_register_timeout(timeout, 0, wpa_driver_wext_scan_timeout, drv,
+			       drv->ctx);
+}
+
+/**
+ * wpa_driver_wext_combo_scan - Request the driver to initiate combo scan
+ * @priv: Pointer to private wext data from wpa_driver_wext_init()
+ * @params: Scan parameters
+ * Returns: 0 on success, -1 on failure
+ */
+int wpa_driver_wext_combo_scan(void *priv, struct wpa_driver_scan_params *params)
+{
+	char buf[WEXT_CSCAN_BUF_LEN];
+	struct wpa_driver_wext_data *drv = priv;
+	struct iwreq iwr;
+	int ret, bp;
+	unsigned i;
+
+	if (!drv->driver_is_started) {
+		wpa_printf(MSG_DEBUG, "%s: Driver stopped", __func__);
+		return 0;
+	}
+
+	wpa_printf(MSG_DEBUG, "%s: Start", __func__);
+
+	/* Set list of SSIDs */
+	bp = WEXT_CSCAN_HEADER_SIZE;
+	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
+	for(i=0; i < params->num_ssids; i++) {
+		if ((bp + IW_ESSID_MAX_SIZE + 10) >= (int)sizeof(buf))
+			break;
+		wpa_printf(MSG_DEBUG, "For Scan: %s", params->ssids[i].ssid);
+		buf[bp++] = WEXT_CSCAN_SSID_SECTION;
+		buf[bp++] = params->ssids[i].ssid_len;
+		os_memcpy(&buf[bp], params->ssids[i].ssid, params->ssids[i].ssid_len);
+		bp += params->ssids[i].ssid_len;
+	}
+
+	/* Set list of channels */
+	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
+	buf[bp++] = 0;
+
+	/* Set passive dwell time (default is 250) */
+	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
+	buf[bp++] = (u8)WEXT_CSCAN_PASV_DWELL_TIME;
+	buf[bp++] = (u8)(WEXT_CSCAN_PASV_DWELL_TIME >> 8);
+
+	/* Set home dwell time (default is 40) */
+	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
+	buf[bp++] = (u8)WEXT_CSCAN_HOME_DWELL_TIME;
+	buf[bp++] = (u8)(WEXT_CSCAN_HOME_DWELL_TIME >> 8);
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = buf;
+	iwr.u.data.length = bp;
+
+	if ((ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr)) < 0) {
+		if (!drv->bgscan_enabled)
+			wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (cscan): %d", ret);
+		else
+			ret = 0;	/* Hide error in case of bg scan */
+	}
+	return ret;
+}
+
+static int wpa_driver_wext_set_cscan_params(char *buf, size_t buf_len, char *cmd)
+{
+	char *pasv_ptr;
+	int bp, i;
+	u16 pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+	u8 channel;
+
+	wpa_printf(MSG_DEBUG, "%s: %s", __func__, cmd);
+
+	/* Get command parameters */
+	pasv_ptr = os_strstr(cmd, ",TIME=");
+	if (pasv_ptr) {
+		*pasv_ptr = '\0';
+		pasv_ptr += 6;
+		pasv_dwell = (u16)atoi(pasv_ptr);
+		if (pasv_dwell == 0)
+			pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+	}
+	channel = (u8)atoi(cmd + 5);
+
+	bp = WEXT_CSCAN_HEADER_SIZE;
+	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
+
+	/* Set list of channels */
+	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
+	buf[bp++] = channel;
+	if (channel != 0) {
+		i = (pasv_dwell - 1) / WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+		for (; i > 0; i--) {
+			if ((size_t)(bp + 12) >= buf_len)
+				break;
+			buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
+			buf[bp++] = channel;
+		}
+	} else {
+		if (pasv_dwell > WEXT_CSCAN_PASV_DWELL_TIME_MAX)
+			pasv_dwell = WEXT_CSCAN_PASV_DWELL_TIME_MAX;
+	}
+
+	/* Set passive dwell time (default is 250) */
+	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
+	if (channel != 0) {
+		buf[bp++] = (u8)WEXT_CSCAN_PASV_DWELL_TIME_DEF;
+		buf[bp++] = (u8)(WEXT_CSCAN_PASV_DWELL_TIME_DEF >> 8);
+	} else {
+		buf[bp++] = (u8)pasv_dwell;
+		buf[bp++] = (u8)(pasv_dwell >> 8);
+	}
+
+	/* Set home dwell time (default is 40) */
+	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
+	buf[bp++] = (u8)WEXT_CSCAN_HOME_DWELL_TIME;
+	buf[bp++] = (u8)(WEXT_CSCAN_HOME_DWELL_TIME >> 8);
+
+	/* Set cscan type */
+	buf[bp++] = WEXT_CSCAN_TYPE_SECTION;
+	buf[bp++] = WEXT_CSCAN_TYPE_PASSIVE;
+	return bp;
+}
+
+static char *wpa_driver_get_country_code(int channels)
+{
+	char *country = "US"; /* WEXT_NUMBER_SCAN_CHANNELS_FCC */
+
+	if (channels == WEXT_NUMBER_SCAN_CHANNELS_ETSI)
+		country = "EU";
+	else if( channels == WEXT_NUMBER_SCAN_CHANNELS_MKK1)
+		country = "JP";
+	return country;
+}
+
+#ifndef HOSTAPD
+#define WEXT_BGSCAN_HEADER           "BGSCAN-CONFIG "
+#define WEXT_BGSCAN_HEADER_SIZE      14
+#define WEXT_SSID_AMOUNT             16
+#define WEXT_BGCAN_BUF_LEN           720
+#define WEXT_CSCAN_SSID_SECTION      'S'
+#define SSID_MAX_SIZE                32
+#define WEXT_BGSCAN_RSSI_SECTION     'R'
+#define WEXT_BGSCAN_INTERVAL_SECTION 'T'
+#define WEXT_BGSCAN_INTERVAL_DEF     30
+#define WEXT_BGSCAN_REPEAT_SECTION   'E'
+#define WEXT_BGSCAN_REPEAT_DEF       5
+
+static char *getop(char *s, int *first_time)
+{
+	const char delim[] = " \t\n";
+	char *p;
+	if (*first_time){
+		p = strtok(s, delim);
+		*first_time = FALSE;
+	}
+	else{
+		p = strtok(NULL, delim);
+	}
+	return (p);
+}
+
+static int wpa_driver_set_backgroundscan_params(void *priv, char *cmd)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct ifreq ifr;
+	android_wifi_priv_cmd priv_cmd;
+	struct wpa_supplicant *wpa_s;
+	int ret = 0, i = 0, bp;
+	char buf[WEXT_BGCAN_BUF_LEN];
+	struct wpa_ssid *ssid_conf;
+	int first_time = TRUE;
+	char *opstr = NULL;
+	char *ptr = NULL;
+	int find_ssid = 0;
+	int find_interval = 0;
+	int find_repeat = 0;
+
+	if (drv == NULL) {
+		wpa_printf(MSG_ERROR, "%s: drv is NULL. Exiting", __func__);
+		return -1;
+	}
+	if (drv->ctx == NULL) {
+		wpa_printf(MSG_ERROR, "%s: drv->ctx is NULL. Exiting", __func__);
+		return -1;
+	}
+	wpa_s = (struct wpa_supplicant *)(drv->ctx);
+	if (wpa_s->conf == NULL) {
+		wpa_printf(MSG_ERROR, "%s: wpa_s->conf is NULL. Exiting", __func__);
+		return -1;
+	}
+	ssid_conf = wpa_s->conf->ssid;
+
+	bp = WEXT_BGSCAN_HEADER_SIZE;
+	os_memcpy(buf, WEXT_BGSCAN_HEADER, bp);
+
+	opstr = getop(cmd, &first_time);
+	while ((opstr = getop(cmd, &first_time)) != NULL) {
+		if((ptr = strstr(opstr, "SSID=")) != NULL) {
+			find_ssid = 1;
+			ptr = ptr + strlen("SSID=");
+			buf[bp++] = WEXT_CSCAN_SSID_SECTION;
+			buf[bp++] = strlen(ptr);
+			os_memcpy(&buf[bp], ptr, strlen(ptr));
+			bp += strlen(ptr);
+			i++;
+		}
+		else if((ptr = strstr(opstr, "RSSI=")) != NULL) {
+			ptr = ptr + strlen("RSSI=");
+			buf[bp++] = WEXT_BGSCAN_RSSI_SECTION;
+			buf[bp++] = atoi(ptr);
+		}
+		else if((ptr = strstr(opstr, "INTERVAL=")) != NULL) {
+			find_interval = 1;
+			ptr = ptr + strlen("INTERVAL=");
+			buf[bp++] = WEXT_BGSCAN_INTERVAL_SECTION;
+			buf[bp++] = (u8)atoi(ptr);
+			buf[bp++] = (u8)(atoi(ptr) >> 8);
+		}
+		else if((ptr = strstr(opstr, "REPEAT=")) != NULL) {
+			find_repeat = 1;
+			ptr = ptr + strlen("REPEAT=");
+			buf[bp++] = WEXT_BGSCAN_REPEAT_SECTION;
+			buf[bp++] = (u8)atoi(ptr);
+		}
+	}
+
+	if(!find_ssid) {
+		while ((i < WEXT_SSID_AMOUNT) && (ssid_conf != NULL)) {
+			if ((!ssid_conf->disabled) && (ssid_conf->ssid_len <= SSID_MAX_SIZE)){
+				wpa_printf(MSG_DEBUG, "For BG Scan: %s", ssid_conf->ssid);
+				buf[bp++] = WEXT_CSCAN_SSID_SECTION;
+				buf[bp++] = ssid_conf->ssid_len;
+				os_memcpy(&buf[bp], ssid_conf->ssid, ssid_conf->ssid_len);
+				bp += ssid_conf->ssid_len;
+				i++;
+			}
+			ssid_conf = ssid_conf->next;
+		}
+	}
+
+	if(!find_interval){
+		buf[bp++] = WEXT_BGSCAN_INTERVAL_SECTION;
+		buf[bp++] = WEXT_BGSCAN_INTERVAL_DEF;
+		buf[bp++] = (WEXT_BGSCAN_INTERVAL_DEF >> 8);
+	}
+
+	if(!find_repeat){
+		buf[bp++] = WEXT_BGSCAN_REPEAT_SECTION;
+		buf[bp++] = WEXT_BGSCAN_REPEAT_DEF;
+	}
+
+	memset(&ifr, 0, sizeof(ifr));
+	memset(&priv_cmd, 0, sizeof(priv_cmd));
+	os_strncpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
+
+	priv_cmd.buf = buf;
+	priv_cmd.used_len = WEXT_BGCAN_BUF_LEN;
+	priv_cmd.total_len = WEXT_BGCAN_BUF_LEN;
+	ifr.ifr_data = &priv_cmd;
+
+	if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 14, &ifr)) < 0) {
+		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (bgscan config): %d", ret);
+	} else {
+		wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
+	}
+	return ret;
+}
+#endif
+
+int wpa_driver_wext_driver_cmd( void *priv, char *cmd, char *buf, size_t buf_len )
+{
+	struct wpa_driver_wext_data *drv = priv;
+	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+	struct iwreq iwr;
+	int ret = 0, flags;
+
+	wpa_printf(MSG_DEBUG, "%s %s len = %d", __func__, cmd, buf_len);
+
+	if (!drv->driver_is_started && (os_strcasecmp(cmd, "START") != 0)) {
+		wpa_printf(MSG_ERROR,"WEXT: Driver not initialized yet");
+		return -1;
+	}
+
+	if (os_strcasecmp(cmd, "RSSI-APPROX") == 0) {
+		os_strncpy(cmd, RSSI_CMD, MAX_DRV_CMD_SIZE);
+	} else if( os_strncasecmp(cmd, "SCAN-CHANNELS", 13) == 0 ) {
+		int no_of_chan;
+
+		no_of_chan = atoi(cmd + 13);
+		os_snprintf(cmd, MAX_DRV_CMD_SIZE, "COUNTRY %s",
+			wpa_driver_get_country_code(no_of_chan));
+	} else if (os_strcasecmp(cmd, "STOP") == 0) {
+		linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0);
+	} else if( os_strcasecmp(cmd, "RELOAD") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Reload command");
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+		return ret;
+#ifndef HOSTAPD
+	} else if( os_strncasecmp(cmd, "BGSCAN-START") == 0 ) {
+		/* Issue a command 'BGSCAN-CONFIG' to driver */
+		ret = wpa_driver_set_backgroundscan_params(priv);
+		if (ret < 0) {
+			wpa_printf(MSG_ERROR, "%s: failed to issue command: BGSCAN-START\n", __func__);
+		}
+		drv->bgscan_enabled = 1;
+		return ret;
+	} else if( os_strcasecmp(cmd, "BGSCAN-STOP") == 0 ) {
+		drv->bgscan_enabled = 0;
+		return 0;
+#endif
+	}
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	os_memcpy(buf, cmd, strlen(cmd) + 1);
+	iwr.u.data.pointer = buf;
+	iwr.u.data.length = buf_len;
+
+	if( os_strncasecmp(cmd, "CSCAN", 5) == 0 ) {
+		if (!wpa_s->scanning && ((wpa_s->wpa_state <= WPA_SCANNING) ||
+					(wpa_s->wpa_state >= WPA_COMPLETED))) {
+			iwr.u.data.length = wpa_driver_wext_set_cscan_params(buf, buf_len, cmd);
+		} else {
+			wpa_printf(MSG_ERROR, "Ongoing Scan action...");
+			return ret;
+		}
+	}
+
+	ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr);
+
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "%s failed (%d): %s", __func__, ret, cmd);
+		drv->errors++;
+		if (drv->errors > DRV_NUMBER_SEQUENTIAL_ERRORS) {
+			drv->errors = 0;
+			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+		}
+	} else {
+		drv->errors = 0;
+		ret = 0;
+		if ((os_strcasecmp(cmd, RSSI_CMD) == 0) ||
+		    (os_strcasecmp(cmd, LINKSPEED_CMD) == 0) ||
+		    (os_strcasecmp(cmd, "MACADDR") == 0) ||
+		    (os_strcasecmp(cmd, "GETPOWER") == 0) ||
+		    (os_strcasecmp(cmd, "GETBAND") == 0)) {
+			ret = strlen(buf);
+		} else if (os_strcasecmp(cmd, "START") == 0) {
+			drv->driver_is_started = TRUE;
+			linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1);
+			/* os_sleep(0, WPA_DRIVER_WEXT_WAIT_US);
+			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED"); */
+		} else if (os_strcasecmp(cmd, "STOP") == 0) {
+			drv->driver_is_started = FALSE;
+			/* wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED"); */
+		} else if (os_strncasecmp(cmd, "CSCAN", 5) == 0) {
+			wpa_driver_wext_set_scan_timeout(priv);
+			wpa_supplicant_notify_scanning(wpa_s, 1);
+		}
+		wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
+	}
+	return ret;
+}
+
+int wpa_driver_signal_poll(void *priv, struct wpa_signal_info *si)
+{
+	char buf[MAX_DRV_CMD_SIZE];
+	struct wpa_driver_wext_data *drv = priv;
+	char *prssi;
+	int res;
+
+	os_memset(si, 0, sizeof(*si));
+	res = wpa_driver_wext_driver_cmd(priv, RSSI_CMD, buf, sizeof(buf));
+	/* Answer: SSID rssi -Val */
+	if (res < 0)
+		return res;
+	prssi = strcasestr(buf, RSSI_CMD);
+	if (!prssi)
+		return -1;
+	si->current_signal = atoi(prssi + strlen(RSSI_CMD) + 1);
+
+	res = wpa_driver_wext_driver_cmd(priv, LINKSPEED_CMD, buf, sizeof(buf));
+	/* Answer: LinkSpeed Val */
+	if (res < 0)
+		return res;
+	si->current_txrate = atoi(buf + strlen(LINKSPEED_CMD) + 1) * 1000;
+
+	return 0;
+}
diff --git a/88x9098/wlan/hal/wlan_lib/driver_cmd_wext.h b/88x9098/wlan/hal/wlan_lib/driver_cmd_wext.h
new file mode 100644
index 0000000..ada5dd1
--- /dev/null
+++ b/88x9098/wlan/hal/wlan_lib/driver_cmd_wext.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Portions copyright (C) 2017 Broadcom Limited
+ * Portions copyright 2015-2021 NXP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DRIVER_CMD_WEXT_H
+#define DRIVER_CMD_WEXT_H
+
+#define WEXT_NUMBER_SCAN_CHANNELS_FCC	11
+#define WEXT_NUMBER_SCAN_CHANNELS_ETSI	13
+#define WEXT_NUMBER_SCAN_CHANNELS_MKK1	14
+
+#define WPA_DRIVER_WEXT_WAIT_US		400000
+#define WEXT_CSCAN_BUF_LEN		360
+#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
+#define WEXT_CSCAN_HEADER_SIZE		12
+#define WEXT_CSCAN_SSID_SECTION		'S'
+#define WEXT_CSCAN_CHANNEL_SECTION	'C'
+#define WEXT_CSCAN_NPROBE_SECTION	'N'
+#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
+#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
+#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
+#define WEXT_CSCAN_TYPE_SECTION		'T'
+#define WEXT_CSCAN_TYPE_DEFAULT		0
+#define WEXT_CSCAN_TYPE_PASSIVE		1
+#define WEXT_CSCAN_PASV_DWELL_TIME	130
+#define WEXT_CSCAN_PASV_DWELL_TIME_DEF	250
+#define WEXT_CSCAN_PASV_DWELL_TIME_MAX	3000
+#define WEXT_CSCAN_HOME_DWELL_TIME	130
+
+#endif /* DRIVER_CMD_WEXT_H */
-- 
2.25.1


From c7edc3af6e40965dfdef1afc896557997efb9adc Mon Sep 17 00:00:00 2001
From: TomWang <townwang@retronix.com.tw>
Date: Mon, 4 Sep 2023 13:25:48 +0800
Subject: [PATCH] support IVI GMSL camera.

---
 .../renesas/r8a7795-salvator-xs-android.dts   |  215 ++-
 arch/arm64/configs/android_salvator_defconfig |   11 +
 drivers/media/i2c/soc_camera/Kconfig          |   22 +
 drivers/media/i2c/soc_camera/Makefile         |    4 +-
 drivers/media/i2c/soc_camera/ar0233.c         |  514 ++++++
 drivers/media/i2c/soc_camera/ar0233.h         | 1168 ++++++++++++
 drivers/media/i2c/soc_camera/common.h         |  512 ++++++
 drivers/media/i2c/soc_camera/gmsl_common.h    |  517 ++++++
 drivers/media/i2c/soc_camera/max9295.h        |   39 +
 drivers/media/i2c/soc_camera/max96712.c       | 1616 +++++++++++++++++
 drivers/media/i2c/soc_camera/max96712.h       |  313 ++++
 drivers/media/i2c/soc_camera/max96712_debug.h |  362 ++++
 drivers/media/i2c/soc_camera/rtx_ov10635.c    |  703 +++++++
 drivers/media/i2c/soc_camera/rtx_ov10635.h    | 1143 ++++++++++++
 .../media/i2c/soc_camera/rtx_ov10635_debug.h  |   54 +
 drivers/media/platform/rcar-vin/rcar-core.c   |    5 +
 drivers/media/platform/rcar-vin/rcar-dma.c    |    5 +
 .../nxp/88x9098/wlan_src/script/usbconfig     |  Bin 0 -> 9098 bytes
 drivers/regulator/Kconfig                     |    6 +
 drivers/regulator/Makefile                    |    1 +
 drivers/regulator/max2008x-regulator.c        |  525 ++++++
 21 files changed, 7726 insertions(+), 9 deletions(-)
 create mode 100644 drivers/media/i2c/soc_camera/ar0233.c
 create mode 100644 drivers/media/i2c/soc_camera/ar0233.h
 create mode 100644 drivers/media/i2c/soc_camera/common.h
 create mode 100644 drivers/media/i2c/soc_camera/gmsl_common.h
 create mode 100644 drivers/media/i2c/soc_camera/max9295.h
 create mode 100644 drivers/media/i2c/soc_camera/max96712.c
 create mode 100644 drivers/media/i2c/soc_camera/max96712.h
 create mode 100644 drivers/media/i2c/soc_camera/max96712_debug.h
 create mode 100644 drivers/media/i2c/soc_camera/rtx_ov10635.c
 create mode 100644 drivers/media/i2c/soc_camera/rtx_ov10635.h
 create mode 100644 drivers/media/i2c/soc_camera/rtx_ov10635_debug.h
 create mode 100644 drivers/net/wireless/nxp/88x9098/wlan_src/script/usbconfig
 create mode 100644 drivers/regulator/max2008x-regulator.c

diff --git a/arch/arm64/boot/dts/renesas/r8a7795-salvator-xs-android.dts b/arch/arm64/boot/dts/renesas/r8a7795-salvator-xs-android.dts
index 3e937dff9235..926069c09518 100644
--- a/arch/arm64/boot/dts/renesas/r8a7795-salvator-xs-android.dts
+++ b/arch/arm64/boot/dts/renesas/r8a7795-salvator-xs-android.dts
@@ -16,6 +16,9 @@
 #include "r8a7795.dtsi"
 
 #define SSI6_USE_USB2_PINS
+//#define CAMERA_AR0233
+#define CAMERA_OV10635
+
 
 / {
 	model = "Retronix IVI board based on r8a7795 ES3.0+ with 16GiB (4x4 GiB)";
@@ -437,12 +440,17 @@
 
 	gpio_keys {
 		compatible = "gpio-keys";
+		
+		soft-sw2 {
+			label = "SW-2-3";
+			gpios = <&gpio5 22 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_F3>;
+		};
 
-		power {
-			label = "SW-TACT-22";
+		soft-sw3 {
+			label = "SW-2-4";
 			gpios = <&gpio5 23 GPIO_ACTIVE_LOW>;
-			linux,code = <116>;
-			gpio-key,wakeup;
+			linux,code = <KEY_F4>;
 		};
 		
 	};
@@ -753,7 +761,7 @@
 			csi41_in: endpoint {
 				clock-lanes = <0>;
 				data-lanes = <1 2 3 4>;
-				/* remote-endpoint = <&adv7482_txa>; */
+				remote-endpoint = <&deser_out0>;
 			};
 		};
 	};
@@ -1308,13 +1316,204 @@
 	};
 
 	U4600: MAX96712@29 { /* MAX96712 over level shift ic TXS0104(U4601) */
-		compatible = "max,MAX96712";
+		compatible = "maxim,max96712";
 		reg = <0x29>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		regs = <0x0c 0x0d 0x0e 0x0f>;
+		// shutdown-gpios = <&gpio3 2 GPIO_ACTIVE_HIGH>; /* HW pull up directly */
+		maxim,links-mipi-map = <1 1 1 1>;
+		maxim,vc_base = <0>;
+		
+		
+#ifdef CAMERA_OV10635
+		maxim,dt = <0x1e>;
+		maxim,gmsl = <1>;
+		maxim,hsync = <0>;
+		maxim,vsync = <0>;
+		maxim,de = <1>;
+#endif
+#ifdef CAMERA_OX03F10
+		maxim,dt = <0x2b>;
+		maxim,gmsl = <2>;
+		maxim,hsync = <1>;
+		maxim,vsync = <1>;
+		maxim,de = <1>;
+		maxim,gmsl-rate = <1>;//1 for 3Gbps, 2 for 6Gbps
+		csi-rate = <1200>;
+#endif
+#ifdef CAMERA_AR0233
+		maxim,dt = <0x2c>;
+		maxim,gmsl = <2>;
+		maxim,hsync = <1>;
+		maxim,vsync = <1>;
+		maxim,de = <1>;
+		maxim,gmsl-rate = <2>;//1 for 3Gbps, 2 for 6Gbps
+#endif
+		poc0-supply = <&vdd_cam2>;
+		poc1-supply = <&vdd_cam0>;
+		poc2-supply = <&vdd_cam1>;
+		poc3-supply = <&vdd_cam3>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				deser_in0: endpoint {
+					remote-endpoint = <&camera_out0>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				deser_in1: endpoint {
+					remote-endpoint = <&camera_out1>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				deser_in2: endpoint {
+					remote-endpoint = <&camera_out2>;
+				};
+			};
+
+			port@3 {
+				reg = <3>;
+				deser_in3: endpoint {
+					remote-endpoint = <&camera_out3>;
+				};
+			};
+
+			port@4 {
+				reg = <4>;
+				deser_out0: endpoint {
+					clock-lanes = <0>;
+					data-lanes = <1 2 3 4>;
+					remote-endpoint = <&csi41_in>;
+				};
+			};
+		};
+	
+		i2c@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0>;
+
+			camera@60 {
+#ifdef CAMERA_AR0233
+				compatible = "quanta,ar0233";
+#endif
+#ifdef CAMERA_OV10635
+				compatible = "ovti,ov10635";
+				dvp-order = <1>;
+#endif
+				reg = <0x60 0x0c>;
+
+				port {
+					camera_out0: endpoint {
+						remote-endpoint = <&deser_in0>;
+					};
+				};
+			};
+		};
+
+		i2c@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+
+			camera@61 {
+#ifdef CAMERA_AR0233
+				compatible = "quanta,ar0233";
+#endif
+#ifdef CAMERA_OV10635
+				compatible = "ovti,ov10635";
+#endif
+				reg = <0x61 0x0d>;
+
+				port {
+					camera_out1: endpoint {
+						remote-endpoint = <&deser_in1>;
+					};
+				};
+			};
+		};
+
+		i2c@2 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <2>;
+
+			camera@62 {
+#ifdef CAMERA_AR0233
+				compatible = "quanta,ar0233";
+#endif
+#ifdef CAMERA_OV10635
+				compatible = "ovti,ov10635";
+#endif
+				reg = <0x62 0x0e>;
+
+				port {
+					camera_out2: endpoint {
+						remote-endpoint = <&deser_in2>;
+					};
+				};
+			};
+		};
+
+		i2c@3 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <3>;
+
+			camera@63 {
+#ifdef CAMERA_AR0233
+				compatible = "quanta,ar0233";
+#endif
+#ifdef CAMERA_OV10635
+				compatible = "ovti,ov10635";
+#endif
+				reg = <0x63 0x0f>;
+
+				port {
+					camera_out3: endpoint {
+						remote-endpoint = <&deser_in3>;
+					};
+				};
+			};
+		};
 	};
 
-	U4602: MAX20087@28 { /* MAX20087 for Camera power */
-		compatible = "max,MAX20087";
+	max2008x@28 {
+		compatible = "maxim,max2008x";
 		reg = <0x28>;
+		#io-channel-cells = <1>;
+		status = "okay";//"disabled";//
+		
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			vdd_cam0: SW0 {
+				reg = <0>;
+				regulator-name = "Camera-0";
+			};
+			vdd_cam1: SW1 {
+				reg = <1>;
+				regulator-name = "Camera-1";
+			};
+			vdd_cam2: SW2 {
+				reg = <2>;
+				regulator-name = "Camera-2";
+			};
+			vdd_cam3: SW3 {
+				reg = <3>;
+				regulator-name = "Camera-3";
+			};
+		};
 	};
 };
 
diff --git a/arch/arm64/configs/android_salvator_defconfig b/arch/arm64/configs/android_salvator_defconfig
index 0cf28746e481..cb4632990718 100644
--- a/arch/arm64/configs/android_salvator_defconfig
+++ b/arch/arm64/configs/android_salvator_defconfig
@@ -382,6 +382,11 @@ CONFIG_USB_VIDEO_CLASS=m
 CONFIG_V4L_PLATFORM_DRIVERS=y
 CONFIG_SOC_CAMERA=y
 CONFIG_SOC_CAMERA_PLATFORM=y
+
+CONFIG_SOC_CAMERA_MAX9286=y
+CONFIG_SOC_CAMERA_MAX96712=y
+#CONFIG_SOC_CAMERA_OV106XX=y
+
 CONFIG_VIDEO_RCAR_CSI2=y
 CONFIG_VIDEO_RCAR_VIN=y
 CONFIG_VIDEO_RCAR_VIN_DEBUG=y
@@ -556,3 +561,9 @@ CONFIG_CRYPTO_GHASH_ARM64_CE=y
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_REGULATOR_MAX2008X=y
+CONFIG_SOC_CAMERA_AR0233=y
+CONFIG_SOC_CAMERA_OV10635=y
diff --git a/drivers/media/i2c/soc_camera/Kconfig b/drivers/media/i2c/soc_camera/Kconfig
index d30a3f9fbde1..a2b08154320a 100644
--- a/drivers/media/i2c/soc_camera/Kconfig
+++ b/drivers/media/i2c/soc_camera/Kconfig
@@ -83,6 +83,12 @@ config SOC_CAMERA_MAX9286
 	help
 	  This is a MAXIM max9286 GMSL driver
 
+config SOC_CAMERA_MAX96712
+	tristate "max96712 GMSL support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a MAXIM max96712 GMSL driver
+	  
 config SOC_CAMERA_TI9X4
 	tristate "ti9x4 FPDLink3 support"
 	depends on SOC_CAMERA && I2C
@@ -94,3 +100,19 @@ config SOC_CAMERA_OV106XX
 	depends on SOC_CAMERA && I2C
 	help
 	  This is a runtime detected GMSL/FPDLink3 sensors driver
+
+config SOC_CAMERA_AR0233
+	tristate "ar0233 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a runtime detected GMSL sensors driver
+
+config SOC_CAMERA_OV10635
+	tristate "ov10635 camera support"
+	depends on I2C && VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a GMSL/FPDLink cameras support
+	  This camera should be used in conjunction with a GMSL or
+	  or FPDLink deserialiser
+	
diff --git a/drivers/media/i2c/soc_camera/Makefile b/drivers/media/i2c/soc_camera/Makefile
index 1134c039fafe..7d80d4bdf067 100644
--- a/drivers/media/i2c/soc_camera/Makefile
+++ b/drivers/media/i2c/soc_camera/Makefile
@@ -13,4 +13,6 @@ obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
 obj-$(CONFIG_SOC_CAMERA_MAX9286)	+= max9286.o
 obj-$(CONFIG_SOC_CAMERA_TI9X4)		+= ti9x4.o
 obj-$(CONFIG_SOC_CAMERA_OV106XX)	+= ov106xx.o
-
+obj-$(CONFIG_SOC_CAMERA_AR0233) 	+= ar0233.o
+obj-$(CONFIG_SOC_CAMERA_OV10635) 	+= rtx_ov10635.o
+obj-$(CONFIG_SOC_CAMERA_MAX96712)	+= max96712.o
diff --git a/drivers/media/i2c/soc_camera/ar0233.c b/drivers/media/i2c/soc_camera/ar0233.c
new file mode 100644
index 000000000000..8d0d0dcdd5f0
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/ar0233.c
@@ -0,0 +1,514 @@
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/soc_camera.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+
+#include "ar0233.h"
+#include "max9295.h"
+#include "gmsl_common.h"
+
+static const int ar0233_i2c_addr[] = {0x10};
+
+#define AR0233_PID_REG		0x3000
+#define AR0233_REV_REG		0x0058
+
+#define AR0233_PID		0x0956
+
+#define ar0233_MEDIA_BUS_FMT	MEDIA_BUS_FMT_SRGGB12_1X12
+
+struct ar0233_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializer */
+	int				ser_addr;
+};
+
+static inline struct ar0233_priv *to_ar0233(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ar0233_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ar0233_priv, hdl)->sd;
+}
+
+static int max9295_set_regs(struct i2c_client *client, const struct max9295_reg *regs, int nr_regs)
+{
+	struct ar0233_priv *priv = to_ar0233(client);
+	int i = 0;
+	int val;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == MAX9295_TABLE_END) {
+			mdelay(1000);
+			continue;
+		}
+		reg16_write_addr(client, priv->ser_addr, regs[i].reg, regs[i].val);
+	}
+
+	return 0;
+}
+
+static int ar0233_set_regs(struct i2c_client *client,
+			  const struct ar0233_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == AR0233_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+		
+		reg16_write16(client, regs[i].reg, regs[i].val);
+	}
+
+	return 0;
+}
+
+static int ar0233_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ar0233_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0233_priv *priv = to_ar0233(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = ar0233_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ar0233_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = ar0233_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ar0233_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = ar0233_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ar0233_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0233_priv *priv = to_ar0233(client);
+
+	return 0;
+}
+
+static int ar0233_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0233_priv *priv = to_ar0233(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ar0233_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0233_priv *priv = to_ar0233(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ar0233_g_mbus_config(struct v4l2_subdev *sd,
+				struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+#ifdef KERNEL_5
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+#else
+	cfg->type = V4L2_MBUS_CSI2;
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ar0233_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = reg16_read16(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ar0233_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return reg16_write16(client, (u16)reg->reg, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops ar0233_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ar0233_g_register,
+	.s_register = ar0233_s_register,
+#endif
+};
+
+static int ar0233_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0233_priv *priv = to_ar0233(client);
+	int ret = -EINVAL;
+	u16 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ar0233_ctrl_ops = {
+	.s_ctrl = ar0233_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ar0233_video_ops = {
+	.s_stream	= ar0233_s_stream,
+	.g_mbus_config	= ar0233_g_mbus_config,
+};
+
+static const struct v4l2_subdev_pad_ops ar0233_subdev_pad_ops = {
+	.get_edid	= ar0233_get_edid,
+	.enum_mbus_code	= ar0233_enum_mbus_code,
+	.get_selection	= ar0233_get_selection,
+	.set_selection	= ar0233_set_selection,
+	.get_fmt	= ar0233_get_fmt,
+	.set_fmt	= ar0233_set_fmt,
+};
+
+static struct v4l2_subdev_ops ar0233_subdev_ops = {
+	.core	= &ar0233_core_ops,
+	.video	= &ar0233_video_ops,
+	.pad	= &ar0233_subdev_pad_ops,
+};
+
+static ssize_t ar0233_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ar0233_priv *priv = to_ar0233(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ar0233, S_IRUGO, ar0233_otp_id_show, NULL);
+
+static int ar0233_initialize(struct i2c_client *client)
+{
+	struct ar0233_priv *priv = to_ar0233(client);
+	u16 pid = 0, rev = 0, val = 0;
+
+	if(priv->ser_addr == 0x0c)//first camera
+	{
+		mdelay(3000);
+	}
+
+	{	
+		max9295_set_regs(client, max9295_regs_rtx_1, ARRAY_SIZE(max9295_regs_rtx_1));
+	}
+
+	setup_i2c_translator(client, priv->ser_addr, ar0233_i2c_addr[0]);
+		
+	/* check product ID */
+	reg16_read16(client, AR0233_PID_REG, &pid);
+
+	if (pid != AR0233_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	{
+		ar0233_set_regs(client, ar0233_2048x1280_crop_30fps_final, ARRAY_SIZE(ar0233_2048x1280_crop_30fps_final)); 
+	}
+	
+	priv->max_width = AR0233_MAX_WIDTH;
+	priv->max_height = AR0233_MAX_HEIGHT;
+
+	dev_info(&client->dev, "PID %x (rev%x), res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, rev, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+
+	return 0;
+}
+
+static int ar0233_parse_dt(struct device_node *np, struct ar0233_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ar0233_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{	
+	struct ar0233_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ar0233_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ar0233_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ar0233_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ar0233_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+	
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ar0233) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ar0233_remove(struct i2c_client *client)
+{
+	struct ar0233_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ar0233);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ar0233_id[] = {
+	{ "ar0233", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0233_id);
+
+static const struct of_device_id ar0233_of_ids[] = {
+	{ .compatible = "quanta,ar0233", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ar0233_of_ids);
+
+static struct i2c_driver ar0233_i2c_driver = {
+	.driver	= {
+		.name = "ar0233",
+		.of_match_table = ar0233_of_ids,
+	},
+	.probe = ar0233_probe,
+	.remove = ar0233_remove,
+	.id_table = ar0233_id,
+};
+
+module_i2c_driver(ar0233_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for AR0233");
+MODULE_AUTHOR("Retronix");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/soc_camera/ar0233.h b/drivers/media/i2c/soc_camera/ar0233.h
new file mode 100644
index 000000000000..289f6d8d883e
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/ar0233.h
@@ -0,0 +1,1168 @@
+/*
+ * ON Semiconductor AP020X-AR023X sensor camera
+ *
+ * Copyright (C) 2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define AR0233_MAX_WIDTH	1920
+#define AR0233_MAX_HEIGHT	1200
+
+#define AR0233_TABLE_WAIT_MS	0xff00
+#define AR0233_TABLE_END	0xff01
+
+#define AR0233_DELAY		0xffff
+
+struct ar0233_reg {
+	u16	reg;
+	u16	val;
+};
+
+///////////////////////////////////
+#define MAX9295_TABLE_END	0xff01
+
+struct max9295_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct max9295_reg max9295_regs_rtx_1[] = {
+/* enable FSIN */
+{0x002,  0xF3},
+{0x330,  0x00},
+{0x331,  0x33},
+{0x332,  0xE4},
+{0x333,  0xE4},
+{0x0003, 0x07},
+{0x0006, 0xBF},
+{0x03F0, 0x51},
+{0x02CA, 0x80},
+{0x02CB, 0x24},
+{MAX9295_TABLE_END, 0x00},
+{0x02CA, 0x90},
+{0x02CB, 0x24},
+{MAX9295_TABLE_END, 0x00}
+};
+
+
+static const struct ar0233_reg ar0233_2048x1280_crop_30fps_final[] = {
+{0x3C72, 0x0076},
+{0x3C74, 0x0031},
+{0x3C76, 0x00DC},
+{0x3C78, 0x01AA},
+{0x3C7A, 0x0352},
+{0x3C7C, 0x06AA},
+{0x356A, 0x81AA},
+{0x3568, 0x0028},
+{0x37B2, 0x1FFF},
+{0x3562, 0x0C08},
+{0x3520, 0x0080},
+{0x353C, 0x9A8A},
+{0x3576, 0x1DFF},
+{0x3544, 0x030F},
+{0x3534, 0x3898},
+{0x353A, 0x9A9A},
+{0x356E, 0x048A},
+{0x3564, 0x1223},
+{0x3508, 0xAF1A},
+{0x3086, 0x0000},
+{0x34BA, 0x0001},
+{0x34B8, 0x0001},
+{0x3550, 0x806C},
+{0x3522, 0x0519},
+{0x3E3E, 0x000C},
+{0x3092, 0x408C},
+{0x3530, 0x1F18},
+{0x350E, 0x2092},
+{0x336E, 0x0142},
+{0x3364, 0x0766},
+{0x3528, 0xE008},
+{0x351A, 0xF400},
+{0x357A, 0x0044},
+{0x3514, 0x5B5B},
+{0x3578, 0x5B5B},
+{0x3526, 0x1000},
+{0x3518, 0x4444},
+{0x352A, 0x0827},
+{0x3548, 0x3A28},
+{0x354A, 0x323C},
+{0x3512, 0x0EDC},
+{0x352C, 0xA800},
+{0x2512, 0x8000}, 
+{0x2510, 0x070F}, 
+{0x2510, 0x1011}, 
+{0x2510, 0x1216}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0x191A},
+{0x2510, 0x1E1F},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0x213F},
+{0x2510, 0x5071},
+{0x2510, 0x8489},
+{0x2510, 0x8C8F},
+{0x2510, 0x92FF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xC003}, 
+{0x2510, 0x805A},
+{0x2510, 0xA0E0}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3042}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3048}, 
+{0x2510, 0x3088}, 
+{0x2510, 0x30A0}, 
+{0x2510, 0x3090}, 
+{0x2510, 0x32C2},
+{0x2510, 0xA0C0}, 
+{0x2510, 0x9008}, 
+{0x2510, 0x8802}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x9018}, 
+{0x2510, 0x891A}, 
+{0x2510, 0x807E},
+{0x2510, 0x20FF}, 
+{0x2510, 0x895B}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x897B}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x897F}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0xA0C4}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x805A},
+{0x2510, 0x9039}, 
+{0x2510, 0x20FF}, 
+{0x2510, 0x907F}, 
+{0x2510, 0x895B}, 
+{0x2510, 0x2064}, 
+{0x2510, 0x891B}, 
+{0x2510, 0x2010}, 
+{0x2510, 0x8803}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF},
+{0x2510, 0x7FFF},
+{0x2510, 0x20FF}, 
+{0x2510, 0x906B}, 
+{0x2510, 0x2064}, 
+{0x2510, 0x3084}, 
+{0x2510, 0x2003}, 
+{0x2510, 0x3044}, 
+{0x2510, 0x2000}, 
+{0x2510, 0xA004}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x2400}, 
+{0x2510, 0x2401}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x2400}, 
+{0x2510, 0x2401}, 
+{0x2510, 0x2702}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2421}, 
+{0x2510, 0x2703}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2421}, 
+{0x2510, 0x2704}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2421}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x2201},
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x2741}, 
+{0x2510, 0x2428},
+{0x2510, 0x2740}, 
+{0x2510, 0x2428},
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0xB800}, 
+{0x2510, 0x8058}, 
+{0x2510, 0xA005}, 
+{0x2510, 0x3101}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3104}, 
+{0x2510, 0xB035}, 
+{0x2510, 0xB075}, 
+{0x2510, 0x30C1}, 
+{0x2510, 0x3102}, 
+{0x2510, 0x3041}, 
+{0x2510, 0xB808},
+{0x2510, 0x3202}, 
+{0x2510, 0xB848}, 
+{0x2510, 0xB84C}, 
+{0x2510, 0x2201},
+{0x2510, 0xB377}, 
+{0x2510, 0x8843}, 
+{0x2510, 0x916F}, 
+{0x2510, 0x2201},
+{0x2510, 0xB84E}, 
+{0x2510, 0xF905}, 
+{0x2510, 0xF907}, 
+{0x2510, 0x2200}, 
+{0x2510, 0x885B}, 
+{0x2510, 0xA898}, 
+{0x2510, 0xA8D8}, 
+{0x2510, 0xF8E8}, 
+{0x2510, 0x80D8},
+{0x2510, 0x9007}, 
+{0x2510, 0x916F}, 
+{0x2510, 0x2206}, 
+{0x2510, 0xB808}, 
+{0x2510, 0xC800}, 
+{0x2510, 0xE809}, 
+{0x2510, 0x88DB},
+{0x2510, 0xF8A8}, 
+{0x2510, 0xF888}, 
+{0x2510, 0x2203}, 
+{0x2510, 0xB07B}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x80C8},
+{0x2510, 0x8088},
+{0x2510, 0x220B}, 
+{0x2510, 0xB06A}, 
+{0x2510, 0x88CB},
+{0x2510, 0x888B},
+{0x2510, 0x2224}, 
+{0x2510, 0xB04A}, 
+{0x2510, 0x2218}, 
+{0x2510, 0x210D},
+{0x2510, 0x2108},
+{0x2510, 0x902F}, 
+{0x2510, 0xB04B}, 
+{0x2510, 0xF880}, 
+{0x2510, 0x2205},
+{0x2510, 0x2205},
+{0x2510, 0x2203},
+{0x2510, 0x9800},
+{0x2510, 0xB043}, 
+{0x2510, 0xA8C9}, 
+{0x2510, 0x31C1}, 
+{0x2510, 0x80A8},
+{0x2510, 0x2205}, 
+{0x2510, 0x916F}, 
+{0x2510, 0x2104}, 
+{0x2510, 0x88AB},
+{0x2510, 0x2104},
+{0x2510, 0xB808},
+{0x2510, 0x9800},
+{0x2510, 0x2440}, 
+{0x2510, 0xF110}, 
+{0x2510, 0xF804}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x8088}, 
+{0x2510, 0x3002}, 
+{0x2510, 0xB838}, 
+{0x2510, 0xA8C8}, 
+{0x2510, 0xB04B}, 
+{0x2510, 0x2442}, 
+{0x2510, 0x3210}, 
+{0x2510, 0x2206}, 
+{0x2510, 0x888B}, 
+{0x2510, 0x2203},
+{0x2510, 0xF1CB},
+{0x2510, 0xF1CC},
+{0x2510, 0xF1CC},
+{0x2510, 0x2201},
+{0x2510, 0x3202}, 
+{0x2510, 0xF880}, 
+{0x2510, 0xB830},
+{0x2510, 0xC801}, 
+{0x2510, 0x30C2}, 
+{0x2510, 0xE80C}, 
+{0x2510, 0x2201}, 
+{0x2510, 0xB04A}, 
+{0x2510, 0x2226},
+{0x2510, 0x2205},
+{0x2510, 0x3241}, 
+{0x2510, 0x2206},
+{0x2510, 0x902F}, 
+{0x2510, 0x220E},
+{0x2510, 0x2205},
+{0x2510, 0x2204}, 
+{0x2510, 0xB042}, 
+{0x2510, 0xA9A1}, 
+{0x2510, 0x8008}, 
+{0x2510, 0xB0D3},
+{0x2510, 0x31C1}, 
+{0x2510, 0x916B}, 
+{0x2510, 0x2008},
+{0x2510, 0x32C1},
+{0x2510, 0x8803}, 
+{0x2510, 0xA044}, 
+{0x2510, 0x3044}, 
+{0x2510, 0x2000}, 
+{0x2510, 0xA004}, 
+{0x2510, 0x2000},
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0xA084}, 
+{0x2510, 0x30D0}, 
+{0x2510, 0x807C},
+{0x2510, 0x3141}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3042}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3142}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3042},
+{0x2510, 0x2000},
+{0x2510, 0x3281},
+{0x2510, 0x3041},
+{0x2510, 0x3042},
+{0x2510, 0x2000},
+{0x2510, 0x3290},
+{0x2510, 0x3041},
+{0x2510, 0x3042},
+{0x2510, 0x2000}, 
+{0x2510, 0x3110}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3120}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3282},
+{0x2510, 0x3041}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x32A0},
+{0x2510, 0x3041}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x881B}, 
+{0x2510, 0x887F},
+{0x2510, 0xA08C}, 
+{0x2510, 0x221F}, 
+{0x2510, 0xA084}, 
+{0x2510, 0x2440}, 
+{0x2510, 0x3260},
+{0x2510, 0x3248},
+{0x2510, 0xB095}, 
+{0x2510, 0xF110}, 
+{0x2510, 0xF864}, 
+{0x2510, 0xF90D}, 
+{0x2510, 0x3084}, 
+{0x2510, 0x32C1},
+{0x2510, 0x3090}, 
+{0x2510, 0x3088}, 
+{0x2510, 0x2443},
+{0x2510, 0x8058}, 
+{0x2510, 0x3001}, 
+{0x2510, 0x2442}, 
+{0x2510, 0x3220}, 
+{0x2510, 0x2002}, 
+{0x2510, 0x8867},
+{0x2510, 0x2004}, 
+{0x2510, 0x8803}, 
+{0x2510, 0x2441}, 
+{0x2510, 0x30C2}, 
+{0x2510, 0xA9A0}, 
+{0x2510, 0xB094}, 
+{0x2510, 0x2201}, 
+{0x2510, 0xA0C4}, 
+{0x2510, 0x3044}, 
+{0x2510, 0x2000}, 
+{0x2510, 0xA004}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0xB980}, 
+{0x2510, 0xA881},
+{0x2510, 0xA8C1},
+{0x2510, 0x8108}, 
+{0x2510, 0xA105}, 
+{0x2510, 0x30C1}, 
+{0x2510, 0x2020},
+{0x2510, 0x3101}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3104}, 
+{0x2510, 0x3102}, 
+{0x2510, 0x3041}, 
+{0x2510, 0xF860}, 
+{0x2510, 0xB095}, 
+{0x2510, 0x2001},
+{0x2510, 0xB988},
+{0x2510, 0xB9F8}, 
+{0x2510, 0xB9FC}, 
+{0x2510, 0x8803}, 
+{0x2510, 0x916F}, 
+{0x2510, 0x2001},
+{0x2510, 0xB9FE}, 
+{0x2510, 0xF905}, 
+{0x2510, 0xF907}, 
+{0x2510, 0x3202}, 
+{0x2510, 0x880B}, 
+{0x2510, 0xB397}, 
+{0x2510, 0xF8E8}, 
+{0x2510, 0x8188},
+{0x2510, 0x9007}, 
+{0x2510, 0x916F}, 
+{0x2510, 0x2204}, 
+{0x2510, 0xB137}, 
+{0x2510, 0xB9B8}, 
+{0x2510, 0xC801}, 
+{0x2510, 0xE809}, 
+{0x2510, 0xB177}, 
+{0x2510, 0x888B},
+{0x2510, 0xF8A8}, 
+{0x2510, 0xF888}, 
+{0x2510, 0x2203}, 
+{0x2510, 0xA8C8},
+{0x2510, 0xB07B}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x8188},
+{0x2510, 0x8088},
+{0x2510, 0x220B}, 
+{0x2510, 0xB06A}, 
+{0x2510, 0x888B},
+{0x2510, 0x888B},
+{0x2510, 0x2224}, 
+{0x2510, 0xB04A}, 
+{0x2510, 0x2218}, 
+{0x2510, 0x210A},
+{0x2510, 0x210A},
+{0x2510, 0xB04B}, 
+{0x2510, 0x902F}, 
+{0x2510, 0xF880}, 
+{0x2510, 0x2211},
+{0x2510, 0x2205},
+{0x2510, 0x2204}, 
+{0x2510, 0xB043}, 
+{0x2510, 0xA8C1},
+{0x2510, 0x31C1}, 
+{0x2510, 0x2200},
+{0x2510, 0x8048},
+{0x2510, 0x2103}, 
+{0x2510, 0x916F}, 
+{0x2510, 0x2106}, 
+{0x2510, 0x884B},
+{0x2510, 0x210A},
+{0x2510, 0xA8C1},
+{0x2510, 0x2440}, 
+{0x2510, 0xF110}, 
+{0x2510, 0xF804}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x8008},
+{0x2510, 0x2002},
+{0x2510, 0x880B},
+{0x2510, 0x3002}, 
+{0x2510, 0xB988}, 
+{0x2510, 0x2442}, 
+{0x2510, 0x3210}, 
+{0x2510, 0x2206}, 
+{0x2510, 0x2441}, 
+{0x2510, 0xA8C1},
+{0x2510, 0xF1CB},
+{0x2510, 0xF1CC},
+{0x2510, 0xF1CC},
+{0x2510, 0x2010},
+{0x2510, 0x8088},
+{0x2510, 0x200C},
+{0x2510, 0x888B},
+{0x2510, 0x2005},
+{0x2510, 0xA8D0},
+{0x2510, 0xB04B},
+{0x2510, 0x3202}, 
+{0x2510, 0xF880}, 
+{0x2510, 0xB980},
+{0x2510, 0xC800}, 
+{0x2510, 0x30C2}, 
+{0x2510, 0xE80C}, 
+{0x2510, 0x2201}, 
+{0x2510, 0xB04A}, 
+{0x2510, 0x2213},
+{0x2510, 0x2225},
+{0x2510, 0x8088},
+{0x2510, 0x2205},
+{0x2510, 0x888B},
+{0x2510, 0x2203},
+{0x2510, 0x3241}, 
+{0x2510, 0x902F}, 
+{0x2510, 0x2206},
+{0x2510, 0x2204}, 
+{0x2510, 0xB042}, 
+{0x2510, 0xA9A1}, 
+{0x2510, 0x8058}, 
+{0x2510, 0xB093}, 
+{0x2510, 0x31C1}, 
+{0x2510, 0x916B}, 
+{0x2510, 0x2007},
+{0x2510, 0x3084},
+{0x2510, 0x32C1},
+{0x2510, 0x8803}, 
+{0x2510, 0xA144}, 
+{0x2510, 0x3044}, 
+{0x2510, 0x2000}, 
+{0x2510, 0xA004}, 
+{0x2510, 0xB800}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x30D0}, 
+{0x2510, 0xA184}, 
+{0x2510, 0xB980}, 
+{0x2510, 0x807C},
+{0x2510, 0x3141}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3042}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3142}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x3042},
+{0x2510, 0x2000},
+{0x2510, 0x3281},
+{0x2510, 0x3041},
+{0x2510, 0x3042},
+{0x2510, 0x2000},
+{0x2510, 0x3290},
+{0x2510, 0x3041},
+{0x2510, 0x3042},
+{0x2510, 0x2000}, 
+{0x2510, 0x3110}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3120}, 
+{0x2510, 0x3041}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x3282},
+{0x2510, 0x3041},
+{0x2510, 0x2000},
+{0x2510, 0x32A0},
+{0x2510, 0x3041},
+{0x2510, 0x2000},
+{0x2510, 0x881B}, 
+{0x2510, 0x887F},
+{0x2510, 0x2440}, 
+{0x2510, 0x3260},
+{0x2510, 0x3248},
+{0x2510, 0xB095}, 
+{0x2510, 0xF110}, 
+{0x2510, 0xF864}, 
+{0x2510, 0xF90D}, 
+{0x2510, 0x32C2},
+{0x2510, 0x30A0}, 
+{0x2510, 0x3090}, 
+{0x2510, 0x3088}, 
+{0x2510, 0x2443},
+{0x2510, 0x8058}, 
+{0x2510, 0x3001}, 
+{0x2510, 0x2202}, 
+{0x2510, 0x885B},
+{0x2510, 0x2442}, 
+{0x2510, 0x3220}, 
+{0x2510, 0x2003},
+{0x2510, 0x8058},
+{0x2510, 0x2001},
+{0x2510, 0x885B}, 
+{0x2510, 0x2441}, 
+{0x2510, 0x30C2}, 
+{0x2510, 0x2007},
+{0x2510, 0x8018}, 
+{0x2510, 0x2000}, 
+{0x2510, 0x881B}, 
+{0x2510, 0x2008}, 
+{0x2510, 0x801A},
+{0x2510, 0x200A},
+{0x2510, 0x8002},
+{0x2510, 0xA9A1},
+{0x2510, 0xB094}, 
+{0x2510, 0x2201}, 
+{0x2510, 0x8803}, 
+{0x2510, 0xA1C4}, 
+{0x2510, 0x3044}, 
+{0x2510, 0xB800}, 
+{0x2510, 0xA004}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x3141},
+{0x2510, 0xA005},
+{0x2510, 0xC800},
+{0x2510, 0xE802},
+{0x2510, 0x31C1},
+{0x2510, 0x2440}, 
+{0x2510, 0x2442}, 
+{0x2510, 0xC801},
+{0x2510, 0x30C2}, 
+{0x2510, 0x31C1},
+{0x2510, 0xA044},
+{0x2510, 0x3044},
+{0x2510, 0x2000}, 
+{0x2510, 0xA004},
+{0x2510, 0x2000}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x2703},
+{0x2510, 0x3242}, 
+{0x2510, 0x2424},
+{0x2510, 0x2703}, 
+{0x2510, 0x2427},
+{0x2510, 0x2704},
+{0x2510, 0x3242},
+{0x2510, 0x2424},
+{0x2510, 0x2704},
+{0x2510, 0x2427},
+{0x2510, 0x7FFF},
+{0x2510, 0x7FFF},
+{0x2510, 0x2703}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2703},
+{0x2510, 0x2421}, 
+{0x2510, 0x2704}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2704},
+{0x2510, 0x2421}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0xB095},
+{0x2510, 0xF110},
+{0x2510, 0xF864},
+{0x2510, 0xF90D},
+{0x2510, 0x3001},
+{0x2510, 0x2442},
+{0x2510, 0x30C2},
+{0x2510, 0xA9A0},
+{0x2510, 0xB094},
+{0x2510, 0xB800},
+{0x2510, 0x7FFF},
+{0x2510, 0x7FFF},
+{0x2510, 0x2759}, 
+{0x2510, 0x2422}, 
+{0x2510, 0x2758}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2403}, 
+{0x2510, 0x2712}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2422}, 
+{0x2510, 0x271A}, 
+{0x2510, 0x3242}, 
+{0x2510, 0x2420}, 
+{0x2510, 0x2702}, 
+{0x2510, 0x2423}, 
+{0x2510, 0x2759},
+{0x2510, 0x2425}, 
+{0x2510, 0x2758},
+{0x2510, 0x2426},
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0x7FFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF}, 
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0xFFFF},
+{0x2510, 0x3433},
+{0x2510, 0x360D},
+{0x3364, 0x0766},
+{0x3082, 0x0   },
+{0x30BA, 0x1120}, 
+{0x302A,      6},
+{0x302C, 0x0701},
+{0x302E,      5},
+{0x3030,     75},
+{0x3036,      6},
+{0x3038,      2},
+{0x31DC, 0x1FA0},
+{0x31AC, 0x0C0C},
+{0x31AE, 0x0204}, 
+{0x3342, 0x122C},
+{0x3346, 0x122C},
+{0x334A, 0x122C},
+{0x334E, 0x122C},
+{0x3344, 0x0011},
+{0x3348, 0x0011},
+{0x334C, 0x0011},
+{0x3350, 0x0011},
+{0x31B0, 0x0033},
+{0x31B2, 0x0020},
+{0x31B4, 0x3144},
+{0x31B6, 0x2143},
+{0x31B8, 0x30C7},
+{0x31BA, 0x0185},
+{0x31BC, 0x8584},
+{0x30A2, 0x0001},
+{0x30A6, 0x0001},
+{0x3040, 0x0000},
+{0x3044, 0x0400},
+{0x3004,     10},
+{0x3008,   2057},
+{0x3002,      4},
+{0x3006,   1283},
+{0x3032, 0x0000},
+{0x3400, 0x0020},
+{0x300C,   1672},
+{0x300A,   1345},
+{0x3012,   1128},
+{0x3042, 0x0000},
+{0x32EA, 0x3C0E},
+{0x32EC, 0x72A0},
+{0x3110, 0x0001},
+{0x31D0, 0x0   },
+//{0x3070, 0x0002},		//test pattern (color bar)
+{0x3064, 0x0000}, 
+{0x301A, 0x005C}, 
+{AR0233_TABLE_END, 0x00}
+};
diff --git a/drivers/media/i2c/soc_camera/common.h b/drivers/media/i2c/soc_camera/common.h
new file mode 100644
index 000000000000..4586e9073f8d
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/common.h
@@ -0,0 +1,512 @@
+/*
+ * MAXIM GMSL common header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/i2c-mux.h>
+#include "max9295.h"
+
+#define MAX9271_ID			0x09
+#define MAX9286_ID			0x40
+#define MAX9288_ID			0x2A
+#define MAX9290_ID			0x2C
+#define MAX9295A_ID			0x91
+#define MAX9295B_ID			0x93
+#define MAX9296A_ID			0x94
+#define MAX96705_ID			0x41
+#define MAX96706_ID			0x4A
+#define MAX96707_ID			0x45 /* MAX96715: same but lack of HS pin */
+#define MAX96708_ID			0x4C
+#define MAX96712_ID			0x20
+#define MAX96717_ID			0x20
+#define MAX96717F_ID		0xC8
+
+#define UB960_ID			0x00 /* strapped */
+
+#define BROADCAST			0x6f
+
+#define REG8_NUM_RETRIES		1 /* number of read/write retries */
+#define REG16_NUM_RETRIES		10 /* number of read/write retries */
+
+static inline char* chip_name(int id)
+{
+	switch (id) {
+	case MAX9271_ID:
+		return "MAX9271";
+	case MAX9286_ID:
+		return "MAX9286";
+	case MAX9288_ID:
+		return "MAX9288";
+	case MAX9290_ID:
+		return "MAX9290";
+	case MAX9295A_ID:
+		return "MAX9295A";
+	case MAX9295B_ID:
+		return "MAX9295B";
+	case MAX9296A_ID:
+		return "MAX9296A";
+	case MAX96705_ID:
+		return "MAX96705";
+	case MAX96706_ID:
+		return "MAX96706";
+	case MAX96707_ID:
+		return "MAX96707";
+	case MAX96712_ID:
+		return "MAX96712";
+	case MAX96717F_ID:
+		return "MAX96717F";		
+	default:
+		return "serializer";
+	}
+}
+
+enum gmsl_mode {
+	MODE_GMSL1 = 1,
+	MODE_GMSL2,
+};
+
+#define MAXIM_I2C_I2C_SPEED_837KHZ	(0x7 << 2) /* 837kbps */
+#define MAXIM_I2C_I2C_SPEED_533KHZ	(0x6 << 2) /* 533kbps */
+#define MAXIM_I2C_I2C_SPEED_339KHZ	(0x5 << 2) /* 339 kbps */
+#define MAXIM_I2C_I2C_SPEED_173KHZ	(0x4 << 2) /* 174kbps */
+#define MAXIM_I2C_I2C_SPEED_105KHZ	(0x3 << 2) /* 105 kbps */
+#define MAXIM_I2C_I2C_SPEED_085KHZ	(0x2 << 2) /* 84.7 kbps */
+#define MAXIM_I2C_I2C_SPEED_028KHZ	(0x1 << 2) /* 28.3 kbps */
+#define MAXIM_I2C_I2C_SPEED		MAXIM_I2C_I2C_SPEED_339KHZ
+
+#define MIPI_DT_GENERIC			0x10
+#define MIPI_DT_GENERIC_1		0x11
+#define MIPI_DT_EMB			0x12
+#define MIPI_DT_YUV8			0x1e
+#define MIPI_DT_YUV10			0x1f
+#define MIPI_DT_RGB565			0x22
+#define MIPI_DT_RGB666			0x23
+#define MIPI_DT_RGB888			0x24
+#define MIPI_DT_RAW8			0x2a
+#define MIPI_DT_RAW10			0x2b
+#define MIPI_DT_RAW12			0x2c
+#define MIPI_DT_RAW14			0x2d
+#define MIPI_DT_RAW16			0x2e
+#define MIPI_DT_RAW20			0x2f
+#define MIPI_DT_YUV12			0x30
+
+static inline int mipi_dt_to_bpp(unsigned int dt)
+{
+	switch (dt) {
+		case 0x2a:
+		case 0x10 ... 0x12:
+		case 0x31 ... 0x37:
+			return 0x08;
+		case 0x2b:
+			return 0x0a;
+		case 0x2c:
+			return 0x0c;
+		case 0x0d:
+			return 0x0e;
+		case 0x22:
+		case 0x1e:
+		case 0x2e:
+			return 0x10;
+		case 0x23:
+			return 0x12;
+		case 0x1f:
+		case 0x2f:
+			return 0x14;
+		case 0x24:
+		case 0x30:
+			return 0x18;
+		default:
+			return 0x08;
+	}
+}
+
+static inline int reg8_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ret;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg8_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read(struct i2c_client *client, u16 reg, u8 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 1);
+			if (ret == 1)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = buf[0];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write(struct i2c_client *client, u16 reg, u8 val)
+{
+	int ret, retries;
+	u8 buf[3] = {reg >> 8, reg & 0xff, val};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 3);
+		if (ret == 3)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg16_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 2);
+			if (ret == 2)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ((u16)buf[0] << 8) | buf[1];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int ret, retries;
+	u8 buf[4] = {reg >> 8, reg & 0xff, val >> 8, val & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 4);
+		if (ret == 4)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read_n(struct i2c_client *client, u16 reg, u8 *val, int n)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, val, n);
+			if (ret == n)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x registers 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write_n(struct i2c_client *client, u16 reg, const u8* val, int n)
+{
+	int ret, retries;
+	u8 buf[8];
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	memcpy(&buf[2], val, n);
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2 + n);
+		if (ret == 2 + n)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2[n];
+		ret = reg16_read_n(client, reg, val2, n);
+		if (ret < 0)
+			return ret;
+
+		if (memcmp(val, val2, n)) {
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x-0x%x "
+				"'%*phN'->'%*phN'\n", client->addr, reg, reg + n,
+				n, val, n, val2);
+				ret = -EBADE;
+		}
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_read_addr(struct i2c_client *client, int addr, u8 reg, u8 *val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_READ, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			addr, reg, ret);
+	} else {
+		*val = data.byte;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write_addr(struct i2c_client *client, u8 addr, u8 reg, u8 val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	data.byte = val;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_WRITE, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x value 0x%0x: %d\n",
+			addr, reg, val, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+
+static inline int reg16_write_addr(struct i2c_client *client, int chip, u16 reg, u8 val)
+{
+	struct i2c_msg msg[1];
+	u8 wbuf[3];
+	int ret;
+
+	msg->addr = chip;
+	msg->flags = 0;
+	msg->len = 3;
+	msg->buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+	wbuf[2] = val;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x wr 0x%04x (0x%02x): %d\n",
+			chip, reg, val, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int reg16_read_addr(struct i2c_client *client, int chip, u16 reg, int *val)
+{
+	struct i2c_msg msg[2];
+	u8 wbuf[2];
+	u8 rbuf[1];
+	int ret;
+
+	msg[0].addr = chip;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+
+	msg[1].addr = chip;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = rbuf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x rd 0x%04x: %d\n", chip, reg, ret);
+		return ret;
+	}
+
+	*val = rbuf[0];
+
+	return 0;
+}
+
+#define __reg8_read(addr, reg, val)		reg8_read_addr(priv->client, addr, reg, val)
+#define __reg8_write(addr, reg, val)		reg8_write_addr(priv->client, addr, reg, val)
+#define __reg16_read(addr, reg, val)		reg16_read_addr(priv->client, addr, reg, val)
+#define __reg16_write(addr, reg, val)		reg16_write_addr(priv->client, addr, reg, val)
+
+/* copy this struct from drivers/i2c/i2c-mux.c for getting muxc from adapter private data */
+struct i2c_mux_priv {
+	struct i2c_adapter adap;
+	struct i2c_algorithm algo;
+	struct i2c_mux_core *muxc;
+	u32 chan_id;
+};
+
+static inline int get_des_id(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9286"))
+		return MAX9286_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9288"))
+		return MAX9288_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9296"))
+		return MAX9296A_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96706"))
+		return MAX96706_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96712"))
+		return MAX96712_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "ub9x4"))
+		return UB960_ID;
+
+	return -EINVAL;
+}
+
+static inline int get_des_addr(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	return to_i2c_client(mux_priv->muxc->dev)->addr;
+}
+
+static inline void setup_i2c_translator(struct i2c_client *client, int ser_addr, int sensor_addr)
+{
+	int gmsl_mode = MODE_GMSL2;
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX96706_ID:
+		reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		/* parse gmsl mode from deserializer */
+		reg16_read_addr(client, get_des_addr(client), 6, &gmsl_mode);
+		gmsl_mode = !!(gmsl_mode & BIT(7)) + 1;
+
+		if (gmsl_mode == MODE_GMSL1) {
+			reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+			reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		}
+		if (gmsl_mode == MODE_GMSL2) {
+			reg16_write_addr(client, ser_addr, MAX9295_I2C2, client->addr << 1); /* Sensor translated I2C address */
+			reg16_write_addr(client, ser_addr, MAX9295_I2C3, sensor_addr << 1); /* Sensor native I2C address */
+		}
+		break;
+	case UB960_ID:
+		reg8_write_addr(client, get_des_addr(client), 0x65, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, get_des_addr(client), 0x5d, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	}
+	usleep_range(2000, 2500);
+}
diff --git a/drivers/media/i2c/soc_camera/gmsl_common.h b/drivers/media/i2c/soc_camera/gmsl_common.h
new file mode 100644
index 000000000000..b676e8e2a8f6
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/gmsl_common.h
@@ -0,0 +1,517 @@
+/*
+ * MAXIM GMSL common header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/i2c-mux.h>
+#include "max9295.h"
+
+#define MAX9271_ID			0x09
+#define MAX9286_ID			0x40
+#define MAX9288_ID			0x2A
+#define MAX9290_ID			0x2C
+#define MAX9295A_ID			0x91
+#define MAX9295B_ID			0x93
+#define MAX9296A_ID			0x94
+#define MAX96705_ID			0x41
+#define MAX96706_ID			0x4A
+#define MAX96707_ID			0x45 /* MAX96715: same but lack of HS pin */
+#define MAX96708_ID			0x4C
+#define MAX96712_ID			0x20
+#define MAX96717F_ID			0xC8
+#define UB960_ID			0x00 /* strapped */
+
+#define BROADCAST			0x6f
+
+#define REG8_NUM_RETRIES		1 /* number of read/write retries */
+#define REG16_NUM_RETRIES		10 /* number of read/write retries */
+
+static inline char* chip_name(int id)
+{
+	switch (id) {
+	case MAX9271_ID:
+		return "MAX9271";
+	case MAX9286_ID:
+		return "MAX9286";
+	case MAX9288_ID:
+		return "MAX9288";
+	case MAX9290_ID:
+		return "MAX9290";
+	case MAX9295A_ID:
+		return "MAX9295A";
+	case MAX9295B_ID:
+		return "MAX9295B";
+	case MAX9296A_ID:
+		return "MAX9296A";
+	case MAX96705_ID:
+		return "MAX96705";
+	case MAX96706_ID:
+		return "MAX96706";
+	case MAX96707_ID:
+		return "MAX96707";
+	case MAX96712_ID:
+		return "MAX96712";
+	case MAX96717F_ID:
+		return "MAX96717F";
+	default:
+		return "serializer";
+	}
+}
+
+enum gmsl_mode {
+	MODE_GMSL1 = 1,
+	MODE_GMSL2,
+};
+
+enum gmsl2_rate {
+	GMSL2_3Gbps = 1,
+	GMSL2_6Gbps,
+};
+
+#define MAXIM_I2C_I2C_SPEED_837KHZ	(0x7 << 2) /* 837kbps */
+#define MAXIM_I2C_I2C_SPEED_533KHZ	(0x6 << 2) /* 533kbps */
+#define MAXIM_I2C_I2C_SPEED_339KHZ	(0x5 << 2) /* 339 kbps */
+#define MAXIM_I2C_I2C_SPEED_173KHZ	(0x4 << 2) /* 174kbps */
+#define MAXIM_I2C_I2C_SPEED_105KHZ	(0x3 << 2) /* 105 kbps */
+#define MAXIM_I2C_I2C_SPEED_085KHZ	(0x2 << 2) /* 84.7 kbps */
+#define MAXIM_I2C_I2C_SPEED_028KHZ	(0x1 << 2) /* 28.3 kbps */
+#define MAXIM_I2C_I2C_SPEED		MAXIM_I2C_I2C_SPEED_339KHZ
+
+#define MIPI_DT_GENERIC			0x10
+#define MIPI_DT_GENERIC_1		0x11
+#define MIPI_DT_EMB			0x12
+#define MIPI_DT_YUV8			0x1e
+#define MIPI_DT_YUV10			0x1f
+#define MIPI_DT_RGB565			0x22
+#define MIPI_DT_RGB666			0x23
+#define MIPI_DT_RGB888			0x24
+#define MIPI_DT_RAW8			0x2a
+#define MIPI_DT_RAW10			0x2b
+#define MIPI_DT_RAW12			0x2c
+#define MIPI_DT_RAW14			0x2d
+#define MIPI_DT_RAW16			0x2e
+#define MIPI_DT_RAW20			0x2f
+#define MIPI_DT_YUV12			0x30
+
+static inline int mipi_dt_to_bpp(unsigned int dt)
+{
+	switch (dt) {
+		case 0x2a:
+		case 0x10 ... 0x12:
+		case 0x31 ... 0x37:
+			return 0x08;
+		case 0x2b:
+			return 0x0a;
+		case 0x2c:
+			return 0x0c;
+		case 0x0d:
+			return 0x0e;
+		case 0x22:
+		case 0x1e:
+		case 0x2e:
+			return 0x10;
+		case 0x23:
+			return 0x12;
+		case 0x1f:
+		case 0x2f:
+			return 0x14;
+		case 0x24:
+		case 0x30:
+			return 0x18;
+		default:
+			return 0x08;
+	}
+}
+
+static inline int reg8_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ret;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg8_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read(struct i2c_client *client, u16 reg, u8 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 1);
+			if (ret == 1)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = buf[0];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write(struct i2c_client *client, u16 reg, u8 val)
+{
+	int ret, retries;
+	u8 buf[3] = {reg >> 8, reg & 0xff, val};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 3);
+		if (ret == 3)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg16_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 2);
+			if (ret == 2)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ((u16)buf[0] << 8) | buf[1];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int ret, retries;
+	u8 buf[4] = {reg >> 8, reg & 0xff, val >> 8, val & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 4);
+		if (ret == 4)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read_n(struct i2c_client *client, u16 reg, u8 *val, int n)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, val, n);
+			if (ret == n)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x registers 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write_n(struct i2c_client *client, u16 reg, const u8* val, int n)
+{
+	int ret, retries;
+	u8 buf[8];
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	memcpy(&buf[2], val, n);
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2 + n);
+		if (ret == 2 + n)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2[n];
+		ret = reg16_read_n(client, reg, val2, n);
+		if (ret < 0)
+			return ret;
+
+		if (memcmp(val, val2, n)) {
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x-0x%x "
+				"'%*phN'->'%*phN'\n", client->addr, reg, reg + n,
+				n, val, n, val2);
+				ret = -EBADE;
+		}
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_read_addr(struct i2c_client *client, int addr, u8 reg, u8 *val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_READ, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			addr, reg, ret);
+	} else {
+		*val = data.byte;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write_addr(struct i2c_client *client, u8 addr, u8 reg, u8 val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	data.byte = val;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_WRITE, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x value 0x%0x: %d\n",
+			addr, reg, val, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+
+static inline int reg16_write_addr(struct i2c_client *client, int chip, u16 reg, u8 val)
+{
+	struct i2c_msg msg[1];
+	u8 wbuf[3];
+	int ret;
+
+	msg->addr = chip;
+	msg->flags = 0;
+	msg->len = 3;
+	msg->buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+	wbuf[2] = val;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x wr 0x%04x (0x%02x): %d\n",
+			chip, reg, val, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int reg16_read_addr(struct i2c_client *client, int chip, u16 reg, int *val)
+{
+	struct i2c_msg msg[2];
+	u8 wbuf[2];
+	u8 rbuf[1];
+	int ret;
+
+	msg[0].addr = chip;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+
+	msg[1].addr = chip;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = rbuf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x rd 0x%04x: %d\n", chip, reg, ret);
+		return ret;
+	}
+
+	*val = rbuf[0];
+
+	return 0;
+}
+
+#define __reg8_read(addr, reg, val)		reg8_read_addr(priv->client, addr, reg, val)
+#define __reg8_write(addr, reg, val)		reg8_write_addr(priv->client, addr, reg, val)
+#define __reg16_read(addr, reg, val)		reg16_read_addr(priv->client, addr, reg, val)
+#define __reg16_write(addr, reg, val)		reg16_write_addr(priv->client, addr, reg, val)
+
+/* copy this struct from drivers/i2c/i2c-mux.c for getting muxc from adapter private data */
+struct i2c_mux_priv {
+	struct i2c_adapter adap;
+	struct i2c_algorithm algo;
+	struct i2c_mux_core *muxc;
+	u32 chan_id;
+};
+
+static inline int get_des_id(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9286"))
+		return MAX9286_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9288"))
+		return MAX9288_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9296"))
+		return MAX9296A_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96706"))
+		return MAX96706_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96712"))
+		return MAX96712_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "ub9x4"))
+		return UB960_ID;
+
+	return -EINVAL;
+}
+
+static inline int get_des_addr(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	return to_i2c_client(mux_priv->muxc->dev)->addr;
+}
+
+static inline void setup_i2c_translator(struct i2c_client *client, int ser_addr, int sensor_addr)
+{
+	int gmsl_mode = MODE_GMSL2;
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX96706_ID:
+		reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		/* parse gmsl mode from deserializer */
+		reg16_read_addr(client, get_des_addr(client), 6, &gmsl_mode);
+		gmsl_mode = !!(gmsl_mode & BIT(7)) + 1;
+
+		if (gmsl_mode == MODE_GMSL1) {
+printk("666666artie666666 %s-%d: GMSL1\n", __func__, __LINE__);
+			reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+			reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		}
+		if (gmsl_mode == MODE_GMSL2) {
+printk("666666artie666666 %s-%d: GMSL2\n", __func__, __LINE__);
+			reg16_write_addr(client, ser_addr, MAX9295_I2C2, client->addr << 1); /* Sensor translated I2C address */
+			reg16_write_addr(client, ser_addr, MAX9295_I2C3, sensor_addr << 1); /* Sensor native I2C address */
+		}
+		break;
+	case UB960_ID:
+		reg8_write_addr(client, get_des_addr(client), 0x65, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, get_des_addr(client), 0x5d, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	}
+	usleep_range(2000, 2500);
+}
diff --git a/drivers/media/i2c/soc_camera/max9295.h b/drivers/media/i2c/soc_camera/max9295.h
new file mode 100644
index 000000000000..864c44100790
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/max9295.h
@@ -0,0 +1,39 @@
+/*
+ * MAXIM max9295 GMSL2 driver header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define MAX9295_REG2			0x02
+#define MAX9295_REG7			0x07
+#define MAX9295_CTRL0			0x10
+#define MAX9295_I2C2			0x42
+#define MAX9295_I2C3			0x43
+#define MAX9295_I2C4			0x44
+#define MAX9295_I2C5			0x45
+#define MAX9295_I2C6			0x46
+
+#define MAX9295_CROSS(n)		(0x1b0 + n)
+
+#define MAX9295_GPIO_A(n)		(0x2be + (3 * n))
+#define MAX9295_GPIO_B(n)		(0x2bf + (3 * n))
+#define MAX9295_GPIO_C(n)		(0x2c0 + (3 * n))
+
+#define MAX9295_VIDEO_TX_BASE(n)	(0x100 + (0x8 * n))
+#define MAX9295_VIDEO_TX0(n)		(MAX9295_VIDEO_TX_BASE(n) + 0)
+#define MAX9295_VIDEO_TX1(n)		(MAX9295_VIDEO_TX_BASE(n) + 1)
+
+#define MAX9295_FRONTTOP_0		0x308
+#define MAX9295_FRONTTOP_9		0x311
+#define MAX9295_FRONTTOP_12		0x314
+#define MAX9295_FRONTTOP_13		0x315
+
+#define MAX9295_MIPI_RX0		0x330
+#define MAX9295_MIPI_RX1		0x331
+#define MAX9295_MIPI_RX2		0x332
+#define MAX9295_MIPI_RX3		0x333
\ No newline at end of file
diff --git a/drivers/media/i2c/soc_camera/max96712.c b/drivers/media/i2c/soc_camera/max96712.c
new file mode 100644
index 000000000000..28ee4712e53a
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/max96712.c
@@ -0,0 +1,1616 @@
+/*
+ * MAXIM max96712 GMSL2 driver
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-clk.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+#include "max96712.h"
+#include "max96712_debug.h"
+
+static char mbus_default[10] = "mipi"; /* mipi, dvp */
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int poc_trig;
+module_param(poc_trig, int, 0644);
+MODULE_PARM_DESC(poc_trig, " Use PoC triggering during RC setup. Useful on systems with dedicated PoC and unstable ser-des lock");
+
+static int him;
+module_param(him, int, 0644);
+MODULE_PARM_DESC(him, " Use High-Immunity mode (default: leagacy mode)");
+
+static int fsync_period;
+module_param(fsync_period, int, 0644);
+MODULE_PARM_DESC(fsync_period, " Frame sync period (default: 3.2MHz)");
+
+static int hsync = 0;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 0;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 0 - not inverted)");
+
+static int de = 1;
+module_param(de, int, 0644);
+MODULE_PARM_DESC(vsync, " DE invertion (default: 1 - inverted)");
+
+static int gpio_resetb;
+module_param(gpio_resetb, int, 0644);
+MODULE_PARM_DESC(gpio_resetb, " Serializer GPIO reset (default: 0 - not used)");
+
+static int active_low_resetb;
+module_param(active_low_resetb, int, 0644);
+MODULE_PARM_DESC(active_low_resetb, " Serializer GPIO reset level (default: 0 - active high)");
+
+static int timeout_n = 300;
+module_param(timeout_n, int, 0644);
+MODULE_PARM_DESC(timeout_n, " Timeout of link detection (default: 100 retries)");
+
+static int poc_delay = 50;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 50 ms)");
+
+static int bws;
+module_param(bws, int, 0644);
+MODULE_PARM_DESC(bws, " BWS mode (default: 0 - 24-bit gmsl packets)");
+
+static int dbl = 1;
+module_param(dbl, int, 0644);
+MODULE_PARM_DESC(dbl, " DBL mode (default: 1 - DBL mode enabled)");
+
+static int dt = MIPI_DT_YUV8;
+module_param(dt, int, 0644);
+MODULE_PARM_DESC(dt, " DataType (default: 0x1e - YUV8)");
+
+static unsigned long crossbar = 0xba9876543210;
+module_param(crossbar, ulong, 0644);
+MODULE_PARM_DESC(crossbar, " Serializer crossbar setup (default: ba9876543210 - reversed)");
+
+static int gmsl = MODE_GMSL2;
+module_param(gmsl, int, 0644);
+MODULE_PARM_DESC(gmsl, " GMSL mode (default: 2 - GMSL2)");
+
+static char *mbus = mbus_default;
+module_param(mbus, charp, 0644);
+MODULE_PARM_DESC(mbus, " Interfaces mipi,dvp (default: dvp)");
+
+static int gpio0 = -1, gpio1 = -1, gpio4 = 1, gpio7 = -1, gpio8 = -1;
+module_param(gpio0, int, 0644);
+MODULE_PARM_DESC(gpio0, "  GPIO0 function select (default: GPIO0 tri-state)");
+module_param(gpio1, int, 0644);
+MODULE_PARM_DESC(gpio1, "  GPIO1 function select (default: GPIO1 tri-state)");
+module_param(gpio4, int, 0644);
+MODULE_PARM_DESC(gpio4, "  GPIO4 function select (default: GPIO4 tri-state)");
+module_param(gpio7, int, 0644);
+MODULE_PARM_DESC(gpio7, "  GPIO7 function select (default: GPIO7 tri-state)");
+module_param(gpio8, int, 0644);
+MODULE_PARM_DESC(gpio8, "  GPIO8 function select (default: GPIO8 tri-state)");
+
+static const struct regmap_config max96712_regmap[] = {
+	{
+		/* max96712 */
+		.reg_bits = 16,
+		.val_bits = 8,
+		.max_register = 0x1f03,
+	}, {
+		/* max9271/max96705 */
+		.reg_bits = 8,
+		.val_bits = 8,
+		.max_register = 0xff,
+	}, {
+		/* max9695 */
+		.reg_bits = 16,
+		.val_bits = 8,
+		.max_register = 0x1b03,
+	}
+};
+
+static void max96712_write_remote_verify(struct max96712_priv *priv, int link_n, u8 reg, int val)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int timeout;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		u8 val2 = 0;
+
+		ser_write(reg, val);
+		ser_read(reg, &val2);
+		if (val2 == val)
+			break;
+
+		usleep_range(1000, 1500);
+	}
+
+	if (timeout >= 10)
+		dev_err(&priv->client->dev, "timeout remote write acked\n");
+}
+
+static void max96712_reset_oneshot(struct max96712_priv *priv, int mask)
+{
+	int timeout;
+	int reg = 0;
+
+	mask &= 0x0f;
+	des_update_bits(MAX96712_CTRL1, mask, mask); /* set reset one-shot */
+
+	/* wait for one-shot bit self-cleared */
+	for (timeout = 0; timeout < 100; timeout++) {
+		des_read(MAX96712_CTRL1, &reg);
+		if (!(reg & mask))
+			break;
+
+		mdelay(1);
+	}
+
+	if (reg & mask)
+		dev_err(&priv->client->dev, "Failed reset oneshot 0x%x\n", mask);
+}
+
+/* -----------------------------------------------------------------------------
+ * MIPI, mapping, routing
+ */
+
+static void max96712_pipe_override(struct max96712_priv *priv, unsigned int pipe,
+				   unsigned int dt, unsigned int vc)
+{
+	int bpp, bank;
+
+	bpp = mipi_dt_to_bpp(dt);
+	bank = pipe / 4;
+	pipe %= 4;
+
+	if (priv->dbl == 1) {
+		/* DBL=1 is MUX mode, DBL=0 is Normal mode */
+		des_update_bits(MAX_BACKTOP27(bank), BIT(pipe + 4), BIT(pipe + 4));	/* enable MUX mode */
+		bpp = bpp / 2;								/* divide because of MUX=1 */
+	}
+
+	switch (pipe) {
+	case 0:
+		/* Pipe X: 0 or 4 */
+		des_update_bits(MAX_BACKTOP12(bank), 0x1f << 3, bpp << 3);
+		des_update_bits(MAX_BACKTOP13(bank), 0x0f, vc);
+		des_update_bits(MAX_BACKTOP15(bank), 0x3f, dt);
+		des_update_bits(bank ? MAX_BACKTOP28(0) : MAX_BACKTOP22(0), BIT(6), BIT(6)); /* enalbe s/w override */
+		break;
+	case 1:
+		/* Pipe Y: 1 or 5 */
+		des_update_bits(MAX_BACKTOP18(bank), 0x1f, bpp);
+		des_update_bits(MAX_BACKTOP13(bank), 0x0f << 4, vc << 4);
+		des_update_bits(MAX_BACKTOP16(bank), 0x0f, dt & 0x0f);
+		des_update_bits(MAX_BACKTOP15(bank), 0x03 << 6, (dt & 0x30) << 2);
+		des_update_bits(bank ? MAX_BACKTOP28(0) : MAX_BACKTOP22(0), BIT(7), BIT(7)); /* enable s/w override */
+		break;
+	case 2:
+		/* Pipe Z: 2 or 6 */
+		des_update_bits(MAX_BACKTOP19(bank), 0x03, bpp & 0x03);
+		des_update_bits(MAX_BACKTOP18(bank), 0xe0, (bpp & 0x1c) << 3);
+		des_update_bits(MAX_BACKTOP14(bank), 0x0f, vc);
+		des_update_bits(MAX_BACKTOP17(bank), 0x03, dt & 0x03);
+		des_update_bits(MAX_BACKTOP16(bank), 0x0f << 4, (dt & 0x3c) << 2);
+		des_update_bits(bank ? MAX_BACKTOP30(0) : MAX_BACKTOP25(0), BIT(6), BIT(6)); /* enable s/w override */
+		break;
+	case 3:
+		/* Pipe U: 3 or 7 */
+		des_update_bits(MAX_BACKTOP19(bank), 0xfc, bpp << 2);
+		des_update_bits(MAX_BACKTOP14(bank), 0x0f << 4, vc << 4);
+		des_update_bits(MAX_BACKTOP17(bank), 0x3f << 2, dt << 2);
+		des_update_bits(bank ? MAX_BACKTOP30(0) : MAX_BACKTOP25(0), BIT(7), BIT(7)); /* enable s/w override */
+		break;
+	}
+}
+
+static void max96712_set_pipe_to_mipi_mapping(struct max96712_priv *priv,
+					      unsigned int pipe, unsigned int map_n,
+					      unsigned int in_dt, unsigned int in_vc,
+					      unsigned int out_dt, unsigned int out_vc, unsigned int out_mipi)
+{
+	int offset = 2 * (map_n % 4);
+
+	des_write(MAX_MIPI_MAP_SRC(pipe, map_n), (in_vc << 6) | in_dt);
+	des_write(MAX_MIPI_MAP_DST(pipe, map_n), (out_vc << 6) | out_dt);
+	des_update_bits(MAX_MIPI_MAP_DST_PHY(pipe, map_n / 4), 0x03 << offset, out_mipi << offset);
+	des_update_bits(MAX_MIPI_TX11(pipe), BIT(map_n), BIT(map_n));	/* enable SRC_n to DST_n mapping */
+}
+
+static void max96712_mipi_setup(struct max96712_priv *priv)
+{
+	des_write(MAX96712_VIDEO_PIPE_EN, 0);	/* disable all pipes */
+	des_update_bits(MAX_MIPI_PHY0, 0x80, 0x00); /* Disable all MIPI clocks running force */
+	des_update_bits(MAX_BACKTOP12(0), 0x02, 0); /* CSI output disable */
+
+	des_write(MAX_MIPI_PHY0, 0x04);		/* MIPI Phy 2x4 mode */
+	des_write(MAX_MIPI_PHY3, 0xe4);		/* Lane map: straight */
+	des_write(MAX_MIPI_PHY4, 0xe4);		/* Lane map: straight */
+	//des_write(MAX_MIPI_PHY5, 0x00);	/* HS_prepare time, non-inverted polarity */
+	//des_write(MAX_MIPI_PHY6, 0x00);
+
+	des_write(MAX_MIPI_TX10(1), 0xc0);	/* MIPI1: 4 lanes */
+	des_write(MAX_MIPI_TX10(2), 0xc0);	/* MIPI2: 4 lanes */
+
+	des_update_bits(MAX_BACKTOP22(0), 0x3f, ((priv->csi_rate[1] / 100) & 0x1f) | BIT(5)); /* MIPI rate */
+	des_update_bits(MAX_BACKTOP25(0), 0x3f, ((priv->csi_rate[1] / 100) & 0x1f) | BIT(5));
+	des_update_bits(MAX_BACKTOP28(0), 0x3f, ((priv->csi_rate[2] / 100) & 0x1f) | BIT(5));
+	des_update_bits(MAX_BACKTOP31(0), 0x3f, ((priv->csi_rate[2] / 100) & 0x1f) | BIT(5));
+
+	des_update_bits(MAX_MIPI_PHY2, 0xf0, 0xf0); /* enable all MIPI PHYs */
+}
+
+/* -----------------------------------------------------------------------------
+ * GMSL1
+ */
+
+static int max96712_gmsl1_sensor_reset(struct max96712_priv *priv, int link_n, int reset_on)
+{
+	struct max96712_link *link = priv->link[link_n];
+
+	if (priv->gpio_resetb < 1 || priv->gpio_resetb > 5)
+		return -EINVAL;
+
+	/* sensor reset/unreset */
+	ser_write(0x0f, (0xfe & ~BIT(priv->gpio_resetb)) | /* set GPIOn value to reset/unreset */
+		  ((priv->active_low_resetb ? BIT(priv->gpio_resetb) : 0) ^ reset_on));
+	ser_write(0x0e, 0x42 | BIT(priv->gpio_resetb)); /* set GPIOn direction output */
+
+	return 0;
+}
+
+static void max96712_gmsl1_cc_enable(struct max96712_priv *priv, int link, int on)
+{
+	des_update_bits(MAX_GMSL1_4(link), 0x03, on ? 0x03 : 0x00);
+	usleep_range(2000, 2500);
+}
+
+static int max96712_gmsl1_get_link_lock(struct max96712_priv *priv, int link_n)
+{
+	int val = 0;
+
+	des_read(MAX_GMSL1_CB(link_n), &val);
+
+	return !!(val & BIT(0));
+}
+
+static void max96712_gmsl1_link_crossbar_setup(struct max96712_priv *priv, int link, int dt)
+{
+	/* Always decode reversed bus, since we always reverse on serializer (old imagers need this) */
+	switch (dt) {
+	case MIPI_DT_YUV8:
+		des_write(MAX_CROSS(link, 0), 7);
+		des_write(MAX_CROSS(link, 1), 6);
+		des_write(MAX_CROSS(link, 2), 5);
+		des_write(MAX_CROSS(link, 3), 4);
+		des_write(MAX_CROSS(link, 4), 3);
+		des_write(MAX_CROSS(link, 5), 2);
+		des_write(MAX_CROSS(link, 6), 1);
+		des_write(MAX_CROSS(link, 7), 0);
+
+		if (priv->dbl == 0) {
+			/* deserializer DBL=1 is MUX, DBL=0 is Normal */
+			des_write(MAX_CROSS(link, 8), 15);
+			des_write(MAX_CROSS(link, 9), 14);
+			des_write(MAX_CROSS(link, 10), 13);
+			des_write(MAX_CROSS(link, 11), 12);
+			des_write(MAX_CROSS(link, 12), 11);
+			des_write(MAX_CROSS(link, 13), 10);
+			des_write(MAX_CROSS(link, 14), 9);
+			des_write(MAX_CROSS(link, 15), 8);
+		}
+		break;
+	case MIPI_DT_RAW12:
+		des_write(MAX_CROSS(link, 0), 11);
+		des_write(MAX_CROSS(link, 1), 10);
+		des_write(MAX_CROSS(link, 2), 9);
+		des_write(MAX_CROSS(link, 3), 8);
+		des_write(MAX_CROSS(link, 4), 7);
+		des_write(MAX_CROSS(link, 5), 6);
+		des_write(MAX_CROSS(link, 6), 5);
+		des_write(MAX_CROSS(link, 7), 4);
+		des_write(MAX_CROSS(link, 8), 3);
+		des_write(MAX_CROSS(link, 9), 2);
+		des_write(MAX_CROSS(link, 10), 1);
+		des_write(MAX_CROSS(link, 11), 0);
+
+		if (priv->dbl == 0) {
+			/* deserializer DBL=1 is MUX, DBL=0 is Normal */
+			des_write(MAX_CROSS(link, 12), 23);
+			des_write(MAX_CROSS(link, 13), 22);
+			des_write(MAX_CROSS(link, 14), 21);
+			des_write(MAX_CROSS(link, 15), 20);
+			des_write(MAX_CROSS(link, 16), 19);
+			des_write(MAX_CROSS(link, 17), 18);
+			des_write(MAX_CROSS(link, 18), 17);
+			des_write(MAX_CROSS(link, 19), 16);
+			des_write(MAX_CROSS(link, 20), 15);
+			des_write(MAX_CROSS(link, 21), 14);
+			des_write(MAX_CROSS(link, 22), 13);
+			des_write(MAX_CROSS(link, 23), 12);
+		}
+		break;
+	default:
+		dev_err(&priv->client->dev, "crossbar for dt %d is not supported\n", dt);
+		break;
+	}
+
+	des_write(MAX_CROSS(link, 24), (priv->hsync ? 0 : 0x40) + 24);	/* invert HS polarity */	//RTX Modify
+	des_write(MAX_CROSS(link, 25), (priv->vsync ? 0 : 0x40) + 25);	/* invert VS polarity */	//RTX Modify
+	des_write(MAX_CROSS(link, 26), (priv->de 	? 0 : 0x40) + 26);	/* invert DE polarity */	//RTX Modify
+}
+
+static void max96712_gmsl1_initial_setup(struct max96712_priv *priv)
+{
+	int i;
+
+	des_update_bits(MAX96712_REG6, 0xf0, 0);			/* set GMSL1 mode */
+	des_write(MAX96712_REG26, 0x11);				/* 187.5M/3G */
+	des_write(MAX96712_REG27, 0x11);				/* 187.5M/3G */
+
+	for (i = 0; i < priv->n_links; i++) {
+		des_write(MAX_GMSL1_2(i), 0x03);			/* Autodetect serial data rate range */
+		des_write(MAX_GMSL1_4(i), 0);				/* disable REV/FWD CC */
+		des_update_bits(MAX_GMSL1_6(i), BIT(7), priv->him ? BIT(7) : 0); /* HIM/Legacy mode */
+		des_write(MAX_GMSL1_7(i), (priv->dbl ? BIT(7) : 0) |	/* DBL mode */
+					  (priv->bws ? BIT(5) : 0) |	/* BWS 32/24-bit */
+					  (priv->hibw ? BIT(3) : 0) |	/* High-bandwidth mode */
+					  (priv->hven ? BIT(2) : 0));	/* HS/VS encoding enable */
+		des_write(MAX_GMSL1_D(i), 0);				/* disable artificial ACKs, RC conf disable */
+		des_write(MAX_GMSL1_F(i), 0);				/* disable DE processing */
+		des_write(MAX_GMSL1_96(i), (0x13 << 3) | 0x3);		/* color map: RAW12 double - i.e. bypass packet as is */
+	}
+}
+
+static int max96712_gmsl1_reverse_channel_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int ser_addrs[] = { 0x40 };					/* possible MAX9271/MAX96705 addresses on i2c bus */
+	int lock_sts;
+	int timeout = priv->timeout;
+	char timeout_str[40];
+	u8 val = 0;
+	int ret = 0;
+
+	des_write(MAX_GMSL1_D(link_n), 0x81);			/* enable artificial ACKs, RC conf mode */
+	des_write(MAX_RLMSC5(link_n), 0xa0);			/* override RC pulse length */
+	des_write(MAX_RLMSC4(link_n), 0x80);			/* override RC rise/fall time */
+	usleep_range(2000, 2500);
+	des_write(MAX_GMSL1_4(link_n), 0x3);			/* enable REV/FWD CC */
+	des_write(MAX96712_REG6, BIT(link_n));			/* GMSL1 mode, enable GMSL link# */
+	max96712_reset_oneshot(priv, BIT(link_n));
+	usleep_range(2000, 2500);
+
+	for (; timeout > 0; timeout--) {
+		if (priv->him) {
+			/* HIM mode setup */
+			__reg8_write(ser_addrs[0], 0x4d, 0xc0);
+			usleep_range(2000, 2500);
+			__reg8_write(ser_addrs[0], 0x04, 0x43);	/* wake-up, enable RC, conf_link */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				__reg8_write(ser_addrs[0], 0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+								 (priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+								 (0x80) |				/* DBL=1 in serializer */
+								 (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+				usleep_range(2000, 2500);
+			}
+		} else {
+			/* Legacy mode setup */
+			des_write(MAX_RLMS95(link_n), 0x88);		/* override RC Tx amplitude */
+			usleep_range(2000, 2500);
+
+			__reg8_write(ser_addrs[0], 0x04, 0x43);		/* wake-up, enable RC, conf_link */
+			usleep_range(2000, 2500);
+			__reg8_write(ser_addrs[0], 0x08, 0x01);		/* RC receiver high threshold enable */
+			__reg8_write(ser_addrs[0], 0x97, 0x5f);		/* enable RC programming (MAX96705-MAX96711 only) */
+			usleep_range(2000, 2500);
+
+			if (priv->bws) {
+				__reg8_write(ser_addrs[0], 0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+								 (priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+								 (0x80) |				/* DBL=1 in serializer */
+								 (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+				usleep_range(2000, 2500);
+			}
+
+			des_write(MAX_RLMS95(link_n), 0xd3);	/* increase RC Tx amplitude */
+			usleep_range(2000, 2500);
+		}
+
+		__reg8_read(ser_addrs[0], 0x1e, &val);		
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			printk(KERN_ERR "[ RTX - %s - %d] val[%d] = 0x%X!!!!!!!!!!!\n", __func__, __LINE__, link_n, val);
+			link->ser_id = val;
+			__reg8_write(ser_addrs[0], 0x00, link->ser_addr << 1);	 /* relocate serizlizer on I2C bus */
+			usleep_range(2000, 2500);
+			break;
+		}
+
+		/* Check if already initialized (after reboot/reset ?) */
+		ser_read(0x1e, &val);		
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			printk(KERN_ERR "[ RTX - %s - %d] val[%d] = 0x%X!!!!!!!!!!!\n", __func__, __LINE__, link_n, val);
+			link->ser_id = val;
+			ser_write(0x04, 0x43);			/* enable RC, conf_link */
+			usleep_range(2000, 2500);
+			ret = -EADDRINUSE;
+			break;
+		}
+
+		if (poc_trig) {
+			if (!IS_ERR(link->poc_reg) && (timeout % poc_trig == 0)) {
+				regulator_disable(link->poc_reg); /* POC power off */
+				mdelay(200);
+				ret = regulator_enable(link->poc_reg); /* POC power on */
+				if (ret)
+					dev_err(&link->client->dev, "failed to enable poc regulator\n");
+				mdelay(priv->poc_delay);
+			}
+		}
+	}
+
+	max96712_gmsl1_sensor_reset(priv, link_n, 0);		/* sensor un-reset */
+
+	des_write(MAX_GMSL1_D(link_n), 0);			/* disable artificial ACKs, RC conf disable */
+	usleep_range(2000, 2500);
+	des_read(MAX_GMSL1_CB(link_n), &lock_sts);
+	lock_sts = !!(lock_sts & 0x01);
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	priv->links_mask |= BIT(link_n);
+
+out:
+	sprintf(timeout_str, " retries=%d lock_sts=%d", priv->timeout - timeout, lock_sts);
+	dev_info(&priv->client->dev, "GMSL1 link%d %s %sat 0x%x %s %s\n", link_n, chip_name(link->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", link->ser_addr,
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL link establish" : "",
+			       priv->timeout - timeout ? timeout_str : "");
+	return ret;
+}
+
+static int max96712_gmsl1_link_serializer_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+
+	/* GMSL setup */
+	ser_write(0x0d, 0x22 | MAXIM_I2C_I2C_SPEED);		/* disable artificial ACK, I2C speed set */
+	ser_write(0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+			(priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+			(0x80) |				/* DBL=1 in serializer */
+			(priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+	usleep_range(2000, 2500);
+	ser_write(0x02, 0xff);					/* spread spectrum +-4%, pclk range automatic, Gbps automatic */
+	usleep_range(2000, 2500);
+
+	if (link->ser_id != MAX9271_ID) {
+		switch (priv->dt) {
+		case MIPI_DT_YUV8:
+			if (priv->dbl == 1) {
+				/* setup crossbar for YUV8/RAW8: reverse DVP bus */
+				ser_write(0x20, priv->cb[7]);
+				ser_write(0x21, priv->cb[6]);
+				ser_write(0x22, priv->cb[5]);
+				ser_write(0x23, priv->cb[4]);
+				ser_write(0x24, priv->cb[3]);
+				ser_write(0x25, priv->cb[2]);
+				ser_write(0x26, priv->cb[1]);
+				ser_write(0x27, priv->cb[0]);
+
+				/* this is second byte in the packet (DBL=1 in serializer always) */
+				ser_write(0x30, priv->cb[7] + 16);
+				ser_write(0x31, priv->cb[6] + 16);
+				ser_write(0x32, priv->cb[5] + 16);
+				ser_write(0x33, priv->cb[4] + 16);
+				ser_write(0x34, priv->cb[3] + 16);
+				ser_write(0x35, priv->cb[2] + 16);
+				ser_write(0x36, priv->cb[1] + 16);
+				ser_write(0x37, priv->cb[0] + 16);
+			} else {
+				/* setup crossbar for YUV8/RAW8: reversed DVP bus */
+				ser_write(0x20, priv->cb[4]);
+				ser_write(0x21, priv->cb[3]);
+				ser_write(0x22, priv->cb[2]);
+				ser_write(0x23, priv->cb[1]);
+				ser_write(0x24, priv->cb[0]);
+				ser_write(0x25, 0x40);
+				ser_write(0x26, 0x40);
+				if (link->ser_id == MAX96705_ID) {
+					ser_write(0x27, 14); /* HS: D14->D18  */
+					ser_write(0x28, 15); /* VS: D15->D19 */
+					ser_write(0x29, 14); /* DE: D14->D20 */
+				}
+				if (link->ser_id == MAX96707_ID) {
+					ser_write(0x27, 12); /* HS: D12->D18, this is a virtual NC pin, hence it is D14 at HS */
+					ser_write(0x28, 13); /* VS: D13->D19 */
+					ser_write(0x29, 12); /* DE: D12->D20 */
+				}
+				ser_write(0x2A, 0x40);
+
+				/* this is second byte in the packet (DBL=1 in serializer) */
+				ser_write(0x30, 0x10 + priv->cb[7]);
+				ser_write(0x31, 0x10 + priv->cb[6]);
+				ser_write(0x32, 0x10 + priv->cb[5]);
+				ser_write(0x33, 0x10 + priv->cb[4]);
+				ser_write(0x34, 0x10 + priv->cb[3]);
+				ser_write(0x35, 0x10 + priv->cb[2]);
+				ser_write(0x36, 0x10 + priv->cb[1]);
+				ser_write(0x37, 0x10 + priv->cb[0]);
+				ser_write(0x38, priv->cb[7]);
+				ser_write(0x39, priv->cb[6]);
+				ser_write(0x3A, priv->cb[5]);
+
+				ser_write(0x67, 0xC4); /* DBL_ALIGN_TO = 100b */
+			}
+			break;
+		case MIPI_DT_RAW12:
+			/* setup crossbar for RAW12: reverse DVP bus */
+			ser_write(0x20, priv->cb[11]);
+			ser_write(0x21, priv->cb[10]);
+			ser_write(0x22, priv->cb[9]);
+			ser_write(0x23, priv->cb[8]);
+			ser_write(0x24, priv->cb[7]);
+			ser_write(0x25, priv->cb[6]);
+			ser_write(0x26, priv->cb[5]);
+			ser_write(0x27, priv->cb[4]);
+			ser_write(0x28, priv->cb[3]);
+			ser_write(0x29, priv->cb[2]);
+			ser_write(0x2a, priv->cb[1]);
+			ser_write(0x2b, priv->cb[0]);
+
+			/* this is second byte in the packet (DBL=1 in serializer) */
+			ser_write(0x30, priv->cb[11] + 16);
+			ser_write(0x31, priv->cb[10] + 16);
+			ser_write(0x32, priv->cb[9] + 16);
+			ser_write(0x33, priv->cb[8] + 16);
+			ser_write(0x34, priv->cb[7] + 16);
+			ser_write(0x35, priv->cb[6] + 16);
+			ser_write(0x36, priv->cb[5] + 16);
+			ser_write(0x37, priv->cb[4] + 16);
+			ser_write(0x38, priv->cb[3] + 16);
+			ser_write(0x39, priv->cb[2] + 16);
+			ser_write(0x3a, priv->cb[1] + 16);
+			ser_write(0x3b, priv->cb[0] + 16);
+
+			if (!(priv->bws || priv->hibw) && priv->dbl)
+				dev_err(&priv->client->dev, " BWS must be 27/32-bit for RAW12 in DBL mode\n");
+			break;
+		}
+	}
+
+	/* I2C translator setup */
+	//ser_write(0x09, OV490_I2C_ADDR_NEW << 1);	/* sensor I2C translated - must be set by sensor driver */
+	//ser_write(0x0A, OV490_I2C_ADDR << 1);		/* sensor I2C native - must be set by sensor driver */
+	ser_write(0x0B, BROADCAST << 1);		/* serializer broadcast I2C translated */
+	ser_write(0x0C, link->ser_addr << 1);		/* serializer broadcast I2C native */
+	/* put serializer in configuration link state  */
+	ser_write(0x04, 0x43);				/* enable RC, conf_link */
+	usleep_range(2000, 2500);
+
+	return 0;
+}
+
+static void max96712_gmsl1_link_pipe_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int pipe = link_n; /* straight map */
+	int dt = priv->dt; /* should come from imager */
+	int in_vc = 0;
+
+	max96712_pipe_override(priv, pipe, dt, in_vc);		/* override dt, vc */
+
+	des_write(MAX_MIPI_TX11(pipe), 0x00);			/* disable all mappings */
+	des_write(MAX_MIPI_TX12(pipe), 0x00);
+
+	/* use map #0 for payload data */
+	max96712_set_pipe_to_mipi_mapping(priv, pipe, 0,	/* pipe, map# */
+					  dt, in_vc,		/* src DT, VC */
+					  dt, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	/* use map #1 for FS */
+	max96712_set_pipe_to_mipi_mapping(priv, pipe, 1,	/* pipe, map# */
+					  0x00, in_vc,		/* src DT, VC */
+					  0x00, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	/* use map #2 for FE */
+	max96712_set_pipe_to_mipi_mapping(priv, pipe, 2,	/* pipe, map# */
+					  0x01, in_vc,		/* src DT, VC */
+					  0x01, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	usleep_range(5000, 5500);
+
+	link->pipes_mask |= BIT(pipe);
+}
+
+static void max96712_gmsl1_postinit(struct max96712_priv *priv)
+{
+	int i;
+	u8 val = 0;
+
+	for (i = 0; i < priv->n_links; i++) {
+		struct max96712_link *link = priv->link[i];
+
+		if (!(priv->links_mask & BIT(i)))
+			continue;
+
+		des_write(MAX_GMSL1_4(i), 0x3);			/* enable REV/FWD CC */
+		des_write(MAX96712_REG6, BIT(i));		/* GMSL1 mode, enable GMSL link# */
+		max96712_reset_oneshot(priv, BIT(i));
+		usleep_range(2000, 2500);
+
+		ser_read(0x15, &val);
+		if (!(val & BIT(1)))
+			dev_warn(&priv->client->dev, "link%d valid PCLK is not detected\n", i);
+
+		/* switch to GMSL serial_link for streaming video */
+		max96712_write_remote_verify(priv, i, 0x04, conf_link ? 0x43 : 0x83);
+		usleep_range(2000, 2500);
+		des_write(MAX_GMSL1_4(i), 0x00);		/* disable REV/FWD CC */
+
+		switch (priv->link[i]->ser_id) {
+		case MAX9271_ID:
+			des_update_bits(MAX_GMSL1_6(i), 0x07, 0x01); /* use D14/15 for HS/VS */
+			break;
+		case MAX96705_ID:
+		case MAX96707_ID:
+			des_update_bits(MAX_GMSL1_6(i), 0x07, 0x00); /* use D18/D19 for HS/VS */
+			break;
+		}
+	}
+
+	for (i = 0; i < priv->n_links; i++)
+		des_write(MAX_GMSL1_4(i), priv->links_mask & BIT(i) ? 0x03 : 0); /* enable REV/FWD CC */
+
+	des_update_bits(MAX96712_REG6, 0x0f, priv->links_mask);	/* enable detected links */
+	max96712_reset_oneshot(priv, priv->links_mask);		/* one-shot reset valid links */
+}
+
+static void max96712_gmsl1_fsync_setup(struct max96712_priv *priv)
+{
+	des_write(MAX96712_FSYNC_5, priv->fsync_period & 0xff);	/* Fsync Period L */
+	des_write(MAX96712_FSYNC_6, (priv->fsync_period >> 8) & 0xff);/* Fsync Period M */
+	des_write(MAX96712_FSYNC_7, priv->fsync_period >> 16);	/* Fsync Period H */
+	//des_write(MAX96712_FSYNC_8, 0x00);			/* Disable Err Thresh */
+	//des_write(MAX96712_FSYNC_9, 0x00);			/* Disable Err Thresh */
+	des_write(MAX96712_FSYNC_10, 0x00);			/* Disable Overlap */
+	des_write(MAX96712_FSYNC_11, 0x00);
+
+	des_write(MAX96712_FSYNC_0, 0x00);			/* Manual method, Internal GMSL1 generator mode */
+
+	des_write(MAX_GMSL1_8(0), 0x11);			/* Fsync Tx Enable on Link A */
+	des_write(MAX_GMSL1_8(1), 0x11);			/* Fsync Tx Enable on Link B */
+	des_write(MAX_GMSL1_8(2), 0x11);			/* Fsync Tx Enable on Link C */
+	des_write(MAX_GMSL1_8(3), 0x11);			/* Fsync Tx Enable on Link D */
+
+	des_write(MAX96712_FSYNC_15, 0x1f);			/* GMSL1 Type Fsync, Enable all pipes */
+}
+
+/* -----------------------------------------------------------------------------
+ * GMSL2
+ */
+
+static void max96712_gmsl2_cc_enable(struct max96712_priv *priv, int link, int on)
+{
+	/* nothing */
+}
+
+static int max96712_gmsl2_get_link_lock(struct max96712_priv *priv, int link_n)
+{
+	int lock_reg[] = {MAX96712_CTRL3, MAX96712_CTRL12, MAX96712_CTRL13, MAX96712_CTRL14};
+	int val = 0;
+
+	des_read(lock_reg[link_n], &val);
+
+	return !!(val & BIT(3));
+}
+
+static void max96712_gmsl2_initial_setup(struct max96712_priv *priv)
+{
+	des_update_bits(MAX96712_REG6, 0xf0, 0xf0);	/* set GMSL2 mode */
+	des_write(MAX96712_REG26, 0x22);		/* 187.5M/6G */
+	des_write(MAX96712_REG27, 0x22);		/* 187.5M/6G */
+}
+
+static int max96712_gmsl2_reverse_channel_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int ser_addrs[] = {0x40, 0x42, 0x60, 0x62}; /* possible MAX9295 addresses on i2c bus */
+	int timeout = priv->timeout;
+	int ret = 0;
+	int i = 0;
+
+	des_write(MAX96712_REG6, 0xf0 | BIT(link_n));		/* GMSL2 mode, enable GMSL link# */
+	max96712_reset_oneshot(priv, BIT(link_n));
+
+	/* wait the link to be established, indicated when status bit LOCKED goes high */
+	for (; timeout > 0; timeout--) {
+		if (max96712_gmsl2_get_link_lock(priv, link_n))
+			break;
+		mdelay(1);
+	}
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ser_addrs); i++) {
+		int val = 0;
+
+		__reg16_read(ser_addrs[i], 0x000d, &val);	/* read serializer ID */
+		if (val == MAX9295A_ID || val == MAX9295B_ID  || val == MAX96717F_ID) {
+			link->ser_id = val;
+			__reg16_write(ser_addrs[i], 0x0000, link->ser_addr << 1); /* relocate serizlizer on I2C bus */
+			usleep_range(2000, 2500);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ser_addrs)) {
+		dev_err(&priv->client->dev, "serializer not found\n");
+		goto out;
+	}
+
+	priv->links_mask |= BIT(link_n);
+
+out:
+	dev_info(&priv->client->dev, "link%d %s %sat 0x%x (0x%x) %s\n", link_n, chip_name(link->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", link->ser_addr, ser_addrs[i],
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL2 link establish" : "");
+	return ret;
+}
+
+static int max96712_gmsl2_link_serializer_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int i;
+
+	if (strcmp(priv->mbus, "dvp") == 0) {
+		ser_write(MAX9295_VIDEO_TX0(0), BIT(6) |	/* line CRC enable */
+						(priv->hven ? BIT(5) : 0)); /* HS/VS encoding */
+		ser_write(MAX9295_VIDEO_TX1(0), 0x0a);	/* BPP = 10 */
+		ser_write(MAX9295_REG7, 0x07);		/* DVP stream, enable HS/VS, rising edge */
+
+		switch (priv->dt) {
+		case MIPI_DT_YUV8:
+		case MIPI_DT_RAW12:
+			/* setup crossbar: strait DVP mapping */
+			ser_write(MAX9295_CROSS(0), priv->cb[0]);
+			ser_write(MAX9295_CROSS(1), priv->cb[1]);
+			ser_write(MAX9295_CROSS(2), priv->cb[2]);
+			ser_write(MAX9295_CROSS(3), priv->cb[3]);
+			ser_write(MAX9295_CROSS(4), priv->cb[4]);
+			ser_write(MAX9295_CROSS(5), priv->cb[5]);
+			ser_write(MAX9295_CROSS(6), priv->cb[6]);
+			ser_write(MAX9295_CROSS(7), priv->cb[7]);
+			ser_write(MAX9295_CROSS(8), priv->cb[8]);
+			ser_write(MAX9295_CROSS(9), priv->cb[9]);
+			ser_write(MAX9295_CROSS(10), priv->cb[10]);
+			ser_write(MAX9295_CROSS(11), priv->cb[11]);
+			break;
+		}
+	} else {
+		/* defaults:
+		 *  REG2	- video enable Pipex X,Z
+		 *  MIPI_RX0	- 1x4 mode (1-port x 4-lanes)
+		 *  MIPI_RX1	- 4-lanes
+		 *  MIPI_RX2, MIPI_RX3 - merge PHY1,PHY2 to 1x4-mode
+		 *  FRONTTOP_9	- start Pipes X,Z from CSI_A,CSI_B
+		 */
+
+		ser_write(MAX9295_FRONTTOP_0, 0x71);                    /* enable Pipe X from from CSI_A,CSI_B */
+		ser_write(MAX9295_FRONTTOP_12, BIT(6) | priv->dt);      /* primary DT for Pipe X */
+		ser_write(MAX9295_FRONTTOP_13, BIT(6) | MIPI_DT_EMB);   /* secondary DT for Pipe X */
+	}
+
+	for (i = 0; i < 11; i++) {
+		if (priv->gpio[i] == 0) {
+			/* GPIO set 0 */
+			ser_write(MAX9295_GPIO_A(i), 0x80);	/* 1MOm, GPIO output low */
+			ser_write(MAX9295_GPIO_B(i), 0xa0);	/* push-pull, pull-down */
+		}
+		if (priv->gpio[i] == 1) {
+			/* GPIO set 1 */
+			ser_write(MAX9295_GPIO_A(i), 0x90);	/* 1MOm, GPIO output high */
+			ser_write(MAX9295_GPIO_B(i), 0x60);	/* push-pull, pull-up */
+		}
+		if (priv->gpio[i] == 2) {
+			/* GPIO FSIN */
+			ser_write(MAX9295_GPIO_A(i), 0x84);	/* 1MOm, GMSL2 RX from deserializer */
+			ser_write(MAX9295_GPIO_C(i), 0x08);	/* pull-none, GPIO ID=8 assosiated with FSYNC transmission */
+		}
+		if (priv->gpio[i] == 3) {
+			/* GPIO Interrupt */
+			ser_write(MAX9295_GPIO_A(i), 0x63);	/* 40kOm, GMSL2 TX to deserializer */
+			ser_write(MAX9295_GPIO_B(i), 0x25);	/* push-pull, pull-none, GPIO stream ID=5 */
+		}
+	}
+
+	/* I2C translator setup */
+	//ser_write(MAX9295_I2C2, OV490_I2C_ADDR_NEW << 1); /* sensor I2C translated - must be set by sensor driver */
+	//ser_write(MAX9295_I2C3, OV490_I2C_ADDR << 1);	/* sensor I2C native - must be set by sensor driver */
+	ser_write(MAX9295_I2C4, BROADCAST << 1);	/* serializer broadcast I2C translated */
+	ser_write(MAX9295_I2C5, link->ser_addr << 1);	/* serializer broadcast I2C native */
+	usleep_range(2000, 2500);
+
+	return 0;
+}
+
+#define RTX_MIPI_OUT_DT_FORCE_TO_RAW8
+
+static struct {
+	int in_dt;
+	int out_dt;
+} gmsl2_pipe_maps[] = {
+	{0x00,		0x00},		/* FS */
+	{0x01,		0x01},		/* FE */
+	{MIPI_DT_YUV8,	MIPI_DT_YUV8},	/* payload data */
+	{MIPI_DT_RAW8,	MIPI_DT_YUV8},
+#ifndef RTX_MIPI_OUT_DT_FORCE_TO_RAW8
+	{MIPI_DT_RAW10,	MIPI_DT_YUV8},
+	{MIPI_DT_RAW12,	MIPI_DT_YUV8},
+#else
+	{MIPI_DT_RAW10,	MIPI_DT_YUV8},
+	{MIPI_DT_RAW12,	MIPI_DT_YUV8},
+#endif
+};
+
+static void max96712_gmsl2_pipe_set_source(struct max96712_priv *priv, int pipe, int phy, int in_pipe)
+{
+	int offset = (pipe % 2) * 4;
+
+	des_update_bits(MAX96712_VIDEO_PIPE_SEL(pipe / 2), 0x0f << offset, (phy << (offset + 2)) |
+									   (in_pipe << offset));
+}
+
+static void max96712_gmsl2_link_pipe_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int pipe = link_n; /* straight mapping */
+	int dt = priv->dt; /* must come from imager */
+	int in_vc = 0;
+	int i;
+
+	max96712_gmsl2_pipe_set_source(priv, pipe, link_n, 0);                  /* route Pipe X only */
+
+	if (strcmp(priv->mbus, "dvp") == 0) {
+		des_write(MAX96712_RX0(pipe), 0);				/* stream_id = 0 */
+		//des_update_bits(MAX_VIDEO_RX0(pipe), BIT(0), BIT(0));		/* disable Packet detector */
+		max96712_pipe_override(priv, pipe, dt, in_vc);			/* override dt, vc */
+	}
+
+	des_write(MAX_MIPI_TX11(pipe), 0x00);					/* disable all mappings */
+	des_write(MAX_MIPI_TX12(pipe), 0x00);
+
+	for (i = 0; i < ARRAY_SIZE(gmsl2_pipe_maps); i++) {
+		max96712_set_pipe_to_mipi_mapping(priv, pipe, i,		/* pipe, map# */
+						  gmsl2_pipe_maps[i].in_dt, in_vc, /* src DT, VC */
+						  gmsl2_pipe_maps[i].out_dt, link->out_vc, /* dst DT, VC */
+						  link->out_mipi);		/* dst MIPI PHY */
+	}
+
+	link->pipes_mask |= BIT(pipe);
+}
+
+static void max96712_gmsl2_postinit(struct max96712_priv *priv)
+{
+	des_update_bits(MAX96712_REG6, 0x0f, priv->links_mask);	/* enable detected links */
+	max96712_reset_oneshot(priv, priv->links_mask);		/* one-shot reset valid links */
+}
+
+static void max96712_gmsl2_link_crossbar_setup(struct max96712_priv *priv, int link, int dt)
+{	
+	des_write(MAX_CROSS(link, 24), (priv->hsync ? 0 : 0x40) + 24);	/* invert HS polarity */	//RTX Modify
+	des_write(MAX_CROSS(link, 25), (priv->vsync ? 0 : 0x40) + 25);	/* invert VS polarity */	//RTX Modify
+	des_write(MAX_CROSS(link, 26), (priv->de 	? 0 : 0x40) + 26);	/* invert DE polarity */	//RTX Modify
+}
+
+static void max96712_gmsl2_fsync_setup(struct max96712_priv *priv)
+{
+	des_write(MAX96712_FSYNC_5, priv->fsync_period & 0xff);	/* Fsync Period L */
+	des_write(MAX96712_FSYNC_6, (priv->fsync_period >> 8) & 0xff);/* Fsync Period M */
+	des_write(MAX96712_FSYNC_7, priv->fsync_period >> 16);	/* Fsync Period H */
+	des_write(MAX96712_FSYNC_10, 0x00);			/* Disable Overlap */
+	des_write(MAX96712_FSYNC_11, 0x00);
+
+	des_write(MAX96712_FSYNC_0, 0x00);			/* Manual method, Internal GMSL2 generator mode */
+	des_write(MAX96712_FSYNC_15, 0x80);			/* GMSL2 Type Fsync, Disable all pipes for manual mode */
+	des_write(MAX96712_FSYNC_17, 8 << 3);			/* GPIO ID=8 assosiated with FSYNC transmission */
+}
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int max96712_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int max96712_i2c_mux_init(struct max96712_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->n_links, 0, I2C_MUX_LOCKED,
+				  max96712_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+#define max96712_cc_enable(priv,i,en)		(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_cc_enable(priv, i, en) : \
+										 max96712_gmsl1_cc_enable(priv, i, en))
+#define max96712_initial_setup(priv)		(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_initial_setup(priv) : \
+										 max96712_gmsl1_initial_setup(priv))
+#define max96712_reverse_channel_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_reverse_channel_setup(priv, i) : \
+										 max96712_gmsl1_reverse_channel_setup(priv, i))
+#define max96712_link_serializer_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_link_serializer_setup(priv, i) : \
+										 max96712_gmsl1_link_serializer_setup(priv, i))
+#define max96712_link_pipe_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_link_pipe_setup(priv, i) : \
+										 max96712_gmsl1_link_pipe_setup(priv, i))
+#define max96712_link_crossbar_setup(priv,i,dt)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_link_crossbar_setup(priv, i, dt) : \
+										 max96712_gmsl1_link_crossbar_setup(priv, i, dt))
+#define max96712_postinit(priv)			(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_postinit(priv) : \
+										 max96712_gmsl1_postinit(priv))
+#define max96712_fsync_setup(priv)		(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_fsync_setup(priv) : \
+										 max96712_gmsl1_fsync_setup(priv))
+
+static int max96712_preinit(struct max96712_priv *priv)
+{
+	int i;
+
+	des_update_bits(MAX96712_PWR1, BIT(6), BIT(6));		/* reset chip */
+	mdelay(5);
+
+	/* enable internal regulator for 1.2V VDD supply */
+	des_update_bits(MAX96712_CTRL0, BIT(2), BIT(2));	/* REG_ENABLE = 1 */
+	des_update_bits(MAX96712_CTRL2, BIT(4), BIT(4));	/* REG_MNL = 1 */
+
+	//for (i = 0; i < priv->n_links; i++) {
+	//	des_write(MAX_RLMS58(i), 0x28);
+	//	des_write(MAX_RLMS59(i), 0x68);
+	//	max96712_reset_oneshot(priv, BIT(i));
+	//}
+
+	/* I2C-I2C timings */
+	for (i = 0; i < 8; i++) {
+		des_write(MAX96712_I2C_0(i), 0x01);		/* Fast mode Plus, 1mS timeout */
+		des_write(MAX96712_I2C_1(i), 0x51);		/* i2c speed: 397Kbps, 1mS timeout */
+	}
+
+	des_update_bits(MAX96712_CTRL11, 0x55, priv->is_coax ? 0x55 : 0); /* cable mode */
+	des_update_bits(MAX96712_REG6, 0x0f, 0);		/* disable all links */
+
+	return 0;
+}
+
+static int max96712_initialize(struct max96712_priv *priv)
+{
+	int ret, i;
+
+	max96712_preinit(priv);
+	max96712_initial_setup(priv);
+	max96712_mipi_setup(priv);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg)) {
+			ret = regulator_enable(priv->link[i]->poc_reg); /* POC power on */
+			if (ret) {
+				dev_err(&priv->link[i]->client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ret = max96712_reverse_channel_setup(priv, i);
+		if (ret == -ETIMEDOUT)
+			continue;
+		if (!ret)
+			max96712_link_serializer_setup(priv, i);
+
+		max96712_link_pipe_setup(priv, i);
+		max96712_link_crossbar_setup(priv, i, priv->dt);
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+		max96712_cc_enable(priv, i, 0);
+	}
+
+	max96712_postinit(priv);
+	max96712_fsync_setup(priv);
+
+	return 0;
+}
+
+static int max96712_reboot_notifier(struct notifier_block *nb, unsigned long code, void *data)
+{
+	struct max96712_priv *priv = container_of(nb, struct max96712_priv, reboot_nb);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg))
+			regulator_disable(priv->link[i]->poc_reg); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int max96712_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(sd);
+	int i, pipes_mask = 0;
+
+	for (i = 0; i < priv->n_links; i++)
+		pipes_mask |= priv->link[i]->pipes_mask;
+
+	if (enable) {
+		des_update_bits(MAX96712_VIDEO_PIPE_EN, pipes_mask, pipes_mask); /* enable link pipes */
+		if (atomic_inc_return(&priv->use_count) == 1) {
+			des_update_bits(MAX_BACKTOP12(0), 0x02, 0x02); /* CSI output enable */
+			/* Workaround for rev3 silicon: */
+			des_update_bits(MAX_MIPI_PHY0, 0x80, 0x80); /* Force all MIPI clocks running */
+		}
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0) {
+			des_update_bits(MAX_MIPI_PHY0, 0x80, 0x00); /* Disable all MIPI clocks running force */
+			des_update_bits(MAX_BACKTOP12(0), 0x02, 0); /* CSI output disable */
+		}
+		des_update_bits(MAX96712_VIDEO_PIPE_EN, pipes_mask, 0); /* disable link pipes */
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops max96712_video_ops = {
+	.s_stream = max96712_s_stream,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int max96712_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(sd);
+	int ret;
+	int val = 0;
+
+	ret = des_read(reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int max96712_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(sd);
+
+	return des_write(reg->reg, (u8)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops max96712_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = max96712_g_register,
+	.s_register = max96712_s_register,
+#endif
+};
+
+static struct v4l2_subdev_ops max96712_subdev_ops = {
+	.core = &max96712_subdev_core_ops,
+	.video = &max96712_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int max96712_notify_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *subdev,
+				 struct v4l2_async_subdev *asd)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max96712_link *link = asd_to_max96712_link(asd);
+	int sink_pad = link->pad;
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, link->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	link->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void max96712_notify_unbind(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *subdev,
+				   struct v4l2_async_subdev *asd)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max96712_link *link = asd_to_max96712_link(asd);
+
+	link->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations max96712_notify_ops = {
+	.bound = max96712_notify_bound,
+	.unbind = max96712_notify_unbind,
+};
+
+static int max96712_v4l2_init(struct i2c_client *client)
+{
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+	long pixel_rate;
+#ifdef KERNEL_5
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+#endif
+	priv->notifier.ops = &max96712_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+	v4l2_i2c_subdev_init(&priv->sd, client, &max96712_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+	/* Only YUV422 bpp=16 supported atm, decode to pixel_rate from fixed csi_rate */
+	pixel_rate = priv->csi_rate[priv->link[0]->out_mipi] / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  pixel_rate, pixel_rate, 1, pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[MAX96712_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[MAX96712_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX96712_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX96712_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX96712_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, MAX96712_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, MAX96712_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+	of_node_put(ep);
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int max96712_parse_dt(struct i2c_client *client)
+{
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	struct property *prop;
+	char name[16];
+	int i, csi_rate, err;
+	u32 addrs[4], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+
+	priv->n_links = naddrs;
+	for (i = 0; i < priv->n_links; i++)
+		priv->link[i]->ser_addr = addrs[i];
+
+	if (of_property_read_u32(np, "maxim,gmsl", &priv->gmsl_mode))
+		priv->gmsl_mode = MODE_GMSL2;
+	if (of_property_read_bool(np, "maxim,stp"))
+		priv->is_coax = 0;
+	else
+		priv->is_coax = 1;
+	if (of_property_read_u32(np, "maxim,resetb-gpio", &priv->gpio_resetb)) {
+		priv->gpio_resetb = -1;
+	} else {
+		if (of_property_read_bool(np, "maxim,resetb-active-high"))
+			priv->active_low_resetb = 0;
+		else
+			priv->active_low_resetb = 1;
+	}
+	if (of_property_read_u32(np, "maxim,fsync-period", &priv->fsync_period))
+		priv->fsync_period = 3210000;/* 96MHz/30fps */
+	priv->pclk_rising_edge = true;
+	if (of_property_read_bool(np, "maxim,pclk-falling-edge"))
+		priv->pclk_rising_edge = false;
+	if (of_property_read_u32(np, "maxim,timeout", &priv->timeout))
+		priv->timeout = 100;
+	if (of_property_read_u32(np, "maxim,him", &priv->him))
+		priv->him = 0;
+	if (of_property_read_u32(np, "maxim,bws", &priv->bws))
+		priv->bws = 0;
+	if (of_property_read_u32(np, "maxim,dbl", &priv->dbl))
+		priv->dbl = 1;
+	if (of_property_read_u32(np, "maxim,hven", &priv->hven))
+		priv->hven = 1;
+	if (of_property_read_u32(np, "maxim,hibw", &priv->hibw))
+		priv->hibw = 0;
+	if (of_property_read_u32(np, "maxim,hsync", &priv->hsync))
+		priv->hsync = hsync;
+	if (of_property_read_u32(np, "maxim,vsync", &priv->vsync))
+		priv->vsync = vsync;
+	if (of_property_read_u32(np, "maxim,de", &priv->de))
+		priv->de = de;		
+	if (of_property_read_u32(np, "maxim,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 50;
+	if (of_property_read_u32(np, "maxim,dt", &priv->dt))
+		priv->dt = MIPI_DT_YUV8;
+	if (of_property_read_u64(np, "maxim,crossbar", &priv->crossbar))
+		priv->crossbar = crossbar;
+	if (of_property_read_string(np, "maxim,mbus", &priv->mbus))
+		priv->mbus = mbus_default;
+	for (i = 0; i < 11; i++) {
+		sprintf(name, "maxim,gpio%d", i);
+		if (of_property_read_u32(np, name, &priv->gpio[i]))
+			priv->gpio[i] = -1;
+	}
+
+	/* module params override dts */
+	if (gmsl != MODE_GMSL2)
+		priv->gmsl_mode = gmsl;
+	if (him)
+		priv->him = him;
+	if (fsync_period) {
+		priv->fsync_period = fsync_period;
+	//	priv->fsync_mode = fsync_mode_default;
+	}
+
+	if (gpio_resetb)
+		priv->gpio_resetb = gpio_resetb;
+	if (active_low_resetb)
+		priv->active_low_resetb = active_low_resetb;
+	if (timeout_n)
+		priv->timeout = timeout_n;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (bws)
+		priv->bws = bws;
+	if (!dbl)
+		priv->dbl = dbl;
+	if (dt != MIPI_DT_YUV8)
+		priv->dt = dt;
+	//if (hsgen)
+	//	priv->hsgen = hsgen;
+	if (gpio0 >= 0)
+		priv->gpio[0] = gpio0;
+	if (gpio1 >= 0)
+		priv->gpio[1] = gpio1;
+	if (gpio4 >= 0)
+		priv->gpio[4] = gpio4;
+	if (gpio7 >= 0)
+		priv->gpio[7] = gpio7;
+	if (gpio8 >= 0)
+		priv->gpio[8] = gpio8;
+	if (strcmp(mbus, "dvp"))
+		priv->mbus = mbus;
+
+	/* parse serializer crossbar setup */
+	for (i = 0; i < 16; i++) {
+		priv->cb[i] = priv->crossbar % 16;
+		priv->crossbar /= 16;
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		priv->link[i]->out_mipi = 1;	/* CSI default forwarding is to MIPI1 */
+		priv->link[i]->out_vc = i;	/* Default VC map: 0 1 2 3 */
+	}
+
+	prop = of_find_property(np, "maxim,links-mipi-map", NULL);
+	if (prop) {
+		const __be32 *map = NULL;
+		u32 val;
+
+		for (i = 0; i < priv->n_links; i++) {
+			map = of_prop_next_u32(prop, map, &val);
+			if (!map)
+				break;
+			if (val >= MAX96712_MAX_MIPI)
+				return -EINVAL;
+			priv->link[i]->out_mipi = val;
+		}
+	}
+
+	if (of_property_read_u32(np, "csi-rate", &csi_rate))
+		csi_rate = 1200;
+
+	for (i = 0; i < priv->n_links; i++)
+		priv->csi_rate[priv->link[i]->out_mipi] = csi_rate;
+
+	prop = of_find_property(np, "maxim,links-vc-map", NULL);
+	if (prop) {
+		const __be32 *map = NULL;
+		u32 val;
+
+		for (i = 0; i < priv->n_links; i++) {
+			map = of_prop_next_u32(prop, map, &val);
+			if (!map)
+				break;
+			if (val >= 4)
+				return -EINVAL;
+			priv->link[i]->out_vc = val;
+		}
+	}
+
+	dev_dbg(&client->dev, "Link# | MIPI rate | Map | VC\n");
+	for (i = 0; i < priv->n_links; i++)
+		dev_dbg(&client->dev, "%5d | %9d | %3d | %2d\n", i, priv->csi_rate[i], priv->link[i]->out_mipi, priv->link[i]->out_vc);
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct max96712_link *link;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > MAX96712_MAX_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+			of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == MAX96712_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+#ifdef KERNEL_5
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+#else
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2) {
+#endif
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		link = priv->link[ep.port];
+		link->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!link->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		link->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+#ifdef KERNEL_5
+		link->asd.match.fwnode = link->fwnode;
+#else
+		link->asd.match.fwnode.fwnode = link->fwnode;
+#endif
+		link->pad = ep.port;
+
+		priv->subdevs[ep.port] = &link->asd;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int max96712_probe(struct i2c_client *client,
+			  const struct i2c_device_id *did)
+{
+	struct max96712_priv *priv;
+	struct gpio_desc *pwdn_gpio;
+	int ret, i;
+	int val = 0;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* update client i2c addr for PnP case */
+	i = of_property_match_string(client->dev.of_node, "reg-names", "max96712");
+	if (i >= 0)
+		of_property_read_u32_index(client->dev.of_node, "reg", i, (unsigned int *)&client->addr);
+
+	priv->regmap = devm_regmap_init_i2c(client, &max96712_regmap[0]);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+
+	priv->ref_clk = v4l2_clk_get(&client->dev, "ref_clk");
+	if (!IS_ERR(priv->ref_clk)) {
+		dev_info(&client->dev, "ref_clk = %luKHz", v4l2_clk_get_rate(priv->ref_clk) / 1000);
+		v4l2_clk_enable(priv->ref_clk);
+	}
+	pwdn_gpio = devm_gpiod_get_optional(&client->dev, "shutdown", GPIOD_OUT_HIGH);
+	if (!IS_ERR(pwdn_gpio)) {
+		udelay(5);
+		gpiod_set_value_cansleep(pwdn_gpio, 0);
+		usleep_range(3000, 5000);
+	}
+	des_read(MAX96712_DEV_ID, &val);
+	if (val != MAX96712_ID)
+		return -ENODEV;
+	for (i = 0; i < MAX96712_MAX_LINKS; i++) {
+		priv->link[i] = devm_kzalloc(&client->dev, sizeof(*priv->link[i]), GFP_KERNEL);
+		if (!priv->link[i])
+			return -ENOMEM;
+	}
+	ret = max96712_parse_dt(client);
+	if (ret)
+		goto out;
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->link[i]->poc_reg = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->link[i]->poc_reg) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+	for (i = 0; i < priv->n_links; i++) {
+		priv->link[i]->client = i2c_new_dummy(client->adapter, priv->link[i]->ser_addr);
+		if (!priv->link[i]->client)
+			return -ENOMEM;
+
+		priv->link[i]->regmap = regmap_init_i2c(priv->link[i]->client, &max96712_regmap[priv->gmsl_mode]);
+		if (IS_ERR(priv->link[i]->regmap))
+			return PTR_ERR(priv->link[i]->regmap);
+	}
+	ret = max96712_i2c_mux_init(priv);
+	if (ret) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	ret = max96712_initialize(priv);
+	if (ret < 0)
+		goto out;
+	ret = max96712_v4l2_init(client);
+	if (ret < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+	priv->reboot_nb.notifier_call = max96712_reboot_notifier;
+	ret = register_reboot_notifier(&priv->reboot_nb);
+	if (ret) {
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+		goto out;
+	}
+	//max96712_debug_add(priv);
+	//max96712_patgen(priv);
+out:
+
+	return ret;
+}
+
+static int max96712_remove(struct i2c_client *client)
+{
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	//max96712_debug_remove(priv);
+	i2c_mux_del_adapters(priv->mux);
+	unregister_reboot_notifier(&priv->reboot_nb);
+
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg))
+			regulator_disable(priv->link[i]->poc_reg); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id max96712_dt_ids[] = {
+	{ .compatible = "maxim,max96712" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max96712_dt_ids);
+
+static const struct i2c_device_id max96712_id[] = {
+	{ "max96712", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max96712_id);
+
+static struct i2c_driver max96712_i2c_driver = {
+	.driver	= {
+		.name		= "max96712",
+		.of_match_table	= of_match_ptr(max96712_dt_ids),
+	},
+	.probe		= max96712_probe,
+	.remove		= max96712_remove,
+	.id_table	= max96712_id,
+};
+
+module_i2c_driver(max96712_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL2 driver for MAX96712");
+MODULE_AUTHOR("Andrey Gusakov, Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/soc_camera/max96712.h b/drivers/media/i2c/soc_camera/max96712.h
new file mode 100644
index 000000000000..9c0c91eeebc9
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/max96712.h
@@ -0,0 +1,313 @@
+/*
+ * MAXIM max96712 GMSL2 driver header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define MAX96712_MAX_LINKS		4
+#define MAX96712_MAX_PIPES		8
+#define MAX96712_MAX_PIPE_MAPS		16
+#define MAX96712_MAX_MIPI		4
+
+enum max96712_pads {
+	MAX96712_SINK_LINK0,
+	MAX96712_SINK_LINK1,
+	MAX96712_SINK_LINK2,
+	MAX96712_SINK_LINK3,
+	MAX96712_SOURCE,
+	MAX96712_N_PADS,
+};
+
+struct max96712_link {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+	int			pad;
+
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	int			ser_id;
+	int			ser_addr;
+	int			pipes_mask;	/* mask of pipes used by this link */
+	int			out_mipi;	/* MIPI# */
+	int			out_vc;		/* VC# */
+	struct regulator	*poc_reg;	/* PoC power supply */
+};
+
+#define asd_to_max96712_link(_asd) \
+	container_of(_asd, struct max96712_link, asd)
+
+struct max96712_priv {
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[MAX96712_N_PADS];
+
+	struct i2c_mux_core	*mux;
+
+	int			n_links;
+	int			links_mask;
+	enum gmsl_mode		gmsl_mode;
+	struct max96712_link	*link[MAX96712_MAX_LINKS];
+	struct v4l2_async_subdev *subdevs[MAX96712_MAX_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			gpio_resetb;
+	int			active_low_resetb;
+	bool			pclk_rising_edge;
+	bool			is_coax;
+	int			him;
+	int			bws;
+	int			dbl;
+	int			hibw;
+	int			hven;
+	int			hsync;
+	int			vsync;
+	int			de;
+	int			dt;
+	u64			crossbar;
+	char			cb[16];
+	const char		*mbus;
+	int			gpio[11];
+	int			timeout;
+	int			poc_delay;
+	struct v4l2_clk		*ref_clk;
+	int			lanes;
+	int			csi_rate[MAX96712_MAX_MIPI];
+	int			fsync_period;
+	atomic_t		use_count;
+	struct notifier_block	reboot_nb;
+};
+
+#define MAX96712_REG4			0x04
+#define MAX96712_REG5			0x05
+#define MAX96712_REG6			0x06
+#define MAX96712_REG14			0x0e
+#define MAX96712_REG26			0x10
+#define MAX96712_REG27			0x11
+
+#define MAX96712_CTRL0			0x17
+#define MAX96712_CTRL1			0x18
+#define MAX96712_CTRL2			0x19
+#define MAX96712_CTRL3			0x1a
+#define MAX96712_CTRL11			0x22
+#define MAX96712_CTRL12			0x0a
+#define MAX96712_CTRL13			0x0b
+#define MAX96712_CTRL14			0x0c
+
+#define MAX96712_PWR1			0x13
+
+#define MAX96712_DEV_ID			0x4a
+#define MAX96712_REV			0x4c
+
+#define MAX96712_VIDEO_PIPE_SEL(n)	(0xf0 + n)
+#define MAX96712_VIDEO_PIPE_EN		0xf4
+
+#define MAX96712_I2C_0(n)		(0x640 + (0x10 * n))
+#define MAX96712_I2C_1(n)		(0x641 + (0x10 * n))
+
+#define MAX96712_RX0(n)			(0x50 + n)
+
+#define MAX_VIDEO_RX_BASE(n)		(n < 5 ? (0x100 + (0x12 * n)) : \
+						 (0x160 + (0x12 * (n - 5))))
+#define MAX_VIDEO_RX0(n)		(MAX_VIDEO_RX_BASE(n) + 0x00)
+#define MAX_VIDEO_RX3(n)		(MAX_VIDEO_RX_BASE(n) + 0x03)
+#define MAX_VIDEO_RX8(n)		(MAX_VIDEO_RX_BASE(n) + 0x08)
+#define MAX_VIDEO_RX10(n)		(MAX_VIDEO_RX_BASE(n) + 0x0a)
+
+#define MAX_VPRBS(n)			(0x1dc + (0x20 * n))
+
+#define MAX_CROSS_BASE(n)		(0x1c0 + (0x20 * n))
+#define MAX_CROSS(n, m)			(MAX_CROSS_BASE(n) + m)
+
+#define MAX_BACKTOP_BASE(bank)		(0x400 + (0x20 * bank))
+#define MAX_BACKTOP1(bank)		(MAX_BACKTOP_BASE(bank) + 0x00)
+#define MAX_BACKTOP11(bank)		(MAX_BACKTOP_BASE(bank) + 0x0a)
+#define MAX_BACKTOP12(bank)		(MAX_BACKTOP_BASE(bank) + 0x0b)
+#define MAX_BACKTOP13(bank)		(MAX_BACKTOP_BASE(bank) + 0x0c)
+#define MAX_BACKTOP14(bank)		(MAX_BACKTOP_BASE(bank) + 0x0d)
+#define MAX_BACKTOP15(bank)		(MAX_BACKTOP_BASE(bank) + 0x0e)
+#define MAX_BACKTOP16(bank)		(MAX_BACKTOP_BASE(bank) + 0x0f)
+#define MAX_BACKTOP17(bank)		(MAX_BACKTOP_BASE(bank) + 0x10)
+#define MAX_BACKTOP18(bank)		(MAX_BACKTOP_BASE(bank) + 0x11)
+#define MAX_BACKTOP19(bank)		(MAX_BACKTOP_BASE(bank) + 0x12)
+#define MAX_BACKTOP20(bank)		(MAX_BACKTOP_BASE(bank) + 0x13)
+#define MAX_BACKTOP21(bank)		(MAX_BACKTOP_BASE(bank) + 0x14)
+#define MAX_BACKTOP22(bank)		(MAX_BACKTOP_BASE(bank) + 0x15)
+#define MAX_BACKTOP23(bank)		(MAX_BACKTOP_BASE(bank) + 0x16)
+#define MAX_BACKTOP24(bank)		(MAX_BACKTOP_BASE(bank) + 0x17)
+#define MAX_BACKTOP25(bank)		(MAX_BACKTOP_BASE(bank) + 0x18)
+#define MAX_BACKTOP26(bank)		(MAX_BACKTOP_BASE(bank) + 0x19)
+#define MAX_BACKTOP27(bank)		(MAX_BACKTOP_BASE(bank) + 0x1a)
+#define MAX_BACKTOP28(bank)		(MAX_BACKTOP_BASE(bank) + 0x1b)
+#define MAX_BACKTOP29(bank)		(MAX_BACKTOP_BASE(bank) + 0x1c)
+#define MAX_BACKTOP30(bank)		(MAX_BACKTOP_BASE(bank) + 0x1d)
+#define MAX_BACKTOP31(bank)		(MAX_BACKTOP_BASE(bank) + 0x1e)
+#define MAX_BACKTOP32(bank)		(MAX_BACKTOP_BASE(bank) + 0x1f)
+
+#define MAX96712_FSYNC_0		0x4a0
+#define MAX96712_FSYNC_5		0x4a5
+#define MAX96712_FSYNC_6		0x4a6
+#define MAX96712_FSYNC_7		0x4a7
+#define MAX96712_FSYNC_8		0x4a8
+#define MAX96712_FSYNC_9		0x4a9
+#define MAX96712_FSYNC_10		0x4aa
+#define MAX96712_FSYNC_11		0x4ab
+#define MAX96712_FSYNC_15		0x4af
+#define MAX96712_FSYNC_17		0x4b1
+
+#define MAX_MIPI_PHY_BASE		0x8a0
+#define MAX_MIPI_PHY0			(MAX_MIPI_PHY_BASE + 0x00)
+#define MAX_MIPI_PHY2			(MAX_MIPI_PHY_BASE + 0x02)
+#define MAX_MIPI_PHY3			(MAX_MIPI_PHY_BASE + 0x03)
+#define MAX_MIPI_PHY4			(MAX_MIPI_PHY_BASE + 0x04)
+#define MAX_MIPI_PHY5			(MAX_MIPI_PHY_BASE + 0x05)
+#define MAX_MIPI_PHY6			(MAX_MIPI_PHY_BASE + 0x06)
+#define MAX_MIPI_PHY8			(MAX_MIPI_PHY_BASE + 0x08)
+#define MAX_MIPI_PHY9			(MAX_MIPI_PHY_BASE + 0x09)
+#define MAX_MIPI_PHY10			(MAX_MIPI_PHY_BASE + 0x0a)
+#define MAX_MIPI_PHY11			(MAX_MIPI_PHY_BASE + 0x0b)
+#define MAX_MIPI_PHY13			(MAX_MIPI_PHY_BASE + 0x0d)
+#define MAX_MIPI_PHY14			(MAX_MIPI_PHY_BASE + 0x0e)
+
+#define MAX_MIPI_TX_BASE(n)		(0x900 + 0x40 * n)
+#define MAX_MIPI_TX2(n)			(MAX_MIPI_TX_BASE(n) + 0x02)
+#define MAX_MIPI_TX10(n)		(MAX_MIPI_TX_BASE(n) + 0x0a)
+#define MAX_MIPI_TX11(n)		(MAX_MIPI_TX_BASE(n) + 0x0b)
+#define MAX_MIPI_TX12(n)		(MAX_MIPI_TX_BASE(n) + 0x0c)
+
+/* 16 pairs of source-dest registers */
+#define MAX_MIPI_MAP_SRC(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x0d + (2 * n))
+#define MAX_MIPI_MAP_DST(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x0e + (2 * n))
+/* Phy dst. Each reg contains 4 dest */
+#define MAX_MIPI_MAP_DST_PHY(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x2d + n)
+
+#define MAX_GMSL1_2(ch)			(0xb02 + (0x100 * ch))
+#define MAX_GMSL1_4(ch)			(0xb04 + (0x100 * ch))
+#define MAX_GMSL1_6(ch)			(0xb06 + (0x100 * ch))
+#define MAX_GMSL1_7(ch)			(0xb07 + (0x100 * ch))
+#define MAX_GMSL1_8(ch)			(0xb08 + (0x100 * ch))
+#define MAX_GMSL1_D(ch)			(0xb0d + (0x100 * ch))
+#define MAX_GMSL1_F(ch)			(0xb0f + (0x100 * ch))
+#define MAX_GMSL1_19(ch)		(0xb19 + (0x100 * ch))
+#define MAX_GMSL1_1B(ch)		(0xb1b + (0x100 * ch))
+#define MAX_GMSL1_1D(ch)		(0xb1d + (0x100 * ch))
+#define MAX_GMSL1_20(ch)		(0xb20 + (0x100 * ch))
+#define MAX_GMSL1_96(ch)		(0xb96 + (0x100 * ch))
+#define MAX_GMSL1_CA(ch)		(0xbca + (0x100 * ch))
+#define MAX_GMSL1_CB(ch)		(0xbcb + (0x100 * ch))
+
+#define MAX_RLMS4(ch)			(0x1404 + (0x100 * ch))
+#define MAX_RLMSA(ch)			(0x140A + (0x100 * ch))
+#define MAX_RLMSB(ch)			(0x140B + (0x100 * ch))
+#define MAX_RLMSA4(ch)			(0x14a4 + (0x100 * ch))
+
+#define MAX_RLMS58(ch)			(0x1458 + (0x100 * ch))
+#define MAX_RLMS59(ch)			(0x1459 + (0x100 * ch))
+#define MAX_RLMS95(ch)			(0x1495 + (0x100 * ch))
+#define MAX_RLMSC4(ch)			(0x14c4 + (0x100 * ch))
+#define MAX_RLMSC5(ch)			(0x14c5 + (0x100 * ch))
+
+static inline int max96712_write(struct max96712_priv *priv, int reg, int val)
+{
+	int ret;
+
+	ret = regmap_write(priv->regmap, reg, val);
+	if (ret)
+		dev_dbg(&priv->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_write_n(struct max96712_priv *priv, int reg, int val, int val_len)
+{
+	int ret;
+
+	ret = regmap_raw_write(priv->regmap, reg, &val, val_len);
+	if (ret)
+		dev_dbg(&priv->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_read(struct max96712_priv *priv, int reg, int *val)
+{
+	int ret;
+
+	ret = regmap_read(priv->regmap, reg, val);
+	if (ret)
+		dev_dbg(&priv->client->dev, "read register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_update_bits(struct max96712_priv *priv, int reg, int mask, int bits)
+{
+	int ret;
+
+	ret = regmap_update_bits(priv->regmap, reg, mask, bits);
+	if (ret)
+		dev_dbg(&priv->client->dev, "update register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+#define des_read(reg, val)					max96712_read(priv, reg, val)
+#define des_write(reg, val)					max96712_write(priv, reg, val)
+#define des_write_n(reg, val_len, val)		max96712_write_n(priv, reg, val, val_len)
+#define des_update_bits(reg, mask, bits)	max96712_update_bits(priv, reg, mask, bits)
+
+static inline int max96712_ser_write(struct max96712_link *link, int reg, int val)
+{
+	int ret;
+
+	ret = regmap_write(link->regmap, reg, val);
+	if (ret < 0)
+		dev_dbg(&link->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_ser_write_n(struct max96712_link *link, int reg, int val, int val_len)
+{
+	int ret;
+
+	ret = regmap_raw_write(link->regmap, reg, &val, val_len);
+	if (ret)
+		dev_dbg(&link->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_ser_read(struct max96712_link *link, int reg, int *val)
+{
+	int ret;
+
+	ret = regmap_read(link->regmap, reg, val);
+	if (ret)
+		dev_dbg(&link->client->dev, "read register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_ser_update_bits(struct max96712_link *link, int reg, int mask, int bits)
+{
+	int ret;
+
+	ret = regmap_update_bits(link->regmap, reg, mask, bits);
+	if (ret)
+		dev_dbg(&link->client->dev, "update register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+#define ser_read(reg, val)					max96712_ser_read(link, reg, (int *)val)
+#define ser_write(reg, val)					max96712_ser_write(link, reg, val)
+#define ser_write_n(reg, val_len, val)		max96712_ser_write_n(link, reg, val, val_len)
+#define ser_update_bits(reg, mask, bits)	max96712_ser_update_bits(link, reg, mask, bits)
diff --git a/drivers/media/i2c/soc_camera/max96712_debug.h b/drivers/media/i2c/soc_camera/max96712_debug.h
new file mode 100644
index 000000000000..7c74b85bd4c5
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/max96712_debug.h
@@ -0,0 +1,362 @@
+/*
+ * MAXIM max96712 GMSL2 driver debug stuff
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+static char *pipe_names[4] = {
+	"X", "Y", "Z", "U"
+};
+
+static int max96712_gmsl1_get_link_lock(struct max96712_priv *priv, int link_n);
+static int max96712_gmsl2_get_link_lock(struct max96712_priv *priv, int link_n);
+
+#define reg_bits(x, y)	((reg >> (x)) & ((1 << (y)) - 1))
+
+static ssize_t max_link_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	int i = -1;
+	int j;
+	int gmsl2;
+	u32 crc = 0 ;
+	char *_buf = buf;
+	int reg = 0;
+
+	if (!sscanf(attr->attr.name, "link_%d", &i))
+		return -EINVAL;
+
+	if (i < 0)
+		return -EINVAL;
+
+	if (i >= priv->n_links) {
+		buf += sprintf(buf, "\n");
+		return (buf - _buf);
+	}
+
+	buf += sprintf(buf, "Link %c status\n", 'A' + i);
+
+	des_read(MAX96712_REG6, &reg);
+	gmsl2 = !!(reg & BIT(4 + i));
+	buf += sprintf(buf, "Link mode: %s\n", gmsl2 ? "GMSL2" : "GMSL1");
+
+	if (gmsl2) {
+		buf += sprintf(buf, "GMSL2 Link lock: %d\n", max96712_gmsl2_get_link_lock(priv, i));
+	} else {
+		reg = max96712_gmsl1_get_link_lock(priv, i);
+		buf += sprintf(buf,
+				"GMSL1_CB: 0x%02x:\t"
+				"LOCKED_G1: %d\n",
+				reg, reg_bits(0, 1));
+
+		des_read(MAX_GMSL1_CA(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_CA: 0x%02x:\t"
+				"PHASELOCK: %d, WBLOCK_G1: %d, DATAOK: %d\n",
+				reg, reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+
+		des_read(MAX_GMSL1_1B(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_1B: 0x%02x:\t"
+				"LINE_CRC_ERR: %d ",
+				reg, reg_bits(2, 1));
+		for (j = 0; j < 4; j++) {
+			des_read(MAX_GMSL1_20(i) + j, &reg);
+			crc = crc | ((reg & 0xff) << (j * 8));
+		}
+		buf += sprintf(buf, "last crc 0x%08x\n", crc);
+
+		des_read(MAX_GMSL1_19(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_19: CC_CRC_ERRCNT %d\n",
+				reg);
+
+		des_read(MAX_GMSL1_1D(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_1D: 0x%02x:\t"
+				"UNDERBOOST: %d, AEQ-BST: %d\n",
+				reg, reg_bits(4, 1), reg_bits(0, 4));
+	}
+
+	return (buf - _buf);
+}
+
+static ssize_t max_pipe_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	char *_buf = buf;
+	int pipe = 0;
+	int map;
+	int maps_en = 0;
+	int pipes_en;
+	int reg = 0;
+	int shift;
+
+	if (!sscanf(attr->attr.name, "pipe_%d", &pipe))
+		return -EINVAL;
+
+	if (pipe < 0)
+		return -EINVAL;
+
+	if (pipe >= MAX96712_MAX_PIPES) {
+		buf += sprintf(buf, "\n");
+		return (buf - _buf);
+	}
+
+	des_read(MAX96712_VIDEO_PIPE_EN, &pipes_en);
+
+	buf += sprintf(buf, "Video Pipe %d %s\n",
+		pipe, (pipes_en & BIT(pipe)) ? "ENABLED" : "disabled");
+	if (!(pipes_en & BIT(pipe)))
+		goto out;
+
+	des_read(MAX_VPRBS(pipe), &reg);
+	/* bit 5 is not valid for MAX96712 */
+	buf += sprintf(buf,
+			"\tVPRBS: 0x%02x\t"
+			"VPRBS_FAIL: %d,"
+			"VIDEO_LOCK: %d\n",
+			reg,
+			reg_bits(5, 1), reg_bits(0, 1));
+
+	/* show source */
+	shift = (pipe % 2) * 4;
+	des_read(MAX96712_VIDEO_PIPE_SEL(pipe / 2), &reg);
+	buf += sprintf(buf, "SRC: PHY %c, PIPE %s\n",
+		'A' + (char)((reg >> (shift + 2)) & 0x03),
+		pipe_names[(reg >> shift) & 0x03]);
+
+	/* show maps */
+	des_read(MAX_MIPI_TX11(pipe), &maps_en);
+	des_read(MAX_MIPI_TX12(pipe), &reg);
+	maps_en |= reg << 8;
+
+	for (map = 0; map < MAX96712_MAX_PIPE_MAPS; map++) {
+		int src, dst, mipi;
+		if (!(maps_en & BIT(map)))
+			continue;
+
+		des_read(MAX_MIPI_MAP_SRC(pipe, map), &src);
+		des_read(MAX_MIPI_MAP_DST(pipe, map), &dst);
+		des_read(MAX_MIPI_MAP_DST_PHY(pipe, map / 4), &mipi);
+
+		buf += sprintf(buf, " MAP%d: DT %02x, VC %d -> DT %02x, VC %d MIPI %d\n",
+			map,
+			src & 0x3f, (src >> 6) & 0x03, dst & 0x3f, (dst >> 6) & 0x03,
+			(mipi >> ((map % 4) * 2)) & 0x03);
+	}
+
+	des_read(MAX_VIDEO_RX0(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX0: 0x%02x\t"
+			"LCRC_ERR: %d, "
+			"LINE_CRC_SEL: %d, "
+			"LINE_CRC_EN: %d, "
+			"DIS_PKT_DET: %d\n",
+			reg,
+			reg_bits(7, 1),
+			reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+	des_read(MAX_VIDEO_RX3(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX3: 0x%02x\t"
+			"HD_TR_MODE: %d, "
+			"DLOCKED: %d, "
+			"VLOCKED: %d, "
+			"HLOCKED: %d, "
+			"DTRACKEN: %d, "
+			"VTRACKEN: %d, "
+			"HTRACKEN: %d\n",
+			reg,
+			reg_bits(6, 1),
+			reg_bits(5, 1), reg_bits(4, 1), reg_bits(3, 1),
+			reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+	des_read(MAX_VIDEO_RX8(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX8: 0x%02x\t"
+			"VID_BLK_LEN_ERR: %d, "
+			"VID_LOCK: %d, "
+			"VID_PKT_DET: %d, "
+			"VID_SEQ_ERR: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1),
+			reg_bits(5, 1), reg_bits(4, 1));
+	des_read(MAX_VIDEO_RX10(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX10: 0x%02x\t"
+			"MASK_VIDEO_DE: %d\n",
+			reg,
+			reg_bits(6, 1));
+
+out:
+	return (buf - _buf);
+}
+
+static ssize_t max_stat_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	int i;
+	char *_buf = buf;
+	int reg = 0;
+
+	/* TODO: add same for 96712 */
+	des_read(MAX96712_REG4, &reg);
+	buf += sprintf(buf,
+			"REG_REG4: 0x%02x\t"
+			"LOCK_CFG: %d\n",
+			reg, reg_bits(5, 1));
+
+	des_read(MAX_BACKTOP1(0), &reg);
+	buf += sprintf(buf,
+			"BACKTOP1: 0x%02x:\t"
+			"CSIPLL3_LOCK: %d, "
+			"CSIPLL2_LOCK: %d, "
+			"CSIPLL1_LOCK: %d, "
+			"CSIPLL0_LOCK: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1));
+
+	des_read(MAX_BACKTOP11(0), &reg);
+	buf += sprintf(buf,
+			"BACKTOP11: 0x%02x:\t"
+			"CMD_OWERFLOW4: %d, "
+			"CMD_OWERFLOW3: %d, "
+			"CMD_OWERFLOW2: %d, "
+			"CMD_OWERFLOW1: %d, "
+			"LMO_3: %d, "
+			"LMO_2: %d, "
+			"LMO_1: %d, "
+			"LMO_0: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1),
+			reg_bits(3, 1), reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+
+	for (i = 0; i < MAX96712_MAX_MIPI; i++) {
+		buf += sprintf(buf, "MIPI %d\n", i);
+		des_read(MAX_MIPI_TX2(i), &reg);
+		buf += sprintf(buf,
+				"\tMIPI_TX2: 0x%02x\n",
+				reg);
+	}
+
+	return (buf - _buf);
+}
+
+static DEVICE_ATTR(link_0, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_1, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_2, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_3, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(pipe_0, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_1, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_2, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_3, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_4, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_5, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_6, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_7, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(stat, S_IRUGO, max_stat_show, NULL);
+
+static struct attribute *max96712_attributes[] = {
+	&dev_attr_link_0.attr,
+	&dev_attr_link_1.attr,
+	&dev_attr_link_2.attr,
+	&dev_attr_link_3.attr,
+	&dev_attr_pipe_0.attr,
+	&dev_attr_pipe_1.attr,
+	&dev_attr_pipe_2.attr,
+	&dev_attr_pipe_3.attr,
+	&dev_attr_pipe_4.attr,
+	&dev_attr_pipe_5.attr,
+	&dev_attr_pipe_6.attr,
+	&dev_attr_pipe_7.attr,
+	&dev_attr_stat.attr,
+	NULL
+};
+
+static const struct attribute_group max96712_group = {
+	.attrs = max96712_attributes,
+};
+
+int max96712_debug_add(struct max96712_priv *priv)
+{
+	int ret;
+
+	ret = sysfs_create_group(&priv->client->dev.kobj,  &max96712_group);
+	if (ret < 0) {
+		dev_err(&priv->client->dev, "Sysfs registration failed\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+void max96712_debug_remove(struct max96712_priv *priv)
+{
+	sysfs_remove_group(&priv->client->dev.kobj, &max96712_group);
+}
+
+#if 1
+int max96712_patgen(struct max96712_priv *priv)
+{
+	int ret = 0;
+
+	const u32 xres = 1280;
+	const u32 yres = 800;
+	const u32 hbp = 128;
+	const u32 hfp = 80;
+	const u32 hsa = 32;
+	const u32 vbp = 17;
+	const u32 vfp = 4;
+	const u32 vsa = 3;
+
+	u32 vtotal = vfp + vsa + vbp + yres;
+	u32 htotal = xres + hfp + hbp + hsa;
+	u32 vs_high = vsa * htotal;
+	u32 vs_low = (vfp + yres + vbp) * htotal;
+	u32 v2h = (vsa + vbp) * htotal + hfp;
+	u32 hs_high = hsa;
+	u32 hs_low = xres + hfp + hbp;
+	u32 v2d = v2h + hsa + hbp;
+	u32 de_high = xres;
+	u32 de_low = hfp + hsa + hbp;
+	u32 de_cnt = yres;
+
+	/* DEBUG_EXTRA & PATGEN_CLK_SRC = 75Mhz pclk */
+	des_write(0x0009, 0x01); /* if DEBUG_EXTRA[1:0] = 2b01, PCLK Frequency is 75MHz (don't care PATGEN_CLK_SRC) */
+	des_write(0x01dc, 0x00);
+
+	des_write_n(0x1052, 3, 0);		/* vs delay */
+	des_write_n(0x1055, 3, vs_high);
+	des_write_n(0x1058, 3, vs_low);
+	des_write_n(0x105B, 3, v2h);
+	des_write_n(0x105E, 2, hs_high);
+	des_write_n(0x1060, 2, hs_low);
+	des_write_n(0x1062, 2, vtotal);		/* hs cnt */
+	des_write_n(0x1064, 3, v2d);
+	des_write_n(0x1067, 2, de_high);
+	des_write_n(0x1069, 2, de_low);
+	des_write_n(0x106B, 2, de_cnt);
+
+	des_write_n(0x106E, 3, 0xff0000);	/* color A */
+	des_write_n(0x1071, 3, 0x0000ff);	/* color B */
+
+	des_write(0x1074, 0x50);	/* chkr_rpt_a = 80 */
+	des_write(0x1075, 0x50);	/* chkr_rpt_b = 80 */
+	des_write(0x1076, 0x50);	/* chkr_alt = 80 */
+
+	des_write(0x1050, 0xe7);	/* gen_vs,gen_hs,gen_de, vtg[0:1] */
+	des_write(0x1051, 0x10);	/* patgen_mode[5:4] = 0b1,checkerboard */
+
+out:
+	return ret;
+}
+#endif
diff --git a/drivers/media/i2c/soc_camera/rtx_ov10635.c b/drivers/media/i2c/soc_camera/rtx_ov10635.c
new file mode 100644
index 000000000000..e18c6cbdb85d
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/rtx_ov10635.c
@@ -0,0 +1,703 @@
+/*
+ * OmniVision ov10635 sensor camera driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+#include "rtx_ov10635.h"
+
+#define OV10635_I2C_ADDR		0x30
+
+#define OV10635_PID_REGA		0x300a
+#define OV10635_PID_REGB		0x300b
+#define OV10635_PID			0xa635
+
+#define OV10635_MEDIA_BUS_FMT		MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov10635_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				subsampling;
+	int				fps_denominator;
+	int				init_complete;
+	u8				id[6];
+	int				dvp_order;
+	int				vsync;
+	/* serializers */
+	int				ser_addr;
+};
+
+static int dvp_order = 0;
+module_param(dvp_order, int, 0644);
+MODULE_PARM_DESC(dvp_order, " DVP bus bits order");
+
+static int vsync = 0;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 0 - not inverted)");
+
+static inline struct ov10635_priv *to_ov10635(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov10635_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov10635_priv, hdl)->sd;
+}
+
+static int ov10635_set_regs(struct i2c_client *client,
+			    const struct ov10635_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100ns */
+			if (reg16_write(client, regs[i].reg, regs[i].val))
+				printk("ov10635 reg 0x%04x write failed\n", regs[i].reg);
+		}
+	}
+
+	return 0;
+}
+
+static void ov10635_otp_id_read(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = to_ov10635(client);
+	int i;
+
+	/* read camera id from OTP memory */
+	reg16_write(client, 0x3d10, 1);
+
+	usleep_range(15000, 16000); /* wait 15ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0x3d00 + i, &priv->id[i]);
+}
+
+static int ov10635_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov10635_set_window(struct v4l2_subdev *sd, int subsampling)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	/* disable clocks */
+	reg16_write(client, 0x302e, 0x00);
+	reg16_write(client, 0x301b, 0xff);
+	reg16_write(client, 0x301c, 0xff);
+	reg16_write(client, 0x301a, 0xff);
+
+	/* setup resolution */
+	reg16_write(client, 0x3808, priv->rect.width >> 8);
+	reg16_write(client, 0x3809, priv->rect.width & 0xff);
+	reg16_write(client, 0x380a, priv->rect.height >> 8);
+	reg16_write(client, 0x380b, priv->rect.height & 0xff);
+
+	/* enable/disable subsampling */
+	reg16_write(client, 0x5005, subsampling ? 0x89 : 0x08);
+	reg16_write(client, 0x3007, subsampling ? 0x02 : 0x01);
+	reg16_write(client, 0x4004, subsampling ? 0x02 : 0x04);
+
+#if 0 /* This is implemented in VIN via SOC_CAMERA layer, hence skip */
+	/* horiz crop start */
+	reg16_write(client, 0x3800, priv->rect.left >> 8);
+	reg16_write(client, 0x3801, priv->rect.left & 0xff);
+	/* horiz crop end */
+	reg16_write(client, 0x3804, (priv->rect.left + priv->rect.width + 1) >> 8);
+	reg16_write(client, 0x3805, (priv->rect.left + priv->rect.width + 1) & 0xff);
+	/* vert crop start */
+	reg16_write(client, 0x3802, priv->rect.top >> 8);
+	reg16_write(client, 0x3803, priv->rect.top & 0xff);
+	/* vert crop end */
+	reg16_write(client, 0x3806, (priv->rect.top + priv->rect.height + 1) >> 8);
+	reg16_write(client, 0x3807, (priv->rect.top + priv->rect.height + 1) & 0xff);
+#endif
+	/* enable clocks */
+	reg16_write(client, 0x301b, 0xf0);
+	reg16_write(client, 0x301c, 0xf0);
+	reg16_write(client, 0x301a, 0xf0);
+	reg16_write(client, 0x302e, 0x01);
+
+	return 0;
+};
+
+static int ov10635_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV10635_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov10635_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV10635_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov10635_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV10635_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov10635_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV10635_PID >> 8;
+	edid->edid[9] = OV10635_PID & 0xff;
+
+	return 0;
+}
+
+static int ov10635_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int subsampling = 0;
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > OV10635_MAX_WIDTH) ||
+	    (rect->top + rect->height > OV10635_MAX_HEIGHT))
+		*rect = priv->rect;
+
+	if (rect->width == OV10635_MAX_WIDTH / 2 &&
+	    rect->height == OV10635_MAX_HEIGHT / 2)
+		subsampling = 1;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	/* change window only for subsampling, crop is done by VIN */
+	if (subsampling != priv->subsampling) {
+		ov10635_set_window(sd, subsampling);
+		priv->subsampling = subsampling;
+	}
+
+	return 0;
+}
+
+static int ov10635_get_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV10635_MAX_WIDTH;
+		sel->r.height = OV10635_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV10635_MAX_WIDTH;
+		sel->r.height = OV10635_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov10635_g_mbus_config(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+#ifdef KERNEL_5
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+#else
+	cfg->type = V4L2_MBUS_CSI2;
+#endif
+
+	return 0;
+}
+
+static int ov10635_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *ival)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	ival->interval.numerator = 1;
+	ival->interval.denominator = priv->fps_denominator;
+
+	return 0;
+}
+
+static int ov10635_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *ival)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int ret = 0;
+
+	if (priv->fps_denominator != ival->interval.denominator) {
+		switch (ival->interval.denominator) {
+		case 5:
+			ret = ov10635_set_regs(client, ov10635_regs_5fps,
+					       ARRAY_SIZE(ov10635_regs_5fps));
+			break;
+		case 10:
+			ret = ov10635_set_regs(client, ov10635_regs_10fps,
+					       ARRAY_SIZE(ov10635_regs_10fps));
+			break;
+		case 15:
+			ret = ov10635_set_regs(client, ov10635_regs_15fps,
+					       ARRAY_SIZE(ov10635_regs_15fps));
+			break;
+		case 30:
+			ret = ov10635_set_regs(client, ov10635_regs_30fps,
+					       ARRAY_SIZE(ov10635_regs_30fps));
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+
+		priv->fps_denominator = ival->interval.denominator;
+	}
+out:
+	return ret;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov10635_g_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u8);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ov10635_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	int ret;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u8);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	ret = reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov10635_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov10635_g_register,
+	.s_register = ov10635_s_register,
+#endif
+};
+
+static int ov10635_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int ret = -EINVAL;
+	u8 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		/* AEC/AGC target */
+		ret = reg16_write(client, 0xc46a, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		udelay(100);
+		ret = ov10635_set_regs(client, &ov10635_regs_contrast[ctrl->val][0], 18);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = reg16_write(client, 0xc316, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		/* CMX ? */
+		ret = 0;
+		break;
+	case V4L2_CID_GAMMA:
+		ret = reg16_write(client, 0xc4be, ctrl->val >> 8);
+		ret |= reg16_write(client, 0xc4bf, ctrl->val & 0xff);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		/* automatic gain/exposure */
+		ret = reg16_write(client, 0x56d0, !ctrl->val);
+		break;
+	case V4L2_CID_GAIN:
+		/* manual gain */
+		ret = reg16_write(client, 0x3504, 0);
+		ret |= reg16_write(client, 0x56d1, ctrl->val >> 8);
+		ret |= reg16_write(client, 0x56d2, ctrl->val & 0xff);
+		ret |= reg16_write(client, 0x3504, 1); /* validate gain */
+		break;
+	case V4L2_CID_EXPOSURE:
+		/* manual exposure */
+		ret = reg16_write(client, 0x3504, 0);
+		ret |= reg16_write(client, 0x56d5, ctrl->val >> 8);
+		ret |= reg16_write(client, 0x56d6, ctrl->val & 0xff);
+		ret |= reg16_write(client, 0x3504, 1); /* validate exposure */
+		break;
+	case V4L2_CID_HFLIP:
+		ret = reg16_read(client, 0x381d, &val);
+		if (ctrl->val)
+			val |= 0x3;
+		else
+			val &= ~0x3;
+		ret |= reg16_write(client, 0x381d, val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = reg16_read(client, 0x381c, &val);
+		if (ctrl->val)
+			val |= 0xc0;
+		else
+			val &= ~0xc0;
+		ret |= reg16_write(client, 0x381c, val);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov10635_ctrl_ops = {
+	.s_ctrl = ov10635_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov10635_video_ops = {
+	.s_stream	= ov10635_s_stream,
+	.g_mbus_config	= ov10635_g_mbus_config,
+	.g_frame_interval = ov10635_g_frame_interval,
+	.s_frame_interval = ov10635_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops ov10635_subdev_pad_ops = {
+	.get_edid	= ov10635_get_edid,
+	.enum_mbus_code	= ov10635_enum_mbus_code,
+	.get_selection	= ov10635_get_selection,
+	.set_selection	= ov10635_set_selection,
+	.get_fmt	= ov10635_get_fmt,
+	.set_fmt	= ov10635_set_fmt,
+};
+
+static struct v4l2_subdev_ops ov10635_subdev_ops = {
+	.core	= &ov10635_core_ops,
+	.video	= &ov10635_video_ops,
+	.pad	= &ov10635_subdev_pad_ops,
+};
+
+static ssize_t ov10635_otp_id_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov10635, S_IRUGO, ov10635_otp_id_show, NULL);
+
+static int ov10635_initialize(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = to_ov10635(client);
+	u8 val = 0;
+	u16 pid = 0;
+	
+	setup_i2c_translator(client, priv->ser_addr, OV10635_I2C_ADDR);
+	udelay(100);
+
+	reg16_read(client, OV10635_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV10635_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV10635_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	/* s/w reset sensor */
+	reg16_write(client, 0x103, 0x1);
+	udelay(100);
+	/* Program wizard registers */
+	ov10635_set_regs(client, ov10635_regs, ARRAY_SIZE(ov10635_regs));
+	/* Set DVP bit swap */
+	reg16_write(client, 0x4709, priv->dvp_order << 4);
+	/* Set VSYNC inversion */
+	reg16_write(client, 0x4708, priv->vsync ? 0x3 : 0x1);
+	/* Read OTP IDs */
+	ov10635_otp_id_read(client);
+
+	dev_info(&client->dev, "PID %x, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov10635_parse_dt(struct device_node *np, struct ov10635_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+	priv->ser_addr = addrs[1];
+
+	if (of_property_read_u32(np, "dvp-order", &priv->dvp_order))
+		priv->dvp_order = 0;
+	if (of_property_read_u32(np, "vsync", &priv->vsync))
+		priv->vsync = 0;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	/* module params override dts */
+	if (dvp_order)
+	{
+		priv->dvp_order = dvp_order;
+	}
+	if (vsync)
+		priv->vsync = vsync;
+
+	return 0;
+}
+
+static int ov10635_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct ov10635_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov10635_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = OV10635_MAX_WIDTH;
+	priv->rect.height = OV10635_MAX_HEIGHT;
+	priv->fps_denominator = 30;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x30);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 4, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 0xff, 1, 0xff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_HUE, 0, 255, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_GAMMA, 0, 0xffff, 1, 0x233);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0x3ff, 1, 0x10);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, 0x80);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov10635_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+	ret = ov10635_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov10635) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+	priv->init_complete = 1;
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov10635_remove(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov10635);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov10635_id[] = {
+	{ "ov10635", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov10635_id);
+
+static const struct of_device_id ov10635_of_ids[] = {
+	{ .compatible = "ovti,ov10635", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov10635_of_ids);
+
+static struct i2c_driver ov10635_i2c_driver = {
+	.driver	= {
+		.name		= "ov10635",
+		.of_match_table	= ov10635_of_ids,
+	},
+	.probe		= ov10635_probe,
+	.remove		= ov10635_remove,
+	.id_table	= ov10635_id,
+};
+
+module_i2c_driver(ov10635_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV10635");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/soc_camera/rtx_ov10635.h b/drivers/media/i2c/soc_camera/rtx_ov10635.h
new file mode 100644
index 000000000000..03346b85b802
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/rtx_ov10635.h
@@ -0,0 +1,1143 @@
+/*
+ * OmniVision ov10635 sensor camera setup 1280x800@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV10635_DISPLAY_PATTERN
+
+#define OV10635_SENSOR_WIDTH		1312
+#define OV10635_SENSOR_HEIGHT		814
+
+#define OV10635_MAX_WIDTH		1280
+#define OV10635_MAX_HEIGHT		800
+
+#define OV10635_PCLK_96MHZ
+//#define OV10635_PCLK_88MHZ
+
+#if defined(OV10635_PCLK_96MHZ)
+/* VTS=PCLK/FPS/HTS/2 (=96MHz/30/1750/2) */
+ #define OV10635_HTS			1750
+ #define OV10635_VTS			914 /* fps=30 */
+#elif defined(OV10635_PCLK_88MHZ)
+/* VTS=PCLK/FPS/HTS/2 (=88MHz/1572/30/2) */
+ #define OV10635_HTS			1572
+ #define OV10635_VTS			933 /* fps=29.9998 */
+#else
+ #error PCLK not defined
+#endif
+
+struct ov10635_reg {
+	u16	reg;
+	u8	val;
+};
+
+static const struct ov10635_reg ov10635_regs[] = {
+//{0x0103, 0x01},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x301B, 0xFF},
+{0x301C, 0xFF},
+{0x301A, 0xFF},
+{0x3011, 0x42},
+{0x6900, 0x0C},
+{0x6901, 0x19},
+{0x3503, 0x10},
+{0x3025, 0x03},
+#if defined(OV10635_PCLK_96MHZ)
+{0x3003, 0x20},
+{0x3004, 0x21},
+#elif defined(OV10635_PCLK_88MHZ)
+{0x3003, 0x16},
+{0x3004, 0x30},
+#endif
+{0x3005, 0x40},
+{0x3006, 0x91},
+{0x3600, 0x74},
+{0x3601, 0x2B},
+{0x3612, 0x00},
+{0x3611, 0x67},
+{0x3633, 0xCA},
+{0x3602, 0xAF},
+{0x3603, 0x04},
+{0x3630, 0x28},
+{0x3631, 0x16},
+{0x3714, 0x10},
+{0x371D, 0x01},
+{0x4300, 0x3A},
+{0x3007, 0x01},
+{0x3024, 0x03},
+{0x3020, 0x0A},
+{0x3702, 0x0D},
+{0x3703, 0x20},
+{0x3704, 0x15},
+{0x3709, 0xA8},
+{0x370C, 0xC7},
+{0x370D, 0x80},
+{0x3712, 0x00},
+{0x3713, 0x20},
+{0x3715, 0x04},
+{0x381D, 0x40},
+{0x381C, 0x00},
+{0x3822, 0x50},
+{0x3824, 0x10},
+{0x3815, 0x8C},
+{0x3804, 0x05},
+{0x3805, 0x1F},
+{0x3800, 0x00},
+{0x3801, 0x00},
+{0x3806, 0x03},
+{0x3807, 0x28},
+{0x3802, 0x00},
+{0x3803, 0x07},
+{0x3808, 0x05},
+{0x3809, 0x00},
+{0x380A, 0x03},
+{0x380B, 0x20},
+{0x380C, OV10635_HTS >> 8},
+{0x380D, OV10635_HTS & 0xff},
+{0x380E, OV10635_VTS >> 8},
+{0x380F, OV10635_VTS & 0xff},
+{0x3813, 0x02},
+{0x3811, 0x08},
+{0x381F, 0x0C},
+{0x3819, 0x04},
+{0x3804, 0x01},
+{0x3805, 0x00},
+{0x3828, 0x03},
+{0x3829, 0x10},
+{0x382A, 0x10},
+{0x3621, 0x63},
+{0x5005, 0x08},
+{0x56D5, 0x00},
+{0x56D6, 0x80},
+{0x56D7, 0x00},
+{0x56D8, 0x00},
+{0x56D9, 0x00},
+{0x56DA, 0x80},
+{0x56DB, 0x00},
+{0x56DC, 0x00},
+{0x56E8, 0x00},
+{0x56E9, 0x7F},
+{0x56EA, 0x00},
+{0x56EB, 0x7F},
+{0x5100, 0x00},
+{0x5101, 0x80},
+{0x5102, 0x00},
+{0x5103, 0x80},
+{0x5104, 0x00},
+{0x5105, 0x80},
+{0x5106, 0x00},
+{0x5107, 0x80},
+{0x5108, 0x00},
+{0x5109, 0x00},
+{0x510A, 0x00},
+{0x510B, 0x00},
+{0x510C, 0x00},
+{0x510D, 0x00},
+{0x510E, 0x00},
+{0x510F, 0x00},
+{0x5110, 0x00},
+{0x5111, 0x80},
+{0x5112, 0x00},
+{0x5113, 0x80},
+{0x5114, 0x00},
+{0x5115, 0x80},
+{0x5116, 0x00},
+{0x5117, 0x80},
+{0x5118, 0x00},
+{0x5119, 0x00},
+{0x511A, 0x00},
+{0x511B, 0x00},
+{0x511C, 0x00},
+{0x511D, 0x00},
+{0x511E, 0x00},
+{0x511F, 0x00},
+{0x56D0, 0x00},
+{0x5006, 0x04},
+{0x5608, 0x05},
+{0x52D7, 0x06},
+{0x528D, 0x08},
+{0x5293, 0x12},
+{0x52D3, 0x12},
+{0x5288, 0x06},
+{0x5289, 0x20},
+{0x52C8, 0x06},
+{0x52C9, 0x20},
+{0x52CD, 0x04},
+{0x5381, 0x00},
+{0x5382, 0xFF},
+{0x5589, 0x76},
+{0x558A, 0x47},
+{0x558B, 0xEF},
+{0x558C, 0xC9},
+{0x558D, 0x49},
+{0x558E, 0x30},
+{0x558F, 0x67},
+{0x5590, 0x3F},
+{0x5591, 0xF0},
+{0x5592, 0x10},
+{0x55A2, 0x6D},
+{0x55A3, 0x55},
+{0x55A4, 0xC3},
+{0x55A5, 0xB5},
+{0x55A6, 0x43},
+{0x55A7, 0x38},
+{0x55A8, 0x5F},
+{0x55A9, 0x4B},
+{0x55AA, 0xF0},
+{0x55AB, 0x10},
+{0x5581, 0x52},
+{0x5300, 0x01},
+{0x5301, 0x00},
+{0x5302, 0x00},
+{0x5303, 0x0E},
+{0x5304, 0x00},
+{0x5305, 0x0E},
+{0x5306, 0x00},
+{0x5307, 0x36},
+{0x5308, 0x00},
+{0x5309, 0xD9},
+{0x530A, 0x00},
+{0x530B, 0x0F},
+{0x530C, 0x00},
+{0x530D, 0x2C},
+{0x530E, 0x00},
+{0x530F, 0x59},
+{0x5310, 0x00},
+{0x5311, 0x7B},
+{0x5312, 0x00},
+{0x5313, 0x22},
+{0x5314, 0x00},
+{0x5315, 0xD5},
+{0x5316, 0x00},
+{0x5317, 0x13},
+{0x5318, 0x00},
+{0x5319, 0x18},
+{0x531A, 0x00},
+{0x531B, 0x26},
+{0x531C, 0x00},
+{0x531D, 0xDC},
+{0x531E, 0x00},
+{0x531F, 0x02},
+{0x5320, 0x00},
+{0x5321, 0x24},
+{0x5322, 0x00},
+{0x5323, 0x56},
+{0x5324, 0x00},
+{0x5325, 0x85},
+{0x5326, 0x00},
+{0x5327, 0x20},
+{0x5609, 0x01},
+{0x560A, 0x40},
+{0x560B, 0x01},
+{0x560C, 0x40},
+{0x560D, 0x00},
+{0x560E, 0xFA},
+{0x560F, 0x00},
+{0x5610, 0xFA},
+{0x5611, 0x02},
+{0x5612, 0x80},
+{0x5613, 0x02},
+{0x5614, 0x80},
+{0x5615, 0x01},
+{0x5616, 0x2C},
+{0x5617, 0x01},
+{0x5618, 0x2C},
+{0x563B, 0x01},
+{0x563C, 0x01},
+{0x563D, 0x01},
+{0x563E, 0x01},
+{0x563F, 0x03},
+{0x5640, 0x03},
+{0x5641, 0x03},
+{0x5642, 0x05},
+{0x5643, 0x09},
+{0x5644, 0x05},
+{0x5645, 0x05},
+{0x5646, 0x05},
+{0x5647, 0x05},
+{0x5651, 0x00},
+{0x5652, 0x80},
+{0x521A, 0x01},
+{0x521B, 0x03},
+{0x521C, 0x06},
+{0x521D, 0x0A},
+{0x521E, 0x0E},
+{0x521F, 0x12},
+{0x5220, 0x16},
+{0x5223, 0x02},
+{0x5225, 0x04},
+{0x5227, 0x08},
+{0x5229, 0x0C},
+{0x522B, 0x12},
+{0x522D, 0x18},
+{0x522F, 0x1E},
+{0x5241, 0x04},
+{0x5242, 0x01},
+{0x5243, 0x03},
+{0x5244, 0x06},
+{0x5245, 0x0A},
+{0x5246, 0x0E},
+{0x5247, 0x12},
+{0x5248, 0x16},
+{0x524A, 0x03},
+{0x524C, 0x04},
+{0x524E, 0x08},
+{0x5250, 0x0C},
+{0x5252, 0x12},
+{0x5254, 0x18},
+{0x5256, 0x1E},
+{0x4606, (2*OV10635_HTS) >> 8}, /* fifo_line_length = 2*hts */
+{0x4607, (2*OV10635_HTS) & 0xff},
+{0x460a, (2*(OV10635_HTS-OV10635_MAX_WIDTH)) >> 8}, /* fifo_hsync_start = 2*(hts - xres) */
+{0x460b, (2*(OV10635_HTS-OV10635_MAX_WIDTH)) & 0xff },
+{0x460C, 0x00},
+{0x4620, 0x0E},
+#if 0
+{0x4700, 0x02}, // BT656: mode is acceptable but artefact lines on left/bottom due to BT656 SAV/EAV are parsed as image data
+#else
+{0x4700, 0x04}, // BT601: 0x08 is also accaptable as HS/VS mode
+#endif
+{0x4701, 0x00},
+{0x4702, 0x01},
+{0x4004, 0x04},
+{0x4005, 0x18},
+{0x4001, 0x06},
+{0x4050, 0x22},
+{0x4051, 0x24},
+{0x4052, 0x02},
+{0x4057, 0x9C},
+{0x405A, 0x00},
+{0x4202, 0x02},
+{0x3023, 0x10},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x6F10, 0x07},
+{0x6F11, 0x82},
+{0x6F12, 0x04},
+{0x6F13, 0x00},
+{0xD000, 0x19},
+{0xD001, 0xA0},
+{0xD002, 0x00},
+{0xD003, 0x01},
+{0xD004, 0xA9},
+{0xD005, 0xAD},
+{0xD006, 0x10},
+{0xD007, 0x40},
+{0xD008, 0x44},
+{0xD009, 0x00},
+{0xD00A, 0x68},
+{0xD00B, 0x00},
+{0xD00C, 0x15},
+{0xD00D, 0x00},
+{0xD00E, 0x00},
+{0xD00F, 0x00},
+{0xD040, 0x9C},
+{0xD041, 0x21},
+{0xD042, 0xFF},
+{0xD043, 0xF8},
+{0xD044, 0xD4},
+{0xD045, 0x01},
+{0xD046, 0x48},
+{0xD047, 0x00},
+{0xD048, 0xD4},
+{0xD049, 0x01},
+{0xD04A, 0x50},
+{0xD04B, 0x04},
+{0xD04C, 0x18},
+{0xD04D, 0x60},
+{0xD04E, 0x00},
+{0xD04F, 0x01},
+{0xD050, 0xA8},
+{0xD051, 0x63},
+{0xD052, 0x02},
+{0xD053, 0xA4},
+{0xD054, 0x85},
+{0xD055, 0x43},
+{0xD056, 0x00},
+{0xD057, 0x00},
+{0xD058, 0x18},
+{0xD059, 0x60},
+{0xD05A, 0x00},
+{0xD05B, 0x01},
+{0xD05C, 0xA8},
+{0xD05D, 0x63},
+{0xD05E, 0x03},
+{0xD05F, 0xF0},
+{0xD060, 0x98},
+{0xD061, 0xA3},
+{0xD062, 0x00},
+{0xD063, 0x00},
+{0xD064, 0x8C},
+{0xD065, 0x6A},
+{0xD066, 0x00},
+{0xD067, 0x6E},
+{0xD068, 0xE5},
+{0xD069, 0x85},
+{0xD06A, 0x18},
+{0xD06B, 0x00},
+{0xD06C, 0x10},
+{0xD06D, 0x00},
+{0xD06E, 0x00},
+{0xD06F, 0x10},
+{0xD070, 0x9C},
+{0xD071, 0x80},
+{0xD072, 0x00},
+{0xD073, 0x03},
+{0xD074, 0x18},
+{0xD075, 0x60},
+{0xD076, 0x00},
+{0xD077, 0x01},
+{0xD078, 0xA8},
+{0xD079, 0x63},
+{0xD07A, 0x07},
+{0xD07B, 0x80},
+{0xD07C, 0x07},
+{0xD07D, 0xFF},
+{0xD07E, 0xF9},
+{0xD07F, 0x03},
+{0xD080, 0x8C},
+{0xD081, 0x63},
+{0xD082, 0x00},
+{0xD083, 0x00},
+{0xD084, 0xA5},
+{0xD085, 0x6B},
+{0xD086, 0x00},
+{0xD087, 0xFF},
+{0xD088, 0x18},
+{0xD089, 0x80},
+{0xD08A, 0x00},
+{0xD08B, 0x01},
+{0xD08C, 0xA8},
+{0xD08D, 0x84},
+{0xD08E, 0x01},
+{0xD08F, 0x04},
+{0xD090, 0xE1},
+{0xD091, 0x6B},
+{0xD092, 0x58},
+{0xD093, 0x00},
+{0xD094, 0x94},
+{0xD095, 0x6A},
+{0xD096, 0x00},
+{0xD097, 0x70},
+{0xD098, 0xE1},
+{0xD099, 0x6B},
+{0xD09A, 0x20},
+{0xD09B, 0x00},
+{0xD09C, 0x95},
+{0xD09D, 0x6B},
+{0xD09E, 0x00},
+{0xD09F, 0x00},
+{0xD0A0, 0xE4},
+{0xD0A1, 0x8B},
+{0xD0A2, 0x18},
+{0xD0A3, 0x00},
+{0xD0A4, 0x0C},
+{0xD0A5, 0x00},
+{0xD0A6, 0x00},
+{0xD0A7, 0x23},
+{0xD0A8, 0x15},
+{0xD0A9, 0x00},
+{0xD0AA, 0x00},
+{0xD0AB, 0x00},
+{0xD0AC, 0x18},
+{0xD0AD, 0x60},
+{0xD0AE, 0x80},
+{0xD0AF, 0x06},
+{0xD0B0, 0xA8},
+{0xD0B1, 0x83},
+{0xD0B2, 0x40},
+{0xD0B3, 0x08},
+{0xD0B4, 0xA8},
+{0xD0B5, 0xE3},
+{0xD0B6, 0x38},
+{0xD0B7, 0x2A},
+{0xD0B8, 0xA8},
+{0xD0B9, 0xC3},
+{0xD0BA, 0x40},
+{0xD0BB, 0x09},
+{0xD0BC, 0xA8},
+{0xD0BD, 0xA3},
+{0xD0BE, 0x38},
+{0xD0BF, 0x29},
+{0xD0C0, 0x8C},
+{0xD0C1, 0x65},
+{0xD0C2, 0x00},
+{0xD0C3, 0x00},
+{0xD0C4, 0xD8},
+{0xD0C5, 0x04},
+{0xD0C6, 0x18},
+{0xD0C7, 0x00},
+{0xD0C8, 0x8C},
+{0xD0C9, 0x67},
+{0xD0CA, 0x00},
+{0xD0CB, 0x00},
+{0xD0CC, 0xD8},
+{0xD0CD, 0x06},
+{0xD0CE, 0x18},
+{0xD0CF, 0x00},
+{0xD0D0, 0x18},
+{0xD0D1, 0x60},
+{0xD0D2, 0x80},
+{0xD0D3, 0x06},
+{0xD0D4, 0xA8},
+{0xD0D5, 0xE3},
+{0xD0D6, 0x67},
+{0xD0D7, 0x02},
+{0xD0D8, 0xA9},
+{0xD0D9, 0x03},
+{0xD0DA, 0x67},
+{0xD0DB, 0x03},
+{0xD0DC, 0xA8},
+{0xD0DD, 0xC3},
+{0xD0DE, 0x3D},
+{0xD0DF, 0x05},
+{0xD0E0, 0x8C},
+{0xD0E1, 0x66},
+{0xD0E2, 0x00},
+{0xD0E3, 0x00},
+{0xD0E4, 0xB8},
+{0xD0E5, 0x63},
+{0xD0E6, 0x00},
+{0xD0E7, 0x18},
+{0xD0E8, 0xB8},
+{0xD0E9, 0x63},
+{0xD0EA, 0x00},
+{0xD0EB, 0x98},
+{0xD0EC, 0xBC},
+{0xD0ED, 0x03},
+{0xD0EE, 0x00},
+{0xD0EF, 0x00},
+{0xD0F0, 0x10},
+{0xD0F1, 0x00},
+{0xD0F2, 0x00},
+{0xD0F3, 0x16},
+{0xD0F4, 0xB8},
+{0xD0F5, 0x83},
+{0xD0F6, 0x00},
+{0xD0F7, 0x19},
+{0xD0F8, 0x8C},
+{0xD0F9, 0x67},
+{0xD0FA, 0x00},
+{0xD0FB, 0x00},
+{0xD0FC, 0xB8},
+{0xD0FD, 0xA4},
+{0xD0FE, 0x00},
+{0xD0FF, 0x98},
+{0xD100, 0xB8},
+{0xD101, 0x83},
+{0xD102, 0x00},
+{0xD103, 0x08},
+{0xD104, 0x8C},
+{0xD105, 0x68},
+{0xD106, 0x00},
+{0xD107, 0x00},
+{0xD108, 0xE0},
+{0xD109, 0x63},
+{0xD10A, 0x20},
+{0xD10B, 0x04},
+{0xD10C, 0xE0},
+{0xD10D, 0x65},
+{0xD10E, 0x18},
+{0xD10F, 0x00},
+{0xD110, 0xA4},
+{0xD111, 0x83},
+{0xD112, 0xFF},
+{0xD113, 0xFF},
+{0xD114, 0xB8},
+{0xD115, 0x64},
+{0xD116, 0x00},
+{0xD117, 0x48},
+{0xD118, 0xD8},
+{0xD119, 0x07},
+{0xD11A, 0x18},
+{0xD11B, 0x00},
+{0xD11C, 0xD8},
+{0xD11D, 0x08},
+{0xD11E, 0x20},
+{0xD11F, 0x00},
+{0xD120, 0x9C},
+{0xD121, 0x60},
+{0xD122, 0x00},
+{0xD123, 0x00},
+{0xD124, 0xD8},
+{0xD125, 0x06},
+{0xD126, 0x18},
+{0xD127, 0x00},
+{0xD128, 0x00},
+{0xD129, 0x00},
+{0xD12A, 0x00},
+{0xD12B, 0x08},
+{0xD12C, 0x15},
+{0xD12D, 0x00},
+{0xD12E, 0x00},
+{0xD12F, 0x00},
+{0xD130, 0x8C},
+{0xD131, 0x6A},
+{0xD132, 0x00},
+{0xD133, 0x76},
+{0xD134, 0xBC},
+{0xD135, 0x23},
+{0xD136, 0x00},
+{0xD137, 0x00},
+{0xD138, 0x13},
+{0xD139, 0xFF},
+{0xD13A, 0xFF},
+{0xD13B, 0xE6},
+{0xD13C, 0x18},
+{0xD13D, 0x60},
+{0xD13E, 0x80},
+{0xD13F, 0x06},
+{0xD140, 0x03},
+{0xD141, 0xFF},
+{0xD142, 0xFF},
+{0xD143, 0xDD},
+{0xD144, 0xA8},
+{0xD145, 0x83},
+{0xD146, 0x40},
+{0xD147, 0x08},
+{0xD148, 0x85},
+{0xD149, 0x21},
+{0xD14A, 0x00},
+{0xD14B, 0x00},
+{0xD14C, 0x85},
+{0xD14D, 0x41},
+{0xD14E, 0x00},
+{0xD14F, 0x04},
+{0xD150, 0x44},
+{0xD151, 0x00},
+{0xD152, 0x48},
+{0xD153, 0x00},
+{0xD154, 0x9C},
+{0xD155, 0x21},
+{0xD156, 0x00},
+{0xD157, 0x08},
+{0x6F0E, 0x03},
+{0x6F0F, 0x00},
+{0x460E, 0x08},
+{0x460F, 0x01},
+{0x4610, 0x00},
+{0x4611, 0x01},
+{0x4612, 0x00},
+{0x4613, 0x01},
+{0x4605, 0x08}, // 8bit
+//{0x4709, 0x10}, // swap data bits order [9:0] -> [0:9]
+{0x4608, 0x00},
+{0x4609, 0x08},
+{0x6804, 0x00},
+{0x6805, 0x06},
+{0x6806, 0x00},
+{0x5120, 0x00},
+{0x3510, 0x00},
+{0x3504, 0x00},
+{0x6800, 0x00},
+{0x6F0D, 0x01},
+{0x4708, 0x01}, // PCLK rising edge, VSYNC active low
+{0x5000, 0xFF},
+{0x5001, 0xBF},
+{0x5002, 0x7E},
+#ifdef OV10635_DISPLAY_PATTERN
+{0x503d, 0x80},
+#else
+{0x503D, 0x00},
+#endif
+{0xC450, 0x01}, /* AA mode */
+{0xC452, 0x04},
+{0xC453, 0x00},
+{0xC454, 0x00},
+{0xC455, 0x01},
+{0xC456, 0x01},
+{0xC457, 0x00},
+{0xC458, 0x00},
+{0xC459, 0x00},
+{0xC45B, 0x00},
+{0xC45C, 0x01},
+{0xC45D, 0x00},
+{0xC45E, 0x00},
+{0xC45F, 0x00},
+{0xC460, 0x00},
+{0xC461, 0x01},
+{0xC462, 0x01},
+{0xC464, 0x03},
+{0xC465, 0x00},
+{0xC466, 0x8A},
+{0xC467, 0x00},
+{0xC468, 0x86},
+{0xC469, 0x00},
+{0xC46A, 0x30},
+{0xC46B, 0x50},
+{0xC46C, 0x30},
+{0xC46D, 0x28},
+{0xC46E, 0x60},
+{0xC46F, 0x40},
+{0xC47C, 0x01},
+{0xC47D, 0x38},
+{0xC47E, 0x00},
+{0xC47F, 0x00},
+{0xC480, 0x00},
+{0xC481, 0xFF},
+{0xC482, 0x00},
+{0xC483, 0x40},
+{0xC484, 0x00},
+{0xC485, 0x18},
+{0xC486, 0x00},
+{0xC487, 0x18},
+{0xC488, (OV10635_VTS-8)*16 >> 8},
+{0xC489, (OV10635_VTS-8)*16 & 0xff},
+{0xC48A, (OV10635_VTS-8)*16 >> 8},
+{0xC48B, (OV10635_VTS-8)*16 & 0xff},
+{0xC48C, 0x00},
+{0xC48D, 0x04},
+{0xC48E, 0x00},
+{0xC48F, 0x04},
+{0xC490, 0x03},
+{0xC492, 0x20},
+{0xC493, 0x08},
+{0xC498, 0x02},
+{0xC499, 0x00},
+{0xC49A, 0x02},
+{0xC49B, 0x00},
+{0xC49C, 0x02},
+{0xC49D, 0x00},
+{0xC49E, 0x02},
+{0xC49F, 0x60},
+{0xC4A0, 0x03},
+{0xC4A1, 0x00},
+{0xC4A2, 0x04},
+{0xC4A3, 0x00},
+{0xC4A4, 0x00},
+{0xC4A5, 0x10},
+{0xC4A6, 0x00},
+{0xC4A7, 0x40},
+{0xC4A8, 0x00},
+{0xC4A9, 0x80},
+{0xC4AA, 0x0D},
+{0xC4AB, 0x00},
+{0xC4AC, 0x0F},
+{0xC4AD, 0xC0},
+{0xC4B4, 0x01},
+{0xC4B5, 0x01},
+{0xC4B6, 0x00},
+{0xC4B7, 0x01},
+{0xC4B8, 0x00},
+{0xC4B9, 0x01},
+{0xC4BA, 0x01},
+{0xC4BB, 0x00},
+{0xC4BC, 0x01},
+{0xC4BD, 0x60},
+{0xC4BE, 0x02},
+{0xC4BF, 0x33},
+{0xC4C8, 0x03},
+{0xC4C9, 0xD0},
+{0xC4CA, 0x0E},
+{0xC4CB, 0x00},
+{0xC4CC, 0x0E},
+{0xC4CD, 0x51},
+{0xC4CE, 0x0E},
+{0xC4CF, 0x51},
+{0xC4D0, 0x04},
+{0xC4D1, 0x80},
+{0xC4E0, 0x04},
+{0xC4E1, 0x02},
+{0xC4E2, 0x01},
+{0xC4E4, 0x10},
+{0xC4E5, 0x20},
+{0xC4E6, 0x30},
+{0xC4E7, 0x40},
+{0xC4E8, 0x50},
+{0xC4E9, 0x60},
+{0xC4EA, 0x70},
+{0xC4EB, 0x80},
+{0xC4EC, 0x90},
+{0xC4ED, 0xA0},
+{0xC4EE, 0xB0},
+{0xC4EF, 0xC0},
+{0xC4F0, 0xD0},
+{0xC4F1, 0xE0},
+{0xC4F2, 0xF0},
+{0xC4F3, 0x80},
+{0xC4F4, 0x00},
+{0xC4F5, 0x20},
+{0xC4F6, 0x02},
+{0xC4F7, 0x00},
+{0xC4F8, 0x00},
+{0xC4F9, 0x00},
+{0xC4FA, 0x00},
+{0xC4FB, 0x01},
+{0xC4FC, 0x01},
+{0xC4FD, 0x00},
+{0xC4FE, 0x04},
+{0xC4FF, 0x02},
+{0xC500, 0x48},
+{0xC501, 0x74},
+{0xC502, 0x58},
+{0xC503, 0x80},
+{0xC504, 0x05},
+{0xC505, 0x80},
+{0xC506, 0x03},
+{0xC507, 0x80},
+{0xC508, 0x01},
+{0xC509, 0xC0},
+{0xC50A, 0x01},
+{0xC50B, 0xA0},
+{0xC50C, 0x01},
+{0xC50D, 0x2C},
+{0xC50E, 0x01},
+{0xC50F, 0x0A},
+{0xC510, 0x00},
+{0xC511, 0x00},
+{0xC512, 0xE5},
+{0xC513, 0x14},
+{0xC514, 0x04},
+{0xC515, 0x00},
+{0xC518, OV10635_VTS >> 8},
+{0xC519, OV10635_VTS & 0xff},
+{0xC51A, OV10635_HTS >> 8},
+{0xC51B, OV10635_HTS & 0xff},
+{0xC2E0, 0x00},
+{0xC2E1, 0x51},
+{0xC2E2, 0x00},
+{0xC2E3, 0xD6},
+{0xC2E4, 0x01},
+{0xC2E5, 0x5E},
+{0xC2E9, 0x01},
+{0xC2EA, 0x7A},
+{0xC2EB, 0x90},
+{0xC2ED, 0x00},
+{0xC2EE, 0x7A},
+{0xC2EF, 0x64},
+{0xC308, 0x00},
+{0xC309, 0x00},
+{0xC30A, 0x00},
+{0xC30C, 0x00},
+{0xC30D, 0x01},
+{0xC30E, 0x00},
+{0xC30F, 0x00},
+{0xC310, 0x01},
+{0xC311, 0x60},
+{0xC312, 0xFF},
+{0xC313, 0x08},
+{0xC314, 0x01},
+{0xC315, 0x00}, /* min saturation gain */
+{0xC316, 0xFF}, /* max saturation gain */
+{0xC317, 0x0B},
+{0xC318, 0x00},
+{0xC319, 0x0C},
+{0xC31A, 0x00},
+{0xC31B, 0xE0},
+{0xC31C, 0x00},
+{0xC31D, 0x14},
+{0xC31E, 0x00},
+{0xC31F, 0xC5},
+{0xC320, 0xFF},
+{0xC321, 0x4B},
+{0xC322, 0xFF},
+{0xC323, 0xF0},
+{0xC324, 0xFF},
+{0xC325, 0xE8},
+{0xC326, 0x00},
+{0xC327, 0x46},
+{0xC328, 0xFF},
+{0xC329, 0xD2},
+{0xC32A, 0xFF},
+{0xC32B, 0xE4},
+{0xC32C, 0xFF},
+{0xC32D, 0xBB},
+{0xC32E, 0x00},
+{0xC32F, 0x61},
+{0xC330, 0xFF},
+{0xC331, 0xF9},
+{0xC332, 0x00},
+{0xC333, 0xD9},
+{0xC334, 0x00},
+{0xC335, 0x2E},
+{0xC336, 0x00},
+{0xC337, 0xB1},
+{0xC338, 0xFF},
+{0xC339, 0x64},
+{0xC33A, 0xFF},
+{0xC33B, 0xEB},
+{0xC33C, 0xFF},
+{0xC33D, 0xE8},
+{0xC33E, 0x00},
+{0xC33F, 0x48},
+{0xC340, 0xFF},
+{0xC341, 0xD0},
+{0xC342, 0xFF},
+{0xC343, 0xED},
+{0xC344, 0xFF},
+{0xC345, 0xAD},
+{0xC346, 0x00},
+{0xC347, 0x66},
+{0xC348, 0x01},
+{0xC349, 0x00},
+{0x6700, 0x04},
+{0x6701, 0x7B},
+{0x6702, 0xFD},
+{0x6703, 0xF9},
+{0x6704, 0x3D},
+{0x6705, 0x71},
+{0x6706, 0x78},
+{0x6708, 0x05},
+{0x6F06, 0x6F},
+{0x6F07, 0x00},
+{0x6F0A, 0x6F},
+{0x6F0B, 0x00},
+{0x6F00, 0x03},
+{0xC34C, 0x01},
+{0xC34D, 0x00},
+{0xC34E, 0x46},
+{0xC34F, 0x55},
+{0xC350, 0x00},
+{0xC351, 0x40},
+{0xC352, 0x00},
+{0xC353, 0xFF},
+{0xC354, 0x04},
+{0xC355, 0x08},
+{0xC356, 0x01},
+{0xC357, 0xEF},
+{0xC358, 0x30},
+{0xC359, 0x01},
+{0xC35A, 0x64},
+{0xC35B, 0x46},
+{0xC35C, 0x00},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0xC261, 0x01},
+{0x301B, 0xF0},
+{0x301C, 0xF0},
+{0x301A, 0xF0},
+{0x6F00, 0xC3},
+{0xC46A, 0x30},
+{0xC46D, 0x20},
+{0xC464, 0x84},
+{0xC465, 0x00},
+{0x6F00, 0x03},
+{0x6F00, 0x43},
+{0x381C, 0x00},
+{0x381D, 0x40},
+{0xC454, 0x01},
+{0x6F00, 0xC3},
+{0xC454, 0x00},
+{0xC4B1, 0x02},
+{0xC4B2, 0x01},
+{0xC4B3, 0x03},
+{0x6F00, 0x03},
+{0x6F00, 0x43},
+/* enable FSIN (FRAMESYNC input) functionality */
+{0x3832, (0x0d+2*0x20+0x15+38) >> 8},
+{0x3833, (0x0d+2*0x20+0x15+38) & 0xff},
+{0x3834, OV10635_VTS >> 8},
+{0x3835, OV10635_VTS & 0xff},
+{0x302E, 0x01},
+};
+
+static const struct ov10635_reg ov10635_regs_30fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+1)=96Mhz, 30fps */
+{0x3003, 0x20},
+{0x3004, 0x21},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_15fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+3)=48Mhz, 15fps */
+{0x3003, 0x20},
+{0x3004, 0x23},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_10fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+5)=32Mhz, 10fps */
+{0x3003, 0x20},
+{0x3004, 0x25},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_5fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/4*32/2(1+5)=96Mhz, 5fps */
+{0x3003, 0x20},
+{0x3004, 0x45},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_contrast[5][18] = {
+{
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x20},
+	{0xc4e5, 0x40},
+	{0xc4e6, 0x60},
+	{0xc4e7, 0x80},
+	{0xc4e8, 0xa0},
+	{0xc4e9, 0xb4},
+	{0xc4ea, 0xc0},
+	{0xc4eb, 0xcb},
+	{0xc4ec, 0xd5},
+	{0xc4ed, 0xde},
+	{0xc4ee, 0xe6},
+	{0xc4ef, 0xed},
+	{0xc4f0, 0xf3},
+	{0xc4f1, 0xf8},
+	{0xc4f2, 0xfc},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x18},
+	{0xc4e5, 0x30},
+	{0xc4e6, 0x48},
+	{0xc4e7, 0x60},
+	{0xc4e8, 0x78},
+	{0xc4e9, 0x90},
+	{0xc4ea, 0xa4},
+	{0xc4eb, 0xb4},
+	{0xc4ec, 0xc2},
+	{0xc4ed, 0xcf},
+	{0xc4ee, 0xdb},
+	{0xc4ef, 0xe5},
+	{0xc4f0, 0xee},
+	{0xc4f1, 0xf6},
+	{0xc4f2, 0xfc},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x10},
+	{0xc4e5, 0x20},
+	{0xc4e6, 0x30},
+	{0xc4e7, 0x40},
+	{0xc4e8, 0x50},
+	{0xc4e9, 0x60},
+	{0xc4ea, 0x70},
+	{0xc4eb, 0x80},
+	{0xc4ec, 0x90},
+	{0xc4ed, 0xa0},
+	{0xc4ee, 0xb0},
+	{0xc4ef, 0xc0},
+	{0xc4f0, 0xd0},
+	{0xc4f1, 0xe0},
+	{0xc4f2, 0xf0},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x0c},
+	{0xc4e5, 0x18},
+	{0xc4e6, 0x24},
+	{0xc4e7, 0x30},
+	{0xc4e8, 0x3c},
+	{0xc4e9, 0x48},
+	{0xc4ea, 0x54},
+	{0xc4eb, 0x62},
+	{0xc4ec, 0x72},
+	{0xc4ed, 0x84},
+	{0xc4ee, 0x94},
+	{0xc4ef, 0xa6},
+	{0xc4f0, 0xb9},
+	{0xc4f1, 0xcd},
+	{0xc4f2, 0xe2},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x06},
+	{0xc4e5, 0x0d},
+	{0xc4e6, 0x15},
+	{0xc4e7, 0x1e},
+	{0xc4e8, 0x28},
+	{0xc4e9, 0x32},
+	{0xc4ea, 0x3c},
+	{0xc4eb, 0x48},
+	{0xc4ec, 0x56},
+	{0xc4ed, 0x66},
+	{0xc4ee, 0x78},
+	{0xc4ef, 0x8c},
+	{0xc4f0, 0xa2},
+	{0xc4f1, 0xba},
+	{0xc4f2, 0xd4},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}
+};
diff --git a/drivers/media/i2c/soc_camera/rtx_ov10635_debug.h b/drivers/media/i2c/soc_camera/rtx_ov10635_debug.h
new file mode 100644
index 000000000000..4c3515a64e88
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/rtx_ov10635_debug.h
@@ -0,0 +1,54 @@
+
+#if 0
+{0x4700, 0x02}, // BT656
+{0x381d, 0x40}, // mirror off
+{0x381c, 0x00}, // flip off
+{0x4300, 0x3a}, // YUV: UYVY
+{0x4708, 0x00}, // PCLK rising edge
+
+// clk = 24Mhz/3*22/2= 88Mhz
+{0x3003, 0x16},
+{0x3004, 0x30},
+#endif
+
+#define WIDTH 1280
+#define HEIGHT 720
+
+// DVP frame size
+{0x3808, WIDTH >> 8},
+{0x3809, WIDTH & 0xff},
+{0x380a, HEIGHT >> 8},
+{0x380b, HEIGHT & 0xff},
+
+{0x3802, ((814 - HEIGHT)/2) >> 8}, // vert crop start
+{0x3803, ((814 - HEIGHT)/2) & 0xff},
+{0x3806, ((814 - HEIGHT)/2 + HEIGHT + 1) >> 8}, // vert crop end
+{0x3807, ((814 - HEIGHT)/2 + HEIGHT + 1) & 0xff},
+
+#if 0
+#define HTS 0x6f6 // got from above table 1782
+#define VTS (0x2ec+80) // got from above table 748 + 80
+
+{0x380c, HTS >> 8}, // hts
+{0x380d, HTS & 0xff},
+{0x380e, VTS >> 8}, // vts
+{0x380f, VTS & 0xff},
+
+// fifo
+{0x4606, (2*HTS) >> 8}, // fifo_line_length = 2*hts
+{0x4607, (2*HTS) & 0xff},
+{0x460a, (2*(HTS-1280)) >> 8}, // fifo_hsync_start = 2*(hts - xres)
+{0x460b, (2*(HTS-1280)) & 0xff },
+
+// exposure
+{0xC488, (VTS-8)*16 >> 8},
+{0xC489, (VTS-8)*16 & 0xff},
+{0xC48A, (VTS-8)*16 >> 8},
+{0xC48B, (VTS-8)*16 & 0xff},
+
+// vts/hts
+{0xC518, VTS >> 8},
+{0xC519, VTS & 0xff},
+{0xC51A, HTS >> 8},
+{0xC51B, HTS & 0xff},
+#endif
diff --git a/drivers/media/platform/rcar-vin/rcar-core.c b/drivers/media/platform/rcar-vin/rcar-core.c
index d6f99dbb165d..a93cd1ba276a 100644
--- a/drivers/media/platform/rcar-vin/rcar-core.c
+++ b/drivers/media/platform/rcar-vin/rcar-core.c
@@ -1250,6 +1250,11 @@ static int rcar_vin_probe(struct platform_device *pdev)
 		ret = PTR_ERR(vin->clk);
 		goto error;
 	}
+	
+	if(vin->id == 4)
+	{
+		rvin_set_channel_routing(vin, 3);
+	}
 
 	return 0;
 error:
diff --git a/drivers/media/platform/rcar-vin/rcar-dma.c b/drivers/media/platform/rcar-vin/rcar-dma.c
index 2fb048ed6ba6..95ac41979aad 100644
--- a/drivers/media/platform/rcar-vin/rcar-dma.c
+++ b/drivers/media/platform/rcar-vin/rcar-dma.c
@@ -1433,6 +1433,11 @@ static int rvin_start_streaming(struct vb2_queue *vq, unsigned int count)
 	unsigned long flags;
 	int ret;
 
+	if(vin->id == 4)
+	{
+		rvin_set_channel_routing(vin, 3);
+	}
+
 	/* Continuous capture requires more buffers then there are HW slots */
 	vin->continuous = count > HW_BUFFER_NUM;
 
diff --git a/drivers/net/wireless/nxp/88x9098/wlan_src/script/usbconfig b/drivers/net/wireless/nxp/88x9098/wlan_src/script/usbconfig
new file mode 100644
index 0000000000000000000000000000000000000000..bc61a611036a4979cf18cac41f20a436f352c382
GIT binary patch
literal 9098
zcmds6eQ;FQb-!9IuvTP{h=OGx&a+z?<Ov(02trJ##mDmD@F5G~;xWx*wY$<=d$qgS
zeG9^^V&sL`n?*5k+)UExOl_x4GgD`Vp$(zQKf+LBCMi`(+oaQ^gI(M{b#W?EjUy+D
zx4+;0ke=jtrv0~f_UygCd(S=hoO3_kd-psU*}c7{rbd_)5VeBn=F`DY2l8(=sg@35
ziA7?ySSjul3sJ?kj^p3~T}PR;02Bn(f|?+tX*d`neGr($Hp(W+guVi_yHN-d`-=wE
zF6&-I8^}e66CjSu_5iZO;6IEu(ikv_?Hq%&8vLt=gCUXyOfqc`z3IjQ-;+%LkEN2m
zA4|p8q>|~vU^t%%x2wJwTI#-I?*ZADdXT6$)RAL^klzVf4!R2jHAFM$HqcVghd}ip
zx|MxafIbYO?2mxnFL4}`XovKbuBbB&I;Z~^>+%PX)AzS)%xsx1FG0QtbO&f9NctD~
z{6szJXVy20Th&?`h13F~O%nu2cY}yuAwY6K#E%dly@Y<me<zU;{m6-5)%aT)H){Fo
zHBRdGrEmiIuYsQbywYc>s1xJ5eT8l>X*`Ua{7-1ic_4lRH2P97L_apd`Z|nv$%oIP
zp2-7|zX$E)XI%sAU$6E1scwIc4M^Vyk^dF}lF^@Q;k9RtzPF1h*($`-$jN_?miNyZ
ze^a;rj>dcDjc=j8L+iu&*s1%!sre5BkNNan1?*vbW$$9C7g%Mo@c*DH&R~J{U&!~a
zX$!CA>hBQtwnz4E-m`0~u=|qfq_B7F-nV7*ZhPPM?fWA=cF*Q5yCb%+A3S1rC;F3l
zH<8<#isti)ys+*5flS)YyV0C$+X6x<A#OuFn`dx5aU>bj75xd<-=4`P(vmTkNF}2A
zgq=)dfWBxfA!}o)OkS5VX*ZWi*#r50*^+m2iCiv|lK^VFG%H4f){DFw&lFrS5KW~r
zG0~UJL1-Upb1{q%8_3F{%;Jy%Gw`3z*kF#j$xK=#1|iPgwGWoXlWDt<PsG7Q`P$Zj
zXfiGOa*2en6Y;1UMQd+9uNqO6j*A_;cWv2fw};#4_8OccSiCZ+5^I?JC@{lUBTM{e
zV*X>~JVTfol1Xg$fJo?d(T26K5Qhub@B$nRT<Z(4`8$y>!Z6#I<Ivd29E)T(a~v>T
z%yB66Fvmf0kU4h2A?7&H4l~CA6K9S?&0&s_Q_P`EmN^!<%N&Q$Aafjif504v&~fHC
zd`>XO=6r@Z4#WecH;Xqz-e<XNFY)hJ81%|TQC+tI9MzUj;h%O^TWEp9;`sF{QVT6{
z*fu^UF)ecFmhn-EX_>=gVEl~4w9v7LUyzuVI;)9KOH7L$&d~UAiD|jBfjBEMJ>YZ_
zAC{P&aCQ=RNlcG8UBsOd(=*ON;x>utA?Gl$B{4na(4g@KiRm#XODrU&=bS;}iFZ-a
zLJvB}iLXmcPdd*Kk4a3AI;V+8f!DtEnbPaU8xvhU-Ogd02Tncy9(vfR|6(xYWgu_z
z^lA8hzlRRu(cz0LaBy{(i_>U1IqC+gV+S9-a`Cj}!TcQG^ctiKcS+?VBS%DWH2C%B
zfveYEWL9oCd96@+bpcswu3Rj=t>*N_LwJlp)}7}$1PTqsoAnMWt7FAW4UoeD6z}E8
zG?|J+(}AO_iZ_Gh$aJ;i<X=Ic({UOd)?Gr;3&Ae-M5Czu@XEzGebHrOBs8?4d|<jX
zcHw$$>)1%sNeV4T>R~~(&`|9Ncz>ouoE$BL(4iEWsw`IGMlVOE==O4CN()}8l`2O<
zOU@m?yFrMJk?AF0{3D9o6OzOH{q-6SRXhCKXe~u1AVZBfvE*E5aARcZbBXeS35X=q
zmikiU=H<ww;<#BR!{p~SmG|5%ADAqS8Cf-@h*yqy#|IZw-9Y6ISzO3sJ&F(;C`E2y
z79x}I!TAv=Eh^7S6UO&L{mYRX%8DD>ie^2cSHaYJ_x>7x58<yAnTE548-*9j$Lpo~
zQ^lbv;YOhD@$*fnxvdbWtSJsnhMrtiElhd;Azc?dIXc)}j!cf!E9V}7AE!#eMyU{r
zW%yyL@@<MmX}a<?@Xo3tXIXoxI8<L#SX$il15B-OZ$mAQu*wrNZpVDq4?PY^GZPsq
z2VwpsMD`7zZ-$DWUs~9z&~l({miy6JwB2&=nne#<Zo@3vV!@%eL3AgzU8I)42-L@r
zPcEb%3U_j~ZouO6qVOD+-Q~yxr>@dWr_<_rYGIxyw512pcO-JY%R8o)TVE-1uCF+B
zP83#B>OM;SfRTEJQpdThuuPYHCvvV!cD<syVpSD~CbT*!cD(j0t&Z$iiI+JA6Quwo
zR|^wfOf|zzm^x8-0J{k--bz_rUu}~(=+#RcthRYS|0U&xx}5J)x;t0;Linr{Ia7|D
z(WZr<<YS^*2zmD_PC0DIODSZg8ntj!m-m*jLM}ID{y%XXH9non^*VkE<~t3mxLe_a
z&bqE@0qdQ`P?yRV%KTjC0-XoJGVT4LRNm6o9{V`7!_WKKJK83m9^MO*iN_DStiyO}
zIyrLXL%RB|nQG3*>|8dN4>afl<-+yAg0Et=V$E=+cVa_hEl%|n2kV5p3~~UZ^4?WB
zegoCw(KE^Y^KWxp;eMFY<1Ut?PkNh_irO8OLy%M)Y!>cvc^FPf5zszV?rfH)C$^Sk
zX^;bRHCD3?@~rgEs<G#Y|5sIq1&{SKYg-5p2zfdeN0;Dt!3$ov9&Ei-90~;rn|W@I
zV(o;STW}&4$}t>}a2(Fg7HH*6qSkqrP3uN^IzOhGVbEj3+rt5eLN!k=@s`sxRMvPK
zQ0e8##uJ{>t8ES)incc80Cg@^-A!P@WMLI>spXaH@C@mMKC>r0CZu|X0-Tj!f(GZ6
z29*_5`aaa?=f>DCq~hLbj4#c_g9p!!-+g#L^fC{?<#=iF(%>8^He)G_e3}37R_oZ>
zw=YZuKKW{XS?Ncmx2sKO%X=nT-`RfQoxmrrmVTN0S@BZ+qo1+$a}P3&z$<tg(z3os
zS*=qLg8@gf)yjg?)u!+4ExubV{K5-!=W7}2ncV$7ehI(Gze*jSx0PUZtXx~<GT>tw
zy3dRf!zf+e!?64jw5acKzE9>7y_t+Fx@Bf<%cK+HKt9@^xZe_%W#MH!mPz*|`>i!c
zENk_VL@tk4-Buj=GYwimOTJF*N*{@)l5tDDxm)SNKyM;fCvM*wO|Nn-zT{ic^fBwe
z{w<mXeQw_-U-PY_N!PI+#!GM}w`-fV$y(dKVf{y~u3RQwh`F++y{)6e%H-zPwOi>7
zgl7urc%4uq@$*2BaKF`(w^p~rTkFL3Xfl<ETW-dZ?XW=e)QL4m1YWws>)ONFHnI0$
zm(Ol(GQ{{L_^pj)1_q)qEuT%ql6}cU{BHB@jmfO?kT5yRe0CZ7G0Obz=XWc=#rZwR
z@3Ec3co#?BbOP__%%2K|C^LhO{C3A9Ox_tF6a234z{=*A!B;`%4uRkA(<g%=ey86+
z&Tq<Q5Wo9FAncUPCDcPViWN9sGbeyi{68mi55SJEz?N&EH$XoJ1#oAy6m$=$9kd11
z4eABuKu>|51HA+~3wi}~4fF=cC~^=B{3d+UNn>^TZ(vidqPz$P%sn8nW9!!Yt<|`W
zX|+Bc?g)2S?QL!A+CI^~)>_?->E9W3RsEXwR`LIzIh;Q>;6{5z7~iofcT7osGiOB@
z+b0p;yk*xKH`*`4PBia`aQs*r9aZk;M7Td)2<x3N2iR!CH#qrKA)9hVSbkWC-NYcu
z@^T=IZOjkeaKf?sa?yc=2*=z^E{_3J_E-#pAS61Fj9~yANc;;+X{sl_l+g)WEs=K3
zy#H@<-lcJUbAQOYM*!{tli0@eTOfSSN<Mi<hz1MTB<@S5wIJ?I%HuxeJ<AVJHtozw
zp8#>M%5kxOn^*v`FUKSg_wfTDE^En${oaHIxgk-<L|&#HAnsN2ai5-mpiY!2hl%y1
z9uW67%iQ0Wz-OWC9~V%>K=@pjeQtp71{iog7<tUO!BQZ@$Ma+wd^~5^PWudB0cGmS
z^NQ!$^C<8PGRerzqQdaK48E7a*J+GI8~I4T@8jdW^G!_7PdGt38F|CNMjp@4*Kmiy
zyET&x-_xidAN_Izd^f<?J8xX}c@|{&cH-4wCk{{}gYBmLHO<Gl;{%v?(=!K>kM9K^
zUk~_t-iPnceSG}(J@h`~z6?J4nB&U3Zt#tv%=u-ae$?aJAlgB`Has8N@BlEnqe_;E
zzY8*ae2#R0?;sg;A`j^z$nc#4-zo5QXdY%p_7#*lKF8(j-YEFE&P_6WS5ZNECXsKk
zufh~zo|I+yu4424$N=Pqk2&Yoq!2FLyWlA9f9lC`sR!3Gbu;N8?!eX?rBG?)nRb89
z^MhDLLsTq5VKp+(1BKNHd~PeO2H^8tVKrOkd0Q)IRP9&Qt`<7?rNT0k&vS)o#q51|
zE$+LSxSyEU%AKj=H45`BWA?teR^R+{AE<T}8Q^+X7@Gr$>snzogIvD~b5?NYH-j;G
zNaj7DR-dq3cdW0KZzZ$$)3y5Th3iPQtLOvQi^BesgZ+6j&8AuzP4Q#@jwk;LIgbs`
zD0u<AWhsqSpCInX8QU=S)nH}Z2W;%C0rv)AV_yw!<Riem#6kwy%fv3^@*+#(I|QRY
z9lr4%2X=gT{`g1H-lhG=@lOErJqH=&H;OMIH}g>=mWV$A_UrQ(z<;XekM>;vHi`EA
zEdcMuIP=u^hsd9YKA%EP{@0O@0W%Im{1)=oQZV$Y#sO@E{{k*+{6XM&IT-pEjqe3c
zoC=1%ukl9Uwvk}yCmMem_=ztBL;nf96!L!$*sKr6C;EUNK>vGn`xC%SEg-I@Q@~uG
z+&PViTzy%$->uufp|PX!Ujm!?YzW+{@{X9v#Fzd-<9^gp{!cajmd3Y$PwV+@3@j7x
z0`op}i)^nKi}m4R;y3qcY~oKFf&KBP&AQ#hpZ04!tj9Z~F;_PAc^sJQU)g(y7y{;H
zroqnw^En7s>Cdm|{+{mt4Pf4o8UC}tet-N8Ft2vIb^m_^Hv5h7tJm3%J70dVaK8Q>
zn90PmYH_6b<u&O;l=Dyh?*lgb*}{5Tr`wIcb^!b1U3-B2@}iob&uPj#3d}Ed?$bud
zdrG&Pc-V6qn|RnC1N-gyIxwGS=#Kuks(-Ed-vp-oE5KvAo%UY^_UrRHus=RF0c`AR
zfIhzlHpxPv5svrwU&V>g$zmQuT*(*t60w|{cME-e;TYmTTYL6(+q-w|??FJ!wzthe
z4{n`l$|5p^ci?O);U?nYwP1~B?EX}yH=45Lo3tG*3?jsYH*7mz7#KKaL`U{+o0V+9
z_U_GlBDO&s#*}BJ%GY!$b>@p73Kw`oAmYh<HWfXFNEZ=5@Aap!V7P83BxkF80FjSH
z85QfbeSy7LU%$<-aa||!xB!qmxOJEb++}ka!~yfRk)B7;FXsA0&Bh|BBt*&p;EYT}
z@CLG-owLC;yDw`yM@@*&-$M0fVuZGgY}(OW4n{IO$JY6wO8Kp0y7)z5Zt@x1!OcJl
z0Y4Q7jO7bDS~@Ry=<hf)it!U%iO8agOU`GUiG=zhq$-f<=R^&HmHrwXb>vunSNCr&
zxS9RZztEZAZrXeqt@WEBb@B%=WpwjB@y<D8N<-%P^Su#Ve(!1ZR19{G4Ea52+u2-#
z8u)}^4s@W_&)*LVV*~MA;<GY7>u-{_%Sf>a$Nt6;HUqZ)ZgM5qep9q>=0|>gcKqfr
N_*@%|hvx*x{|6e$5-I=y

literal 0
HcmV?d00001

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 0fd6195601ba..0d31de7bdc38 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -957,6 +957,12 @@ config REGULATOR_WM8994
 	help
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
+	  
+config REGULATOR_MAX2008X
+	tristate "Maxim 20086-20089 Dual/Quad Camera Power Protector reguator"
+	help
+	  This driver controls  MAX20086-MAX20089 dual/quad camera power
+	  protector IC.
 
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 80ffc57a9ca3..c54d55998430 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_REGULATOR_LP8755) += lp8755.o
 obj-$(CONFIG_REGULATOR_LTC3589) += ltc3589.o
 obj-$(CONFIG_REGULATOR_LTC3676) += ltc3676.o
 obj-$(CONFIG_REGULATOR_MAX14577) += max14577-regulator.o
+obj-$(CONFIG_REGULATOR_MAX2008X) += max2008x-regulator.o
 obj-$(CONFIG_REGULATOR_MAX1586) += max1586.o
 obj-$(CONFIG_REGULATOR_MAX77620) += max77620-regulator.o
 obj-$(CONFIG_REGULATOR_MAX8649)	+= max8649.o
diff --git a/drivers/regulator/max2008x-regulator.c b/drivers/regulator/max2008x-regulator.c
new file mode 100644
index 000000000000..f8462aa54723
--- /dev/null
+++ b/drivers/regulator/max2008x-regulator.c
@@ -0,0 +1,525 @@
+/*
+ * gpio-regulator.c
+ *
+ * Copyright 2019 Andrey Gusakov <andrey.gusakov@cogentembedded.com>
+ *
+ * based on gpio-regulator.c
+ *
+ * Copyright 2011 Heiko Stuebner <heiko@sntech.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This is useful for systems with mixed controllable and
+ * non-controllable regulators, as well as for allowing testing on
+ * systems with no controllable regulators.
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/iio/iio.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regmap.h>
+
+/* Register definitions */
+#define REG_MASK	0x00
+#define REG_CONFIG	0x01
+#define REG_ID		0x02
+#define REG_STAT1	0x03
+/* 16 bit register: 0x04 + 0x05 */
+#define REG_STAT2	0x04
+/* ADC1..ADC4 */
+#define REG_ADC(n)	(0x06 + ((n) & 0x03))
+
+#define REG_CONFIG_ADC_MUX_CUR	0x00
+#define REG_CONFIG_ADC_MUX_VOUT	0x40
+#define REG_CONFIG_ADC_MUX_MISC	0x80
+#define REG_CONFIG_ADC_MUX_MASK	0xc0
+
+struct max2008x_regulator_data {
+	int			id;
+	const char		*name;
+	struct regulator_init_data *init_data;
+	struct device_node 	*of_node;
+};
+
+struct max2008x_data {
+	struct regmap *regmap;
+	struct max2008x_regulator_data  *regulators;
+	struct iio_dev *iio_dev;
+
+	unsigned char id;
+	unsigned char rev;
+	unsigned char num_regulators;
+
+	unsigned char adc_mux;
+};
+
+static int max2008x_set_adc_mux(struct max2008x_data *max, int mux)
+{
+	int ret;
+	unsigned int reg;
+
+	mux = mux & REG_CONFIG_ADC_MUX_MASK;
+	if (mux > REG_CONFIG_ADC_MUX_MISC)
+		return -EINVAL;
+
+	/* do we need this? or we can relay on regmap? */
+	if (mux == max->adc_mux)
+		return 0;
+
+	ret = regmap_write_bits(max->regmap, REG_CONFIG,
+		REG_CONFIG_ADC_MUX_MASK, mux);
+	if (ret)
+		return ret;
+
+	max->adc_mux = mux;
+
+	/* Read ADC1 register to clear ACC bit in STAT1 register */
+	ret = regmap_read(max->regmap, REG_ADC(0), &reg);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int max2008x_read_adc(struct max2008x_data *max, int channel, int *value)
+{
+	int ret;
+	int timeout = 100;
+	unsigned int reg;
+
+	/* shift 3:2 bits to 7:6 */
+	ret = max2008x_set_adc_mux(max, channel << 4);
+	if (ret)
+		return ret;
+
+	do {
+		ret = regmap_read(max->regmap, REG_STAT1, &reg);
+		if (ret)
+			return ret;
+	} while ((!(reg & BIT(4))) && (--timeout));
+
+	if (timeout <= 0)
+		return -ETIMEDOUT;
+
+	ret = regmap_read(max->regmap, REG_ADC(channel & 0x03), &reg);
+	if (ret)
+		return ret;
+	*value = reg;
+
+	return 0;
+}
+
+static int max2008x_get_voltage(struct regulator_dev *dev)
+{
+	int ret;
+	int value = 0;
+	struct max2008x_data *max = rdev_get_drvdata(dev);
+
+	/* voltage channels starts from 4 */
+	ret = max2008x_read_adc(max, dev->desc->id + 4, &value);
+	if (ret)
+		return ret;
+
+	/* in 70mV units */
+	return (value * 70000);
+}
+
+static struct regulator_ops max2008x_ops = {
+	.enable		= regulator_enable_regmap,
+	.disable	= regulator_disable_regmap,
+	.is_enabled	= regulator_is_enabled_regmap,
+	.get_voltage	= max2008x_get_voltage,
+};
+
+static struct of_regulator_match max2008x_matches[] = {
+	[0] = { .name = "SW0"},
+	[1] = { .name = "SW1"},
+	[2] = { .name = "SW2"},
+	[3] = { .name = "SW3"},
+};
+
+static int of_get_max2008x_pdata(struct device *dev,
+				 struct max2008x_data *pdata)
+{
+	int matched, i;
+	struct device_node *np;
+	struct max2008x_regulator_data *regulator;
+
+	np = of_get_child_by_name(dev->of_node, "regulators");
+	if (!np) {
+		dev_err(dev, "missing 'regulators' subnode in DT\n");
+		return -EINVAL;
+	}
+
+	matched = of_regulator_match(dev, np, max2008x_matches,
+				     pdata->num_regulators);
+	of_node_put(np);
+	if (matched <= 0)
+		return matched;
+
+	pdata->regulators = devm_kzalloc(dev,
+					 sizeof(struct max2008x_regulator_data) *
+					 pdata->num_regulators, GFP_KERNEL);
+	if (!pdata->regulators)
+		return -ENOMEM;
+
+	regulator = pdata->regulators;
+
+	for (i = 0; i < pdata->num_regulators; i++) {
+		regulator->id = i;
+		regulator->name = max2008x_matches[i].name;
+		regulator->init_data = max2008x_matches[i].init_data;
+		regulator->of_node = max2008x_matches[i].of_node;
+		regulator++;
+	}
+
+	return 0;
+}
+
+static struct max2008x_regulator_data *max2008x_get_regulator_data(
+		int id, struct max2008x_data *data)
+{
+	int i;
+
+	if (!data)
+		return NULL;
+
+	for (i = 0; i < data->num_regulators; i++) {
+		if (data->regulators[i].id == id)
+			return &data->regulators[i];
+	}
+
+	return NULL;
+}
+
+#define MAX2008X_REG(_name, _id, _supply)				\
+	{								\
+		.name			= _name,			\
+		.supply_name		= _supply,			\
+		.id			= _id,				\
+		.type			= REGULATOR_VOLTAGE,		\
+		.ops			= &max2008x_ops,		\
+		.enable_reg		= REG_CONFIG,			\
+		.enable_mask		= BIT(_id),			\
+		.owner			= THIS_MODULE,			\
+	}
+
+static const struct regulator_desc max2008x_regulators[] = {
+	MAX2008X_REG("SW0", 0, "out0"),
+	MAX2008X_REG("SW1", 1, "out1"),
+	MAX2008X_REG("SW2", 2, "out2"),
+	MAX2008X_REG("SW3", 3, "out3"),
+};
+
+static const char *max2008x_devnames[] = {
+	"max20089",
+	"max20088",
+	"max20087",
+	"max20086"
+};
+
+static int max2008x_adc_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val, int *val2, long mask)
+{
+	int ret;
+	struct max2008x_data *max = iio_device_get_drvdata(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		ret = max2008x_read_adc(max, chan->channel, val);
+		iio_device_release_direct_mode(indio_dev);
+
+		if (ret)
+			return ret;
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		if (chan->type == IIO_VOLTAGE) {
+			/* Vout1..Vout4 and Vin */
+			if (chan->channel <= 8)
+				*val = 70;
+			/* Vdd */
+			else if (chan->channel == 9)
+				*val = 25;
+			/* Viset */
+			else
+				*val = 5;
+		} else if (chan->type == IIO_CURRENT) {
+			*val = 3;
+			*val2 = 0;
+		}
+
+		return IIO_VAL_INT;
+	}
+
+	return 0;
+}
+
+#define MAX2008X_ADC_C_CHAN(_chan, _addr, _name) {		\
+	.type = IIO_CURRENT,					\
+	.indexed = 1,						\
+	.address = _addr,					\
+	.channel = _chan,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
+				BIT(IIO_CHAN_INFO_SCALE),	\
+	.scan_index = _addr,					\
+	.scan_type = {						\
+		.sign = 'u',					\
+		.realbits = 8,					\
+		.storagebits = 8,				\
+		.endianness = IIO_CPU,				\
+	},							\
+	.datasheet_name = _name,				\
+}
+
+#define MAX2008X_ADC_V_CHAN(_chan, _addr, _name) {		\
+	.type = IIO_VOLTAGE,					\
+	.indexed = 1,						\
+	.address = _addr,					\
+	.channel = _chan,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
+				BIT(IIO_CHAN_INFO_SCALE),	\
+	.scan_index = _addr,					\
+	.scan_type = {						\
+		.sign = 'u',					\
+		.realbits = 8,					\
+		.storagebits = 8,				\
+		.endianness = IIO_CPU,				\
+	},							\
+	.datasheet_name = _name,				\
+}
+
+static const struct iio_chan_spec max2008x_adc_channels[] =
+{
+	MAX2008X_ADC_C_CHAN( 0,  0, "out0"),
+	MAX2008X_ADC_C_CHAN( 1,  1, "out1"),
+	MAX2008X_ADC_C_CHAN( 2,  2, "out2"),
+	MAX2008X_ADC_C_CHAN( 3,  3, "out3"),
+	MAX2008X_ADC_V_CHAN( 4,  4, "out0"),
+	MAX2008X_ADC_V_CHAN( 5,  5, "out1"),
+	MAX2008X_ADC_V_CHAN( 6,  6, "out2"),
+	MAX2008X_ADC_V_CHAN( 7,  7, "out3"),
+	MAX2008X_ADC_V_CHAN( 8,  8, "Vin"),
+	MAX2008X_ADC_V_CHAN( 9,  9, "Vdd"),
+	MAX2008X_ADC_V_CHAN(10, 10, "Viset"),
+};
+
+static const struct iio_info max2008x_adc_info = {
+	.read_raw = max2008x_adc_read_raw,
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id max2008x_of_match[] = {
+	{ .compatible = "maxim,max2008x" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max2008x_of_match);
+#endif
+
+
+static const struct regmap_range max2008x_reg_ranges[] = {
+	regmap_reg_range(REG_MASK, REG_ADC(3)),
+};
+
+static const struct regmap_range max2008x_reg_ro_ranges[] = {
+	regmap_reg_range(REG_ID, REG_ADC(3)),
+};
+
+static const struct regmap_range max2008x_reg_volatile_ranges[] = {
+	regmap_reg_range(REG_STAT1, REG_ADC(3)),
+};
+
+static const struct regmap_access_table max2008x_write_ranges_table = {
+	.yes_ranges	= max2008x_reg_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(max2008x_reg_ranges),
+	.no_ranges	= max2008x_reg_ro_ranges,
+	.n_no_ranges	= ARRAY_SIZE(max2008x_reg_ro_ranges),
+};
+
+static const struct regmap_access_table max2008x_read_ranges_table = {
+	.yes_ranges	= max2008x_reg_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(max2008x_reg_ranges),
+};
+
+static const struct regmap_access_table max2008x_volatile_ranges_table = {
+	.yes_ranges	= max2008x_reg_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(max2008x_reg_volatile_ranges),
+};
+
+static const struct regmap_config max2008x_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= REG_ADC(3),
+	.wr_table	= &max2008x_write_ranges_table,
+	.rd_table	= &max2008x_read_ranges_table,
+	.volatile_table	= &max2008x_volatile_ranges_table,
+};
+
+static int max2008x_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+	struct max2008x_data *max;
+	struct gpio_desc *enable_gpio;
+	unsigned int reg;
+	int i, ret;
+
+	max = devm_kzalloc(&client->dev, sizeof(struct max2008x_data),
+			       GFP_KERNEL);
+	if (max == NULL)
+		return -ENOMEM;
+
+	enable_gpio = devm_gpiod_get_optional(&client->dev, "enable", GPIOD_OUT_LOW);
+
+	/* regmap */
+	max->regmap = devm_regmap_init_i2c(client, &max2008x_regmap_config);
+	if (IS_ERR(max->regmap)) {
+		ret = PTR_ERR(max->regmap);
+		dev_err(&client->dev,
+			"regmap allocation failed with err %d\n", ret);
+		return ret;
+	}
+	i2c_set_clientdata(client, max);
+
+	ret = regmap_read(max->regmap, REG_ID, &reg);
+	if (ret)
+		return ret;
+
+	max->id = (reg >> 4) & 0x03;
+	max->rev = reg & 0x0f;
+	/* MAX20086 and MAX20087 have 4 outputs */
+	max->num_regulators = ((max->id == 0x2) || (max->id == 0x3)) ? 4 : 2;
+
+	/* Disable all */
+	ret = regmap_write_bits(max->regmap, REG_CONFIG, BIT(max->num_regulators) - 1, 0x00);
+	if (ret)
+		return ret;
+
+	/* to update mux on first access */
+	max->adc_mux = 0xff;
+
+	/* set autoconvertion mode for ADC */
+	ret = regmap_write_bits(max->regmap, REG_CONFIG, BIT(5), BIT(5));
+	if (ret)
+		return ret;
+
+	dev_info(&client->dev, "%s rev %d found (%d channels)\n",
+		max2008x_devnames[max->id], max->rev, max->num_regulators);
+
+	if (np) {
+		ret = of_get_max2008x_pdata(&client->dev, max);
+		if (ret) {
+			dev_err(&client->dev,
+				"dt parse error %d\n", ret);
+			return ret;
+		}
+	}
+
+	/* Finally register devices */
+	for (i = 0; i < max->num_regulators; i++) {
+		const struct regulator_desc *desc = &max2008x_regulators[i];
+		struct regulator_config config = { };
+		struct max2008x_regulator_data *rdata;
+		struct regulator_dev *rdev;
+
+		config.dev = dev;
+		config.driver_data = max;
+		config.regmap = max->regmap;
+
+		rdata = max2008x_get_regulator_data(desc->id, max);
+		if (rdata) {
+			config.init_data = rdata->init_data;
+			config.of_node = rdata->of_node;
+		}
+
+		rdev = devm_regulator_register(dev, desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(dev, "failed to register %s\n", desc->name);
+			return PTR_ERR(rdev);
+		}
+	}
+
+	/* IIO device */
+	max->iio_dev = devm_iio_device_alloc(dev, 0);
+	if (!max->iio_dev)
+		return -ENOMEM;
+
+	max->iio_dev->info = &max2008x_adc_info;
+	max->iio_dev->dev.parent = dev;
+	max->iio_dev->dev.of_node = dev->of_node;
+	max->iio_dev->name = "max2008x-adc";
+	max->iio_dev->modes = INDIO_DIRECT_MODE;
+
+	max->iio_dev->channels = max2008x_adc_channels;
+	/* only ASIL can measure voltages */
+	if ((max->id == 0x00) || (max->id == 0x02))
+		max->iio_dev->num_channels = ARRAY_SIZE(max2008x_adc_channels);
+	else
+		max->iio_dev->num_channels = 4;
+
+	iio_device_set_drvdata(max->iio_dev, max);
+
+	ret = iio_device_register(max->iio_dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to register IIO device: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, max);
+
+	if (!IS_ERR(enable_gpio))
+		gpiod_set_value_cansleep(enable_gpio, 1);
+
+	return 0;
+}
+
+static const struct i2c_device_id max2008x_id[] = {
+	{ "maxim,max2008x" },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max2008x_id);
+
+static struct i2c_driver max2008x_driver = {
+	.driver		= {
+		.name		= "max2008x",
+		.of_match_table = of_match_ptr(max2008x_of_match),
+	},
+	.probe		= max2008x_probe,
+	.id_table	= max2008x_id,
+};
+
+static int __init max2008x_init(void)
+{
+	return i2c_add_driver(&max2008x_driver);
+}
+subsys_initcall(max2008x_init);
+
+static void __exit max2008x_exit(void)
+{
+	i2c_del_driver(&max2008x_driver);
+}
+module_exit(max2008x_exit);
+
+MODULE_AUTHOR("Andrey Gusakov <andrey.gusakov@cogentembedded.com>");
+MODULE_DESCRIPTION("max2008x Dual/Quad Camera Power Protector");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:max2008x");
-- 
2.17.1


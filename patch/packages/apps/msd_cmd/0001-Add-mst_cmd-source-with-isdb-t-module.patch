From 8cb2f6e3ea4dd5a72673510e30d25e679009e41a Mon Sep 17 00:00:00 2001
From: Jerry Lin <jerrylin@retronix.com.tw>
Date: Tue, 2 Jan 2024 13:44:01 +0800
Subject: [PATCH] Add mst_cmd source with isdb-t module.

---
 Android.bp |  28 ++++
 main.cpp   | 436 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 464 insertions(+)
 create mode 100644 Android.bp
 create mode 100644 main.cpp

diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000..6c2abb0
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,28 @@
+cc_binary {
+    name: "msd_cmd",
+    header_libs: [
+
+    ],
+    include_dirs: [
+
+    ],
+    local_include_dirs: [
+
+    ],
+    srcs: [
+        "main.cpp",
+    ],
+    shared_libs: [
+
+    ],
+    static_libs: [
+
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+        "-Wno-unused-parameter",
+        "-Wno-missing-field-initializers",
+        "-Wno-expansion-to-defined",
+    ],
+}
diff --git a/main.cpp b/main.cpp
new file mode 100644
index 0000000..eb01ccf
--- /dev/null
+++ b/main.cpp
@@ -0,0 +1,436 @@
+#include <fcntl.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <termios.h>
+#include <string.h>
+
+
+
+enum MST_CMD
+{
+	MST_CMD_BOOT = 0,
+	MST_CMD_START_TEST_VIDEO,
+	MST_CMD_STOP_TEST_VIDEO,
+	MST_CMD_START_TEST_AUDIO,
+	MST_CMD_START_TEST_FS_AUDIO,
+	MST_CMD_STOP_TEST_AUDIO,
+	MST_CMD_VERSION,
+	MST_CMD_RECV_MSG,
+	MST_CMD_MAX
+};
+
+char const* MST_CMD_STR_BOOT = "Boot" ;
+char const* MST_CMD_STR_START_TEST_VIDEO = "StartTestVideo" ;
+char const* MST_CMD_STR_STOP_TEST_VIDEO = "StopTestVideo" ;
+char const* MST_CMD_STR_START_TEST_AUDIO = "StartTestAudio" ;
+char const* MST_CMD_STR_START_TEST_FS_AUDIO = "StartTestFsAudio" ;
+char const* MST_CMD_STR_STOP_TEST_AUDIO = "StopTestAudio" ;
+char const* MST_CMD_STR_VERSION = "Version" ;
+char const* MST_CMD_STR_RECV_MSG = "RecvMsg" ;
+
+struct mst_cmd_info_t {
+	char const* cName;
+	int iID;
+};
+
+struct mst_cmd_info_t mMST_CMD_INFO[] = {
+	{MST_CMD_STR_BOOT,					MST_CMD_BOOT},
+	{MST_CMD_STR_START_TEST_VIDEO,		MST_CMD_START_TEST_VIDEO},
+	{MST_CMD_STR_STOP_TEST_VIDEO,		MST_CMD_STOP_TEST_VIDEO},
+	{MST_CMD_STR_START_TEST_AUDIO,		MST_CMD_START_TEST_AUDIO},
+	{MST_CMD_STR_START_TEST_FS_AUDIO,	MST_CMD_START_TEST_FS_AUDIO},
+	{MST_CMD_STR_STOP_TEST_AUDIO,		MST_CMD_STOP_TEST_AUDIO},
+	{MST_CMD_STR_VERSION,				MST_CMD_VERSION},
+	{MST_CMD_STR_RECV_MSG,				MST_CMD_RECV_MSG}
+};
+
+int iReturn_MST_Cmd(char* cCmd)
+{
+	int iRet = -1;
+		
+	for(int i = 0 ; i < MST_CMD_MAX ; i++)
+	{
+		if(strcmp(cCmd, mMST_CMD_INFO[i].cName) == 0)
+		{
+			iRet = mMST_CMD_INFO[i].iID;
+			break;
+		}
+	}
+	
+	return iRet;
+}
+
+int open_serial_port(const char * device, uint32_t baud_rate)
+{
+	int fd = open(device, O_RDWR | O_NOCTTY);
+	if (fd == -1)
+	{
+		perror(device);
+		return -1;
+	}
+	
+	// Flush away any bytes previously read or written.
+	int result = tcflush(fd, TCIOFLUSH);
+	if (result)
+	{
+		perror("tcflush failed");	// just a warning, not a fatal error
+	}
+
+	// Get the current configuration of the serial port.
+	struct termios options;
+	result = tcgetattr(fd, &options);
+	if (result)
+	{
+		perror("tcgetattr failed");
+		close(fd);
+		return -1;
+	}
+
+	// Turn off any options that might interfere with our ability to send and
+	// receive raw binary bytes.
+	options.c_iflag &= ~(INLCR | IGNCR | ICRNL | IXON | IXOFF);
+	options.c_oflag &= ~(ONLCR | OCRNL);
+	options.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
+
+	// Set up timeouts: Calls to read() will return as soon as there is
+	// at least one byte available or when 100 ms has passed.
+	options.c_cc[VTIME] = 1;
+	options.c_cc[VMIN] = 0;
+
+	// This code only supports certain standard baud rates. Supporting
+	// non-standard baud rates should be possible but takes more work.
+	switch (baud_rate)
+	{
+		case 4800:		cfsetospeed(&options, B4800);		break;
+		case 9600:		cfsetospeed(&options, B9600);		break;
+		case 19200:		cfsetospeed(&options, B19200);		break;
+		case 38400:		cfsetospeed(&options, B38400);		break;
+		case 115200:	cfsetospeed(&options, B115200);		break;
+		case 921600:	cfsetospeed(&options, B921600);		break;
+		default:
+			fprintf(stderr, "warning: baud rate %u is not supported, using 9600.\n", baud_rate);
+			cfsetospeed(&options, B9600);
+			break;
+	}
+	cfsetispeed(&options, cfgetospeed(&options));
+
+	result = tcsetattr(fd, TCSANOW, &options);
+	if (result)
+	{
+		perror("tcsetattr failed");
+		close(fd);
+		return -1;
+	}
+
+	return fd;
+}
+
+ssize_t read_port(int fd, uint8_t * buffer, size_t size)
+{
+	size_t received = 0;
+	while (received < size)
+	{
+		ssize_t r = read(fd, buffer + received, size - received);
+		if(r < 0)
+		{
+			perror("failed to read from port");
+			return -1;
+		}
+		if (r == 0)
+		{
+			//Timeout
+			break;
+		}
+		received += r;
+	}
+	return received;
+}
+
+int write_port(int fd, uint8_t * buffer, size_t size)
+{
+	ssize_t result = write(fd, buffer, size);
+	if(result != (ssize_t)size)
+	{
+		perror("failed to write to port");
+		return -1;
+	}
+	return 0;
+}
+
+int get_version(int fd)
+{
+
+	uint8_t command[] = { 0xA5, 0x5A, 0x00, 0x00, 0x03, 0x17, 0x01, 0x13, 0xE4 };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	usleep(500000);
+	
+	//for(int i = 0 ; i < 100 ; i++)
+	{
+		uint8_t buffer[512] = { 0 };
+		size_t length = sizeof(buffer);
+		memset(buffer, 0x00, 512);
+		ssize_t received = read_port(fd, buffer, length);
+		
+		if (received < 0) { return -1; }
+		if (received != length)
+		{
+			fprintf(stderr, "read timeout: expected %lu bytes, got %zu\n", length, received);
+			//return -1;
+		}
+		
+		for(int j = 0 ; j < received ; j++)
+		{		
+			//printf("buffer[%d] = 0x%02X\n", j, buffer[j]);
+			printf("0x%02X ", buffer[j]);
+		}
+		printf("\n");
+		usleep(1000000);
+		////////////////////////////////////////////////////////////////////////////////////////////
+		////////////////////////////////////////////////////////////////////////////////////////////
+		////////////////////////////////////////////////////////////////////////////////////////////
+		{
+			int iIndex = 0;
+			for(iIndex = 0 ; iIndex < received ; iIndex++)
+			{
+				if((iIndex + 26) >= received)
+				{
+					printf("Cannot get version!!! [%d - %zd]\n", iIndex, received);
+					break;
+				}
+				if(buffer[iIndex+0] == 0xA5 
+				&& buffer[iIndex+1] == 0x5A 
+				&& buffer[iIndex+2] == 0x00
+				&& buffer[iIndex+3] == command[3]
+				&& buffer[iIndex+4] == 0x15
+				)
+				{
+					char ver_hw[32] = { 0 };
+					char ver_boot[32] = { 0 };
+					char ver_program[32] = { 0 };
+					
+					memcpy(ver_hw, buffer+iIndex+10, 4);
+					memcpy(ver_boot, buffer+iIndex+14, 4);
+					memcpy(ver_program, buffer+iIndex+18, 8);
+					
+					printf("ver_hw = %s\n", ver_hw);
+					printf("ver_boot = %s\n", ver_boot);
+					printf("ver_program = %s\n", ver_program);
+					
+					break;
+				}
+			}
+		}
+		
+	}
+	return 0;	
+}
+
+int set_StartTestVideoAudioMode(int fd)
+{
+	printf("Excute set Video/Audio Test Mode!!!\n");
+	uint8_t command[] = { 0xA5, 0x5A, 0x00, 0x07, 0x05, 0x1F, 0xF0, 0x05, 0x01, 0x04, 0x06 };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int set_StartTestVideoAudioModeAck(int fd)
+{
+	printf("Excute set Video/Audio Test Mode Ack!!!\n");
+	uint8_t command[] = { 0xA5, 0x5A, 0x80, 0x07, 0x00, 0x3F };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int set_StartTestVideoMode(int fd)
+{
+	printf("Excute set Video Test Mode!!!\n");
+	uint8_t command[] = { 0xA5, 0x5A, 0x00, 0x02, 0x05, 0x68, 0xF0, 0x05, 0x01, 0x00, 0xC2 };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int set_StartTestVideoFsAudioMode(int fd)
+{
+	printf("Excute set Video/Audio Test Mode!!!\n");
+	uint8_t command[] = { 0xA5, 0x5A, 0x00, 0x00, 0x05, 0xB1, 0xF0, 0x05, 0x01, 0x01, 0xF3 };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int set_StartTestVideoModeAck(int fd)
+{
+
+	uint8_t command[] = { 0xA5, 0x5A, 0x80, 0x02, 0x00, 0x48 };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int set_StopTestVideoMode(int fd)
+{
+
+	uint8_t command[] = { 0xA5, 0x5A, 0x00, 0x04, 0x05, 0x32, 0xF0, 0x05, 0x00, 0x00, 0x36 };
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+	
+	return 0;	
+}
+
+int set_StopTestVideoModeAck(int fd)
+{
+
+	uint8_t command[] = { 0xA5, 0x5A, 0x80, 0x04, 0x00, 0x12};
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+	
+	return 0;	
+}
+
+int iRecvBootMsg(int fd)
+{
+	
+	for(int i = 0 ; i < 100 ; i++)
+	{
+		uint8_t buffer[512] = { 0 };
+		size_t length = sizeof(buffer);
+		memset(buffer, 0x00, 512);
+		ssize_t received = read_port(fd, buffer, length);
+		
+		if (received < 0) { return -1; }
+
+		printf("read timeout: expected %lu bytes, got %zu\n", length, received);
+
+		if(buffer[0] == 0xA5)
+		{
+			for(int j = 0 ; j < received ; j++)
+			{		
+				//printf("buffer[%d] = 0x%02X\n", j, buffer[j]);
+				printf("0x%02X ", buffer[j]);
+			}
+			printf("\n");
+		}
+		usleep(1000000);
+	}
+	
+	return 0;
+}
+
+int set_Boot_1(int fd)
+{
+	printf("Excute set_Boot_1\n");
+	uint8_t command[] = { 0xA5, 0x5A, 0x80, 0x01, 0x00, 0x65};
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int set_Boot_2(int fd)
+{
+	printf("Excute set_Boot_2\n");
+	uint8_t command[] = { 0xA5, 0x5A, 0x00, 0x03, 0x0B, 0x83, 0x80, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,0xFF, 0x00, 0x00, 0x64};
+	int result = write_port(fd, command, sizeof(command));
+	if (result) { return -1; }
+
+	return 0;	
+}
+
+int iExecuteUserMode(int iMode, int fd)
+{
+	switch(iMode)
+	{
+		case MST_CMD_BOOT:
+			set_Boot_1(fd);
+			set_Boot_2(fd);
+			usleep(1000000);
+			break;
+		case MST_CMD_START_TEST_VIDEO:
+			set_StartTestVideoMode(fd);
+			//usleep(500000);
+			//set_StartTestVideoModeAck(fd);
+			break;
+		case MST_CMD_STOP_TEST_VIDEO:
+			set_StopTestVideoMode(fd);
+			//usleep(500000);
+			//set_StopTestVideoModeAck(fd);
+			break;
+		break;
+		case MST_CMD_START_TEST_AUDIO:
+			set_StartTestVideoAudioMode(fd);
+			//usleep(500000);
+			//set_StartTestVideoAudioModeAck(fd);
+		break;
+		case MST_CMD_START_TEST_FS_AUDIO:
+			set_StartTestVideoFsAudioMode(fd);
+			//usleep(500000);
+			//set_StartTestVideoAudioModeAck(fd);
+		break;
+		case MST_CMD_STOP_TEST_AUDIO:
+			set_StopTestVideoMode(fd);
+			//usleep(500000);
+			//set_StopTestVideoModeAck(fd);		
+		break;
+		case MST_CMD_VERSION:
+			get_version(fd);
+		break;
+		case MST_CMD_RECV_MSG:
+		break;
+		default: break;
+	}
+	
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	int iMode = -1;
+	
+	//printf("argc is %d\n", argc);
+	//for(int i = 0 ; i < argc ; i++)
+	//{
+	//	printf("argv[%d] = %s\n", i, argv[i]);
+	//}
+	
+	if(argc == 2)
+	{
+		iMode = iReturn_MST_Cmd(argv[1]);
+	}
+	
+	if(iMode == -1)
+	{
+		for(int i = 0 ; i < MST_CMD_MAX ; i++)
+		{
+			printf("./mst_cmd %s\n", mMST_CMD_INFO[i].cName);
+		}
+		
+		return 0;
+	}
+	else
+	{
+		printf("iMode = %d\n", iMode);
+	}
+	
+	//const char * device = "/dev/ttyUSB0";
+	const char * device = "/dev/ttySC3";
+	uint32_t baud_rate = 921600;
+	
+	int fd = open_serial_port(device, baud_rate);
+	if (fd < 0) { return 1; }
+	
+	iExecuteUserMode(iMode, fd);
+
+	close(fd);
+	return 0;
+}
-- 
2.25.1


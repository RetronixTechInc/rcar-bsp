From ade44fdadea46b910228df0f63f1d11c62f48832 Mon Sep 17 00:00:00 2001
From: artiewang <artiewang@retronix.com.tw>
Date: Thu, 31 Aug 2023 17:02:55 +0800
Subject: [PATCH] copy from device/renesas/kingfisher/hal and replace
 kingfisher as renesas

---
 Android.bp                                    |  39 ++
 BroadcastRadio.cpp                            | 211 ++++++++
 BroadcastRadio.h                              |  74 +++
 TunerSession.cpp                              | 450 ++++++++++++++++++
 TunerSession.h                                |  92 ++++
 ...ware.broadcastradio@2.0-service.renesas.rc |   4 +
 ...are.broadcastradio@2.0-service.renesas.xml |  11 +
 resources.h                                   |  31 ++
 service.cpp                                   |  38 ++
 9 files changed, 950 insertions(+)
 create mode 100644 Android.bp
 create mode 100644 BroadcastRadio.cpp
 create mode 100644 BroadcastRadio.h
 create mode 100644 TunerSession.cpp
 create mode 100644 TunerSession.h
 create mode 100644 android.hardware.broadcastradio@2.0-service.renesas.rc
 create mode 100644 android.hardware.broadcastradio@2.0-service.renesas.xml
 create mode 100644 resources.h
 create mode 100644 service.cpp

diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000..a8f6e85
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,39 @@
+cc_binary {
+    name: "android.hardware.broadcastradio@2.0-service.renesas",
+    init_rc: ["android.hardware.broadcastradio@2.0-service.renesas.rc"],
+    vintf_fragments: ["android.hardware.broadcastradio@2.0-service.renesas.xml"],
+
+    vendor: true,
+    relative_install_path: "hw",
+
+    cflags: [
+        "-Wall",
+        "-Wextra",
+        "-Werror",
+    ],
+
+    cppflags: [
+        "-std=c++1z",
+    ],
+
+    srcs: [
+        "BroadcastRadio.cpp",
+        "TunerSession.cpp",
+        "service.cpp"
+    ],
+
+    static_libs: [
+        "android.hardware.broadcastradio@common-utils-2x-lib",
+        "android.hardware.broadcastradio@common-utils-lib",
+    ],
+
+    shared_libs: [
+        "android.hardware.broadcastradio@2.0",
+        "libbase",
+        "libhidlbase",
+        "libhidltransport",
+        "libhardware",
+        "liblog",
+        "libutils",
+    ],
+}
diff --git a/BroadcastRadio.cpp b/BroadcastRadio.cpp
new file mode 100644
index 0000000..19cbc2c
--- /dev/null
+++ b/BroadcastRadio.cpp
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2018 GlobalLogic LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "BroadcastRadioKingfisher"
+#define LOG_NDEBUG 0
+
+#include <linux/videodev2.h>
+
+#include <log/log.h>
+#include <hardware/radio.h>
+
+#include "BroadcastRadio.h"
+#include "TunerSession.h"
+#include "resources.h"
+
+namespace android {
+namespace hardware {
+namespace broadcastradio {
+namespace V2_0 {
+namespace renesas {
+
+static const AmFmRegionConfig gDefaultAmFmConfig = {  //
+    {
+        {65800, 108000, 100, 100},  // FM
+        {531, 26100, 9, 9},          // AM
+    },
+    static_cast<uint32_t>(Deemphasis::D50),
+    static_cast<uint32_t>(Rds::RDS)};
+
+static Properties initProperties() {
+    Properties properties;
+
+    properties.maker = "GlobalLogic";
+    properties.product = "Kingfisher Radio HAL";
+    properties.version = "2.0";
+    properties.serial = "1234567890";
+
+    properties.supportedIdentifierTypes = hidl_vec<uint32_t>(
+        {
+            static_cast<uint32_t>(IdentifierType::AMFM_FREQUENCY),
+            static_cast<uint32_t>(IdentifierType::RDS_PI),
+        });
+    return properties;
+}
+
+BroadcastRadio::BroadcastRadio() :
+    mProperties(initProperties()),
+    mAmFmConfig(gDefaultAmFmConfig) {
+    init();
+}
+
+
+BroadcastRadio::~BroadcastRadio() {
+    ALOGV("%s", __func__);
+
+    if (mFd != -1) {
+        close(mFd);
+        mFd = -1;
+    }
+}
+
+void BroadcastRadio::init() {
+    ALOGV("%s", __func__);
+
+    if (mFd != -1) { /* Already open? */
+        return;
+    }
+
+    const char* radio_device = "/dev/radio0";
+
+    mFd = open(radio_device, O_RDONLY);
+    if (mFd < 0) {
+        ALOGE("Open radio device '%s' failed, err=%s", radio_device, strerror(errno));
+        return;
+    }
+
+    ALOGI("Radio device '%s', fd=%d", radio_device, mFd);
+}
+
+// Methods from ::android::hardware::broadcastradio::V1_0::IBroadcastRadio follow.
+Return<void> BroadcastRadio::getProperties(getProperties_cb _hidl_cb) {
+    ALOGD("%s", __func__);
+
+    _hidl_cb(mProperties);
+    return {};
+}
+
+AmFmRegionConfig BroadcastRadio::getAmFmConfig() const {
+    std::lock_guard<std::mutex> lk(mMut);
+    return mAmFmConfig;
+}
+
+Return<void> BroadcastRadio::openSession(const sp<ITunerCallback>& callback,
+                                         openSession_cb _hidl_cb) {
+    ALOGV("%s", __func__);
+
+    std::lock_guard<std::mutex> lk(mMut);
+
+    auto oldSession = mSession.promote();
+    if (oldSession != nullptr) {
+        ALOGI("Closing previously opened tuner");
+        oldSession->close();
+        mSession = nullptr;
+    }
+
+    sp<TunerSession> newSession = new TunerSession(*this, callback, mFd);
+    mSession = newSession;
+    newSession->switchAmFmBand(FrequencyBand::FM);
+
+    _hidl_cb(Result::OK, newSession);
+    return {};
+}
+
+Return<void> BroadcastRadio::getAmFmRegionConfig(bool full, getAmFmRegionConfig_cb _hidl_cb) {
+    ALOGV("%s(%d)", __func__, full);
+
+    if (mFd < 0) {
+        _hidl_cb(Result::INVALID_STATE, mAmFmConfig);
+        return {};
+    }
+
+    if (full) {
+        AmFmRegionConfig config = {};
+        config.ranges = hidl_vec<AmFmBandRange>(2);
+        config.fmDeemphasis = Deemphasis::D50 | Deemphasis::D75;
+        config.fmRds = Rds::RDS | Rds::RBDS;
+
+        int ret = 0;
+        for (int band = 0;; band++) {
+            struct v4l2_frequency_band v4l2_band = {
+                .type = V4L2_TUNER_RADIO,
+                .tuner = 0,
+                .index = static_cast<__u32>(band)
+            };
+
+            ret = ioctl(mFd, VIDIOC_ENUM_FREQ_BANDS, &v4l2_band);
+            if (ret < 0) {
+                ALOGE("ioctl(VIDIOC_ENUM_FREQ_BANDS) failed, err=%s", strerror(errno));
+                break;
+            }
+
+            config.ranges.resize(band + 1);
+
+            AmFmBandRange& range = config.ranges[band];
+
+            range.lowerBound = v4l2_band.rangelow / 16U;
+            range.upperBound = v4l2_band.rangehigh / 16U;
+            range.scanSpacing = 0;
+
+            if (v4l2_band.modulation == V4L2_BAND_MODULATION_FM) {
+                range.spacing = 100;
+            } else if (v4l2_band.modulation == V4L2_BAND_MODULATION_AM) {
+                range.spacing = 9;
+            }
+        }
+
+        _hidl_cb(Result::OK, config);
+        return {};
+    } else {
+        _hidl_cb(Result::OK, getAmFmConfig());
+        return {};
+    }
+}
+
+Return<void> BroadcastRadio::getDabRegionConfig(getDabRegionConfig_cb _hidl_cb) {
+    ALOGV("%s", __func__);
+    _hidl_cb(Result::NOT_SUPPORTED, {});
+    return {};
+}
+
+Return<void> BroadcastRadio::getImage(uint32_t id, getImage_cb _hidl_cb) {
+    ALOGV("%s(%x)", __func__, id);
+
+    if (id == resources::demoPngId) {
+        _hidl_cb(std::vector<uint8_t>(resources::demoPng, std::end(resources::demoPng)));
+        return {};
+    }
+
+    ALOGI("Image %x doesn't exists", id);
+    _hidl_cb({});
+    return {};
+}
+
+Return<void> BroadcastRadio::registerAnnouncementListener(
+    const hidl_vec<AnnouncementType>& enabled, const sp<IAnnouncementListener>& /* listener */,
+    registerAnnouncementListener_cb _hidl_cb) {
+    ALOGV("%s(%s)", __func__, toString(enabled).c_str());
+
+    _hidl_cb(Result::NOT_SUPPORTED, nullptr);
+    return {};
+}
+
+
+}  // namespace renesas
+}  // namespace V2_0
+}  // namespace broadcastradio
+}  // namespace hardware
+}  // namespace android
diff --git a/BroadcastRadio.h b/BroadcastRadio.h
new file mode 100644
index 0000000..0425fdb
--- /dev/null
+++ b/BroadcastRadio.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 GlobalLogic LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef ANDROID_HARDWARE_BROADCASTRADIO_V2_0_BROADCASTRADIO_H
+#define ANDROID_HARDWARE_BROADCASTRADIO_V2_0_BROADCASTRADIO_H
+
+#include "TunerSession.h"
+
+#include <android/hardware/broadcastradio/2.0/IBroadcastRadio.h>
+#include <broadcastradio-utils-2x/Utils.h>
+#include <hidl/Status.h>
+#include <hidl/MQDescriptor.h>
+
+#include <thread>
+#include <stdlib.h>
+
+namespace android {
+namespace hardware {
+namespace broadcastradio {
+namespace V2_0 {
+namespace renesas {
+
+class BroadcastRadio : public IBroadcastRadio {
+public:
+    BroadcastRadio();
+    ~BroadcastRadio() override;
+
+    // Methods from ::android::hardware::broadcastradio::V2_0::IBroadcastRadio follow.
+    Return<void> getProperties(getProperties_cb _hidl_cb) override;
+
+    Return<void> getAmFmRegionConfig(bool full,
+                                     getAmFmRegionConfig_cb _hidl_cb) override;
+    Return<void> getDabRegionConfig(getDabRegionConfig_cb _hidl_cb) override;
+    Return<void> openSession(const sp<ITunerCallback>& callback,
+                             openSession_cb _hidl_cb) override;
+    Return<void> getImage(uint32_t id, getImage_cb _hidl_cb) override;
+    Return<void> registerAnnouncementListener(const hidl_vec<AnnouncementType>& enabled,
+                                              const sp<IAnnouncementListener>& listener,
+                                              registerAnnouncementListener_cb _hidl_cb) override;
+
+    AmFmRegionConfig getAmFmConfig() const;
+
+    Properties getProperties() const { return mProperties; }
+
+private:
+    void init();
+
+    Properties          mProperties;
+    int                 mFd { -1 };
+
+    mutable std::mutex  mMut;
+    AmFmRegionConfig    mAmFmConfig;
+    wp<TunerSession>    mSession;
+};
+
+}  // namespace renesas
+}  // namespace V2_0
+}  // namespace broadcastradio
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_BROADCASTRADIO_V2_0_BROADCASTRADIO_H
diff --git a/TunerSession.cpp b/TunerSession.cpp
new file mode 100644
index 0000000..2e95afe
--- /dev/null
+++ b/TunerSession.cpp
@@ -0,0 +1,450 @@
+﻿/*
+ * Copyright (C) 2018 GlobalLogic LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "BcRadioDef.TunerSession"
+#define LOG_NDEBUG 0
+
+#include "TunerSession.h"
+
+#include "BroadcastRadio.h"
+
+#include <broadcastradio-utils-2x/Utils.h>
+#include <log/log.h>
+#include <linux/videodev2.h>
+
+namespace android {
+namespace hardware {
+namespace broadcastradio {
+namespace V2_0 {
+namespace renesas {
+
+/* ------------------------------------------------------------------ */
+typedef struct si46xx_rds_data_s {
+    uint16_t pi;
+    uint8_t pty;
+    char ps_name[9];
+    char radiotext[129];
+} si46xx_rds_data_t;
+
+/* ------------------------------------------------------------------ */
+
+using utils::FrequencyBand;
+using utils::tunesTo;
+
+using std::lock_guard;
+using std::move;
+using std::mutex;
+using std::sort;
+using std::vector;
+
+using namespace std::chrono_literals;
+
+namespace delay {
+
+static constexpr auto config = 5ms;
+static constexpr auto seek = 200ms;
+static constexpr auto step = 100ms;
+static constexpr auto tune = 150ms;
+static constexpr auto metadataCheck = 1s;
+
+}  // namespace delay
+
+static ProgramInfo makeDummyProgramInfo(const ProgramSelector& selector) {
+    ProgramInfo info = {};
+    info.selector = selector;
+    info.logicallyTunedTo = utils::make_identifier(
+        IdentifierType::AMFM_FREQUENCY,
+        utils::getId(selector, IdentifierType::AMFM_FREQUENCY));
+    info.physicallyTunedTo = info.logicallyTunedTo;
+    return info;
+}
+
+TunerSession::TunerSession(BroadcastRadio& module,
+                           const sp<ITunerCallback>& callback,
+                           const int& deviceFd)
+    : mCallback(callback),
+      mDeviceFd(deviceFd),
+      mModule(module) {
+}
+
+TunerSession::~TunerSession() {
+    mMetadataThreadExit = true;   // Notify thread to finish and wait for it to terminate.
+}
+
+const BroadcastRadio& TunerSession::module() const {
+    return mModule.get();
+}
+
+void TunerSession::tuneInternalLocked(const ProgramSelector& sel) {
+    ALOGV("%s(%s)", __func__, toString(sel).c_str());
+
+    mCurrentProgram = sel;
+
+    ProgramInfo info = makeDummyProgramInfo(sel);
+
+    ALOGI("Tune channel type=%d, value=%ld", sel.primaryId.type, sel.primaryId.value);
+
+    v4l2_frequency freq = {
+        .tuner = 0,
+        .type = V4L2_TUNER_RADIO,
+        .frequency = static_cast<uint32_t>(sel.primaryId.value)
+    };
+
+    if (ioctl(mDeviceFd, VIDIOC_S_FREQUENCY, &freq) < 0) {
+        ALOGE("ioctl(VIDIOC_S_FREQUENCY) failed, err=%s", strerror(errno));
+        mCallback->onTuneFailed(Result::INTERNAL_ERROR, sel);
+    } else {
+        if (gatherProgramInfo(info)) {
+            info.selector = sel;
+            info.metadata = hidl_vec<Metadata>(
+                {
+                    utils::make_metadata(MetadataKey::RDS_PTY, 25689),
+                    utils::make_metadata(MetadataKey::RDS_PS, "RDS TEXT")
+                });
+            mCurrentProgramInfo = info;
+        }
+        launchMetadataFetchTask();
+    }
+    ALOGI("Tune channel %ld done, tuned", sel.primaryId.value);
+    mIsTuneCompleted = true;
+    mCallback->onCurrentProgramInfoChanged(info);
+}
+
+void TunerSession::switchAmFmBand(const FrequencyBand& band) {
+    ALOGV("%s(band = %d)", __func__, band);
+
+    auto task = [this, band]() {
+        ALOGV("%s(band = %d)", __func__, band);
+        std::lock_guard<std::mutex> lk(mMut);
+
+        v4l2_control ctrl = {.id = V4L2_TUNER_RADIO};
+
+        uint32_t baseFrequency = 0;
+
+        if (band == FrequencyBand::FM) {
+            ALOGI("Setting FM band config");
+            ctrl.value = V4L2_BAND_MODULATION_FM;
+            baseFrequency = 87500;
+        } else if (band == FrequencyBand::AM_LW || band == FrequencyBand::AM_MW ||
+                   band == FrequencyBand::AM_SW) {
+            ALOGI("Setting AM band config");
+            ctrl.value = V4L2_BAND_MODULATION_AM;
+            baseFrequency = 1620;
+        }
+
+        if (ioctl(mDeviceFd, VIDIOC_S_CTRL, &ctrl) < 0) {
+            ALOGE("ioctl(VIDIOC_S_CTRL) failed, err=%s", strerror(errno));
+        } else {
+            ALOGI("Switched to frequency %d", band);
+            mCurrentBand = band;
+
+            ALOGI("Tune to band channel %ld", mCurrentProgram.primaryId.value);
+            v4l2_frequency freq = {
+                .tuner = 0,
+                .type = V4L2_TUNER_RADIO,
+                .frequency = baseFrequency
+            };
+
+            if (ioctl(mDeviceFd, VIDIOC_S_FREQUENCY, &freq) < 0) {
+                ALOGE("ioctl(VIDIOC_S_FREQUENCY) failed, err=%s", strerror(errno));
+            } else {
+                ALOGV("ioctl(VIDIOC_S_FREQUENCY) success");
+            }
+        }
+    };
+
+    mThread.schedule(task, delay::config);
+}
+
+Return<Result> TunerSession::tune(const ProgramSelector& sel) {
+
+    ALOGV("%s: type=%u, value=%lu", __func__, sel.primaryId.type, sel.primaryId.value);
+
+    std::lock_guard<std::mutex> lk(mMut);
+    if (mIsClosed) return Result::INVALID_STATE;
+
+    if (!utils::isSupported(module().getProperties(), sel)) {
+        ALOGW("Selector not supported");
+        return Result::NOT_SUPPORTED;
+    }
+
+    if (!utils::isValid(sel)) {
+        ALOGE("ProgramSelector is not valid");
+        return Result::INVALID_ARGUMENTS;
+    }
+
+    cancelLocked();
+
+    FrequencyBand newBand = utils::getBand(sel.primaryId.value);
+    if (newBand != mCurrentBand) {
+        switchAmFmBand(newBand);
+    }
+
+    mIsTuneCompleted = false;
+
+    auto task = [this, sel]() {
+        std::lock_guard<std::mutex> lk(mMut);
+        tuneInternalLocked(sel);
+    };
+
+    mThread.schedule(task, delay::tune);
+
+    return Result::OK;
+}
+
+Return<Result> TunerSession::scan(bool directionUp, bool /* skipSubChannel */) {
+    ALOGV("%s: direction=%d", __func__, directionUp);
+
+    std::lock_guard<mutex> lk(mMut);
+    if (mIsClosed) return Result::INVALID_STATE;
+
+    cancelLocked();
+
+    if (mCurrentBand == FrequencyBand::UNKNOWN) {
+        switchAmFmBand(FrequencyBand::FM);
+    }
+
+    mIsTuneCompleted = false;
+
+    auto task = [this, directionUp]() {
+        std::lock_guard<std::mutex> lk(mMut);
+        ProgramInfo info;
+
+        ALOGI("Seek start, direction=%d", directionUp);
+
+        v4l2_hw_freq_seek freq_seek = {
+            .tuner = 0,
+            .type = V4L2_TUNER_RADIO,
+            .seek_upward = directionUp,
+            .wrap_around = 1,
+        };
+
+        if (ioctl(mDeviceFd, VIDIOC_S_HW_FREQ_SEEK, &freq_seek) < 0) {
+            ALOGE("ioctl(VIDIOC_S_HW_FREQ_SEEK) failed, err=%s", strerror(errno));
+        } else {
+            if (gatherProgramInfo(info)) {
+                mCurrentProgram = info.selector;
+                mCurrentProgramInfo = info;
+            }
+            launchMetadataFetchTask();
+        }
+
+        ALOGI("Seek done at channel %ld", mCurrentProgram.primaryId.value);
+        mIsTuneCompleted = true;
+        mCallback->onCurrentProgramInfoChanged(info);
+    };
+
+    mThread.schedule(task, delay::seek);
+    return Result::OK;
+}
+
+Return<Result> TunerSession::step(bool directionUp) {
+    ALOGV("%s", __func__);
+    std::lock_guard<mutex> lk(mMut);
+    if (mIsClosed) return Result::INVALID_STATE;
+
+    cancelLocked();
+
+    if (!utils::hasId(mCurrentProgram, IdentifierType::AMFM_FREQUENCY)) {
+        ALOGE("Can't step in anything else than AM/FM");
+        return Result::NOT_SUPPORTED;
+    }
+
+    auto stepTo = utils::getId(mCurrentProgram, IdentifierType::AMFM_FREQUENCY);
+    auto range = getAmFmRangeLocked();
+    if (!range) {
+        ALOGE("Can't find current band");
+        return Result::INTERNAL_ERROR;
+    }
+
+    if (directionUp) {
+        stepTo += range->spacing;
+    } else {
+        stepTo -= range->spacing;
+    }
+    if (stepTo > range->upperBound) stepTo = range->lowerBound;
+    if (stepTo < range->lowerBound) stepTo = range->upperBound;
+
+    mIsTuneCompleted = false;
+    auto task = [this, stepTo]() {
+        ALOGI("Performing step to %s", std::to_string(stepTo).c_str());
+
+        std::lock_guard<mutex> lk(mMut);
+        tuneInternalLocked(utils::make_selector_amfm(stepTo));
+    };
+    mThread.schedule(task, delay::step);
+
+    return Result::OK;
+}
+
+void TunerSession::cancelLocked() {
+    ALOGV("%s", __func__);
+
+    mMetadataThreadExit = true;
+    mThread.cancelAll();
+    if (utils::getType(mCurrentProgram.primaryId) != IdentifierType::INVALID) {
+        mIsTuneCompleted = true;
+    }
+}
+
+Return<void> TunerSession::cancel() {
+    ALOGV("%s", __func__);
+    std::lock_guard<mutex> lk(mMut);
+    if (mIsClosed) return {};
+
+    cancelLocked();
+
+    return {};
+}
+
+Return<Result> TunerSession::startProgramListUpdates(const ProgramFilter& filter) {
+    ALOGV("%s(%s)", __func__, toString(filter).c_str());
+    std::lock_guard<mutex> lk(mMut);
+    if (mIsClosed) return Result::INVALID_STATE;
+
+    return Result::NOT_SUPPORTED;
+}
+
+Return<void> TunerSession::stopProgramListUpdates() {
+    ALOGV("%s", __func__);
+    return {};
+}
+
+Return<void> TunerSession::isConfigFlagSet(ConfigFlag flag, isConfigFlagSet_cb _hidl_cb) {
+    ALOGV("%s(%s)", __func__, toString(flag).c_str());
+
+    _hidl_cb(Result::NOT_SUPPORTED, false);
+    return {};
+}
+
+Return<Result> TunerSession::setConfigFlag(ConfigFlag flag, bool value) {
+    ALOGV("%s(%s, %d)", __func__, toString(flag).c_str(), value);
+
+    return Result::NOT_SUPPORTED;
+}
+
+Return<void> TunerSession::setParameters(const hidl_vec<VendorKeyValue>& /* parameters */,
+                                         setParameters_cb _hidl_cb) {
+    ALOGV("%s", __func__);
+
+    _hidl_cb({});
+    return {};
+}
+
+Return<void> TunerSession::getParameters(const hidl_vec<hidl_string>& /* keys */,
+                                         getParameters_cb _hidl_cb) {
+    ALOGV("%s", __func__);
+
+    _hidl_cb({});
+    return {};
+}
+
+Return<void> TunerSession::close() {
+    ALOGV("%s", __func__);
+    std::lock_guard<mutex> lk(mMut);
+    if (mIsClosed) return {};
+
+    mIsClosed = true;
+    mMetadataThreadExit = true;
+    mThread.cancelAll();
+    return {};
+}
+
+std::optional<AmFmBandRange> TunerSession::getAmFmRangeLocked() const {
+    if (!mIsTuneCompleted) {
+        ALOGW("tune operation in process");
+        return {};
+    }
+    if (!utils::hasId(mCurrentProgram, IdentifierType::AMFM_FREQUENCY)) return {};
+
+    auto freq = utils::getId(mCurrentProgram, IdentifierType::AMFM_FREQUENCY);
+    for (auto&& range : module().getAmFmConfig().ranges) {
+        if (range.lowerBound <= freq && range.upperBound >= freq) return range;
+    }
+
+    return {};
+}
+
+bool TunerSession::gatherProgramInfo(ProgramInfo& info) {
+    /* Get the frequency */
+    v4l2_frequency freq = {
+        .tuner = 0,
+        .type = V4L2_TUNER_RADIO,
+        .frequency = 0
+    };
+
+    if (ioctl(mDeviceFd, VIDIOC_G_FREQUENCY, &freq) < 0) {
+        ALOGE("ioctl(VIDIOC_G_FREQUENCY) failed, err=%s", strerror(errno));
+        return false;
+    }
+
+    /* Get signal quality */
+    v4l2_tuner v4ltun = {
+        .index = 0,
+        .type = V4L2_TUNER_RADIO,
+        .signal = 0,
+        .audmode = 0
+    };
+
+    if (ioctl(mDeviceFd, VIDIOC_G_TUNER, &v4ltun) < 0) {
+        ALOGE("ioctl(VIDIOC_G_TUNER) failed, err=%s", strerror(errno));
+        return false;
+    }
+
+
+    info.signalQuality = v4ltun.signal;
+    info.selector = utils::make_selector_amfm(freq.frequency);
+    if (v4ltun.audmode == V4L2_TUNER_MODE_STEREO) {
+        info.infoFlags |= ProgramInfoFlags::STEREO;
+    }
+
+    return true;
+}
+
+void TunerSession::launchMetadataFetchTask() {
+    if (mIsClosed) {
+        ALOGW("called metadata fetch in wrong state");
+        return;
+    }
+    mMetadataThreadExit = false;
+    mMetadataTask = [this]() {
+        struct si46xx_rds_data_s rds = {};
+        int ret = read(mDeviceFd, &rds, sizeof(rds));
+        if (ret < 0) {
+            ALOGE("RDS data read failed, err=%s", strerror(errno));
+        } else if (!ret) {
+            ALOGV("No RDS data available.");
+        } else {
+            mCurrentProgramInfo.metadata = hidl_vec<Metadata>(
+                {
+                    utils::make_metadata(MetadataKey::RDS_PTY, rds.pty),
+                    utils::make_metadata(MetadataKey::RDS_PS, rds.ps_name),
+                });
+            mCallback->onCurrentProgramInfoChanged(mCurrentProgramInfo);
+        }
+
+        if (!mMetadataThreadExit) {
+            mThread.schedule(mMetadataTask, delay::metadataCheck);
+        }
+    };
+    mThread.schedule(mMetadataTask, delay::metadataCheck);
+}
+
+}  // namespace renesas {
+}  // namespace V2_0 {
+}  // namespace broadcastradio {
+}  // namespace hardware {
+}  // namespace android {
diff --git a/TunerSession.h b/TunerSession.h
new file mode 100644
index 0000000..f96272d
--- /dev/null
+++ b/TunerSession.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2018 GlobalLogic LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef ANDROID_HARDWARE_BROADCASTRADIO_V2_0_TUNERSESSION_H
+#define ANDROID_HARDWARE_BROADCASTRADIO_V2_0_TUNERSESSION_H
+
+#include <android/hardware/broadcastradio/2.0/ITunerCallback.h>
+#include <android/hardware/broadcastradio/2.0/ITunerSession.h>
+#include <broadcastradio-utils-2x/Utils.h>
+#include <broadcastradio-utils/WorkerThread.h>
+
+#include <optional>
+
+namespace android {
+namespace hardware {
+namespace broadcastradio {
+namespace V2_0 {
+namespace renesas {
+
+class BroadcastRadio;
+
+using utils::FrequencyBand;
+
+class TunerSession : public ITunerSession {
+public:
+    TunerSession(BroadcastRadio& module, const sp<ITunerCallback>& callback, const int& deviceFd);
+
+    // V2_0::ITunerSession methods
+    virtual Return<Result> tune(const ProgramSelector& program) override;
+    virtual Return<Result> scan(bool directionUp, bool skipSubChannel) override;
+    virtual Return<Result> step(bool directionUp) override;
+    virtual Return<void> cancel() override;
+    virtual Return<Result> startProgramListUpdates(const ProgramFilter& filter) override;
+    virtual Return<void> stopProgramListUpdates() override;
+    virtual Return<void> isConfigFlagSet(ConfigFlag flag, isConfigFlagSet_cb _hidl_cb) override;
+    virtual Return<Result> setConfigFlag(ConfigFlag flag, bool value) override;
+    virtual Return<void> setParameters(const hidl_vec<VendorKeyValue>& parameters,
+                                       setParameters_cb _hidl_cb) override;
+    virtual Return<void> getParameters(const hidl_vec<hidl_string>& keys,
+                                       getParameters_cb _hidl_cb) override;
+    virtual Return<void> close() override;
+
+    std::optional<AmFmBandRange> getAmFmRangeLocked() const;
+
+    void launchMetadataFetchTask();
+    void switchAmFmBand(const FrequencyBand& band);
+
+private:
+    ~TunerSession();
+
+    void cancelLocked();
+    bool gatherProgramInfo(ProgramInfo& info);
+    const BroadcastRadio& module() const;
+    void tuneInternalLocked(const ProgramSelector& sel);
+
+
+    std::mutex                              mMut;
+    WorkerThread                            mThread;
+    std::atomic<bool>                       mMetadataThreadExit { false };
+    bool                                    mIsClosed = false;
+    std::function<void()>                   mMetadataTask;
+
+    const sp<ITunerCallback>                mCallback;
+
+    const int&                              mDeviceFd;
+    std::reference_wrapper<BroadcastRadio>  mModule;
+
+    bool                                    mIsTuneCompleted = false;
+    ProgramSelector                         mCurrentProgram = {};
+    ProgramInfo                             mCurrentProgramInfo = {};
+    FrequencyBand                           mCurrentBand = FrequencyBand::UNKNOWN;
+};
+
+}  // namespace renesas {
+}  // namespace V2_0 {
+}  // namespace broadcastradio {
+}  // namespace hardware {
+}  // namespace android {
+
+#endif  // ANDROID_HARDWARE_BROADCASTRADIO_V2_0_TUNERSESSION_H
diff --git a/android.hardware.broadcastradio@2.0-service.renesas.rc b/android.hardware.broadcastradio@2.0-service.renesas.rc
new file mode 100644
index 0000000..14fe070
--- /dev/null
+++ b/android.hardware.broadcastradio@2.0-service.renesas.rc
@@ -0,0 +1,4 @@
+service vendor.broadcastradio-2-0 /vendor/bin/hw/android.hardware.broadcastradio@2.0-service.renesas
+    class hal
+    user audioserver
+    group audio
diff --git a/android.hardware.broadcastradio@2.0-service.renesas.xml b/android.hardware.broadcastradio@2.0-service.renesas.xml
new file mode 100644
index 0000000..5af7f1b
--- /dev/null
+++ b/android.hardware.broadcastradio@2.0-service.renesas.xml
@@ -0,0 +1,11 @@
+<manifest version="1.0" type="device">
+    <hal format="hidl">
+        <name>android.hardware.broadcastradio</name>
+        <transport>hwbinder</transport>
+        <version>2.0</version>
+        <interface>
+            <name>IBroadcastRadio</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+</manifest>
diff --git a/resources.h b/resources.h
new file mode 100644
index 0000000..da07293
--- /dev/null
+++ b/resources.h
@@ -0,0 +1,31 @@
+#ifndef ANDROID_HARDWARE_BROADCASTRADIO_V2_0_RESOURCES_H
+#define ANDROID_HARDWARE_BROADCASTRADIO_V2_0_RESOURCES_H
+
+namespace android {
+namespace hardware {
+namespace broadcastradio {
+namespace V2_0 {
+namespace renesas {
+namespace resources {
+
+constexpr int32_t demoPngId = 123456;
+constexpr uint8_t demoPng[] = {
+    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44,
+    0x52, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x08, 0x02, 0x00, 0x00, 0x00, 0x25,
+    0x0b, 0xe6, 0x89, 0x00, 0x00, 0x00, 0x5d, 0x49, 0x44, 0x41, 0x54, 0x68, 0xde, 0xed, 0xd9,
+    0xc1, 0x09, 0x00, 0x30, 0x08, 0x04, 0xc1, 0x33, 0xfd, 0xf7, 0x6c, 0x6a, 0xc8, 0x23, 0x04,
+    0xc9, 0x6c, 0x01, 0xc2, 0x20, 0xbe, 0x4c, 0x86, 0x57, 0x49, 0xba, 0xfb, 0xd6, 0xf4, 0xba,
+    0x3e, 0x7f, 0x4d, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x8f, 0x00, 0xbd, 0xce, 0x7f,
+    0xc0, 0x11, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8, 0xb8, 0x0d, 0x32, 0xd4, 0x0c, 0x77, 0xbd,
+    0xfb, 0xc1, 0xce, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82};
+
+}  // namespace resources
+}  // namespace renesas
+}  // namespace V2_0
+}  // namespace broadcastradio
+}  // namespace hardware
+}  // namespace android
+
+#endif // ANDROID_HARDWARE_BROADCASTRADIO_V2_0_RESOURCES_H
diff --git a/service.cpp b/service.cpp
new file mode 100644
index 0000000..b562832
--- /dev/null
+++ b/service.cpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 GlobalLogic LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "BroadcastRadioKingfisher"
+
+#include <android-base/logging.h>
+#include <android/hardware/broadcastradio/2.0/IBroadcastRadio.h>
+#include <hidl/HidlTransportSupport.h>
+
+#include "BroadcastRadio.h"
+
+using android::hardware::configureRpcThreadpool;
+using android::hardware::joinRpcThreadpool;
+using android::hardware::broadcastradio::V2_0::renesas::BroadcastRadio;
+using android::hardware::broadcastradio::V2_0::IBroadcastRadio;
+
+int main(int /* argc */, char** /* argv */) {
+    android::sp<IBroadcastRadio> radio_hal = new BroadcastRadio;
+
+    configureRpcThreadpool(4, true);
+
+    auto status = radio_hal->registerAsService();
+    CHECK_EQ(status, android::OK) << "Failed to register Broadcast Radio HAL";
+
+    joinRpcThreadpool();
+}
-- 
2.25.1

